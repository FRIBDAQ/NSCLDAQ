<!-- chapter frameworks -->
<chapter id='sbs-scripted'>
    <title id='sbs-scripted-title'> SBS Scripted Readout Framework</title>
    <para>
        This software is  a set of pre-packaged device drivers that are layered
        on top of
        <link linkend='chap-sbsrdo' endterm='chap-sbsrdo-title' />.  You can use
        this to quickly set up readout software without any C++ programming,
        provided that your readout requirements are simple and supported by
        the drivers provided by this framework.  You can also write your own
        device drivers and link together a custom version of this program if
        you have a device that is not supported by the driver but supported
        by the general concept of the program.
    </para>
    <para>
        The remainder of this chapter will:
        <itemizedlist>
            <listitem><para>
                <link linkend='sbs-scripted-sec-intro'> Introduce the general
                concepts behind the scripted readout software.</link>
                Sample setup files are provided as well.
            </para></listitem>
            <listitem><para>
                <link linkend='sbs-scripted-sec-driver'>Describe how to
                write drivers for additional  hardware.</link> This section
                will also describe how to build a custom scripted Readout programs
                that incorporate your customized drivers.
                </para></listitem>
            <listitem><para>
                <link linkend='sbs-scripted-sec-hybrid'>Describe how to build a
                hybrid Scripted Readout program</link> which incorporates
                one or more scripted event segments together with hand written
                C++ event segments.
                </para></listitem>
        </itemizedlist>
        
    </para>
    <section id='sbs-scripted-sec-intro'>
        <title>Introduction to the SBS Scripted Readout Framework</title>
        <para>
            The SBS scripted readout framework allows you to configure
            simple readout programs by providing a Tcl script that describes
            and configures the modules you are using as well as the order in which
            you want them read out. Currently supported modules are:
        </para>
        <variablelist>
            <varlistentry>
                <term>CAEN V775,785,792, and 862
                    32 channel digitizers</term>
                <listitem>
                    <para>
                        The V775 is a TDC, the V785 a peak sensing ADC. The
                        V792 and V862 are charge integrating ADCs (QDCs)
                        where the V862 has independent per channel gates.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>CAEN V830</term>
                <listitem>
                    <para>
                        This is a 32 channel scaler module that is most often
                        used in scaler segments.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>SIS 3300</term>
                <listitem>
                    <para>
                        This is an 8 channel flash adc. The command provides
                        support for the SIS 3301 as well as the SIS 3300.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>CAEN V1x90</term>
                <listitem>
                    <para>
                        This is a family of multi-hit TDC modules that range
                        from 16 to 128 channels.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>Packet</term>
                <listitem>
                    <para>
                        This is a container for other modules that prefaces
                        data from a group of modules with a size and identifier.
                    </para>
                </listitem>
            </varlistentry>
            
        </variablelist>
        <para>
            See
            <link linkend='sbs-scripted-sec-driver'
                  endterm='sbs-scripted-sec-driver-title' />
            for information about how to extend the support of the scripted readout
            to other drivers.  See
            <link linkend='sbs-scripted-sec-hybrid'
                  endterm='sbs-scripted-sec-hybrid-title' />
            for information about how to mix the scripted readout with custom
            code that is not scriptable.  Unless modified, the system requires a CAEN
            V977 to act as both the trigger and the busy if used unmodified.
        </para>
        <para>
            When the Scripted readout system starts, it reads an event and a scaler
            configuration script.  These are both Tcl Scripts with extensions
            that will be described later in this section.  Those extensions
            allow users to describe modules that will be used by the
            experiment and the order in which those modules will be read.
        </para>
        <para>
            The configuration scripts are <filename>hardware.tcl</filename> for
            physic triggers and <filename>scalers.tcl</filename> for the scaler
            cofiguration script.  These are searched for inorder, the user's home
            directory and the current working directory.  The filename can be
            overridden by defining the environment variable <literal>HARDWARE_FILE</literal>
            to point at the event configuration script and
            <literal>SCALER_FILE</literal> to point to the scaler readout
            configuration script.
        </para>
        <para>
            The Readout script is an ordinary Tcl script that makes use of a few
            extensions to the language that support the definition configuration
            and organization of modules.
        </para>
        <formalpara>
            <title><link linkend='sbsreadout3_module' endterm='sbsreadout3_module_title' /></title>
            <para>
                Primarily creates new modules.  When you create a module, you
                assign it a name.  That name then becomes both a Tcl command, which
                you use to configure the module, and a handle to use when other
                commands refer to that module.  Modules also have a type that
                represents the hardware they know how to control.
            </para>
        </formalpara>
        <example>
            <title>Scripted readout module command for a CAEN V775</title>
            <programlisting>
module adc1 caenv775
adc1 configure base 0x1240000 slot 5
            </programlisting>
        </example>
        <formalpara>
            <title><link linkend='sbsreadout3_readout' endterm='sbsreadout3_readout_title' /></title>
            <para>
                Is the command that defines which modules will be read in reponse
                to a trigger and in which order the readout will proceed.  The
                <command>readout</command> command provides the <command>add</command>
                subcommand for adding modules to the readout list.  The modules
                will be read in the order in which they are added.
            </para>
        </formalpara>
        <example>
            <title>Scripted readout <command>readout</command> command</title>
            <programlisting>
readout add adc1
readout add adc2
            </programlisting>
        </example>
        <para>
            Note that the Scaler and Readout configuration files use exactly the
            same command extensions.  Each runs in its own interpreter however so
            that there is no mixup between scaler modules and their read orders
            and the read order for modules that respond to event triggers.
        </para>
    </section>
    <section id='sbs-scripted-sec-driver'>
        <title id='sbs-scripted-sec-driver-title'>Writing a driver</title>
        <para>
            This section describes how to extend the scripted readout framework
            to support additional drivers.  To do this you will need to:
        </para>
        <itemizedlist>
            <listitem><para>
                Obtain a copy of the scripted readout skeleton and makefile.
                </para></listitem>
            <listitem><para>
                Write a module class and a creator for it.
                </para></listitem>
            <listitem><para>
                Derive a class from CScriptedSegment overriding the
                <methodname>addUserWrittenCreators</methodname> method to
                register your own creators.
                </para>
            </listitem>
            <listitem><para>
                Modify Skeleton.cpp to use your CScriptedSegment in place
                of the base class in <methodname>SetupReadout</methodname>
                </para></listitem>
            <listitem><para>
                Modify the Makefile as needed to add your code to the build.
                </para>
            </listitem>
            <listitem><para>
                Build and use your tailored Scripted readout.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            Note that the process for adding scaler drivers is identical
            except that you must extend <classname>CScriptedScalers</classname>
            and register your class in <methodname>SetupScalers</methodname>
        </para>
        <para>
            As you read the remainder of this section, the important concept
            to keep in mind is that both <classname>CScriptedSegment</classname>
            and <classname>CScriptedScalers</classname> create a Tcl interpreter
            and register the <command>module</command> and <command>readout</command>
            commands in that interpreter.  Furthermore, the <command>module</command>
            command can be thought of as a factory for actual modules.
        </para>
        <para>
            When asked to create a new module instance, the <command>module</command>
            command does so by locating a module creator object that has been
            registered with a matching module type.  That creator is then given the
            actual task of creating the module.  The module itself is a Tcl Command
            processor with a dispatcher in the base class.  The module is registered
            as a Tcl command with the name of the module as the Tcl command.
            The module name is also associated with the module object in a
            dictionary maintained by the <command>module</command> command.
        </para>
        <section>
            <title>Obtaining the scripted reaodut skeleton</title>
            <para>
                The scripted readout skeleton is located in
                <filename>skeletons/scriptedReadout/skel</filename> relative
                to the top level of the nscldaq installation.
                If, your installation of NSCLDAQ is at
                <filename>/usr/opt/nscldaq/11.0</filename> for example,
                the following sequence of commands will create a new
                directory and copy the skeleton into that directory.
            </para>
            <informalexample>
                <programlisting>
mkdir development
cd    development
cp /usr/opt/nscldaq/11.0/skeletons/scriptedReadout/skel/* .
                </programlisting>
            </informalexample>
            <para>
                In the remainder of this chapter we are gonig to assume
                your current working directory is a directory in which the
                skeleton has been added.
            </para>
        </section>
        <section>
            <title>Writing a module and a module creator</title>
            <para>
                Writing a module and module creator is the hard work of supporting
                a new device.  The module class supports the module and the creator
                makes the new device known to the <command>module</command>
                command.  To illustrate the basic techniques of writing modules and
                their creators without referring to any specific hardware,
                we are going to develop a 'module' that produces a counting
                pattern.  You will be able to configure the number of words
                in the counting pattern, the starting value of the pattern
                and the direction of the count (ascending or descending).
            </para>
            <para>
                The key features of a module clasa are:
            </para>
            <itemizedlist>
                <listitem><para>They are derived from <classname>CDigitizerModule</classname>
                </para></listitem>
                <listitem><para>They implement an <methodname>Initialize</methodname>
                    That set up the module in accordance with the value of
                    cofiguration options registered for the module at
                    construction time.  This initialization is performed
                    once at the beginning of each bout of data taking
                    (begin or resume).
                    </para></listitem>
                <listitem><para>
                    They implement a <methodname>Prepare</methodname> method which
                    prepares the module for an event (both the first one
                    and subsequent events after the first one). This method
                    is called both at the start of data taking and after
                    acquiring an event.
                </para></listitem>
                <listitem><para>
                    They implement a <methodname>Read</methodname> method
                    which places data from the device into the event buffer
                    in response to a trigger.
                    </para></listitem>
                <listitem><para>
                    They implement a <methodname>Clear</methodname> method
                    which clears any data buffered in the digitizer.  This
                    is called bouth at the start of a bout of data taking
                    and after an event has been read.  In all cases,
                    <methodname>Clear</methodname> is called prior to
                    <methodname>Prepare</methodname>
                    </para></listitem>
                <listitem><para>
                    They implement a <methodname>getType</methodname> method
                    which returns a string documenting the type of module
                    they are.
                    </para></listitem>
            </itemizedlist>
            <para>Note that any methods that are not required may be omitted
                since all methods are default in the base class to do nothing.
            </para>
            <para>
                Armed with the knowledge above the class header is easy to
                write.  Since we are not talking to hardware we can omit
                the <methodname>Prepare</methodname> and <methodname>Clear</methodname>
                methods:
            </para>
            <informalexample>
                <programlisting>
#ifndef __COUNTERMODULE_H             <co id="scripted-counter-include-gaurd" />
#define __COUNTERMODULE_H

#ifndef __CDIGITIZERMODULE_H
#include &lt;CDigitizerModule.h%&gt;  <co id='scripted-counter-include-baseclass' />
#endif
class CCounterModule : public CDigitizerModule { <co id='scripted-counter-include-classdef' />
    int  m_firstValue;
    int  m_length;                    <co id='scripted-counter-include-membervars' />
    int  m_increment;
    
public:
    CCounterModule(const std::string&amp; rName, CTCLInterpreter&amp; interp); <co id='scripted-counter-include-construct' />
    virtual ~CCounterModule();
    
    virtual void Initialize();        
    virtual int  Read(void* pBuffer);     <co id='scripted-counter-include-memberfuncs' />
    virtual std::string getType() const{
       return std::string("counter");
    }
};
#endif
                </programlisting>
            </informalexample>
            <calloutlist>
                <callout arearefs="scripted-counter-include-gaurd">
                    <para>
                        This so-called <firstterm>include-guard</firstterm> is
                        recommended for all headers.  It ensures that multiple
                        inclusions of the header won't cause errors.  The scope
                        of the <literal>#ifndef</literal> is the entire file.
                    </para>
                </callout>
                <callout arearefs='scripted-counter-include-baseclass'>
                    <para>
                        This <literal>#include</literal> is mandatory since
                        we are going to derive a class from the
                        <classname>CDigitizerModule</classname> that is
                        the base class of all drivers for the scripted readout
                        program.
                    </para>
                </callout>
                <callout arearefs='scripted-counter-include-classdef'>
                    <para>
                        As previously discussed, the driver class
                        <classname>CCounterModule</classname> is going to be
                        derived from the <classname>CDigitizerModule</classname>
                        class.
                    </para>
                </callout>
                <callout arearefs='scripted-counter-include-membervars'>
                    <para>
                        The variables shown will be read from the configuration
                        parameters at the time the <methodname>Initialize</methodname>
                        method is called and sgtored for the <methodname>Read</methodname>
                        method.
                    </para>
                </callout>
                <callout arearefs='scripted-counter-include-memberfuncs'>
                    <para>
                        These are the member functions we need to comiplete
                        the functionality of this driver.
                    </para>
                </callout>
            </calloutlist>
            <section>
                <title>Constructor and destructor</title>
                <para>
                    The destructor is a trivial empty method which allows
                    the parent constructor to be called:
                </para>
                <informalexample>
                    <programlisting>
CCounterModule::~CCounterModule() {}
                    </programlisting>
                </informalexample>
                <para>
                    The constructor is a bit more interesting.  It must
                    register the configuration parameters with the base class.
                    The base class not only maintains the database of configuration
                    values but also handles the configuration and cget subcommands
                    that manipulate and list that data:
                </para>
                <informalexample>
                    <programlisting>
CCounterModule::CCounterModule(const string&amp; rName, CTCLInterpreter&amp; rInterp) :
    CDigitizerModule(rName, rInterp)               <co id='scripted-counter-imp-baseconstruct' />
{
    AddIntParam("size", 10);                       <co id='scripted-counter-imp-addint' />
    AddIntParam("start", 1);
    AddIntParam("increment", 1);
}
                    </programlisting>
                </informalexample>
                <calloutlist>
                    <callout arearefs='scripted-counter-imp-baseconstruct'>
                        <para>
                            The constructor initializes the base class
                            passing the name of the module (<parameter>rName</parameter>)
                            and the interpreter that is running the configuration
                            script (<parameter>rInterp</parameter>).  The base
                            class will take care of regsitering the new command.
                        </para>
                    </callout>
                    <callout arearefs='scripted-counter-imp-addint'>
                        <para>
                            The <methodname>AddInt</methodname> base class
                            method adds a configuration parameter to the
                            configuration database maintained by the base class.
                            The first parameter, <literal>size</literal> is the
                            name of the parameter.  The second the initial value.
                            This section of code defines three integer parameter:
                            <literal>size</literal>, <literal>start</literal> and
                            <literal>increment</literal> set the sequence size,
                            starting value and increment value respectively.
                        </para>
                        <para>
                            These are settable using the module instance's
                            <command>config</command> sub-command for example:
                        </para>
                        <informalexample>
                            <programlisting>
module acounter counter
acounter config size 100 start 5 increment -1; # 5,4,3,2...
                            </programlisting>
                        </informalexample>
                        <para>
                            Note that several data types are supported
                            by the configuration database and automatically
                            checked to ensure values are valid.  One can also
                            impose range limits on parameters. A real module
                            might have configuration parameters for the
                            base address of the module as well as the settable
                            values of the hardware that are relevant.
                        </para>
                    </callout>
                </calloutlist>
            </section>
            <section>
                <title>The <methodname>Initialize</methodname> method</title>
                <para>
                    <methodname>Initialize</methodname> is invoked after the
                    configuration script has completely run, but before
                    event or scaler triggers are enabled.
                </para>
                <para>
                    It is pretty common practice to fetch the configuration
                    values from the base class configuration database
                    and where appropriate set hardware from them or save them
                    as member variables for use by the <methodname>Read</methodname>
                    method.   Since we have no hardware we're going to just
                    save the data to our member variables.
                </para>
                <informalexample>
                    <programlisting>
void
CCounterModule::Initialize()
{
    CIntConfigParam* pConfigItem;
    
    pConfigItem = (CIntConfigParam*)(*(Find("size"))); <co id='scripted-counter-imp-paramget' />
    m_length    = pConfigItem->getOptionValue();
    
    pConfigItem = (CIntConfigParam*)(*(Find("start")));
    m_firstValue = pConfigItem->getOptionValue();
    
    pConfigItem = (CIntConfigParam*)(*(Find("increment")));
    m_increment = pConfigItem->getOptionValue();
    
        
}
                    </programlisting>
                </informalexample>
                <calloutlist>
                    <callout arearefs='scripted-counter-imp-paramget'>
                        <para>
                            This section of code gets the value of the <literal>size</literal>
                            configuration parameter and sets it as the value of
                            <varname>m_length</varname>.   The
                            <methodname>Find</methodname> base class
                            method returns an object called a
                            <classname>ParameterIterator</classname>.
                            <classname>ParameterIterator</classname> supports
                            dereferencing in a way that returns a pointer to the
                            underlying parameter object (in this case a
                            <classname>CIntConfigParam</classname>).  That
                            object has a <methodname>getOptionValue</methodname> which
                            will return the value of an option.
                        </para>
                    </callout>
                </calloutlist>
            </section>
            <section>
                <title>The <classname>Read</classname> method</title>
                <para>
                    This method is what actually puts data into the buffer.
                    It accepts a pointer to the raw buffer and returns the
                    number of 16 bit entities it has added to the buffer.
                </para>
                <informalexample>
                    <programlisting>
int CCounterModule::Read(void* pEvent)
{
    uint16_t* p = reinterpret_cast&lt;uint16_t*&gt;(pEvent); <co id='scripted-counter-imp-ptrcast' />
    
    int value = m_firstValue;                                <co id='scripted-counter-imp-initialvalue' />
    for (int i = 0; i &lt; m_length; i++) {                 
        *p++ = value;                                        <co id='scripted-counter-imp-fill' />
        value += m_increment;
    }
    return m_length;                                         <co id='scripted-counter-imp-return' />
}
                    </programlisting>
                </informalexample>
                <calloutlist>
                    <callout arearefs='scripted-counter-imp-ptrcast'>
                        <para>
                            Casts the pointer to the buffer to a pointer to unsigned
                            16 bit words.  To do this requires that the
                            implementation file
                            <literal>#include &lt;stdint.h&gt;</literal> in order
                            to define <type>uint32_t</type>.
                        </para>
                    </callout>
                    <callout arearefs='scripted-counter-imp-initialvalue'>
                        <para>
                            Sets the first value of the output sequence
                            from <varname>m_firstValue</varname> recall
                            that <methodname>Initialize</methodname> set this
                            from the value of the configuration variable
                            <literal>start</literal>
                        </para>
                    </callout>
                    <callout arearefs='scripted-counter-imp-fill'>
                        <para>
                            Puts the sequence into the event buffer
                        </para>
                    </callout>
                    <callout arearefs='scripted-counter-imp-return'>
                        <para>
                            Returns the number of 16 bit words that
                            were put into the event buffer.
                        </para>
                    </callout>
                </calloutlist>
            </section>
            <section>
                <title>The creator</title>
                <para>
                    in order to be known to the <command>module</command>
                    command the <classname>CCounterModue</classname> must
                    have a corresponding creator.  The creator is responsible
                    for creating module instances with specific names.
                    If additional parameters are supplied on the
                    <command>module create</command> command line it is normal
                    to treat them as configuration parameters.
                </para>
                <para>
                    The important parts of the header of the module creator for the
                    counter are shown below.
                </para>
                <informalexample>
                    <programlisting>

#ifndef __CMODULECREATOR_H     //CModuleCreator
#include &lt;CModuleCreator.h&gt;                                 <co id='scripted-include-creator-base' />
#endif
class CCounterCreator  : public CModuleCreator                    <co id='scripted-include-creator-class' />
{	
public:
  CCounterCreator ();                                             <co id='scripted-include-creator-construct' />
  virtual ~CCAENV830Creator ( );


public:

   virtual   CReadableObject* Create (CTCLInterpreter&amp; rInterp, 
				      CTCLResult&amp; rResult,    <co id='scripted-include-creator-create' />
				      int nArgs, char** pArgs)   ;  
   virtual   std::string  Help ();                                <co id='scripted-include-creator-help' />

};

                    </programlisting>
                </informalexample>
                <calloutlist>
                    <callout arearefs='scripted-include-creator-base'>
                        <para>
                            All module creator classes must b derivced from the
                            <classname>CModuleCreator</classname> class.  This
                            <literal>#include</literal> provides the definition
                            of that class to the compiler.
                        </para>
                    </callout>
                    <callout arearefs='scripted-include-creator-class'>
                        <para>
                            As descdribed above, our creator, which we're going
                            to call a <classname>CCounterCreator</classname> must
                            be derived from the <classname>CModuleCreator</classname>
                            base class.  In general if I'm writing support for
                            a scripted readout extension I'll call the
                            actual driver class <classname>CxxxxModule</classname>
                            and the creator <classname>CxxxxCreator</classname> where
                            <replaceable>xxxx</replaceable> is some word or
                            phrase that represents the hardware
                            or function being supported.
                        </para>
                    </callout>
                    <callout arearefs='scripted-include-creator-construct'>
                        <para>
                            Creator classes must invoke the base class constructor
                            as we will see in the implementation file.
                            This implies we need our own constructor to ensure
                            the correct parameterization of the base class
                            constructor. Any other initialization we need to do
                            can also be added to our part of the constructor.
                        </para>
                    </callout>
                    <callout arearefs='scripted-include-creator-create'>
                        <para>
                            The key method for the creator is the
                            <methodname>Create</methodname> method.  It is expected
                            to creat the correct module class and register it with the
                            Tcl interpreter that is running the configuration script.
                        </para>
                    </callout>
                    <callout arearefs='scripted-include-creator-help'>
                        <para>
                            The <command>module</command> command also
                            implements a <command>-types</command> keyword.  When
                            the <command>module -types</command> command is
                            executed, each registered creator is askerd via
                            its <methodname>help</methodname> method to contribute
                            a string that provides the module name and a short
                            description of the module.
                        </para>
                    </callout>
                </calloutlist>
                <para>
                    The important parts of the module creator implementation are shown in
                    the next few code fragments.  Specifically we'll look at the
                    implementation of the constructor, the <methodname>Create</methodname>
                    method and the <methodname>help</methodname> methods.
                </para>
                <para>
                    Let's look at the constructor:
                </para>
                <informalexample>
                    <programlisting>
CCounterCreator::CCounterCreator() :
   CModuleCreator("counter")
{}
                    </programlisting>
                </informalexample>
                <para>
                    The base class of the module creator associates a modle type
                    string with the creator.  This is used by the
                    <command>module</command> command to select the appropriate
                    creator when creating a new module. In this case we will
                    make this creator respond to the <literal>counter</literal>
                    module type.
                </para>
                <informalexample>
                    <programlisting>
 CCounterCreator::Create(CTCLInterpreter&amp; rInterp,
                       CTCLResult&amp; rResult,                    <co id='scripted-include-creator-imp-createsig' />
                       int nArgs, char** pArgs)
{

  CReadableObject* pModule = new CCounterModule(*pArgs, rInterp);  <co id='scripted-include-creator-imp-construct' />
  nArgs -= 2;                   // Get rid of module name and type. <co id='scripted-incldue-creator-imp-skipargs' />
  pArgs += 2;

  // If there are any remaining args, configure the mdoule:

  if (nArgs) {
    int status = pModule->Configure(rInterp, rResult,              <co id='scripted-include-creator-imp-configure' />
                                    nArgs, pArgs);
    if (status != TCL_OK) {
      delete pModule;                                              <co id='scripted-include-creator-imp-failed' />
      pModule = (CReadableObject*)NULL;
    }

  }
  return pModule;                                                 <co id='scripted-include-creator-imp-success' />
}
                    </programlisting>
                </informalexample>
                <calloutlist>
                    <callout arearefs='scripted-include-creator-imp-createsig'>
                        <para>
                           The <methodname>Create</methodname> method is used
                           to actually construct modules.
                           <parameter>rInterp</parameter> is a reference to the
                           Tcl interpreter that is executing the configuration
                           script (specifically the <command>module</command>
                           command).  The <parameter>nArgs</parameter> and
                           <parameter>pArgs</parameter> parameters are the
                           number of command words and a pointer to an array  of
                           pointers to the command words that remain after
                           the <command>module</command> command keyword.
                        </para>
                        <para>
                           Specifically:  <varname>pArgs[0]</varname> points to
                           the name of the module to create.  <varname>pArgs[1]</varname>
                           points to the module type (<literal>counter</literal>).
                           The <command>module</command> command has already
                           ensured that there are at least these two command
                           words.
                        </para>
                    </callout>
                    <callout arearefs='scripted-include-creator-imp-construct'>
                        <para>
                            The creator must construct a new <classname>CCounterModule</classname>
                            object.  This line does so, passing in the
                            requested module name and interpreter.
                            Recall that the module itself registers
                            itself as a new Tcl Command.
                        </para>
                    </callout>
                    <callout arearefs='scripted-incldue-creator-imp-skipargs'>
                        <para>
                            By convention any command line words following the
                            module type are treated as an initial set of
                            configuration parameters.
                            These lines skip <varname>nArgs</varname> and
                            <varname>pArgs</varname> over the name and type
                            so that they point to the first of these.
                        </para>
                    </callout>
                    <callout arearefs='scripted-include-creator-imp-configure'>
                        <para>
                            You may recall the <classname>CDigitizerModule</classname>
                            base class for all module drivers maintains a database
                            of configuration parameters and their values.
                            If there are any command line words remaining the
                            creator invokes the <methodname>Configure</methodname>
                            method of that base class which processes the 
                            remaining parameters and updates the configuration
                            database.
                        </para>
                    </callout>
                    <callout arearefs='scripted-include-creator-imp-failed'>
                        <para>
                            The <methodname>Configure</methodname> method
                            returns a Tcl status code which should be
                            <literal>TCL_OK</literal> on success and
                            <literal>TCL_ERROR</literal> on failure.
                            If we failed to configure the module, the module
                            is deleted and a <literal>NULL</literal> pointer
                            is returned indicating the failure to the
                            <command>module</command> command.
                            The <methodname>Configure</methodname>
                            method is assumed to have set the Tcl result
                            to an appropriate error message string.
                        </para>
                    </callout>
                    <callout arearefs='scripted-include-creator-imp-success'>
                        <para>
                            Finally on success, a pointer to the newly
                            created <literal>counter</literal> instance is
                            returned to the <command>module</command> command
                            processor.  The module will be put in a lookup dictionary
                            so that it can be found given its name.
                        </para>
                    </callout>
                </calloutlist>
                <para>
                    We'll omit a detailed discussion of the <methodname>help</methodname>
                    method other than to say that it should return a string like:
                    <literal>counter - Adds a counting pattern to the event</literal>
                </para>
            </section>
        </section>
        <section>
            <title>Extending <classname>CScriptedSegment</classname></title>
            <para>
                Recall that the Readout framework itself organizes the hardware
                into event segments.  Each event segment is normally responsible
                for some part of the detector system.  Event segments are added
                to the readout program by initialization code in the skeleton
                software (which we will cover in the next section).  
            </para>
            <para>
                The scripted readout framework defines a special
                <classname>CScriptedSegment</classname> which which handles
                reading the configuration file creating the appropriate driver
                modules, configuring them and calling them in the appropriate order
                in response to a trigger.  <classname>CScriptedSegment</classname>
                will need to be extended if you have added your own module drivers.
                Specifically, the segment will need to register creators for your
                new modules with the <command>module</command> command so that
                that command both knows about the new module and has a mechanism
                to create instancs of it.
            </para>
            <para>
                This section will continue the example from the last section and
                show how to derive a new class from the <classname>CScriptedSegment</classname>
                that registeres the <classname>CCounterCreator</classname>.
                The next section will show how to modify <filename>Skeleton.cpp</filename>
                so that it uses your scripted event segment instead of the base
                class.
            </para>
            <para>
                When adding scaler module support, the concept is identical however
                you will derive your class from <classname>CScriptedScalers</classname>
                wich is a <classname>CScaler</classname> class that operates in a
                manner similiar to <classname>CScriptedSegment</classname>.
            </para>
            <para>
                As usual, we start by looking at the important featurs of the
                header for <classname>CMyScriptedSegement</classname> the new
                scripted segment we're going to write.
            </para>
            <informalexample>
                <programlisting>
// CMyScriptedSegment.h

#ifndef __CEVENTSEGMENT_H
#include &lt;CEventSegment.h&gt;                   <co id='scripted-scriptedsegment-baseinc' />
#endif

class CMyScriptedSegment : public CScriptedSegment <co id='scripted-scritpedsegment-classdef' />
{
  virtual void addUserWrittenCreators();           <co id='scripted-scriptedsegment-addcreators' />
};
                </programlisting>
            </informalexample>
            <calloutlist>
                <callout arearefs='scripted-scriptedsegment-baseinc'>
                    <para>
                        This <literal>#include</literal> includes
                        defines the <classname>CScriptedSegment</classname>
                        which will be the base class of the
                        <classname>CMyScriptedSegment</classname> class.
                    </para>
                </callout>
                <callout arearefs='scripted-scritpedsegment-classdef'>
                    <para>
                        The <classname>CMyScriptedSegment</classname> is defined
                        using the <classname>CScriptedSegment</classname> as its
                        base class.
                    </para>
                </callout>
                <callout arearefs='scripted-scriptedsegment-addcreators'>
                    <para>
                        The <classname>CScriptedSegment</classname> base class
                        uses the
                        <ulink url='http://sourcemaking.com/design_patterns/strategy'>
                            Strategy pattern</ulink>.  One of the strategies that is
                        exported by the class is a method for registering user written
                        creators via the virtual function
                        <methodname>addUserWrittenCreators</methodname>.
                    </para>
                    <para>
                        In the base class <classname>CScriptedSegment</classname>
                        the implementation of this function is an empty body
                        (<literal> {} </literal>).  Here we declare our version
                        to override the base class version.
                        The base class code will automatically call our
                        <methodname>addUserWrittenCreators</methodname>
                        method at the right time inthe life-cycle of the
                        <classname>CScriptedSegment</classname>
                    </para>
                </callout>
            </calloutlist>
            <para>
                Now let's look at the key implementation features.
            </para>
            <informalexample>
                <programlisting>
#include "CMyScriptedSegment.h"                   <co id='scripted-scriptedsegment-headers' />
#include "CCounterCreator.h"

void
CMyScriptedSegment::addUserWrittenCreators() {   <co id='scripted-scriptedsegment-uwcreatorimpl' />
    addCreator(*(new CCounterCreator()));        <co id='scripted-scriptedsegment-addcall' />
}
                </programlisting>
            </informalexample>
            <calloutlist>
                <callout arearefs='scripted-scriptedsegment-headers'>
                    <para>
                        The implementation will need to include
                        a minimum of the header for the class itself and the
                        headers for any creators it is going to register.
                    </para>
                </callout>
                <callout arearefs='scripted-scriptedsegment-uwcreatorimpl'>
                    <para>
                        As already discussed, the class we are implementing
                        will produce an implementation that overrides the
                        base class implementation of <methodname>addCreator</methodname>.
                    </para>
                </callout>
                <callout arearefs='scripted-scriptedsegment-addcall'>
                    <para>
                        The <methodname>addCreator</methodname> method in the
                        base class (<classname>CScriptedSegment</classname>)
                        Takes a reference to a <classname>CModuleCreator</classname>
                        object and adds it to the set of creators known by
                        it's <command>module</command> command.
                    </para>
                    <para>
                        The construction
                        <literal>*(new CCounterCreator())</literal>
                        creates a reference to a dynamically allocated
                        <classname>CCounterCreator</classname> object.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section>
            <title>Modifying <filename>Skeleton.cpp</filename></title>
            <para>
                If you have worked with the SBS readout framework, you know
                that everything gets knit together in the
                <filename>Skeleton.cpp</filename> file.  Continuing the
                example in the previous section, we're going to point out
                how to modify <filename>Skeleton.cpp</filename> so that your
                scripted event segment <classname>CMyScriptedSegment</classname>
                is used as the event segment rather than the normal
                <classname>CScritedSegment</classname>.  Doing this ensures
                that your hardware configuration file can use addtional module
                types (such as the <literal>counter</literal> type) you have
                added to the system.
            </para>
            <para>
                We are going to modify the
                <methodname>Skeleton::SetupReadout</methodname> method.
                If you were adding scaler modules you would make very similar
                modifications to the <methodname>Skeleton::SetupScalers</methodname>
            </para>
            <para>
                The first thing you will need to do is add an
                <literal>#include "MyScriptedSegment.h"</literal>
                directive towards the top of the headers in <filename>Skeleton.cpp</filename>
                I like to add <literal>#include</literal> directives at the
                end of those that are already there.
            </para>
            <para>
                Below is what them modified <methodname>SetupReadout</methodname>
                should look like.  Comments have been removed for the sake of
                brevity. The code assumes you are using a V977 coincidence
                register at <literal>0x11110000</literal> of crate 0 as both the trigger
                and busy module.
            </para>
            <informalexample>
                <programlisting>
Skeleton::SetupReadout(CExperiment* pExperiment)
{
  CReadoutMain::SetupReadout(pExperiment);

  pExperiment->EstablishTrigger(new CV977Trigger(0x11110000));  <co id='scripted-skeleton-triggerbusy' />
  pExperiment->EstablishTrigger(new CV977Busy(0x11110000));
  
  pExperiment->AddEventSegment(new CMyScriptedSegment());       <co id='scripted-skeleton-segment' />

}
                </programlisting>
            </informalexample>
            <calloutlist>
                <callout arearefs='scripted-skeleton-triggerbusy'>
                    <para>
                        Sets up the trigger and busy management for the experiment
                        to be a CAEN V977 coincidence register module.
                    </para>
                </callout>
                <callout arearefs='scripted-skeleton-segment'>
                    <para>
                        Sets up the event segment to be the scripted
                        segment we wrote in the previous section.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section>
            <title>Modifying the Makefile</title>
            <para>
                In the previous several sections, we added several source
                files. Not counting headers:
            </para>
                <variablelist>
                    <varlistentry>
                        <term><filename>CCounterModule.cpp</filename></term>
                        <listitem>
                            <para>
                                The driver for the counting pattern 'device'.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><filename>CCounterCreator.cpp</filename></term>
                        <listitem>
                            <para>
                                The creator that the <command>module</command>
                                command associates with the <literal>counter</literal>
                                module type.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><filename>CMyScriptedSegment.cpp</filename></term>
                        <listitem>
                            <para>
                                Scripted event segment that added the
                                <classname>CCounterCreator</classname> to the
                                list of creators known by the scriptable event
                                segment.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    In addition we modified <filename>Skeleton.cpp</filename> but
                    that does not require any changes to the Makefile.  As with most
                    templated NSCL makefiles there is a Makefile definition
                    <literal>OBJECTS</literal> which is the list of object files
                    that must be built and linked into the readout framework.
                </para>
                <para>
                    This is a whitespace separated list.  Initially it looks like
                    <informalexample>
                        <programlisting>
    OBJECTS=Skeleton.o
                        </programlisting>
                    </informalexample>
                    To incorporate our new classes, this line must be modified
                    to read:
                    <informalexample>
                        <programlisting>
    OBJECTS=Skeleton.o CCounterModule.o CCounterCreator.o CMyScriptedSegment.o
                        </programlisting>
                    </informalexample>
                </para>
        </section>
    </section>
    
    <section id='sbs-scripted-sec-hybrid'>
        <title id='sbs-scripted-sec-hybrid-title'>Hybrid scripted readouts</title>
        <para>
            Since the scripted readout framework is fundamentally an SBS
            readout framework with a special event segment many other
            special applications are possible:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    You can add several scripted readout segments.  When you do this
                    you will want each segment to read a different configuration script.
                    This is done by deriving a class from
                    <classname>CScriptedSegement</classname> and overriding the
                    <methodname>getConfigurationFile</methodname> method to return
                    the full path to the configuration file you want read.
                    You should use the full path because in general you can't count
                    on the current working directory being something you now.
                </para>
                <para>
                    You can do the same thing with scripted scalers.
                </para>
            </listitem>
            <listitem>
                <para>
                    You can freely mix 'normal' event segments with
                    scripted segments just by creating hard coded
                    event segments and then registering them along with
                    any scripted segments you have.  Similarly you can
                    mix coded and scripted scaler readouts.
                </para>
            </listitem>
        </itemizedlist>
    </section>
</chapter>

<!-- /chapter -->

<!-- manpage 3sbsReadout -->

<!-- module command -->

      <refentry id='sbsreadout3_module'>
        <refmeta>
           <refentrytitle id='sbsreadout3_module_title'>module</refentrytitle>
           <manvolnum>3sbsreadout</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>module</refname>
           <refpurpose>Create list and delete scripted readout modules.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
          <command>
module <replaceable>name type ?options?</replaceable>
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
module -list ?pattern?
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
module -delete <replaceable>module-name</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
module -types
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This command is defined in scripted readout event segments.
            If no option value is provided a new module instance is
            created and any remaining command line parameters must be legal
            configuration option/value pairs for the moduld's
            <command>config</command> subcommand.  The module's
            <parameter>name</parameter> becomes a Tcl command.
            See
            <link linkend='sbsreadout3_modulesubcommands'
                  endterm='sbsreadout3_modulesubcommands_title' />
            for information about the subcommands that are suppported by modules.
            See the man page for each module type for information about
            the configuration options each module type supports.
           </para>
           <para>
            If the <option>-list</option> option is provided, the names of all
            the known modules are returned as a Tcl list.  The optional
            <parameter>pattern</parameter> parameter is a pattern that can
            contain glob wildcard matching characters.  If provided, only
            the module names that match the <parameter>pattern</parameter> are
            listed.  If not the default pattern is <literal>*</literal> which
            matches anything.
           </para>
           <para>
            If the <option>-delete</option> is provided, the module named
            <parameter>module-name</parameter> is removed from the set of known
            modules. The affect of this on readout lists that contain that module
            (packets are also readout lists) is very badly defined.
           </para>
           <para>
            The <option>-types</option> option lists the set of module
            types that can be created and provides a short description of each
            of them.
           </para>
        </refsect1>


      </refentry>

<!-- module subcommands -->
      <refentry id="sbsreadout3_modulesubcommands">
        <refmeta>
           <refentrytitle id='sbsreadout3_modulesubcommands_title'>Module Subcommands</refentrytitle>
           <manvolnum>3sbsreadout</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>Module Subcommands</refname>
           <refpurpose>Subcommands recognized by all modules</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
<replaceable>module-name</replaceable> config <replaceable>config-options...</replaceable>
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>module-name</replaceable> cget <replaceable>?pattern?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>module-name</replaceable> help
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            All modules created by the
            <link linkend='sbsreadout3_module' endterm='sbsreadout3_module_title' />
            command themselves become new Tcl commands in the interpreter that
            executes the configuration file.  The command word is the module name
            (e.g. <command>module adc1 caenv785</command> creates a command <command>adc1</command>).
            Each of these commands is a command ensemble.  Command ensembles are
            commands whose first parameter word is a subcommand.  An example of
            a command ensemble in standart Tcl is the
            <ulink url='http://www.tcl.tk/man/tcl8.5/TclCmd/string.htm'><command>string</command></ulink>
            command.
           </para>
           <para>
            The following subcommands are supported, though an individual module
            driver
            can define more subcommands. 
           </para>
           <variablelist>
            <varlistentry>
                <term><command>config</command> <replaceable>config-options...</replaceable></term>
                <listitem>
                    <para>
                        The remaining parameters are configuration option names
                        followed by a new value for the option.  The
                        <command>config</command> sub-command is used to describe
                        to each module the way it should run. 
                    </para>
                    <para>
                        Each module will define a set of configuration parameters
                        that match the settable capabilities of the module.
                        The module's initialization and read methods will use
                        the values of these options to determine how to set up
                        the module for data taking and how to read the module
                        out.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>cget</command> <replaceable>?pattern?</replaceable></term>
                <listitem>
                    <para>
                        Returns Tcl list whose elements are themselves two element
                        sub-lists consisting of an option keyword and its value
                        in that order. If <replaceable>pattern</replaceable> is
                        provided it is a pattern with glob wild-card characters and
                        only those options whose names match the pattern will be
                        listed.  If omitted, the pattern defaults to <literal>*</literal>
                        which lists all options.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>help</command></term>
                <listitem>
                    <para>
                        Returns information about the module and the set of
                        configuration parameters supported.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <para>
            The actual options vary from module type to module type.
            Each module type has a manpage in this section that describes
            the options it supports.
           </para>
        </refsect1>

      </refentry>


<!-- readout command -->

      <refentry id="sbsreadout3_readout">
        <refmeta>
           <refentrytitle id='sbsreadout3_readout_title'>readout</refentrytitle>
           <manvolnum>3sbsreadout</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>readout</refname>
           <refpurpose>Maintain list of modules to readout</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
         <command>
readout config <replaceable>options...</replaceable>            
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
readout cget <replaceable>?pattern?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
readout help
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
readout add <replaceable>module-name1 ?module-name2...?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
readout list <replaceable>?pattern?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
readout remove <replaceable>module-name</replaceable>
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            The <command>readout</command> command is actually a module type
            that provides the top level list of things to read.  It maintains
            an ordered list of modules.  When a run starts, the modules
            are iterated through to initialize the system, prepare it for read,
            readout in response to triggers and so on.
           </para>
           <para>
            <command>readout</command> is also implemented as a module
            type
            (see <link linkend='sbsreadout3_packet_module' endterm='sbsreadout3_packet_module_title' />
            below).  Used as such you can divide the readout into labeled packets
            and sub packets to any depth required.
           </para>
        </refsect1>
        <refsect1>
            
           <title>
              OPTIONS
           </title>
           <para>
            the <command>readout</command> command supports options that
            provide the capability of wrapping the data read by its modules
            into an NSCL packet.  An NSCL packet is a structure that consists
            of a header and a body.  The header contains in order a 16 bit word
            count and a 16 bit type tag called an <firstterm>id</firstterm>.
            The configuration options that control this capability are shown
            below:
           </para>
           <variablelist>
            <varlistentry>
                <term><option>packetize</option> <replaceable>boolean-value</replaceable></term>
                <listitem>
                    <para>
                        Enables or disables wrapping the data in a packet.
                        This is <literal>false</literal> by default.
                        Set <parameter>boolean-value</parameter> to <literal>true</literal>
                        to enable packet wrapping.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>id</option> <replaceable>integer-value</replaceable></term>
                <listitem>
                    <para>
                        Sets the packet id to use when <option>packetize</option>
                        is <literal>true</literal>. The value of this option
                        defaults to <literal>-1</literal> which is deliberately
                        not suitable.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>
        <refsect1>
            <title>SUB-COMMANDS</title>
            <para>
                Since the <command>readout</command> command is a module command,
                it understands the <command>config</command>, <command>cget</command>
                and <command>help</command> subcommands documented by the
                <link linkend='sbsreadout3_modulesubcommands'>module subcommands</link>
                manpage.
            </para>
            <para>
                In addition, in order to support the maintenance of the module
                list, <command>readout</command> defines some additional
                subcommands:
            </para>
            <variablelist>
                <varlistentry>
                    <term><command>add</command> <replaceable>module-name1, ?...?</replaceable></term>
                    <listitem>
                        <para>
                            Each remaining command line work is the name of a
                            module that was defined via the <command>module</command>
                            command.  These modules are appended in order to the
                            list of modules the <command>readout</command> maintains.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>list</command> <replaceable>?pattern?</replaceable></term>
                    <listitem>
                        <para>
                            Lists the modules (in order) maintained by the readout
                            list.  If the <replaceable>pattern</replaceable> is
                            provided it is a string with glob wildcard characters
                            that filters out the set of module names that are
                            listed.  If not provided the filter pattern is
                            <literal>*</literal> listing all modules.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>remove</command> <replaceable>module-name</replaceable></term>
                    <listitem>
                        <para>
                            Removes the modle <replaceable>module-name</replaceable> from
                            the list of modules maintained by the <command>readout</command>
                            command. Note that this does not affect the order
                            of the other modules in the list.  For example:
                        </para>
                        <informalexample>
                            <screen>
<command>readout list</command>
<computeroutput>a b c d</computeroutput>
<command>readout remove c</command>
<command>readout list</command>
<computeroutput>a b d</computeroutput>
                            </screen>
                        </informalexample>
                    </listitem>
                </varlistentry>
                
            </variablelist>
        </refsect1>
      </refentry>


<!-- individual module type manpages -->

<!-- v775 -->

      <refentry id="sbsreadout3_v775_module">
        <refmeta>
           <refentrytitle id="sbsreadout3_v775_module_title">caenv775</refentrytitle>
           <manvolnum>3sbsreadout</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>caenv775</refname>
           <refpurpose>CAENV775 module type</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
        <command>
module create <replaceable>name</replaceable> caenv775 <replaceable>?options...?</replaceable>
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>name</replaceable> config <replaceable>?options...?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>name</replaceable> cget <replaceable>?pattern?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>name</replaceable> help
                </command>
            </cmdsynopsis>


        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            The <literal>caenv775</literal> module type provides support for the
            CAEN V775 32 channel TDC module in the scripted readout framework.
            Instances of this module are created using the
            <command>module</command> command as shown in the SYNOPSIS above.
            The result is a new Tcl command which accepts all if the normal
            <link linkend="sbsreadout3_modulesubcommands">module subcommands</link>.
           </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <para>
            The module configuration options supported by the <literal>caenv775</literal>
            module type are:
           </para>
           <variablelist>
            <!-- common to all CAEN modules -->
            <varlistentry>
                <term><option>crate</option> <replaceable>crate-no</replaceable></term>
                <listitem>
                    <para>
                        Specifies the VME crate in which the module lives.
                        This defaults to <literal>0</literal> which is a good
                        default for single crate systems.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>slot</option> <replaceable>geo-num</replaceable></term>
                <listitem>
                    <para>
                        Determines the geographical address assigned to the module.
                        Note that for modules with a middle connector inserted in
                        a VME crate with a middle connector, this value comes
                        from the actual physical slot and cannot be
                        overidden.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>threshold</option> <replaceable>32-element-list</replaceable></term>
                <listitem>
                    <para>
                        Suplies the thrsehold values for the digitizer.  This is a Tcl list of
                        32 integers that will be programmed into the threshold memory.  Note
                        that for 16 channel units (NIM inputs), every other value is
                        used as the digitizer hooks up inputs to every other input channel.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>keepunder</option> <replaceable>boolean-value</replaceable></term>
                <listitem>
                    <para>
                        Defaults to <literal>false</literal> if set to <literal>true</literal>
                        values with are below the threshold will be kept.  It is often useful to
                        start up with this value and <option>keepoverflow</option> set to
                        <literal>true</literal> so that you can see what's going on in all
                        channels of the digitizer until it is properly set up.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>keepoverflow</option> <replaceable>boolean-value</replaceable></term>
                <listitem>
                    <para>
                        Defaults to <literal>false</literal> if set to <literal>true</literal>
                        channels that have overflow values (e.g. in common start mode channels
                        without a stop), are not suppressed from the data.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>card</option> <replaceable>boolean-value</replaceable></term>
                <listitem>
                    <para>
                        Defaults to <literal>true</literal> if set <literal>false</literal>
                        the entire digitizer card is disabled.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>geo</option> <replaceable>boolean-value</replaceable></term>
                <listitem>
                    <para>
                        Defaults to <literal>true</literal> which means that geographical
                        addressing will be used for the card.  Note that:
                        <itemizedlist>
                            <listitem>
                                <para>
                                The board must have a middle VME connector.
                                </para>
                            </listitem>
                        </itemizedlist>
                        <itemizedlist>
                            <listitem>
                                <para>
                                The board must be used with a VME crate that has the
                                middle connector specified by the CERN VME rev C
                                extensions.
                                </para>
                            </listitem>
                        </itemizedlist>
                    </para>
                    <para>
                        While at the time this framework was written the
                        conditions required to run with geographical addressing
                        were commonly available, this is no longer true, and the
                        use of this option is no longer recommended.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>enable</option> <replaceable>list-of-integers</replaceable></term>
                <listitem>
                    <para>
                        The <replaceable>list-of-integers</replaceable> represent
                        the per channel enables (kill bits in the CAEN manual) for
                        the digitizer.  Non zero values represent an enable and
                        zero values represent a disabled channel.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>base</option> <replaceable>base-address</replaceable></term>
                <listitem>
                    <para>
                        Provides the base address of the module as set by the
                        rotary switches on the module.   Note that the actual
                        A32 (extended) address must be provided, not just the
                        rotary switch values.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>fastclearwindow</option> <replaceable>ticks</replaceable></term>
                <listitem>
                    <para>
                        Sets the value of the fast clear window register.   This
                        defaults to <literal>0</literal>
                    </para>
                </listitem>
            </varlistentry>
    
            
            <!-- Specific to the v775 -->
            <varlistentry>
                <term><option>range</option> <replaceable>integer-value</replaceable></term>
                <listitem>
                    <para>
                        Sets the TDC range value.  This is an integer between
                        <literal>140</literal> and <literal>1200</literal>
                        respectively.  The correspondence between this
                        value and the actual range in real time units is
                        documented in the V775 manual.  Defaults to
                        <literal>500</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>commonstart</option> <replaceable>bool</replaceable></term>
                <listitem>
                    <para>
                        Defaults to <literal>true</literal> if set to
                        <literal>false</literal> the gate input will be used
                        as a common stop input and the channel inputs are
                        individual start inputs.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>

      </refentry>


<!-- v785 -->
      <refentry id="sbsreadout3_v785_module">
        <refmeta>
           <refentrytitle id="sbsreadout3_v785_module_title">caenv785</refentrytitle>
           <manvolnum>3sbsreadout</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>caenv785</refname>
           <refpurpose>CAENV775 module type</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
        <command>
module create <replaceable>name</replaceable> caenv785 <replaceable>?options...?</replaceable>
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>name</replaceable> config <replaceable>?options...?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>name</replaceable> cget <replaceable>?pattern?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>name</replaceable> help
                </command>
            </cmdsynopsis>


        </refsynopsisdiv>        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            The <literal>caenv785</literal> module type provides support for the
            CAEN V785 peak sensing ADC.  Since this is a module type it supports
            all of the subcommands documented in
            the <link linkend="sbsreadout3_modulesubcommands">module subcommands</link>
            manpage.
           </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           
           <para>
            The module configuration options supported by the <literal>caenv785</literal>
            module type are:
           </para>
           <variablelist>
            <!-- common to all CAEN modules -->
            <varlistentry>
                <term><option>crate</option> <replaceable>crate-no</replaceable></term>
                <listitem>
                    <para>
                        Specifies the VME crate in which the module lives.
                        This defaults to <literal>0</literal> which is a good
                        default for single crate systems.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>slot</option> <replaceable>geo-num</replaceable></term>
                <listitem>
                    <para>
                        Determines the geographical address assigned to the module.
                        Note that for modules with a middle connector inserted in
                        a VME crate with a middle connector, this value comes
                        from the actual physical slot and cannot be
                        overidden.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>threshold</option> <replaceable>32-element-list</replaceable></term>
                <listitem>
                    <para>
                        Suplies the thrsehold values for the digitizer.  This is a Tcl list of
                        32 integers that will be programmed into the threshold memory.  Note
                        that for 16 channel units (NIM inputs), every other value is
                        used as the digitizer hooks up inputs to every other input channel.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>keepunder</option> <replaceable>boolean-value</replaceable></term>
                <listitem>
                    <para>
                        Defaults to <literal>false</literal> if set to <literal>true</literal>
                        values with are below the threshold will be kept.  It is often useful to
                        start up with this value and <option>keepoverflow</option> set to
                        <literal>true</literal> so that you can see what's going on in all
                        channels of the digitizer until it is properly set up.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>keepoverflow</option> <replaceable>boolean-value</replaceable></term>
                <listitem>
                    <para>
                        Defaults to <literal>false</literal> if set to <literal>true</literal>
                        channels that have overflow values (e.g. in common start mode channels
                        without a stop), are not suppressed from the data.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>card</option> <replaceable>boolean-value</replaceable></term>
                <listitem>
                    <para>
                        Defaults to <literal>true</literal> if set <literal>false</literal>
                        the entire digitizer card is disabled.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>geo</option> <replaceable>boolean-value</replaceable></term>
                <listitem>
                    <para>
                        Defaults to <literal>true</literal> which means that geographical
                        addressing will be used for the card.  Note that:
                        <itemizedlist>
                            <listitem>
                                <para>
                                The board must have a middle VME connector.
                                </para>
                            </listitem>
                        </itemizedlist>
                        <itemizedlist>
                            <listitem>
                                <para>
                                The board must be used with a VME crate that has the
                                middle connector specified by the CERN VME rev C
                                extensions.
                                </para>
                            </listitem>
                        </itemizedlist>
                    </para>
                    <para>
                        While at the time this framework was written the
                        conditions required to run with geographical addressing
                        were commonly available, this is no longer true, and the
                        use of this option is no longer recommended.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>enable</option> <replaceable>list-of-integers</replaceable></term>
                <listitem>
                    <para>
                        The <replaceable>list-of-integers</replaceable> represent
                        the per channel enables (kill bits in the CAEN manual) for
                        the digitizer.  Non zero values represent an enable and
                        zero values represent a disabled channel.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>base</option> <replaceable>base-address</replaceable></term>
                <listitem>
                    <para>
                        Provides the base address of the module as set by the
                        rotary switches on the module.   Note that the actual
                        A32 (extended) address must be provided, not just the
                        rotary switch values.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>fastclearwindow</option> <replaceable>ticks</replaceable></term>
                <listitem>
                    <para>
                        Sets the value of the fast clear window register.   This
                        defaults to <literal>0</literal>
                    </para>
                </listitem>
            </varlistentry>
            <!-- V785 specific options  - there are none -->
            
           </variablelist>
        </refsect1>

      </refentry>

<!-- v792 -->
      <refentry id="sbsreadout3_v792_module">
        <refmeta>
           <refentrytitle id="sbsreadout3_v792_module_title">caenv792</refentrytitle>
           <manvolnum>3sbsreadout</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>caenv792</refname>
           <refpurpose>CAENV792 module type</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
        <command>
module create <replaceable>name</replaceable> caenv792 <replaceable>?options...?</replaceable>
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>name</replaceable> config <replaceable>?options...?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>name</replaceable> cget <replaceable>?pattern?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>name</replaceable> help
                </command>
            </cmdsynopsis>


        </refsynopsisdiv>        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            The <literal>caenv792</literal> module type provides support for the
            CAEN V792 current integrating ADC.  Since this is a module type it supports
            all of the subcommands documented in
            the <link linkend="sbsreadout3_modulesubcommands">module subcommands</link>
            manpage.
           </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <para>
            The modules configuration options supported by the <literal>caenv792</literal>
            module type are:
           </para>
           <variablelist>
            <!-- common to all CAEN modules -->
            <varlistentry>
                <term><option>crate</option> <replaceable>crate-no</replaceable></term>
                <listitem>
                    <para>
                        Specifies the VME crate in which the module lives.
                        This defaults to <literal>0</literal> which is a good
                        default for single crate systems.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>slot</option> <replaceable>geo-num</replaceable></term>
                <listitem>
                    <para>
                        Determines the geographical address assigned to the module.
                        Note that for modules with a middle connector inserted in
                        a VME crate with a middle connector, this value comes
                        from the actual physical slot and cannot be
                        overidden.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>threshold</option> <replaceable>32-element-list</replaceable></term>
                <listitem>
                    <para>
                        Suplies the thrsehold values for the digitizer.  This is a Tcl list of
                        32 integers that will be programmed into the threshold memory.  Note
                        that for 16 channel units (NIM inputs), every other value is
                        used as the digitizer hooks up inputs to every other input channel.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>keepunder</option> <replaceable>boolean-value</replaceable></term>
                <listitem>
                    <para>
                        Defaults to <literal>false</literal> if set to <literal>true</literal>
                        values with are below the threshold will be kept.  It is often useful to
                        start up with this value and <option>keepoverflow</option> set to
                        <literal>true</literal> so that you can see what's going on in all
                        channels of the digitizer until it is properly set up.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>keepoverflow</option> <replaceable>boolean-value</replaceable></term>
                <listitem>
                    <para>
                        Defaults to <literal>false</literal> if set to <literal>true</literal>
                        channels that have overflow values (e.g. in common start mode channels
                        without a stop), are not suppressed from the data.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>card</option> <replaceable>boolean-value</replaceable></term>
                <listitem>
                    <para>
                        Defaults to <literal>true</literal> if set <literal>false</literal>
                        the entire digitizer card is disabled.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>geo</option> <replaceable>boolean-value</replaceable></term>
                <listitem>
                    <para>
                        Defaults to <literal>true</literal> which means that geographical
                        addressing will be used for the card.  Note that:
                        <itemizedlist>
                            <listitem>
                                <para>
                                The board must have a middle VME connector.
                                </para>
                            </listitem>
                        </itemizedlist>
                        <itemizedlist>
                            <listitem>
                                <para>
                                The board must be used with a VME crate that has the
                                middle connector specified by the CERN VME rev C
                                extensions.
                                </para>
                            </listitem>
                        </itemizedlist>
                    </para>
                    <para>
                        While at the time this framework was written the
                        conditions required to run with geographical addressing
                        were commonly available, this is no longer true, and the
                        use of this option is no longer recommended.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>enable</option> <replaceable>list-of-integers</replaceable></term>
                <listitem>
                    <para>
                        The <replaceable>list-of-integers</replaceable> represent
                        the per channel enables (kill bits in the CAEN manual) for
                        the digitizer.  Non zero values represent an enable and
                        zero values represent a disabled channel.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>base</option> <replaceable>base-address</replaceable></term>
                <listitem>
                    <para>
                        Provides the base address of the module as set by the
                        rotary switches on the module.   Note that the actual
                        A32 (extended) address must be provided, not just the
                        rotary switch values.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>fastclearwindow</option> <replaceable>ticks</replaceable></term>
                <listitem>
                    <para>
                        Sets the value of the fast clear window register.   This
                        defaults to <literal>0</literal>
                    </para>
                </listitem>
            </varlistentry>
            <!-- V792 specific options   -->
            <varlistentry>
                <term><option>Iped</option> <replaceable>integer</replaceable></term>
                <listitem>
                    <para>
                        Defaults to <literal>0</literal> this value,
                        in the range <literal>0-255</literal> is programmed
                        into the current pedestal register.  A charge proportional
                        to this value is injected into the charge accumulation
                        capacitor while the gate is open.  This is intended to
                        compensate for the leakage current that can be significant
                        for long gates.  Without it, meaningful signals could
                        leak down in to the threshold region of the ADC given a
                        long gate.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>

      </refentry>


<!-- v830 -->

      <refentry id="sbsreadout3_v830_module">
        <refmeta>
           <refentrytitle id='sbsreadout3_v830_module_title'>caenv830</refentrytitle>
           <manvolnum>3sbsreadout</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>caenv830</refname>
           <refpurpose>CAEN V830 scaler support</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
        <command>
module create <replaceable>name</replaceable> caenv830 <replaceable>?options...?</replaceable>
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>name</replaceable> config <replaceable>?options...?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>name</replaceable> cget <replaceable>?pattern?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>name</replaceable> help
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This module type provides support for the CAEN V830 32 channel scaler
            module. Since this is a scripted modue type it supports all of
            the subcommands described in
            the <link linkend="sbsreadout3_modulesubcommands">module subcommands</link>
            manpage.
           </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
            <varlistentry>
                <term><option>base</option> <replaceable>base-address</replaceable></term>
                <listitem>
                    <para>
                        Provides the VME base address of the module.  This must
                        match the base address in the rotary switches on the module.
                        Note that this value should be the full 32-bit address
                        not just the value of the four rotary switches.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>slot</option> <replaceable>geo-address</replaceable></term>
                <listitem>
                    <para>
                        The scaler output can include a header with a programmable
                        virtual slot number.  The value of
                        <replaceable>geo-address</replaceable> an dinteger between
                        <literal>0</literal> and <literal>255</literal> is
                        used for the geographical address.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>crate</option> <replaceable>crate-num</replaceable></term>
                <listitem>
                    <para>
                        The number of the VME crate in which the scaler lives.
                        This defaults to <literal>0</literal> which is suitable
                        for a systsem with only one VME crate.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>geo</option> <replaceable>boolean</replaceable></term>
                <listitem>
                    <para>
                        If <literal>true</literal>, the default, geographical
                        addressing is used to initialize the module.  If
                        <literal>false</literal> the base address is used.
                        Note that for geographical addressing to be used, it is
                        necessary for the module to have a middle VME connector and
                        for the VME crate to have a similar CERN VME rev.C middle
                        connector as well, as that supplies the slot number to the
                        module.
                    </para>
                    <para>
                        Originally this combination of VME crate and module were
                        quite common, now mch less so.  It is therefore recommended
                        to set this parameter to <literal>false</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>enables</option> <replaceable>list-of-32-ints</replaceable></term>
                <listitem>
                    <para>
                        Provides a list of channel enables.  This must be a valid
                        Tcl list containing exactly 32 elements.  Channels for which
                        elements are non-zero are enabled, channels for which elements
                        are <literal>0</literal> are disabled.  The default value is
                        a list of 32 <literal>1</literal> values which enables
                        all channels.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>trigger</option> <replaceable>selector</replaceable></term>
                <listitem>
                    <para>
                        Determines the trigger mode.  This is an encode value which is
                        one of the following
                    </para>
                    <itemizedlist>
                        <listitem><para><literal>0</literal> trigger is disabled</para></listitem>
                        <listitem><para><literal>1</literal> trigger is random (due to VME or external inputs)</para></listitem>
                        <listitem><para><literal>2</literal> Trigger is periodic.</para></listitem>
                    </itemizedlist>
                    <para>
                        In most cases you should use the default value <literal>1</literal> which selects
                        random trigger mode.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>wide</option> <replaceable>boolean</replaceable></term>
                <listitem>
                    <para>
                        When this option is <literal>true</literal> the data are read
                        in the 32 bit mode shown in figure <literal>3.2</literal> of
                        the V8320 manual.  When <literal>false</literal> the data
                        are read in the 26 bit scaler format shown in
                        figure <literal>3.3</literal> of the same manual.
                    </para>
                    <para>
                        The recomended value for this parameter is <literal>true</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>header</option> <replaceable>boolean</replaceable></term>
                <listitem>
                    <para>
                        If <literal>true</literal>, which is the default a header
                        describe in section <literal>3.2</literal> figure
                        <literal>3.1</literal> of the V830
                        manual will be read.  If <literal>false</literal> the
                        header is suppressed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>autoreset</option> <replaceable>boolean</replaceable></term>
                <listitem>
                    <para>
                        If <literal>true</literal>, the default, the
                        module is initialized so that a latch of the scaler value
                        also clears the counters.  This is suitable for use
                        as an incremental scaler.
                    </para>
                    <para>
                        If <literal>false</literal> scaler channels are not
                        reset on a latch.  This provides support for non-incremental
                        scalers.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>fpclearmeb</option> <replaceable>boolean</replaceable></term>
                <listitem>
                    <para>
                        If <literal>true</literal> the front panel input
                        can clear the scaler counts.  If <literal>false</literal>,
                        the default, the front panel signal will not clear the
                        scaler counters.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>manualclear</option> <replaceable>boolean</replaceable></term>
                <listitem>
                    <para>
                        If <literal>true</literal> after reading a software clear
                        is performed on the module. If <literal>false</literal>,
                        which is the default, this is not performed.
                    </para>
                    <para>
                        The recommended way to get incremental behavior is to
                        set <option>autoreset</option> to <literal>true</literal>
                        rather than using this method.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>packetize</option> <replaceable>boolean</replaceable></term>
                <listitem>
                    <para>
                        If <literal>true</literal> wrap the data from the
                        digitizer in an NSCL packet consisting of a word count
                        and an id value.  If <literal>false</literal>, the default,
                        no such wrapping is performed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>id</option> <replaceable>integer</replaceable></term>
                <listitem>
                    <para>
                        Provides the value of the id field of the packet
                        header when <option>packetize</option> is <literal>true</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>vmetrigger</option> <replaceable>boolean</replaceable></term>
                <listitem>
                    <para>
                        If <literal>true</literal> a VME trigger is performed
                        prior to readout.  If <literal>false</literal>, the default,
                        this is not performed.   If you are using this scaler
                        to provide periodic scaler data this should be
                        <literal>true</literal> as you want the readout timer
                        to initiate the trigger.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>

      </refentry>


<!-- packet -->
      <refentry id="sbsreadout3_packet_module">
        <refmeta>
           <refentrytitle id="sbsreadout3_packet_module_title">packet</refentrytitle>
           <manvolnum>sbsreadout3</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>packet</refname>
           <refpurpose>Scripted readout packet encapsulator</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
         <cmdsynopsis>
         <command>
module create <replaceable>name</replaceable> packet <replaceable>?options...</replaceable>

          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>name</replaceable> configure <replaceable>options...</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>name</replaceable> cget <replaceable>?pattern?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>name</replaceable> help
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This module type is actually a 
            <link linkend='sbsreadout3_readout' endterm='sbsreadout3_readout_title' />
            module.  It can be used to:
           </para>
           <itemizedlist>
            <listitem>
                <para>Organize the readout into logical chunks</para>
            </listitem>
            <listitem>
                <para>Encapsulate logical chunks of the readout into
                    packets using the <option>id</option> and
                    <option>packetize</option> configuration option to
                    enabled encapsulation and to specify the packet id.
                </para>
            </listitem>
           </itemizedlist>
           <para>
            For further documentation see:
            <link linkend='sbsreadout3_readout' endterm='sbsreadout3_readout_title' />.
           </para>
        </refsect1>
      </refentry>

<!-- sis3300 -->
      <refentry id="sbsreadout3_sis3300_module">
        <refmeta>
           <refentrytitle id="sbsreadout3_sis3300_module_title">sis3300</refentrytitle>
           <manvolnum>3sbsreadout</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>sis3300</refname>
           <refpurpose>Scripted Readout SIS 3300 support.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
module create <replaceable>name</replaceable> sis3300 <replaceable>?options...?</replaceable>
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>name</replaceable> config <replaceable>option1 value1 ?....?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>name</replaceable> cget <replaceable>?pattern?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>name</replaceable> help
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Provides support for the SIS3300 and SIS3301 flash ADC modules.
            Note that this module can create a very large contribution to the
            event size depending on the size of the waveform acquired.
           </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <para>This module is a little complex so refer to the manual
            for detailed information about the meanings of parameters if you don't
            understand them.
           </para>
           <variablelist>
            <varlistentry>
                <term><option>base</option> <replaceable>base-address</replaceable></term>
                <listitem>
                    <para>
                        Sets the base address for the module.  This must match the
                        base address implied by the rotary switches.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>crate</option> <replaceable>crate-no</replaceable></term>
                <listitem>
                    <para>
                        Sets the number of the VME crate in which the module is
                        inserted.  This defaults to 0 which is suitable for
                        a single crate system.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>startdelay</option> <replaceable>delay-ticks</replaceable></term>
                <listitem>
                    <para>
                        When using the external start, a start signal is
                        internally delayed by <parameter>delay-ticks</parameter>+2 clocks
                        before being presented to the internal circuitry.  
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>stopdelay</option> <replaceable>delay-ticks</replaceable></term>
                <listitem>
                    <para>
                        When using the external stop input, this provides a
                        delay of <parameter>delay-ticks</parameter>+2 clocks
                        before the stop is presented to the circuitry.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>gate</option> <replaceable>boolean</replaceable></term>
                <listitem>
                    <para>
                        Enables or disables gate mode for the module.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>wrap</option> <replaceable>boolean</replaceable></term>
                <listitem>
                    <para>
                        Enables or disables wrap mode for the module's acquisition
                        memory management.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>thresholds</option> <replaceable>list-of-8-integers</replaceable></term>
                <listitem>
                    <para>
                        Provides the leading edge discriminator thresholds for each
                        channel.  See also <option>lt</option> below.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>lt</option> <replaceable>boolean</replaceable></term>
                <listitem>
                    <para>
                        If <literal>true</literal> the leading edge discriminator
                        fires when the data go below the threshold.  If
                        <literal>false</literal> (the default) the discriminator
                        fires when the data go above the threshold.
                    </para>
                    <para>
                        Note that the discriminator is actually firmware that
                        monitors the flash ADC values rather than an analog
                        leading edge discriminator.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>freerunning</option> <replaceable>boolean</replaceable></term>
                <listitem>
                    <para>
                        If <literal>true</literal> the module is always sampling
                        and only stops sampling when the stop input occurs
                        (see also <option>stopdelay</option>).  If <literal>false</literal>
                        (the default), the module starts sampling when the
                        start input occurs and stops either on the stop or
                        when the requested number of samples has been acquired.
                        See also <option>startdelay</option> and <option>samplesize</option>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>usegroups</option> <replaceable>bitmask</replaceable></term>
                <listitem>
                    <para>
                        The FADC is organized as two channel groups.  Each group
                        can be independently enabled or disabled.  <parameter>bitmask</parameter>
                        is a mask of the enabled channels.  The default value
                        <literal>0xf</literal> enables all four groups (8 channels).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>id</option> <replaceable>number</replaceable></term>
                <listitem>
                    <para>
                        See <option>subpacket</option> below.  If subpacketing
                        is enabled, the data from the digitizer is encapsulated
                        in a packet (size and Id).  <parameter>number</parameter> will
                        be used as the Id for the packet.  The default value is
                        <literal>0x3300</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>subpacket</option> <replaceable>boolean</replaceable></term>
                <listitem>
                    <para>
                        If <literal>true</literal> (the default), the data from
                        the digitizer is encapsulated in a packet.  The id of
                        the packet is set using the <option>id</option> option
                        above.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>clock</option> <replaceable>clock-selector</replaceable></term>
                <listitem>
                    <para>
                        Sets the sampling frequency for the FADC.  The legal values
                        are a specific set of text strings:
                        <literal>100Mhz, 50Mhz, 25Mhz, 12.5Mhz, 6.25Mhz, 3.125Mhz</literal>
                        set specific frequencies while
                        <literal>frontpanel</literal> indicates the clock will
                        be a front panel input and
                        <literal>p2</literal> indicates the clock will come in on
                        the defined uncommitted P2 backplane pin.
                        The default value is <literal>100Mhz</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>samplesize</option> <replaceable>sample-size-selector</replaceable></term>
                <listitem>
                    <para>
                        Sets the number of samples after which acquisition
                        will stop in start stop mode if not explicitly stopped.
                        Legal values are:
                        <literal>128K, 16K, 4K, 2K, 1K, 512, 256</literal> and
                        <literal>128</literal>.  The default value is
                        <literal>16K</literal>.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>

      </refentry>

<!-- 1x90 -->

      <refentry id="sbsreadout3_v1x90_module">
        <refmeta>
           <refentrytitle id="sbsreadout3_v1x90_module_title">v1x90</refentrytitle>
           <manvolnum>3sbsreadout</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>v1x90</refname>
           <refpurpose>Scripted readout support for CAEN V1190/V1290 TDC</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
module create <replaceable>name</replaceable> v1x90 <replaceable>?option...?</replaceable>
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>name</replaceable> config <replaceable>option1 value1 ?...?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>name</replaceable> cget <replaceable>?pattern?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>name</replaceable> help
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Provides support for the CAEN V1190 and V1290 multi-hit TDCs.  If you
            are used to a common start or common stop TDC it is important that
            you set aside that model of thinking before using this device.
            Support for this TDC is provided for <emphasis>Trigger Matching</emphasis>
            mode.  No support is provided for <emphasis>Continuous storage</emphasis>mode.
           </para>
           <para>
            In trigger matching mode, a front panel trigger together with a trigger
            offset and window size, define a time window in which hits are accepted.
            The offset can be prior to the trigger or after the trigger time.
            It is important to note that the trigger is accepted by the TDC on the
            edge of its internal FPGA clock (25ns/tick) rather than at the resolution
            of the TDC.  This means that if you need absolute trigger-relative
            timing you will need
            to split the trigger and digitize it as well so that it can be digitally
            subtracted from the hits (in analysis software)
            otherwise your time resolution will be limited
            to only 25ns.
           </para>
           <para>
            The TDC is rather complex and I recommend you thoroughly understand
            the manual before proceeding.
           </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
            <varlistentry>
                <term><option>base</option> <replaceable>base-address</replaceable></term>
                <listitem>
                    <para>
                        Sets the base address of the module.  This must match
                        the address implied by the rotary switch settings on the
                        module itself.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>crate</option> <replaceable>crate-number</replaceable></term>
                <listitem>
                    <para>
                        Sets the number of the VME crate in which the module
                        is installed.   This defaults to <literal>0</literal>
                        which works for systems with a single VME crate.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>vsn</option> <replaceable>virtual-slot</replaceable></term>
                <listitem>
                    <para>
                        Data from the TDC is identified by a virtual slot number.
                        This is an 8 bit number (range 0-255) that should be
                        unique across al TDCs and allows you to distinguish data
                        from specific TDCs. The default value is <literal>0</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>termination</option> <replaceable>termination-selector</replaceable></term>
                <listitem>
                    <para>
                        Control bus termination can be any of three possible
                        values:  <literal>on</literal> the control bus is terminated
                        <literal>off</literal> the control bus is not terminated.
                        <literal>switch</literal> termination is determined
                        by the position of the <literal>TERM</literal> switch
                        on the module circuit board.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>tagtriggertime</option> <replaceable>boolean</replaceable></term>
                <listitem>
                    <para>
                        If <literal>true</literal> the trigger time is included
                        in the data.  Note that this trigger time is only
                        known to a time resolution of <literal>25ns</literal>.
                        The default value is <literal>true</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>eclprogout</option> <replaceable>output-selector</replaceable></term>
                <listitem>
                    <para>
                        The module has an ECL output that can be programmed to
                        reflect several conditions.  The <parameter>output-selector</parameter>
                        determines the condition that is reflected on the output pin.
                    </para>
                    <para>
                        Legal values are <literal>dataready</literal>,
                        <literal>full</literal>,
                        <literal>almostfull</literal>,
                        or <literal>error</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>windowwidth</option> <replaceable>integer</replaceable></term>
                <listitem>
                    <para>
                        Determines the number of clock ticks (25ns units) of
                        the window in which hits are accepted. See the manual for
                        the legal range of values.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>offset</option> <replaceable>integer</replaceable></term>
                <listitem>
                    <para>
                        Determines the offset of the start of the window relative
                        to the trigger latch time.   This can be a negative
                        (window opens prior to the trigger) or positive (window
                        opens after the trigger) value.  See the manual for the
                        legal range of values.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>extramargin</option> <replaceable>integer</replaceable></term>
                <listitem>
                    <para>
                        This parameter provides an extra time buffer for the
                        matching window to make up for the fact that the
                        matching window is only precise to the FPGA clock which
                        runs a click every 25ns.  The manual describes the
                        range of legal values and refers to this parameter as the
                        <emphasis>extra search margin</emphasis>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>rejectmargin</option> <replaceable>integer</replaceable></term>
                <listitem>
                    <para>
                        In order to support matching windows that preceded the trigger,
                        hits are recorded in an internal buffer and only recorded
                        to the multi event buffer when a trigger occurs, at which time
                        the hits inside the window are transferred.
                        The <option>rejectmargin</option> determines the minimum
                        retention time of the hits.  
                    </para>
                </listitem>
            </varlistentry>
                
            <varlistentry>
                <term><option>subtractriggertime</option> <replaceable>boolean</replaceable></term>
                <listitem>
                    <para>
                        If <literal>true</literal> (the default), the trigger time
                        is subtracted from te hit time.  If <literal>false</literal>
                        the trigger time is not subtracted from the hit tiems.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>edgedetectmode</option> <replaceable>edge-detect-selector</replaceable></term>
                <listitem>
                    <para>
                        Determines which edges of the signal are digitized.
                        If <literal>leading</literal> is selected, the leading edge
                        of the signal is digitizied.  If <literal>trailing</literal>
                        the trailing edge.  if <literal>both</literal> both edges of
                        the signal are digitized resulting in two times for each
                        pusle.  If <literal>pair</literal>, two time values are
                        digitized for each hit.  The leading edge time and the
                        width of the pulse.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>encapsulatetdc</option> <replaceable>boolean</replaceable></term>
                <listitem>
                    <para>
                        If <literal>true</literal> (the default) the data from each
                        TDC chip in the module is encapsulated in a TDC header and
                        trailer as defined by the module data format, if <literal>false</literal>
                        these headers are omitted from the data.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>maxhits</option> <replaceable>max-hit-selector</replaceable></term>
                <listitem>
                    <para>
                        Determines the maximum number of hits that will be accepted
                        by the TDC for an event.  Note that this is across all channel.
                        To further clarify, selecting a value of <literal>1</literal>
                        means the entire module will only give you at most a single
                        hit for each event.
                    </para>
                    <para>
                        Legal values are <literal>1, 2, 4, 8, 16, 32, 64, 128</literal>
                        and <literal>unlimited</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>individuallsb</option> <replaceable>lsb-selector</replaceable></term>
                <listitem>
                    <para>
                        Determines the meaning of the least significant bit for a
                        conversion time value.  The legal values are:
                        <literal>25ps, 100ps, 200ps</literal> and <literal>800ps</literal>.
                        The default value is <literal>100ps</literal>.  Note that not
                        all TDC models support all of these values.  There is
                        currently no checking done to ensure that you have chosen a
                        legal value fro the module you are using.
                        This value only is meaningful when the edge match mode is
                        not <literal>pair</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>pairleresolution</option> <replaceable>pairleres-selector</replaceable></term>
                <listitem>
                    <para>
                        When in <literal>pair</literal> mode determines the resolution
                        of the arrival time of the leading edge.  This can be one of
                        <literal>100ps, 200ps, 400ps, 800ps, 1600ps, 320ps, 6250ps</literal>
                        or <literal>12500ps</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>pairwidthresolution</option> <replaceable>pairwidres-selector</replaceable></term>
                <listitem>
                    <para>
                        When in <literal>pair</literal> mode, determines the resolution
                        with which the width of the input puls is measured.   This can
                        be one of the following values:
                        <literal>100ps, 200ps, 400ps, 800ps, 1600ps, 3200ps, 6250ps, 12500ps,
                        25ns, 50ns, 100ns, 200ns, 400ns</literal> or
                        <literal>800ns</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>deadtime</option> <replaceable>dead-time-selector</replaceable></term>
                <listitem>
                    <para>
                        In order to prevent digitization of signal reflection from the
                        input cables,  once a hit is recorded, a channel will
                        remain insensitive to addtional hits for a programmable
                        dead time that is determined by this parameter.
                        Legal values of the <parameter>dead-time-selector</parameter>
                        are:
                        <literal>5ns, 10ns, 30ns</literal> and <literal>100ns</literal>.
                    </para>
                </listitem>
            </varlistentry>
           </variablelist>
        </refsect1>
      </refentry>

<!-- CDigitizerModule base class -->
	 <refentry id="sbsreadout3_digitizer_class">
       <refmeta>
          <refentrytitle id="sbsreadout3_digitizer_class_title">CDigitizerModule</refentrytitle>
          <manvolnum>3sbsreadout</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CDigitizerModule</refname>
          <refpurpose>Scripted readout base class for module support.</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>
            <ooclass><classname>CDigitizerModule : public CReadableObject</classname></ooclass>
           <constructorsynopsis>
          <methodname>CDigitizerModule</methodname>
          <methodparam><modifier>const</modifier> <type>std::string&amp; </type>
            <parameter>rName</parameter></methodparam>
          <methodparam><type>CTCLInterpreter&amp;</type> <parameter>rInterp</parameter></methodparam>
           </constructorsynopsis>
        </synopsis>
        <synopsis>
            <ooclass><classname>CReadableObject : public SConfigurableObject</classname></ooclass>
           <constructorsynopsis>
          <methodname>CReadableObject</methodname>
          <methodparam><modifier>const</modifier> <type>std::string&amp; </type>
            <parameter>rName</parameter></methodparam>
          <methodparam><type>CTCLInterpreter&amp;</type> <parameter>rInterp</parameter></methodparam>
           </constructorsynopsis>
           <methodsynopsis>
           <modifier>virtual </modifier><type>void</type>
             <methodname>Initialize</methodname>
             <void />
             <modifier> = 0</modifier>
           </methodsynopsis>
           <methodsynopsis>
               <modifier>virtual</modifier>
               <type>void</type>
               <methodname>Prepare</methodname>
               <void />
               <modifier> = 0</modifier>
           </methodsynopsis>
           <methodsynopsis>
               <modifier>virtual</modifier>
               <type>int</type>
               <methodname>Read</methodname>
               <methodparam><type>void*</type> <parameter>pBuffer</parameter></methodparam>
               <modifier> = 0</modifier>
           </methodsynopsis>
           <methodsynopsis>
               <modifier>virtual</modifier>
               <type>void</type>
               <methodname>Clear</methodname>
               <void />
               <modifier> = 0</modifier>
           </methodsynopsis>
           <methodsynopsis>
               <modifier></modifier>
               <type>void</type>
               <methodname>Link</methodname>
               <methodparam><type>CReadOrder*</type> <parameter>pReader</parameter></methodparam>
               <exceptionname></exceptionname>
               <modifier></modifier>
           </methodsynopsis>
           <methodsynopsis>
               <modifier></modifier>
               <type>void</type>
               <methodname>Unlink</methodname>
               <void />
               <exceptionname></exceptionname>
               <modifier></modifier>
           </methodsynopsis>
           <methodsynopsis>
               <modifier></modifier>
               <type>bool</type>
               <methodname>isLinked</methodname>
               <void />
               <exceptionname></exceptionname>
               <modifier></modifier>
           </methodsynopsis>
           <methodsynopsis>
               <modifier></modifier>
               <type>std::string</type>
               <methodname>getType</methodname>
               <void />
               <exceptionname></exceptionname>
               <modifier>const = 0</modifier>
           </methodsynopsis>
           <methodsynopsis>
               <modifier>virtual</modifier>
               <type>void</type>
               <methodname>OnDelete</methodname>
               <void />
               <exceptionname></exceptionname>
               <modifier></modifier>
           </methodsynopsis>  
        </synopsis>        
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            The <classname>CDigitizerModule</classname> and its base class
            <classname>CReadableObject</classname> together provide the
            infrastructure for something that can be read out.  See as well
            <link linkend='sbsreadout3_sconfigurableobject_class'
                  endterm='sbsreadout3_sconfigurableobject_class_title' />
            which provides the command dispatching to support the subcommands
            that all readable objects also support.
          </para>
          <para>
            This class is an abstract base class.  Specifically,
            <methodname>Initialize</methodname>,
            <methodname>Prepare</methodname>
            <methodname>Read</methodname> and
            <methodname>Clear</methodname>
            are method which must be supplied by subclasses and are used
            during the process of data taking.
            <methodname>getType</methodname> is also pure virtual and
            is expected to return a string that describes the module type.
          </para>
          <para>
            While <methodname>OnDelete</methodname> is also virtual, it is a
            life-cycle method that has a reasonable default implementation and,
            in most cases, will not need to be overidden.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <variablelist>
            <varlistentry>
                <term>
                       <constructorsynopsis>
                      <methodname>CReadableObject</methodname>
                      <methodparam><modifier>const</modifier> <type>std::string&amp; </type>
                        <parameter>rName</parameter></methodparam>
                      <methodparam><type>CTCLInterpreter&amp;</type> <parameter>rInterp</parameter></methodparam>
                       </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a <classname>CReadableObject</classname>
                        <parameter>rName</parameter> is the name of the object.
                        Normally this is the name provided to the
                        <command>module create</command> command.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                       <methodsynopsis>
                       <modifier>virtual </modifier><type>void</type>
                         <methodname>Initialize</methodname>
                         <void />
                         <modifier> = 0</modifier>
                       </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This virtual method must be implemented by derived classes.
                        it is expected to perform one-time initialization
                        at the start of a run or resume of a run.  Normaly,
                        this method determines the current module configuration
                        and sets up the module it is controlling from the
                        information in that configuration.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                       <methodsynopsis>
                           <modifier>virtual</modifier>
                           <type>void</type>
                           <methodname>Prepare</methodname>
                           <void />
                           <modifier> = 0</modifier>
                       </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This virtual method must be implemented by derived
                        classes (even if the method does nothing).  It is called
                        just prior to awaiting the next trigger.  If any per-event
                        preparation is required, this method is expected to
                        perform it on the device.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                       <methodsynopsis>
                           <modifier>virtual</modifier>
                           <type>int</type>
                           <methodname>Read</methodname>
                           <methodparam><type>void*</type> <parameter>pBuffer</parameter></methodparam>
                           <modifier> = 0</modifier>
                       </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method must be implemented by derived classes.
                        It is called in response to a trigger.  It is expected
                        to read the data from an event into the buffer
                        pointed to by <parameter>pBuffer</parameter>.
                        The return value should be the number of
                        <type>uint16_t</type> words placed in
                        <parameter>pBuffer</parameter>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                       <methodsynopsis>
                           <modifier>virtual</modifier>
                           <type>void</type>
                           <methodname>Clear</methodname>
                           <void />
                           <modifier> = 0</modifier>
                       </methodsynopsis>
                </term>
            
                <listitem>
                    <para>
                        Pure virtual method that must be implemented in derived
                        classes.  The method is expected to clear any data that is
                        latched in the module.  This is called after each
                        call to <methodname>Read</methodname> as well as at the
                        beginning of the run.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                       <methodsynopsis>
                           <modifier></modifier>
                           <type>void</type>
                           <methodname>Link</methodname>
                           <methodparam><type>CReadOrder*</type> <parameter>pReader</parameter></methodparam>
                           <exceptionname></exceptionname>
                           <modifier></modifier>
                       </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        When a device is placed in a packet or the top level
                        <command>readout</command> object, it is said to have an
                        owner.  The owner is the readout object in whose list it
                        immediately lives.
                        If the software attempts to place a <classname>CReadableObject</classname>
                        in more than one <command>readout</command> object,
                        an exception is raised indicating the object is already
                        linked.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                       <methodsynopsis>
                           <modifier></modifier>
                           <type>void</type>
                           <methodname>Unlink</methodname>
                           <void />
                           <exceptionname></exceptionname>
                           <modifier></modifier>
                       </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Reverses the effect of <methodname>Link</methodname>.
                        On return the object is not owned by any <command>readout</command>
                        object.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                       <methodsynopsis>
                           <modifier></modifier>
                           <type>bool</type>
                           <methodname>isLinked</methodname>
                           <void />
                           <exceptionname></exceptionname>
                           <modifier></modifier>
                       </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>true</literal> if the object has an
                        owner (was <methodname>Link</methodname>ed).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                       <methodsynopsis>
                           <modifier></modifier>
                           <type>std::string</type>
                           <methodname>getType</methodname>
                           <void />
                           <exceptionname></exceptionname>
                           <modifier>const = 0</modifier>
                       </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a string that describes the module type.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                       <methodsynopsis>
                           <modifier>virtual</modifier>
                           <type>void</type>
                           <methodname>OnDelete</methodname>
                           <void />
                           <exceptionname></exceptionname>
                           <modifier></modifier>
                       </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called if the module is deleted.  The base
                        class makes this object not owned, and removes the object
                        from the current owner's readout list.
                    </para>
                </listitem>
            </varlistentry>
          </variablelist>
       </refsect1>
     </refentry>
         
<!-- CConfigurationParameter -->

	 <refentry id="sbsreadout3_cconfigurationparameter_class">
       <refmeta>
          <refentrytitle id="sbsreadout3_cconfigurationparameter_class_title">CConfigurationParameter</refentrytitle>
          <manvolnum>3sbsreadout</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CConfigurationParameter</refname>
          <refpurpose>Configuration parameters</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>

            <ooclass><classname>CConfigurationParameter</classname></ooclass>
           <constructorsynopsis>
          <methodname>CConfigurationParameter </methodname>
          <methodparam><modifier>const</modifier>
            <type>std::string&amp;</type><parameter> keyword</parameter></methodparam>
          <exceptionname></exceptionname>
           </constructorsynopsis>
           <methodsynopsis>
               <modifier></modifier>
               <type>std::string</type>
               <methodname> getSwitch</methodname>
               <void />
               <exceptionname></exceptionname>
               <modifier></modifier>
           </methodsynopsis>
           <methodsynopsis>
               <modifier></modifier>
               <type>std::string </type>
               <methodname>getValue</methodname>
               <void />
               <exceptionname></exceptionname>
               <modifier> const</modifier>
           </methodsynopsis>
           <methodsynopsis>
               <modifier> </modifier>
               <type>bool </type>
               <methodname>Match </methodname>
               <methodparam>
                <modifier>const</modifier> <type>std::string&amp;</type>
                <parameter>rSwitch</parameter>
               </methodparam>
               <exceptionname></exceptionname>
               <modifier></modifier>
           </methodsynopsis>
           <methodsynopsis>
               <modifier>virtual </modifier>
               <type>int    ;</type>
               <methodname>operator() </methodname>
               <methodparam>
                <type>CTCLInterpreter&amp;</type> <parameter>rInterp</parameter>
               </methodparam>
               <methodparam>
                <type>CTCLResult&amp;</type> <parameter>rResult</parameter>
               </methodparam>
               <methodparam>
                <modifier>const</modifier> <type>char*</type>
                <parameter>parameter</parameter>
               </methodparam>
               <exceptionname></exceptionname>
               <modifier></modifier>
           </methodsynopsis>
           <methodsynopsis>
               <modifier></modifier>
               <type>std::string </type>
               <methodname>getOptionString </methodname>
               <void />
               <exceptionname></exceptionname>
               <modifier>const</modifier>
           </methodsynopsis>
           <methodsynopsis>
               <modifier>virtual   </modifier>
               <type>int </type>
               <methodname>SetValue </methodname>
               <methodparam>
                <type>CTCLInterpreter&amp;</type> <parameter>rInterp</parameter>
               </methodparam>
               <methodparam>
                <type>CTCLResult&amp;</type> <parameter>rResult</parameter>
               </methodparam>
               <methodparam>
                <modifier>const</modifier> <type>char*</type>
                <parameter>pvalue</parameter>  
               </methodparam>
               <exceptionname></exceptionname>
               <modifier> = 0</modifier>
           </methodsynopsis>
           <methodsynopsis>
               <modifier>virtual </modifier>
               <type>std::string </type>
               <methodname>GetParameterFormat</methodname>
               <void />
               <exceptionname></exceptionname>
               <modifier>= 0</modifier>
           </methodsynopsis>
           
           <ooclass><classname>CBoolConfigParam : public CConfigurationParameter</classname></ooclass>
           <constructorsynopsis>
              <methodname>CBoolConfigParam</methodname>
              <methodparam>
                <modifier>const</modifier>
                <type>std::string&amp;</type>
                <parameter>rName</parameter>
              </methodparam>
              <methodparam>
                <type>bool</type>
                <parameter>fDefault</parameter>
                <initializer> = false</initializer>
              </methodparam>
              <exceptionname></exceptionname>
           </constructorsynopsis>
           <methodsynopsis>
               <modifier></modifier>
               <type>bool </type>
               <methodname>getOptionValue</methodname>
               <void />
               <exceptionname></exceptionname>
               <modifier></modifier>
           </methodsynopsis>
           <methodsynopsis>
               <modifier>virtual</modifier>
               <type>int</type>
               <methodname>SetValue</methodname>
               <methodparam>
                <type>CTCLInterpreter&amp;</type> <parameter>rInterp</parameter>
               </methodparam>
               <methodparam>
                <type>CTCLResult&amp;</type> <parameter>rResult</parameter>
               </methodparam>
               <methodparam>
                <modifier>const</modifier>
                <type>char*</type>
                <parameter>pFlag</parameter>
               </methodparam>
               <exceptionname></exceptionname>
               <modifier></modifier>
           </methodsynopsis>
           <methodsynopsis>
               <modifier> virtual </modifier>
               <type>std::string </type>
               <methodname>GetParameterFormat</methodname>
               <void />
               <exceptionname></exceptionname>
               <modifier></modifier>
           </methodsynopsis>
           
           <ooclass><classname>CEnumParameter : public CConfigurationParameter</classname></ooclass>
           <constructorsynopsis>
            <methodname>CEnumParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>keyword</parameter>
            </methodparam>
            <methodparam>
		 <type>std::vector&lt;CEnumParameter::enumeratorValue&gt;</type>
                 <parameter>values</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type>
                <parameter>defaultValue</parameter>
            </methodparam>
           </constructorsynopsis>
           <methodsynopsis>
               <modifier>virtual</modifier>
               <type> int </type>
               <methodname>SetValue</methodname>
               <methodparam>
                <type>CTCLInterpreter&amp;</type>
                <parameter>rInterp</parameter>
               </methodparam>
               <methodparam>
                <type>CTCLResult&amp;</type>
                <parameter>rResult</parameter>
               </methodparam>
               <methodparam>
                <modifier>const</modifier> <type>char*</type>
                <parameter>pValue</parameter>
               </methodparam>
               <exceptionname></exceptionname>
               <modifier></modifier>
           </methodsynopsis>  
           <methodsynopsis>
               <modifier>virtual </modifier>
               <type>std::string </type>
               <methodname>GetParameterFormat();</methodname>
               <void />
               <exceptionname></exceptionname>
               <modifier></modifier>
           </methodsynopsis>  
            <methodsynopsis>
                <modifier></modifier>
                <type>int </type>
                <methodname>GetEnumValue</methodname>
                <void />
                <exceptionname></exceptionname>
                <modifier></modifier>
            </methodsynopsis>  
        
            <ooclass><classname>CIntArrayParam : public CConfigurationParameter</classname></ooclass>
            <constructorsynopsis>
                <methodname>CIntArrayParam</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>std::string&amp;</type>
                    <parameter>rName</parameter>
                </methodparam>
                <methodparam>
                    <type>unsigned int</type> <parameter>size</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>nDefault</parameter>
                    <initializer>= 0</initializer>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CIntArrayParam</methodname>
                <methodparam>
                    <modifier>const</modifier><type>std::string&amp;</type>
                    <parameter>rName</parameter>
                </methodparam>
                <methodparam>
                  <type>unsigned int</type> <parameter>size</parameter>
                </methodparam>
                <methodparam>
                  <type>int</type> <parameter>nLow</parameter>
                </methodparam>
                <methodparam>
                  <type>int</type> <parameter>nHigh</parameter>
                </methodparam>
                <methodparam>
                  <type>int</type> <parameter>nDefault</parameter>
                  <initializer>= 0</initializer>
                </methodparam>
            </constructorsynopsis>
            <methodsynopsis>
                <modifier></modifier>
                <type>int </type>
                <methodname>getSize</methodname>
                <void />
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>const </modifier>
                <type> int* </type>
                <methodname>getValues </methodname>
                <void />
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier></modifier>
                <type> bool </type>
                <methodname>getCheckRange </methodname>
                <void />
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier></modifier>
                <type>int  </type>
                <methodname>getLow </methodname>
                <void />
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier></modifier>
                <type> int </type>
                <methodname>getHigh </methodname>
                <void />
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier></modifier>
                <type> int&amp;        </type>
                <methodname>operator[] </methodname>
                <methodparam>
                    <modifier></modifier>
                    <type>int</type>
                    <parameter>n</parameter>
                </methodparam>
                <modifier></modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual </modifier>
                <type> int</type>
                <methodname> SetValue</methodname>
                <methodparam>
                    <modifier></modifier>
                    <type> CTCLInterpreter&amp; </type>
                    <parameter>rInterp</parameter>
                </methodparam>
                <methodparam>
                    <modifier></modifier>
                    <type>CTCLResult&amp; </type>
                    <parameter>rResult</parameter>
                </methodparam>
                <methodparam>
                    <modifier>const </modifier>
                    <type>char* </type>
                    <parameter>pValues</parameter>
                </methodparam>
                <modifier></modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual </modifier>
                <type>std::string  </type>
                <methodname>GetParameterFormat</methodname>
                <void />
                <modifier></modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier></modifier>
                <type> void </type>
                <methodname>setRange</methodname>
                <methodparam>
                    <modifier></modifier>
                    <type>int  </type>
                    <parameter>nLow</parameter>
                </methodparam>
                <methodparam>
                    <modifier></modifier>
                    <type>int </type>
                    <parameter>nHigh</parameter>
                </methodparam>
                <modifier></modifier>
            </methodsynopsis>
            
            <ooclass><classname>CIntConfigParam : public CConfigurationParameter</classname></ooclass>
            <constructorsynopsis>
                <methodname>CIntConfigParam</methodname>
                <methodparam>
                    <modifier>const </modifier>
                    <type>std::string&amp; </type>
                    <parameter>rName</parameter>
                </methodparam>
                <methodparam>
                    <modifier></modifier>
                    <type>int </type>
                    <parameter>nDefault</parameter>
                    <initializer>=0</initializer>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CIntConfigParam</methodname>
                <methodparam>
                    <modifier>const  </modifier>
                    <type>std::string&amp;</type>
                    <parameter>rName</parameter>
                </methodparam>
                <methodparam>
                    <modifier></modifier>
                    <type>int </type>
                    <parameter>nLow</parameter>
                </methodparam>
                <methodparam>
                    <modifier></modifier>
                    <type>int </type>
                    <parameter>nHigh</parameter>
                </methodparam>   
                <methodparam>
                    <modifier></modifier>
                    <type>int </type>
                    <parameter>nDefault</parameter>
                    <initializer>=0</initializer>
                </methodparam>         
            </constructorsynopsis>
            <methodsynopsis>
                <modifier></modifier>
                <type>  bool </type>
                <methodname>getCheckrange</methodname>
                <void />
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier></modifier>
                <type> int </type>
                <methodname>getLow</methodname>
                <void />
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier></modifier>
                <type> int </type>
                <methodname>getHigh</methodname>
                <void />
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier></modifier>
                <type>int </type>
                <methodname>getOptionValue</methodname>
                <void />
                <exceptionname></exceptionname>
                <modifier></modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>int </type>
                <methodname>SetValue </methodname>
                <methodparam>
                    <type>CTCLInterpreter&amp;</type><parameter> rInterp</parameter>
                </methodparam>
                <methodparam>
                    <type>CTCLResult&amp;</type><parameter> rResult</parameter>
                </methodparam>
                <methodparam>
                    <modifier>const</modifier>
                    <type>char*</type>
                    <parameter>pValue</parameter>
                </methodparam>
                <exceptionname></exceptionname>
                <modifier></modifier>
            </methodsynopsis>  
            <methodsynopsis>
                <modifier>virtual </modifier>
                <type>std::string </type>
                <methodname>GetParameterFormat</methodname>
                <void />
                <exceptionname></exceptionname>
                <modifier></modifier>
            </methodsynopsis>  
            <methodsynopsis>
                <modifier></modifier>
                <type>void </type>
                <methodname>setRange</methodname>
                <methodparam>
                    <type>int</type><parameter>nLo</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>nHi</parameter>
                </methodparam>
                <exceptionname></exceptionname>
                <modifier></modifier>
            </methodsynopsis>  
            
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            <link linkend="sbsreadout3_digitizer_class"
                  endterm="sbsreadout3_digitizer_class_title" /> objects
            include a database of configuration items managed by their base
            class
            <link linkend='sbsreadout3_sconfigurableobject_class'
                  endterm='sbsreadout3_sconfigurableobject_class_title' />.
            The items in this database are derived from the
            <classname>CConfigurableObject</classname>.  The derived classes
            provide a strongly typed system of parameters.  Each type can also have
            associated with it type specific constraints.
          </para>
          <para>
            The remaining sections of this manpage describe the predefined
            members of the class hierarchy that is derived from
            <classname>CConfigurableObject</classname>.  Sophisticated programmers
            can extend this hierarchy if needed.
          </para>
       </refsect1>
       <refsect1>
          <title>
            <classname>CConfigurationParameter</classname>
          </title>
          <para>
            This is the abstract base class of the parameter item hierarchy.  It
            defines the programmatic interfaces all configuration parameters
            must implement:
          </para>
          <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                     <methodname>CConfigurationParameter </methodname>
                     <methodparam><modifier>const</modifier>
                       <type>std::string&amp;</type><parameter> keyword</parameter></methodparam>
                     <exceptionname></exceptionname>
                      </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructor for the named parameter <parameter>keyword</parameter>.
                        The <parameter>keyword</parameter> is the parameter name
                        used in e.g. <command>config</command> subcommands.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                      <methodsynopsis>
                          <modifier></modifier>
                          <type>std::string</type>
                          <methodname> getSwitch</methodname>
                          <void />
                          <exceptionname></exceptionname>
                          <modifier></modifier>
                      </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the nameof the configuration option this object
                        represents.   Normally, this is the <parameter>keyword</parameter>
                        parameter passed into the constructor.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                      <methodsynopsis>
                          <modifier></modifier>
                          <type>std::string </type>
                          <methodname>getValue</methodname>
                          <void />
                          <exceptionname></exceptionname>
                          <modifier> const</modifier>
                      </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the string representation of the value of the
                        configuration item.  All configuration items have a string
                        representation.  Derived classes may define an alternative
                        representation as well.  Typically a derived class will
                        enforce the convertability of the string value to the
                        alternative representation by overriding the
                        <methodname>SetValue</methodname> method below.  Derived
                        classes will usually also provide a mechanism to access
                        the alternative representation's natural form.
                    </para>
                    <para>
                        See also the <methodname>GetParameterFormat</methodname>
                        method below.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                      <methodsynopsis>
                          <modifier> </modifier>
                          <type>bool </type>
                          <methodname>Match </methodname>
                          <methodparam>
                           <modifier>const</modifier> <type>std::string&amp;</type>
                           <parameter>rSwitch</parameter>
                          </methodparam>
                          <exceptionname></exceptionname>
                          <modifier></modifier>
                      </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        The configuration management pieces of
                        <link linkend='sbsreadout3_sconfigurableobject_class'
                              endterm='sbsreadout3_sconfigurableobject_class_title' />
                        determine which configuration item is being referred to by
                        asking each item if it responds to a specific name.  The
                        <methodname>Match</methodname> method compares the
                        parameter keyword passed in to the constructor to its
                        <parameter>rSwitch</parameter> parameter and returns
                        true if they are the same.
                    </para>
                    <para>
                        Presently this comparison is case sensitive.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>  
                      <methodsynopsis>
                          <modifier>virtual </modifier>
                          <type>int    ;</type>
                          <methodname>operator() </methodname>
                          <methodparam>
                           <type>CTCLInterpreter&amp;</type> <parameter>rInterp</parameter>
                          </methodparam>
                          <methodparam>
                           <type>CTCLResult&amp;</type> <parameter>rResult</parameter>
                          </methodparam>
                          <methodparam>
                           <modifier>const</modifier> <type>char*</type>
                           <parameter>parameter</parameter>
                          </methodparam>
                          <exceptionname></exceptionname>
                          <modifier></modifier>
                      </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Thie method is invoked when <methodname>Match</methodname>
                        returns true as a result of a
                        <command>config</command> subcommand.
                        It invokes <methodname>SetValue</methodname> which is
                        assumed to at least ensure the value can be translated
                        to any internal representation and then stores the
                        string representation of the value if successful.
                    </para>
                    <para>
                        On success <literal>TCL_OK</literal> is returned
                        otherwise, <literal>TCL_ERROR</literal> is returned.
                    </para>
                    <para>
                        While derived classes can override this method normally
                        they don't need to, and should not.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                      <methodsynopsis>
                          <modifier></modifier>
                          <type>std::string </type>
                          <methodname>getOptionString </methodname>
                          <void />
                          <exceptionname></exceptionname>
                          <modifier>const</modifier>
                      </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is synonymous with
                        <methodname>getValue</methodname>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                      <methodsynopsis>
                          <modifier>virtual   </modifier>
                          <type>int </type>
                          <methodname>SetValue </methodname>
                          <methodparam>
                           <type>CTCLInterpreter&amp;</type> <parameter>rInterp</parameter>
                          </methodparam>
                          <methodparam>
                           <type>CTCLResult&amp;</type> <parameter>rResult</parameter>
                          </methodparam>
                          <methodparam>
                           <modifier>const</modifier> <type>char*</type>
                           <parameter>pvalue</parameter>  
                          </methodparam>
                          <exceptionname></exceptionname>
                          <modifier> = 0</modifier>
                      </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is a pure virtual method that must be supplied by
                        concrete derivations of this abstract base class.  Normally,
                        this method ensures that the string pointed to by
                        <parameter>pvalue</parameter>
                        is a legal value for the configuration parameter
                        (both in type and any constraints that might be applied).
                        Often this method actually converts and caches
                        <parameter>pvalue</parameter> in the format appropriate
                        to the type of the parameter (e.g. <classname>CIntConfigParam</classname>
                        converts <parameter>pvalue</parameter> to an <type>int</type>).
                    </para>
                    <para>
                        <parameter>rInterp</parameter> is a reference to the
                        interpreter that is executing the configuration command
                        that invoked this.  <parameter>rResult</parameter> is the
                        intepreter result object which can be set to a value
                        that, in the case of a normal return, will be the interpreter
                        result and, in the case of a failure will be an error message.
                    </para>
                    <para>
                        A normal return is indicated by a return value of
                        <literal>TCL_OK</literal>.  A failed return is indicated
                        by a return value of <literal>TCL_ERROR</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                      <methodsynopsis>
                          <modifier>virtual </modifier>
                          <type>std::string </type>
                          <methodname>GetParameterFormat</methodname>
                          <void />
                          <exceptionname></exceptionname>
                          <modifier>= 0</modifier>
                      </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Derived classes should supply this method.  It is
                        expected to return a string that hints at the format
                        of the parameter value.  For example for an
                        <classname>CIntArrayParam</classname> insstance with
                        an array size of 16,  the return value is
                        <literal>int[16]</literal>
                    </para>
                </listitem>
            </varlistentry>
          </variablelist>
       </refsect1>
        <refsect1>
            <title><classname>CBoolConfigParam</classname></title>
            <para>
                This is a concrete class derived from the
                <classname>CConfigurationParameter</classname>.  The class
                constrains its values to be compatibile with boolean values.
                Acceptable <literal>true</literal> values are
                <literal>true, on</literal> and <literal>enable</literal>.
                Acceptable false values are <literal>false off</literal>
                and <literal>disable</literal>.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                        <methodname>CBoolConfigParam</methodname>
                        <methodparam>
                          <modifier>const</modifier>
                          <type>std::string&amp;</type>
                          <parameter>rName</parameter>
                        </methodparam>
                        <methodparam>
                          <type>bool</type>
                          <parameter>fDefault</parameter>
                          <initializer> = false</initializer>
                        </methodparam>
                        <exceptionname></exceptionname>
                     </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The constructor for this class.
                            <parameter>rName</parameter> is the name of the
                            configuration parameter.  <parameter>fDefault</parameter>
                            is the initial value given to the parameter
                            (in the event the configuration script never
                            configures this parameter).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                     <methodsynopsis>
                         <modifier></modifier>
                         <type>bool </type>
                         <methodname>getOptionValue</methodname>
                         <void />
                         <exceptionname></exceptionname>
                         <modifier></modifier>
                     </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the <type>bool</type> representation of the
                            current parameter value.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                     <methodsynopsis>
                         <modifier>virtual</modifier>
                         <type>int</type>
                         <methodname>SetValue</methodname>
                         <methodparam>
                          <type>CTCLInterpreter&amp;</type> <parameter>rInterp</parameter>
                         </methodparam>
                         <methodparam>
                          <type>CTCLResult&amp;</type> <parameter>rResult</parameter>
                         </methodparam>
                         <methodparam>
                          <modifier>const</modifier>
                          <type>char*</type>
                          <parameter>pFlag</parameter>
                         </methodparam>
                         <exceptionname></exceptionname>
                         <modifier></modifier>
                     </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Determines if the string pointed to by
                            <parameter>pFlag</parameter> is a valid boolean
                            value.  If so the string and boolean representation
                            are updated and <literal>TCL_OK</literal> is returned.
                            If not, <parameter>rResult</parameter> is filled in
                            with an error message and <literal>TCL_ERROR</literal>
                            is returned.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                     <methodsynopsis>
                         <modifier> virtual </modifier>
                         <type>std::string </type>
                         <methodname>GetParameterFormat</methodname>
                         <void />
                         <exceptionname></exceptionname>
                         <modifier></modifier>
                     </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the string:
                            <literal>on | off</literal>.  Note that
                            other representations are legal (see above).
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
        <refsect1>
            <title><classname>CEnumParameter</classname></title>
            <para>
                This concrete subclass of
                <classname>CConfigurationParameer</classname> is represents
                a parameter that can hold one of a distinct set of strings.
                The class supports mapping each allowed string to an integer value.
                This supports direct conversion of a string to the contents of a
                register bit field.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                        <methodname>CEnumParameter</methodname>
                        <methodparam>
                            <type>std::string</type> <parameter>keyword</parameter>
                        </methodparam>
                        <methodparam>
                             <type>std::vector&lt;CEnumParameter::enumeratorValues&gt;</type>
                             <parameter>values</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::string</type>
                            <parameter>defaultValue</parameter>
                        </methodparam>
                       </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Constructor.  The <parameter>keyword</parameter> is
                            the name of the parameter.   <parameter>values</parameter>
                            defines the legal values of the parameter and their mappings
                            to integers.   <parameter>defaultValue</parameter> is the
                            default value and shoulid be one of the strings
                            defined as legal by <parameter>values</parameter>
                        </para>
                        <para>
                            <parameter>values</parameter> is a vector containing
                            <classname>CEnumParameter::enumeratorValues</classname>
                            structs.  This struct has the fields:
                            <structfield>std::string s_name</structfield> which contains
                            the string value of a legal parameter value and
                            <structfield>int s_value</structfield> which is the
                            integer value to which <structfield>s_name</structfield>
                            should map.
                        </para>
                        <para>
                            <classname>CEnumParameter::enumeratorValue</classname>
                            provides a constructor for convenience that has in order
                            the requested values for <structfield>s_name</structfield>
                            and <structfield>s_value</structfield> as parameters.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                       <methodsynopsis>
                           <modifier>virtual</modifier>
                           <type> int </type>
                           <methodname>SetValue</methodname>
                           <methodparam>
                            <type>CTCLInterpreter&amp;</type>
                            <parameter>rInterp</parameter>
                           </methodparam>
                           <methodparam>
                            <type>CTCLResult&amp;</type>
                            <parameter>rResult</parameter>
                           </methodparam>
                           <methodparam>
                            <modifier>const</modifier> <type>char*</type>
                            <parameter>pValue</parameter>
                           </methodparam>
                           <exceptionname></exceptionname>
                           <modifier></modifier>
                       </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Determines if the string pointed to by
                            <parameter>pValue</parameter> is one of the
                            legal <structfield>s_name</structfield> values for
                            the enumerator.  If so, the string value is saved and
                            <literal>TCL_OK</literal> is returned. If not,
                            <literal>TCL_ERROR</literal> is returned and
                            <parameter>rResult</parameter> the interpreter result
                            value is set to an informative error message.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                       <methodsynopsis>
                           <modifier>virtual </modifier>
                           <type>std::string </type>
                           <methodname>GetParameterFormat();</methodname>
                           <void />
                           <exceptionname></exceptionname>
                           <modifier></modifier>
                       </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns a string that lists the legal value strings
                            separated by the <literal>|</literal> character.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>int </type>
                            <methodname>GetEnumValue</methodname>
                            <void />
                            <exceptionname></exceptionname>
                            <modifier></modifier>
                        </methodsynopsis>  
                    </term>
                    <listitem>
                        <para>
                            Returns the <structfield>s_value</structfield> field
                            corresponding to the current string value of the
                            parameter.  Note that the base class
                            <methodname>getOptionString</methodname> method can
                            retrieve the raw string value.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
        <refsect1>
            <title>CIntArrayParam</title>
            <para>
                This is a concrete derived class whose instances hold
                arrays of integer values.  The array values are passed in
                to the option as Tcl lists whose elements are then set in
                consecutive elements of the array.  The list must always
                contain all values in the array.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                            <constructorsynopsis>
                            <methodname>CIntArrayParam</methodname>
                            <methodparam>
                                <modifier>const</modifier>
                                <type>std::string&amp;</type>
                                <parameter>rName</parameter>
                            </methodparam>
                            <methodparam>
                                <type>unsigned int</type> <parameter>size</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>nDefault</parameter>
                                <initializer>= 0</initializer>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Constructs a parameter named <parameter>rName</parameter>.
                            The parameter is an array of exactly <parameter>size</parameter>
                            elements.  The elements of the array are all initialized
                            to <parameter>nDefault</parameter>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>CIntArrayParam</methodname>
                            <methodparam>
                                <modifier>const</modifier><type>std::string&amp;</type>
                                <parameter>rName</parameter>
                            </methodparam>
                            <methodparam>
                              <type>unsigned int</type> <parameter>size</parameter>
                            </methodparam>
                            <methodparam>
                              <type>int</type> <parameter>nLow</parameter>
                            </methodparam>
                            <methodparam>
                              <type>int</type> <parameter>nHigh</parameter>
                            </methodparam>
                            <methodparam>
                              <type>int</type> <parameter>nDefault</parameter>
                              <initializer>= 0</initializer>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This constructor has additional parameters
                            that constrain the values of the array elements
                            to be at least <parameter>nLow</parameter> and
                            ad most <parameter>nHigh</parameter>.  If any
                            element is out of range no elements get modified.
                        </para>
                        <para>
                            Clearly <parameter>nDefault</parameter> should
                            also satisfy this constraint.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>int </type>
                            <methodname>getSize</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the number of elements the array has.
                            this is the value of the <parameter>size</parameter>
                            parameter to the constructor.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>const </modifier>
                            <type> int* </type>
                            <methodname>getValues </methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns a pointer to an array of <type>int</type>
                            values that are the contents of the array.  Note
                            that this is readonly and storage is managed
                            by the object not by the caller.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type> bool </type>
                            <methodname>getCheckRange </methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            If this returns <literal>true</literal> the parameter
                            has a value range constraint defined.  If
                            <literal>false</literal> the contents of the
                            array are not constrained.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>int  </type>
                            <methodname>getLow </methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the low limit set at construction time.
                            if <methodname>getCheckRange</methodname> returns
                            <literal>false</literal> the value retured is
                            undefined.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type> int </type>
                            <methodname>getHigh </methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the high limit set at construction time.
                            if <methodname>getCheckRange</methodname> returns
                            <literal>false</literal> the value retured is
                            undefined.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type> int&amp;        </type>
                            <methodname>operator[] </methodname>
                            <methodparam>
                                <modifier></modifier>
                                <type>int</type>
                                <parameter>n</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Provides indexing into the array of values.
                            Note that this method supports indexing both for
                            <firstterm>lvalues</firstterm> and
                            <firstterm>rvalues</firstterm> (that is on the left
                            or right side of an assignment).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual </modifier>
                            <type> int</type>
                            <methodname> SetValue</methodname>
                            <methodparam>
                                <modifier></modifier>
                                <type> CTCLInterpreter&amp; </type>
                                <parameter>rInterp</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier></modifier>
                                <type>CTCLResult&amp; </type>
                                <parameter>rResult</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier>const </modifier>
                                <type>char* </type>
                                <parameter>pValues</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            If <parameter>pValues</parameter> points to a valid
                            Tcl list whose elements are integers and, if range
                            checking, all elements satisfy the range constraints,
                            the array elements are replaced with the elements
                            of that list.  Note that the list must also have
                            the correct number of elements. 
                        </para>
                        <para>
                            On success, the method returns <literal>TCL_OK</literal>
                            if any of the restrictions described above are not
                            satisfied, the method returns <literal>TCL_ERROR</literal>
                            and <parameter>rResult</parameter> is set with a human
                            meaningful error message.  The <parameter>rInterp</parameter>
                            interpreter is used to parse the list.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual </modifier>
                            <type>std::string  </type>
                            <methodname>GetParameterFormat</methodname>
                            <void />
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns a string of the form:
                            <literal>int[<replaceable>n</replaceable>]</literal>
                            where <replaceable>n</replaceable> is the array
                            size.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type> void </type>
                            <methodname>setRange</methodname>
                            <methodparam>
                                <modifier></modifier>
                                <type>int  </type>
                                <parameter>nLow</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier></modifier>
                                <type>int </type>
                                <parameter>nHigh</parameter>
                            </methodparam>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Sets a new range constraint on the values of the
                            array.  Note that this does not check the value of
                            the array against the new constraint.  If you call
                            this method after the array may have been assigned
                            values you may want to reset the array to a
                            legal default value, or set of values.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
        <refsect1>
            <title><classname>CIntConfigParam</classname></title>
            <para>
                This class is a concrete class that represents a single integer
                valued parameter.  The parameter can optionally have range
                constraints applied to its value.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>CIntConfigParam</methodname>
                            <methodparam>
                                <modifier>const </modifier>
                                <type>std::string&amp; </type>
                                <parameter>rName</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier></modifier>
                                <type>int </type>
                                <parameter>nDefault</parameter>
                                <initializer>=0</initializer>
                            </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Constructs an integer configuration parameter with
                            no range constraint.  <parameter>rName</parameter>
                            is the name of the parameter and its initial
                            value is <parameter>nDefault</parameter>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                            <methodname>CIntConfigParam</methodname>
                            <methodparam>
                                <modifier>const  </modifier>
                                <type>std::string&amp;</type>
                                <parameter>rName</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier></modifier>
                                <type>int </type>
                                <parameter>nLow</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier></modifier>
                                <type>int </type>
                                <parameter>nHigh</parameter>
                            </methodparam>   
                            <methodparam>
                                <modifier></modifier>
                                <type>int </type>
                                <parameter>nDefault</parameter>
                                <initializer>=0</initializer>
                            </methodparam>         
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Creates an integer parameter whose value is constrained
                            to be at least <parameter>nLow</parameter> and
                            at most <parameter>nHigh</parameter>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>  bool </type>
                            <methodname>getCheckrange</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This method returns <literal>true</literal> if the
                            parameter has a range constraint defined.
                            Range constraints can be defined either at construction
                            time or by invoking the <methodname>setRange</methodname>
                            method after the object is constructed.
                            If no range constraint is in place this method
                            returnes <literal>false</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type> int </type>
                            <methodname>getLow</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the low limit of the range constraint
                            on the parameter.  If no range constraint has been
                            set (<methodname>getCheckRange</methodname> returns
                            <literal>false</literal>), the value returned from
                            this method has no meaning.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type> int </type>
                            <methodname>getHigh</methodname>
                            <void />
                            <modifier>const</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the upper limit of the range constraint
                            set on the parameter.  If no range constraint has
                            been set, the return value from this method is
                            meaningless.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>int </type>
                            <methodname>getOptionValue</methodname>
                            <void />
                            <exceptionname></exceptionname>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the current value of the configuration parameter
                            as an integer.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <modifier>virtual</modifier>
                            <type>int </type>
                            <methodname>SetValue </methodname>
                            <methodparam>
                                <type>CTCLInterpreter&amp;</type><parameter> rInterp</parameter>
                            </methodparam>
                            <methodparam>
                                <type>CTCLResult&amp;</type><parameter> rResult</parameter>
                            </methodparam>
                            <methodparam>
                                <modifier>const</modifier>
                                <type>char*</type>
                                <parameter>pValue</parameter>
                            </methodparam>
                            <exceptionname></exceptionname>
                            <modifier></modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Called by the configuration manager to attempt to
                            provide a new value for the parameter.  If
                            <parameter>pValue</parameter> points to a string that
                            converts to an integer and, if the parameter has a
                            range constraint, satisfies the range constraint,
                            the parameter value is modified and
                            <literal>TCL_OK</literal> is returned.   If not
                            <literal>TCL_ERROR</literal> is returned and a human
                            readable error message is set in <parameter>rResult</parameter>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                            <methodsynopsis>
                                <modifier>virtual </modifier>
                                <type>std::string </type>
                                <methodname>GetParameterFormat</methodname>
                                <void />
                                <exceptionname></exceptionname>
                                <modifier></modifier>
                            </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the string <literal>int</literal> indicating that
                            parameters of this type expect integer values.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                            <methodsynopsis>
                                <modifier></modifier>
                                <type>void </type>
                                <methodname>setRange</methodname>
                                <methodparam>
                                    <type>int</type><parameter>nLo</parameter>
                                </methodparam>
                                <methodparam>
                                    <type>int</type> <parameter>nHi</parameter>
                                </methodparam>
                                <exceptionname></exceptionname>
                                <modifier></modifier>
                            </methodsynopsis>  
                    </term>
                    <listitem>
                        <para>
                            Sets a new range constraint from
                            <parameter>nLo</parameter> as the lower limit and
                            <parameter>nHi</parameter> as the upper limit.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
        <refsect1>
            <title>SEE ALSO</title>
            <para>
            <link linkend='sbsreadout3_sconfigurableobject_class'
                endterm='sbsreadout3_sconfigurableobject_class_title' />
            </para>
        </refsect1>
     </refentry>     

<!-- SConfigurableObject -->

	 <refentry id='sbsreadout3_sconfigurableobject_class'>
       <refmeta>
          <refentrytitle id='sbsreadout3_sconfigurableobject_class_title'>SConfigurableObject</refentrytitle>
          <manvolnum>3</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>SConfigurableObject</refname>
          <refpurpose>Scripted Readout Configuration database</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>
            <command>
#include &lt;CConfigurableObject.h&gt;  // Note different name.
            </command>
            <ooclass><classname>SConfigurableObject : public CTCLProcessor</classname></ooclass>
           <constructorsynopsis>
          <methodname>SConfigurableObject </methodname>
          <methodparam>
            <modifier>const</modifier>
            <type> std::string&amp;</type>
            <parameter>rName</parameter>
          </methodparam>
          <methodparam>
            <type>CTCLInterpreter&amp;</type>
            <parameter>rInterp</parameter>
          </methodparam>
          <exceptionname></exceptionname>
           </constructorsynopsis>
           
           <methodsynopsis>
          <type>std::string </type>
             <methodname>getName</methodname>
             <void />
             <exceptionname></exceptionname>
             <modifier>const</modifier>
           </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual  </modifier>
                <type>int      </type>
                <methodname>operator() </methodname>
                <methodparam>
                    <type>CTCLInterpreter&amp;</type><parameter> rInterp</parameter>
                </methodparam>
                <methodparam>
                    <type>CTCLResult&amp;</type><parameter> rResult</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type><parameter> nArgs</parameter>
                </methodparam>
                <methodparam>
                    <type>char**</type> <parameter>pArgs</parameter>
                </methodparam>
                <exceptionname></exceptionname>
                <modifier></modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual  </modifier>
                <type>int      </type>
                <methodname>Configure </methodname>
                <methodparam>
                    <type>CTCLInterpreter&amp;</type><parameter> rInterp</parameter>
                </methodparam>
                <methodparam>
                    <type>CTCLResult&amp;</type> <parameter>rResult</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>nArgs</parameter>
                </methodparam>
                <methodparam>
                    <type>char**</type> <parameter>pArgs</parameter>
                </methodparam>
                <exceptionname></exceptionname>
                <modifier></modifier>
            </methodsynopsis>  
            <methodsynopsis>
                <modifier>virtual  </modifier>
                <type>int      </type>
                <methodname>ListConfiguration </methodname>
                <methodparam>
                    <type>CTCLInterpreter&amp;</type>
                    <parameter>rInterp</parameter>
                </methodparam>
                <methodparam>
                    <type>CTCLResult&amp;</type>
                    <parameter>rResult</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>nArgs</parameter>
                </methodparam>
                <methodparam>
                    <type>char**</type> <parameter>pArgs</parameter>
                </methodparam>
                <exceptionname></exceptionname>
                <modifier></modifier>
            </methodsynopsis>  
            <methodsynopsis>
                <modifier></modifier>
                <type>SConfigurableObject::ParameterIterator </type>
                <methodname>AddParameter</methodname>
                <methodparam>
                    <type>CConfigurationParameter*</type>
                    <parameter>pConfigParam</parameter>
                </methodparam>
                <exceptionname></exceptionname>
                <modifier></modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier></modifier>
                <type>SConfigurableObject::ParameterIterator  </type>
                <methodname>AddIntParam </methodname>
                <methodparam>
                    <modifier>const </modifier>
                    <type>std::string&amp;</type><parameter> sParamName</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type><parameter> nDefault</parameter>
                    <initializer>=0</initializer>
                </methodparam>
                <exceptionname></exceptionname>
                <modifier></modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier> </modifier>
                <type>SConfigurableObject::ParameterIterator </type>
                <methodname>AddBoolParam </methodname>
                <methodparam>
                    <modifier>const</modifier><type> std::string&amp;</type>
                    <parameter>rName</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type><parameter> fDefault</parameter>
                </methodparam>
                <exceptionname></exceptionname>
                <modifier></modifier>
            </methodsynopsis>  
            <methodsynopsis>
                <modifier></modifier>
                <type>SConfigurableObject::ParameterIterator </type>
                <methodname>AddStringParam </methodname>
                <methodparam>
                    <modifier>const</modifier><type> std::string&amp;</type>
                    <parameter>rName</parameter>
                </methodparam>
                <exceptionname></exceptionname>
                <modifier></modifier>
            </methodsynopsis>  
            <methodsynopsis>
                <modifier></modifier>
                <type>SConfigurableObject::ParameterIterator </type>
                <methodname>AddIntArrayParam </methodname>
                <methodparam>
                    <modifier>const</modifier><type> std::string&amp;</type>
                    <parameter>rParameterName</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type><parameter> nArraySize</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type><parameter> nDefault</parameter>
                    <initializer>=0</initializer>
                </methodparam>
                <exceptionname></exceptionname>
                <modifier></modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier></modifier>
                <type>SConfigurableObject::ParameterIterator </type>
                <methodname>AddStringArrayParam </methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>std::string&amp;</type>
                    <parameter>rName</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type>
                    <parameter>nArraySize</parameter>
                </methodparam>
                <exceptionname></exceptionname>
                <modifier></modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier></modifier>
                <type>SConfigurableObject::ParameterIterator</type>
                <methodname>AddEnumParam</methodname>
                <methodparam>
                    <type> std::string</type>
                    <parameter>name</parameter>
                </methodparam>
                <methodparam>
                    <type>std::vector&lt;std::pair&lt;std::string, int&gt; &gt;</type>
                    <parameter>values</parameter>
                </methodparam>
                <methodparam>
                    <type>std::string</type><parameter> defaultValue</parameter>
                </methodparam>
                <exceptionname></exceptionname>
                <modifier></modifier>
            </methodsynopsis>  
            <methodsynopsis>
                <modifier></modifier>
                <type>SConfigurableObject::ParameterIterator </type>
                <methodname>Find </methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>std::string&amp;</type> <parameter> rKeyword</parameter>
                </methodparam>
                <exceptionname></exceptionname>
                <modifier></modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier></modifier>
                <type>SConfigurableObject::ParameterIterator</type>
                <methodname> begin</methodname>
                <void />
                <exceptionname></exceptionname>
                <modifier></modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier></modifier>
                <type>SConfigurableObject::ParameterIterator </type>
                <methodname>end</methodname>
                <void />
                <exceptionname></exceptionname>
                <modifier></modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier></modifier>
                <type>int </type>
                <methodname>size</methodname>
                <void />
                <exceptionname></exceptionname>
                <modifier></modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier></modifier>
                <type>std::string </type>
                <methodname>ListParameters </methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>std::string&amp;</type>
                    <parameter>rPattern</parameter>
                </methodparam>
                <exceptionname></exceptionname>
                <modifier></modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier></modifier>
                <type>std::string  </type>
                <methodname>ListKeywords</methodname>
                <void />
                <modifier></modifier>
            </methodsynopsis>  
            <methodsynopsis>
                <modifier></modifier>
                <type>int </type>
                <methodname>getIntegerValue</methodname>
                <methodparam>
                    <type>std::string</type>
                    <parameter>name</parameter>
                </methodparam>
                <exceptionname></exceptionname>
                <modifier></modifier>
            </methodsynopsis>  
            <methodsynopsis>
                <modifier></modifier>
                <type>bool </type>
                <methodname>getBoolValue</methodname>
                <methodparam>
                    <type>std::string</type><parameter> name</parameter>
                </methodparam>
                <exceptionname></exceptionname>
                <modifier></modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier></modifier>
                <type>CIntArrayParam* </type>
                <methodname>getIntArray</methodname>
                <methodparam>
                    <type>std::string</type><parameter> name</parameter>
                </methodparam>
                <exceptionname></exceptionname>
                <modifier></modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier></modifier>
                <type>int</type>
                <methodname>getEnumValue</methodname>
                <methodparam>
                    <type>std::string</type>
                    <parameter>name</parameter>
                </methodparam>
                <exceptionname></exceptionname>
                <modifier></modifier>
            </methodsynopsis>  
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            This class is an eventual base class for the
            <link linkend='sbsreadout3_digitizer_class'
                  endterm='sbsreadout3_digitizer_class_title' />
            and is responsible for managing the command dispatching and
            configuration management for classes derived from that class.
          </para>
          <para>
            Configuration parameters are held in a searchable container.  The
            class can produce <classname>SConfigurableParameter::ParameterIterator</classname>
            objects which are essentially pointers to <classname>CConfigurationParameter*</classname>.
            The iterator refers to pointers so that the actual parameter can
            polymorph (recall that <classname>CConfigurationParameter</classname>
            is an abstract base class).
          </para>
          <para>
            Convenience methods are also provided to locate and perform
            common operations on parameters of well known types.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                   <methodname>SConfigurableObject </methodname>
                   <methodparam>
                     <modifier>const</modifier>
                     <type> std::string&amp;</type>
                     <parameter>rName</parameter>
                   </methodparam>
                   <methodparam>
                     <type>CTCLInterpreter&amp;</type>
                     <parameter>rInterp</parameter>
                   </methodparam>
                   <exceptionname></exceptionname>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a new configurable object.
                        <parameter>rName</parameter> is the name of the new object.
                        This is normally the name of the digitizer module that
                        is being created.
                    </para>
                    <para>
                        The <classname>SConfigurableObject</classname> registers
                        <parameter>rName</parameter> as  a new Tcl command in
                        <parameter>rInterp</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                   <type>std::string </type>
                      <methodname>getName</methodname>
                      <void />
                      <exceptionname></exceptionname>
                      <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the name of this object.  This is also a command
                        that is registered in the interpreter that processes
                        the configuration script.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                     <methodsynopsis>
                         <modifier>virtual  </modifier>
                         <type>int      </type>
                         <methodname>operator() </methodname>
                         <methodparam>
                             <type>CTCLInterpreter&amp;</type><parameter> rInterp</parameter>
                         </methodparam>
                         <methodparam>
                             <type>CTCLResult&amp;</type><parameter> rResult</parameter>
                         </methodparam>
                         <methodparam>
                             <type>int</type><parameter> nArgs</parameter>
                         </methodparam>
                         <methodparam>
                             <type>char**</type> <parameter>pArgs</parameter>
                         </methodparam>
                         <exceptionname></exceptionname>
                         <modifier></modifier>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Performs command processing of the command words
                        specified by <parameter>nArgs</parameter> (number of words)
                        and <parameter>pArgs</parameter> (Pointer to array of null terminated
                        strings that make up the command words).
                        <parameter>rInterp</parameter> is the interpreter that is
                        processing the command and <parameter>rResult</parameter> contains
                        the final result string.
                    </para>
                    <para>
                        This method recognizes and processes the
                        <command>config</command>, <command>cget</command>
                        and <command>help</command> sub-commands.
                        Derived classes can override this method.  If they do so,
                        and still want the command configurability, they should
                        attempt to recognize their own keywords and, if that fails,
                        invoke this base class method to ensure the standard
                        sub-commands are executed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                     <methodsynopsis>
                         <modifier>virtual  </modifier>
                         <type>int      </type>
                         <methodname>Configure </methodname>
                         <methodparam>
                             <type>CTCLInterpreter&amp;</type><parameter> rInterp</parameter>
                         </methodparam>
                         <methodparam>
                             <type>CTCLResult&amp;</type> <parameter>rResult</parameter>
                         </methodparam>
                         <methodparam>
                             <type>int</type> <parameter>nArgs</parameter>
                         </methodparam>
                         <methodparam>
                             <type>char**</type> <parameter>pArgs</parameter>
                         </methodparam>
                         <exceptionname></exceptionname>
                         <modifier></modifier>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is dispatched to in response to the
                        <command>config</command> subcommand.  It ensures that
                        <parameter>nArgs</parameter> and <parameter>pArgs</parameter> are
                        consistent with a configuration command (an even number
                        of addition parameters with at least one configuration
                        keyword and its value).
                    </para>
                    <para>
                        The configuration changes are performed in a single pass
                        from left to right on the command line.
                        this means that if there are errors either in configuration
                        parameter keywords or their values, any configuration
                        operations performed prior to the failing operation will
                        not be rolled back to their prior values.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                     <methodsynopsis>
                         <modifier>virtual  </modifier>
                         <type>int      </type>
                         <methodname>ListConfiguration </methodname>
                         <methodparam>
                             <type>CTCLInterpreter&amp;</type>
                             <parameter>rInterp</parameter>
                         </methodparam>
                         <methodparam>
                             <type>CTCLResult&amp;</type>
                             <parameter>rResult</parameter>
                         </methodparam>
                         <methodparam>
                             <type>int</type> <parameter>nArgs</parameter>
                         </methodparam>
                         <methodparam>
                             <type>char**</type> <parameter>pArgs</parameter>
                         </methodparam>
                         <exceptionname></exceptionname>
                         <modifier></modifier>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Dispatched to by <methodname>operator()</methodname>
                        if the subcommand was <command>cget</command>.  The
                        current object's configuration is marshalled and returned
                        int <parameter>rResult</parameter> in a form that is
                        easily interpreted by Tcl scripts.  The form is a Tcl
                        list of two element sublists.  Each sublist contains,
                        in order, a configuration parmameter name and its value.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                     <methodsynopsis>
                         <modifier></modifier>
                         <type>SConfigurableObject::ParameterIterator </type>
                         <methodname>AddParameter</methodname>
                         <methodparam>
                             <type>CConfigurationParameter*</type>
                             <parameter>pConfigParam</parameter>
                         </methodparam>
                         <exceptionname></exceptionname>
                         <modifier></modifier>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates a configuration parameter.  This method is
                        intended to create custom parameter types.  See
                        the convenience method below for methods that produce
                        specific parameter types.
                        <parameter>pConfigParam</parameter> is the parameter
                        that will be added.  Recall that a
                        <classname>CConfigurationParameter</classname> has a name.
                        That name will be the configuration parameter keyword.
                    </para>
                    <para>
                        The return value is a <type>SConfigurableObject::ParameterIterator</type>.
                        This is a pointer-like object which, when dereferenced
                        provides a pointer to the actual configuration parameter.
                        Note that normally prior to use, the returned pointer will
                        have to be cast to be a pointer to the actual type of the
                        parameter.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                     <methodsynopsis>
                         <modifier></modifier>
                         <type>SConfigurableObject::ParameterIterator  </type>
                         <methodname>AddIntParam </methodname>
                         <methodparam>
                             <modifier>const </modifier>
                             <type>std::string&amp;</type><parameter> sParamName</parameter>
                         </methodparam>
                         <methodparam>
                             <type>int</type><parameter> nDefault</parameter>
                             <initializer>=0</initializer>
                         </methodparam>
                         <exceptionname></exceptionname>
                         <modifier></modifier>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates an integer configuration parameter
                        (<link linkend='sbsreadout3_cconfigurationparameter_class'>
                        <classname>CIntConfigParam</classname></link>).
                        <parameter>sParamName</parameter> is the name of the
                        parameter and <parameter>nDefault</parameter> will be the
                        initial value of the parameter.
                    </para>
                    <para>
                        The method returns a <classname>SConfigurableObject::ParameterIterator</classname>
                        which, when dereferenced returns a pointer to a
                        <link linkend='sbsreadout3_cconfigurationparameter_class'
                              endterm='sbsreadout3_cconfigurationparameter_class_title' />.
                        Prior to use, this should be cast to a pointer to a
                        <classname>CIntConfigtParam</classname>.  For example, when
                        called within a method of a class derived from a
                        <classname>SConfigurableObject</classname>:
                    </para>
                    <informalexample>
                        <programlisting>
CIntConfigParam* pParam = reinterpret_cast&lt;CIntConfigParam*&gt;(*AddIntParam("someParam"));
                        </programlisting>
                    </informalexample>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                     <methodsynopsis>
                         <modifier> </modifier>
                         <type>SConfigurableObject::ParameterIterator </type>
                         <methodname>AddBoolParam </methodname>
                         <methodparam>
                             <modifier>const</modifier><type> std::string&amp;</type>
                             <parameter>rName</parameter>
                         </methodparam>
                         <methodparam>
                             <type>bool</type><parameter> fDefault</parameter>
                         </methodparam>
                         <exceptionname></exceptionname>
                         <modifier></modifier>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a boolean parameter
                        <classname>CBoolConfigParam</classname>
                        named <parameter>rName</parameter>
                        with the default value <parameter>fDefault</parameter>.
                        The return value is a
                        <classname>SConfigurableObject::ParameterIterator</classname>.
                        See the documentation of the <methodname>AddIntParam</methodname>
                        for more information about how to use the return value.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                     <methodsynopsis>
                         <modifier></modifier>
                         <type>SConfigurableObject::ParameterIterator </type>
                         <methodname>AddStringParam </methodname>
                         <methodparam>
                             <modifier>const</modifier><type> std::string&amp;</type>
                             <parameter>rName</parameter>
                         </methodparam>
                         <exceptionname></exceptionname>
                         <modifier></modifier>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a string valued parameter
                        (<classname>CStringConfigParam</classname>)
                        to the configuration
                        database for this object.   The name of the parameter
                        will be <parameter>rName</parameter>.  The initial
                        value of the string will be empty.
                        The return value is a <classname>SConfigurableObject::ParameterIterator</classname>
                        which can be used as described in <methodname>AddIntParam</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                     <methodsynopsis>
                         <modifier></modifier>
                         <type>SConfigurableObject::ParameterIterator </type>
                         <methodname>AddIntArrayParam </methodname>
                         <methodparam>
                             <modifier>const</modifier><type> std::string&amp;</type>
                             <parameter>rParameterName</parameter>
                         </methodparam>
                         <methodparam>
                             <type>int</type><parameter> nArraySize</parameter>
                         </methodparam>
                         <methodparam>
                             <type>int</type><parameter> nDefault</parameter>
                             <initializer>=0</initializer>
                         </methodparam>
                         <exceptionname></exceptionname>
                         <modifier></modifier>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a configuration parameter that is a fixed sized
                        array of integers (<classname>CIntArrayParam</classname>).
                        The array will be named <parameter>rParameterName</parameter>
                        and contains <parameter>nArraySize</parameter> elements each
                        initialized to <parameter>nDefault</parameter>
                    </para>
                    <para>
                        The return value of the method is a
                        <classname>SConfigurableObject::ParameterIterator</classname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                     <methodsynopsis>
                         <modifier></modifier>
                         <type>SConfigurableObject::ParameterIterator </type>
                         <methodname>AddStringArrayParam </methodname>
                         <methodparam>
                             <modifier>const</modifier>
                             <type>std::string&amp;</type>
                             <parameter>rName</parameter>
                         </methodparam>
                         <methodparam>
                             <type>int</type>
                             <parameter>nArraySize</parameter>
                         </methodparam>
                         <exceptionname></exceptionname>
                         <modifier></modifier>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a parameter that is an array of strings
                        (<classname>CStringArrayParam</classname>).  The
                        parameter's name is <parameter>rName</parameter>. The
                        array is fixed size containing
                        <parameter>nArraySize</parameter> elements.
                    </para>
                    <para>
                        As with other parameter creation methods, the return
                        value is a <classname>SConfigurableObject::ParameterIterator</classname>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                     <methodsynopsis>
                         <modifier></modifier>
                         <type>SConfigurableObject::ParameterIterator</type>
                         <methodname>AddEnumParam</methodname>
                         <methodparam>
                             <type> std::string</type>
                             <parameter>name</parameter>
                         </methodparam>
                         <methodparam>
                             <type>std::vector&lt;std::pair&lt;std::string, int&gt; &gt;</type>
                             <parameter>values</parameter>
                         </methodparam>
                         <methodparam>
                             <type>std::string</type><parameter> defaultValue</parameter>
                         </methodparam>
                         <exceptionname></exceptionname>
                         <modifier></modifier>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds an enumerated parameter
                        (<classname>CEnumParameter</classname>) to the configuration
                         database.
                        The name of the parameter is <parameter>name</parameter>.
                        The <parameter>values</parameter> vector contains the
                        legal string values and the corresponding integer values.
                        The <parameter>defaultValue</parameter> must be set to
                        the default value which should be one of the
                        elements of the <parameter>values</parameter> vector.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                     <methodsynopsis>
                         <modifier></modifier>
                         <type>SConfigurableObject::ParameterIterator </type>
                         <methodname>Find </methodname>
                         <methodparam>
                             <modifier>const</modifier>
                             <type>std::string&amp;</type> <parameter> rKeyword</parameter>
                         </methodparam>
                         <exceptionname></exceptionname>
                         <modifier></modifier>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a <classname>SConfigurableObject::ParameterIterator</classname>
                        pointer like object to a pointer to the configuration object
                        named <parameter>rKeyword</parameter>.  If the configuration
                        database does not contain an object named,
                        <parameter>rKeyword</parameter> the method returns the
                        value that would be returned from
                        <methodname>end</methodname> below.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                     <methodsynopsis>
                         <modifier></modifier>
                         <type>SConfigurableObject::ParameterIterator</type>
                         <methodname> begin</methodname>
                         <void />
                         <exceptionname></exceptionname>
                         <modifier></modifier>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer like object
                        (<classname>SConfigurableObject::ParameterIterator</classname>)
                        that points to a pointer to the first configuration parameter
                        object in the object's configuration database.  Note that
                        if there are not yet any configuration objects,
                        this will return the value returned from
                        <methodname>end</methodname> below.
                    </para>
                    <para>
                        <classname>SConfigurableObject::ParameterIterator</classname>
                        objects are pointer-like.  When dereferenced, they produce
                        a <classname>CConfigurationParameter*</classname>.  They can
                        also be incremented via <literal>++</literal> to point
                        to the next object in the container that represents the
                        configuration database.  If there are no more elements
                        in the container <literal>++</literal> will produce
                        an object equal to the return value for
                        <methodname>end</methodname> below.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                     <methodsynopsis>
                         <modifier></modifier>
                         <type>SConfigurableObject::ParameterIterator </type>
                         <methodname>end</methodname>
                         <void />
                         <exceptionname></exceptionname>
                         <modifier></modifier>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a <classname>SConfigurableObject::ParameterIterator</classname>
                        that does not point to anything but represents an iterator
                        that has stepped off the end of the container.
                        Thus you can iterate over all configuration objects in
                        the container via a loop like:
                    </para>
                    <informalexample>
                        <programlisting>
SConfigurableObject::ParameterIterator p = begin()
while (p != end()) {
   CConfiguationParameter* pParam = *p;
   ...
   p++;
}
                        </programlisting>
                    </informalexample>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                     <methodsynopsis>
                         <modifier></modifier>
                         <type>int </type>
                         <methodname>size</methodname>
                         <void />
                         <exceptionname></exceptionname>
                         <modifier></modifier>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the number of configuration items in the
                        configuration database.  This provides an alternative
                        mechanism for iterating through the collection:
                    </para>
                    <informalexample>
                        <programlisting>
SConfigurableObject::ParameterIterator p = begin();
for (int = 0; i &lt;  size(); i++) {
    CConfigurationParameter* pParam = *p;
    ...
    p++;
}
                        </programlisting>
                    </informalexample>
                </listitem>
            </varlistentry>
          </variablelist>
          <variablelist>
            <varlistentry>
                <term>
                     <methodsynopsis>
                         <modifier></modifier>
                         <type>std::string </type>
                         <methodname>ListParameters </methodname>
                         <methodparam>
                             <modifier>const</modifier>
                             <type>std::string&amp;</type>
                             <parameter>rPattern</parameter>
                         </methodparam>
                         <exceptionname></exceptionname>
                         <modifier></modifier>
                     </methodsynopsis>
                </term>

                <listitem>
                    <para>
                        Produces a string that is a properly formatted Tcl list
                        of parameters that match the glob pattern
                        in <parameter>rPattern</parameter>.  If required, elements
                        of the list are properly quoted.  The list consists of two
                        element sublists that contain in order the name of a
                        configuration parameter and its value.
                    </para>
                </listitem>
            </varlistentry>
          <varlistentry>
            <term>
                     <methodsynopsis>
                         <modifier></modifier>
                         <type>std::string  </type>
                         <methodname>ListKeywords</methodname>
                         <void />
                         <modifier></modifier>
                     </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns a string that consists of configuration
                    parameter names followed
                    by the format required of that parameter.  The output
                    of this method is intended for human consumption.
                </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
                     <methodsynopsis>
                         <modifier></modifier>
                         <type>int </type>
                         <methodname>getIntegerValue</methodname>
                         <methodparam>
                             <type>std::string</type>
                             <parameter>name</parameter>
                         </methodparam>
                         <exceptionname></exceptionname>
                         <modifier></modifier>
                     </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns the value of the integer parameter named
                    <parameter>name</parameter>.  If that parameter does not
                    exists, a <type>std::string</type> exception is thrown indicating
                    that.  Note that the operation of this method is not well
                    defined if <parameter>name</parameter> is not a
                    <classname>CIntConfigParam</classname>.
                </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
                    <methodsynopsis>
                         <modifier></modifier>
                         <type>bool </type>
                         <methodname>getBoolValue </methodname>
                         <methodparam>
                             <type>std::string</type><parameter> name</parameter>
                         </methodparam>
                         <exceptionname></exceptionname>
                         <modifier></modifier>
                     </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns the boolean parameter named by <parameter>name</parameter>.
                    If <parameter>name</parameter> is not the name of a configuration
                    parameter for this object, a <type>std::string</type> exception
                    is raised whose value is a human readable error message.
                </para>
                <para>
                    The return value of this methdo is not well defined if
                    <parameter>name</parameter> is not a <classname>CBoolConfigParam</classname>
                    object.
                </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
                     <methodsynopsis>
                         <modifier></modifier>
                         <type>CIntArrayParam* </type>
                         <methodname>getIntArray</methodname>
                         <methodparam>
                             <type>std::string</type><parameter> name</parameter>
                         </methodparam>
                         <exceptionname></exceptionname>
                         <modifier></modifier>
                     </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns a pointer to the <classname>CIntArrayParam</classname>
                    integer array parameter named <parameter>name</parameter>.
                    If there is no parameter named <parameter>name</parameter>
                    a <type>std::string</type> exception is thrown containing a
                    human readable error message.
                </para>
                <para>
                    The behavior of invoking methods on the return value if
                    <parameter>name</parameter> does not identify a
                    <classname>CIntArrayParam</classname> is not well defined.
                </para>
            </listitem>
          </varlistentry>
          <varlistentry>
            <term>
                     <methodsynopsis>
                         <modifier></modifier>
                         <type>int</type>
                         <methodname>getEnumValue</methodname>
                         <methodparam>
                             <type>std::string</type>
                             <parameter>name</parameter>
                         </methodparam>
                         <exceptionname></exceptionname>
                         <modifier></modifier>
                     </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns the value of an enumerated parameter
                    <parameter>name</parameter>.  If
                    there is no configuration parameter <parameter>name</parameter>,
                    a <type>std::string</type> exception is thrown with a human
                    readable error message.
                </para>
                <para>
                    The value returned is the integer value that corresponds
                    to the current <type>std::string</type> configured for
                    <parameter>name</parameter>.  The behavior of this method
                    is not well defined if <parameter>name</parameter>
                    does not identify a <classname>CEnumParameter</classname>.
                </para>
            </listitem>
          </varlistentry>
            
          </variablelist>
       </refsect1>
        <refsect1>
           <title>PUBLIC VARIABLES, TYPES and CONSTANTS</title>
           <variablelist>
            <varlistentry>
                <term>
                    typedef std::list&lt;CConfigurationParameter*&gt; ConfigArray;
                </term>
                <listitem>
                    <para>
                        This is the type of the container that holds the
                        configuration database.  Publicizing this type
                        is required to publicize the next type.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    typedef ConfigArray::iterator ParameterIterator;
                </term>
                <listitem>
                    <para>
                        A pointer like object which when dereferenced returns a
                        <classname>CConfigurationParameter*</classname>.  Iterators
                        can also be incremented to 'point' to the next item in the
                        container of configuration parameters.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    std::vector&lt;std::pair&lt;std::string, int&gt; &gt;
                </term>
                <listitem>
                    <para>
                        This vector type contains legal values for enumerated
                        parameters.  The first item of each pair is a valid text
                        string that can be configured into enumerated parameters
                        while the second item is the integer equivalent that will
                        be returned from <methodname>getEnumValue</methodname> when
                        the parameter is configured with the <type>std::string</type>
                        value of the pair.
                    </para>
                </listitem>
            </varlistentry>
          </variablelist>
        </refsect1>
     </refentry>     
<!-- CModuleCreator base class -->
	 <refentry id="sbsreadout3_cmodule_creator_class">
       <refmeta>
          <refentrytitle id="sbsreadout3_cmodule_creator_class_title"> CModuleCreator </refentrytitle>
          <manvolnum>3sbsreadout</manvolnum>
       </refmeta>
       <refnamediv>
          <refname> CModuleCreator </refname>
          <refpurpose>Scripted readout base class for module creators</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>
            <ooclass><classname> CModuleCreator </classname></ooclass>
           <constructorsynopsis>
          <methodname>CModuleCreator </methodname>
          <methodparam>
            <type>const std::string&amp;</type>
            <parameter>rType</parameter>
          </methodparam>
          <exceptionname></exceptionname>
           </constructorsynopsis>
           <methodsynopsis>
            <type>std::string </type>
             <methodname>getModuleType </methodname>
             <void />
             <exceptionname></exceptionname>
             <modifier>const</modifier>
           </methodsynopsis>
           <methodsynopsis>
               <modifier></modifier>
               <type>bool    </type>
               <methodname>Match </methodname>
               <methodparam>
                    <modifier>const</modifier><type> std::string&amp;</type>
                    <parameter>rType</parameter> 
               </methodparam>
               <exceptionname></exceptionname>
               <modifier>const</modifier>
           </methodsynopsis>  
            <methodsynopsis>
                <modifier>virtual </modifier>
                <type>CReadableObject* </type>
                <methodname>Create </methodname>
                <methodparam>
                    <type>CTCLInterpreter&amp;</type><parameter> rInterp</parameter>
                </methodparam>
                <methodparam>
                    <type>CTCLResult&amp;</type><parameter> rResult</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type><parameter> nArgs</parameter>
                </methodparam>
                <methodparam>
                    <type>char**</type><parameter> pArgs</parameter>  
                </methodparam>
                <exceptionname></exceptionname>
                <modifier> = 0</modifier>
            </methodsynopsis>  
            <methodsynopsis>
                <modifier>virtual </modifier>
                <type>std::string  </type>
                <methodname>Help   </methodname>
                <void />
                <exceptionname></exceptionname>
                <modifier>= 0</modifier>
            </methodsynopsis>  
    
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            The scripted readout <command>module create</command> command relies
            on a set of <classname>CModuleCreator</classname> objects to do the
            actual creation.  The application registers these with the
            <classname>CModuleCommand</classname>.  This is the key to the extensibility
            of this framework, as it implies that the <command>module create</command>
            command can create an extensible set of module objects.
          </para>
          <para>
            To build a module creator, the application programmer needs to
            derive an object from <classname>CModuleCommand</classname> and
            implement that object's <methodname>Create</methodname> and
            <methodname>Help</methodname> methods.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                   <methodname>CModuleCreator </methodname>
                   <methodparam>
                     <type>const std::string&amp;</type>
                     <parameter>rType</parameter>
                   </methodparam>
                   <exceptionname></exceptionname>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        The <parameter>rType</parameter> parameter of the
                        constructor defines the keyword that must be matched
                        for this creator to be used to create a module.
                        For example, the command:
                    </para>
                    <informalexample>
                        <programlisting>
module create amodule mymoduletype
                        </programlisting>
                    </informalexample>
                    <para>
                        Will use the module creator that was constructed with
                        the <parameter>rType</parameter> set to
                        <literal>mymoduletype</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                     <type>std::string </type>
                      <methodname>getModuleType </methodname>
                      <void />
                      <exceptionname></exceptionname>
                      <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method just returns the value of
                        <parameter>rValue</parameter> as passed into the constructor.
                        In the example in the constructor documentation, the
                        creator would return <literal>mymoduletype</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier></modifier>
                        <type>bool    </type>
                        <methodname>Match </methodname>
                        <methodparam>
                             <modifier>const</modifier><type> std::string&amp;</type>
                             <parameter>rType</parameter> 
                        </methodparam>
                        <exceptionname></exceptionname>
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns <literal>true</literal>  if
                        <parameter>rType</parameter> is the same as the string passed
                        in to the contructor.  To continue the example
                        above, if <parameter>rType</parameter> were
                        <literal>mymoduletype</literal> this method would return
                        <literal>true</literal>, otherwise <literal>false</literal>
                        is returned.
                    </para>
                    <para>
                        This mmethod is used by the <command>module</command> command
                        to determine which creator can handle a specific module type.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                     <methodsynopsis>
                         <modifier>virtual </modifier>
                         <type>CReadableObject* </type>
                         <methodname>Create </methodname>
                         <methodparam>
                             <type>CTCLInterpreter&amp;</type><parameter> rInterp</parameter>
                         </methodparam>
                         <methodparam>
                             <type>CTCLResult&amp;</type><parameter> rResult</parameter>
                         </methodparam>
                         <methodparam>
                             <type>int</type><parameter> nArgs</parameter>
                         </methodparam>
                         <methodparam>
                             <type>char**</type><parameter> pArgs</parameter>  
                         </methodparam>
                         <exceptionname></exceptionname>
                         <modifier> = 0</modifier>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Must be defined by concrete subclasses.  This method
                        is expected to create the <classname>CReadableObject</classname>
                        expected by the <command>module </command> command registering
                        it on the <parameter>rInterp</parameter>.  In practice note
                        that <classname>CReadableObject</classname> constructors
                        self register the object.
                    </para>
                    <para>
                        The <parameter>nArgs</parameter> and <parameter>pArgs</parameter>
                        parameters are the number and pointers to the words in the
                        command tail. Specifically, <parameter>*pArgs</parameter> is
                        a pointer to the module name and <parameter>*(pArgs+1)</parameter> is a pointer
                        to the module type.
                    </para>
                    <para>
                        By convention, if there are any additional command parameter words
                        after the module type, these are passed to the <methodname>Configure</methodname>
                        method of the newly created module.  This allows for one-step creation
                        and configuration.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                     <methodsynopsis>
                         <modifier>virtual </modifier>
                         <type>std::string  </type>
                         <methodname>Help   </methodname>
                         <void />
                         <exceptionname></exceptionname>
                         <modifier>= 0</modifier>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a string that is used by the <command>module</command>
                        command when describing the set of modules that can be
                        created.  This is used in pseudo code like:
                    </para>
                    <informalexample>
                        <programlisting>
std::string helpstring
foreach modulecreator
    helpstring += modulecreator.getModuleType()
               +  " " + modulecreator.Help() + "\n";

                        </programlisting>
                    </informalexample>
                </listitem>
            </varlistentry>
          </variablelist>
       </refsect1>
       
     </refentry>     
<!-- CScriptedSegment base class -->

	 <refentry id="sbsreadout3_cscriptedsegment_class">
       <refmeta>
          <refentrytitle id="sbsreadout3_cscriptedsegment_class_title">CScriptedSegment</refentrytitle>
          <manvolnum>3sbsreadout</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CScriptedSegment</refname>
          <refpurpose>Scripted readout event segment</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>
            <ooclass><classname>CScriptedSegment : public CEventSegment</classname></ooclass>
           <constructorsynopsis>
          <methodname> CScriptedSegment</methodname>
          <void />
          <exceptionname></exceptionname>
           </constructorsynopsis>
           <methodsynopsis>
            <type>void </type>
             <methodname>addCreator</methodname>
             <methodparam>
                <type>CModuleCreator&amp;</type><parameter> creator</parameter>
             </methodparam>
             <exceptionname></exceptionname>
             <modifier></modifier>
           </methodsynopsis>
            <methodsynopsis>
                <modifier></modifier>
                <type>void </type>
                <methodname>addStandardCreators</methodname>
                <void />
                <exceptionname></exceptionname>
                <modifier></modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual </modifier>
                <type>void </type>
                <methodname>addUserWrittenCreators</methodname>
                <void />
                <exceptionname></exceptionname>
                <modifier></modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>std::string </type>
                <methodname>getConfigurationFile</methodname>
                <void />
                <exceptionname></exceptionname>
                <modifier></modifier>
            </methodsynopsis>  
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            This class is a scripted event segment.  It ties together the
            <command>readout</command> and <command>module</command> commands
            along with a set of module creators and an interpreter that
            will be used to execute the configuration file.
          </para>
          <para>
            The virtual methods <methodname>addUserWrittenCreators</methodname>
            and <methodname>getConfigurationFile</methodname> allow applications
            to tailor the important aspects of this class.
          </para>
          <para>
            Note that since this class is derived from
            <link linkend='manpage.ceventsegment'
                  endterm='manpage.ceventsegment_title' />,
            it defines and implements the <methodname>initialize</methodname>,
            <methodname>clear</methodname>, <methodname>disable</methodname>
            and <methodname>read</methodname> methods from that class.
            Those implementations iterate through the modules thta have been
            added to the <command>readout</command> in the order in which they
            have been added invoking appropriate methods in those modules.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>  
          <variablelist>
            <varlistentry>
                <term>
                      <constructorsynopsis>
                        <methodname> CScriptedSegment</methodname>
                        <void />
                        <exceptionname></exceptionname>
                         </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructor. Weaves together a Tcl interpreter, a configuration
                        file a <command>readout</command> and a <command>module</command>
                        command along with a set of module creators to build an event
                        segment that is configurable via a Tcl script.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>     
                       <methodsynopsis>
                        <type>void </type>
                         <methodname>addCreator</methodname>
                         <methodparam>
                            <type>CModuleCreator&amp;</type><parameter> creator</parameter>
                         </methodparam>
                         <exceptionname></exceptionname>
                         <modifier></modifier>
                       </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is a convenience method used by
                        <methodname>addStandardCreators</methodname> and, if used,
                        <methodname>addUserWrittenCreators</methodname> to register
                        module creators with the object/interpreter's
                        <command>module</command> command.  <parameter>creator</parameter>
                        is a reference to a <classname>CModuleCreator</classname>
                        object that will be added.  The creator object must live
                        for the lifetime of this object.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                        <methodsynopsis>
                            <modifier></modifier>
                            <type>void </type>
                            <methodname>addStandardCreators</methodname>
                            <void />
                            <exceptionname></exceptionname>
                            <modifier></modifier>
                        </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is invoked from the
                        <methodname>initialize</methodname> method to register
                        the creators for the standard supported modules.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                        <methodsynopsis>
                            <modifier>virtual </modifier>
                            <type>void </type>
                            <methodname>addUserWrittenCreators</methodname>
                            <void />
                            <exceptionname></exceptionname>
                            <modifier></modifier>
                        </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called by <methodname>initialize</methodname>.  The
                        implementation in the base class is empty.  Derived classes
                        may override this implementation to create and register
                        additional module creators by invoking
                        <methodname>addCreator</methodname> as needed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                        <methodsynopsis>
                            <modifier>virtual</modifier>
                            <type>std::string </type>
                            <methodname>getConfigurationFile</methodname>
                            <void />
                            <exceptionname></exceptionname>
                            <modifier></modifier>
                        </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called by <methodname>initialize</methodname> to obtain
                        the path to the configuration file.  The base class
                        implementation returns the first match among
                        <literal>$HARDWARE_FILE</literal>, <filename>$HOME/config/hardware.tcl</filename>
                        <filename>./hardware.tcl</filename>.  An error is thrown
                        (<classname>CErrnoException</classname> with a meaningful error message)
                        if there is no match in any of these locations.
                    </para>
                    <para>
                        <methodname>getConfigurationFile</methodname> is virtual
                        allowing you to override this behavior.  This is normally
                        done if you want a scriptable event segment to use
                        a different configuration script.
                    </para>
                </listitem>
            </varlistentry>
          </variablelist>
       </refsect1>
     </refentry>     

<!-- CScriptedScalers base class -->

	 <refentry id="sbsreadout3_cscriptedscalers_class">
       <refmeta>
          <refentrytitle id="sbsreadout3_cscriptedscalers_class_title">CScriptedScalers</refentrytitle>
          <manvolnum>3sbsreadout</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CScriptedScalers</refname>
          <refpurpose>Scaler class that is scriptably configured.</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>
            <ooclass><classname>CScriptedScalers : public CScaler</classname></ooclass>
           <constructorsynopsis>
          <methodname>CScriptedScalers</methodname>
          <void />
          <exceptionname></exceptionname>
           </constructorsynopsis>
           <methodsynopsis>
          <type>void </type>
             <methodname>addCreator</methodname>
             <methodparam>
                <type>CModuleCreator&amp;</type> <parameter>creator</parameter>
             </methodparam>
             <exceptionname></exceptionname>
             <modifier></modifier>
           </methodsynopsis>
           <methodsynopsis>
               <modifier></modifier>
               <type>void </type>
               <methodname>addStandardCreators</methodname>
               <void />
               <exceptionname></exceptionname>
               <modifier></modifier>
           </methodsynopsis>  
            <methodsynopsis>
                <modifier>virtual </modifier>
                <type>void </type>
                <methodname>addUserWrittenCreators</methodname>
                <void />
                <exceptionname></exceptionname>
                <modifier></modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual </modifier>
                <type>std::string </type>
                <methodname>getConfigurationFile</methodname>
                <void />
                <exceptionname></exceptionname>
                <modifier></modifier>
            </methodsynopsis>  
  
  
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            This is a scriptable scaler module.  It is for scalers
            what
            <link linkend='sbsreadout3_cscriptedsegment_class'
                  endterm='sbsreadout3_cscriptedsegment_class' />
            is for event segments.  The methods in this class have
            identical meaning and usage as for
            <link linkend='sbsreadout3_cscriptedsegment_class'
                  endterm='sbsreadout3_cscriptedsegment_class' />.
          </para>
       </refsect1>
     </refentry>     
<!-- /manpage -->