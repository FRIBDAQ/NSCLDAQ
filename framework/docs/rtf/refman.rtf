{\rtf1\ansi\ansicpg1252\uc1 \deff0\deflang1033\deflangfe1033
{\fonttbl {\f0\froman\fcharset0\fprq2{\*\panose 02020603050405020304}Times New Roman;}
{\f1\fswiss\fcharset0\fprq2{\*\panose 020b0604020202020204}Arial;}
{\f2\fmodern\fcharset0\fprq1{\*\panose 02070309020205020404}Courier New;}
{\f3\froman\fcharset2\fprq2{\*\panose 05050102010706020507}Symbol;}
}
{\colortbl;\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;\red0\green0\blue128;\red0\green128\blue128;\red0\green128\blue0;\red128\green0\blue128;\red128\green0\blue0;\red128\green128\blue0;\red128\green128\blue128;\red192\green192\blue192;}
{\stylesheet
{\widctlpar\adjustright \fs20\cgrid \snext0 Normal;}
{\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid \sbasedon0 \snext0 heading 1;}
{\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid \sbasedon0 \snext0 heading 2;}
{\s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid \sbasedon0 \snext0 heading 3;}
{\s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext0 heading 4;}{\*\cs10 \additive Default Paragraph Font;}
{\s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid \sbasedon0 \snext15 Title;}
{\s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid \sbasedon0 \snext16 Subtitle;}
{\s17\sa60\sb30\widctlpar\qj \fs22\cgrid \sbasedon0 \snext17 BodyText;}
{\s18\widctlpar\fs22\cgrid \sbasedon0 \snext18 DenseText;}
{\s28\widctlpar\tqc\tx4320\tqr\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext28 header;}
{\s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid \sbasedon0 \snext29 footer;}
{\s30\li360\sa60\sb120\keepn\widctlpar\adjustright \b\f1\fs20\cgrid \sbasedon0 \snext30 GroupHeader;}
{\s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext41 Code Example 0;}
{\s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext42 Code Example 1;}
{\s42\li720\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext43 Code Example 2;}
{\s43\li1080\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext44 Code Example 3;}
{\s44\li1440\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext45 Code Example 4;}
{\s45\li1800\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext46 Code Example 5;}
{\s46\li2160\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext47 Code Example 6;}
{\s47\li2520\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext48 Code Example 7;}
{\s48\li2880\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 8;}
{\s49\li3240\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \sbasedon0 \snext49 Code Example 9;}
{\s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext51 List Continue 0;}
{\s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext52 List Continue 1;}
{\s52\li720\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext53 List Continue 2;}
{\s53\li1080\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext54 List Continue 3;}
{\s54\li1440\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext55 List Continue 4;}
{\s55\li1800\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext56 List Continue 5;}
{\s56\li2160\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext57 List Continue 6;}
{\s57\li2520\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext58 List Continue 7;}
{\s58\li2880\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 8;}
{\s59\li3240\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \sbasedon0 \snext59 List Continue 9;}
{\s60\li0\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext61 DescContinue 0;}
{\s61\li360\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext62 DescContinue 1;}
{\s62\li720\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext63 DescContinue 2;}
{\s63\li1080\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext64 DescContinue 3;}
{\s64\li1440\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext65 DescContinue 4;}
{\s65\li1800\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext66 DescContinue 5;}
{\s66\li2160\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext67 DescContinue 6;}
{\s67\li2520\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext68 DescContinue 7;}
{\s68\li2880\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 8;}
{\s69\li3240\widctlpar\ql\adjustright \fs20\cgrid \sbasedon0 \snext69 DescContinue 9;}
{\s70\li0\sa30\sb30\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext81 LatexTOC 0;}
{\s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext82 LatexTOC 1;}
{\s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext83 LatexTOC 2;}
{\s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext84 LatexTOC 3;}
{\s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext85 LatexTOC 4;}
{\s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext86 LatexTOC 5;}
{\s76\li2160\sa12\sb12\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext87 LatexTOC 6;}
{\s77\li2520\sa9\sb9\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext88 LatexTOC 7;}
{\s78\li2880\sa6\sb6\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 8;}
{\s79\li3240\sa3\sb3\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid \sbasedon0 \snext89 LatexTOC 9;}
{\s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid \sbasedon0 \snext81 \sautoupd List Bullet 0;}
{\s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid \sbasedon0 \snext82 \sautoupd List Bullet 1;}
{\s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid \sbasedon0 \snext83 \sautoupd List Bullet 2;}
{\s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid \sbasedon0 \snext84 \sautoupd List Bullet 3;}
{\s84\fi-360\li1800\widctlpar\jclisttab\tx1800{\*\pn \pnlvlbody\ilvl0\ls5\pnrnot0\pndec }\ls5\adjustright \fs20\cgrid \sbasedon0 \snext85 \sautoupd List Bullet 4;}
{\s85\fi-360\li2160\widctlpar\jclisttab\tx2160{\*\pn \pnlvlbody\ilvl0\ls6\pnrnot0\pndec }\ls6\adjustright \fs20\cgrid \sbasedon0 \snext86 \sautoupd List Bullet 5;}
{\s86\fi-360\li2520\widctlpar\jclisttab\tx2520{\*\pn \pnlvlbody\ilvl0\ls7\pnrnot0\pndec }\ls7\adjustright \fs20\cgrid \sbasedon0 \snext87 \sautoupd List Bullet 6;}
{\s87\fi-360\li2880\widctlpar\jclisttab\tx2880{\*\pn \pnlvlbody\ilvl0\ls8\pnrnot0\pndec }\ls8\adjustright \fs20\cgrid \sbasedon0 \snext88 \sautoupd List Bullet 7;}
{\s88\fi-360\li3240\widctlpar\jclisttab\tx3240{\*\pn \pnlvlbody\ilvl0\ls9\pnrnot0\pndec }\ls9\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 8;}
{\s89\fi-360\li3600\widctlpar\jclisttab\tx3600{\*\pn \pnlvlbody\ilvl0\ls10\pnrnot0\pndec }\ls10\adjustright \fs20\cgrid \sbasedon0 \snext89 \sautoupd List Bullet 9;}
{\s90\fi-360\li360\widctlpar\fs20\cgrid \sbasedon0 \snext91 \sautoupd List Enum 0;}
{\s91\fi-360\li720\widctlpar\fs20\cgrid \sbasedon0 \snext92 \sautoupd List Enum 1;}
{\s92\fi-360\li1080\widctlpar\fs20\cgrid \sbasedon0 \snext93 \sautoupd List Enum 2;}
{\s93\fi-360\li1440\widctlpar\fs20\cgrid \sbasedon0 \snext94 \sautoupd List Enum 3;}
{\s94\fi-360\li1800\widctlpar\fs20\cgrid \sbasedon0 \snext95 \sautoupd List Enum 4;}
{\s95\fi-360\li2160\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s96\fi-360\li2520\widctlpar\fs20\cgrid \sbasedon0 \snext96 \sautoupd List Enum 5;}
{\s97\fi-360\li2880\widctlpar\fs20\cgrid \sbasedon0 \snext98 \sautoupd List Enum 7;}
{\s98\fi-360\li3240\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 8;}
{\s99\fi-360\li3600\widctlpar\fs20\cgrid \sbasedon0 \snext99 \sautoupd List Enum 9;}
}
{\comment begin body}
{\info 
{\title {\comment Spectrodaq External Event Framework Reference Manual 0.2}Spectrodaq External Event Framework}
{\comment Generated byDoxgyen. }
{\creatim \yr2003\mo2\dy4\hr12\min34\sec49}
}\pard\plain 
\sectd\pgnlcrm
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\vertalc\qc\par\par\par\par\par\par\par\pard\plain \s15\qc\sb240\sa60\widctlpar\outlinelevel0\adjustright \b\f1\fs32\kerning28\cgrid 
{\field\fldedit {\*\fldinst TITLE \\*MERGEFORMAT}{\fldrslt TITLE}}\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
\par
\par\par\par\par\par\par\par\par\par\par\par\par
\pard\plain \s16\qc\sa60\widctlpar\outlinelevel1\adjustright \f1\cgrid 
{\field\fldedit {\*\fldinst AUTHOR \\*MERGEFORMAT}{\fldrslt AUTHOR}}\par
Version 0.2\par{\field\fldedit {\*\fldinst CREATEDATE \\*MERGEFORMAT}{\fldrslt CREATEDATE}}\par
\page\page\vertalt
\pard\plain 
{\field\fldedit {\*\fldinst TOC \\f \\*MERGEFORMAT}{\fldrslt Table of contents}}\par
\pard\plain 

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
spectrodaq client application framework\par \pard\plain 
{\tc \v Main Page}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
{{{\b \par
Author: }}\par
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid Ron Fox , Eric Kasten (Spectrodaq) , Jason Venema\par
}{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v Introduction}
Introduction\par
{\bkmkstart Intro}
{\bkmkend Intro}
}\par
This documentation describes an application framework which simplifies the process of writing clients to spectrodaq, the NSCL data acquisition and distribution system. This set of web pages provides general documenation as well as reference information for this class library.\par
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v Getting Started}
Getting Started\par
{\bkmkstart Starting}
{\bkmkend Starting}
}\par
To write programs under the client application framework you will need to know:{
\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
1.\tab How to {\b subclass the DAQROCNode class.} (p.{\field\fldedit {\*\fldinst PAGEREF Writing \\*MERGEFORMAT}{\fldrslt pagenum}})
\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
2.\tab How to  {\b Write a Makefile} (p.{\field\fldedit {\*\fldinst PAGEREF Makefile \\*MERGEFORMAT}{\fldrslt pagenum}})
  to build your program.\par
}{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid {\tc\tcl3 \v Writing a subclass of DAQROCNode}
Writing a subclass of DAQROCNode\par
{\bkmkstart Writing}
{\bkmkend Writing}
}\par
DAQROCNode (DAQ Readout Controller Node) is the base class from which all spectrodaq clients are derived.  {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid #include <iostream.h>\par
#include <spectrodaq.h>\par
#include <SpectroFramework.h>\par
\par
class MyClass : public DAQROCNode\par
\{\par
protected:\par
  int operator()(int argc, char** pargv);\par
\};\par
\par
int\par
MyClass::operator()(int argc, char** pargv)\par
\{\par
  cout << "Hello World." << endl;\par
\}\par
\par
MyClass theApp;\par
\par
}
 is a minimal sample Spectrodaq client which uses the framework.\par
This example includes the following headers:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
<spectrodaq.h> - header which defines the spectrodaq client interface classes.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
<{\b SpectroFramework.h}> - header which defines the classes in the application framwork.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
<iostream.h> - Which defines classes in the C++ I/O subsystem.\par
}The bulk of the program is the definition of a class: MyClass which extends DAQROCNode, definining and implementing the operator() member function. This member function is called when Spectrodaq has initialized and is ready to run application code. The implementation of that function simply puts the message "Hello World" to stdout.\par
The final line of the example declares an instance of MyClass. This instance is the application object which will actually be run by spectrodaq.\par
This example shows the general pattern which you must follow to write Spectrodaq clients:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Include the necessary headers (<spectrodaq.h> <{\b SpectroFramework.h}> at a minimum.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Write a subclass to DAQROCNode which defines the behavior of your application. The entry point to the program will be the operator() member function which has the same signature as the main function. be sure not to provide an implementation of {\b main}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF FdMonitorTest_8cpp_a1 \\*MERGEFORMAT}{\fldrslt pagenum}}}) as that's provided by the spectrodaq client libraries.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Declare an instance of this class to provide spectrodaq with an application object to run.\par
}{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid {\tc\tcl3 \v Writing a Makefile for framework programs.}
Writing a Makefile for framework programs.\par
{\bkmkstart Makefile}
{\bkmkend Makefile}
}\par
Writing a Makefile to build your application requires:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Obtaining the compilation and link flags needed by spectrodaq.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Listing the dependencies between modules, and build rules needed to get from indenendent to dependent half of these dependencies.\par
}For the example in  {\b the previous section} (p.{\field\fldedit {\*\fldinst PAGEREF Writing \\*MERGEFORMAT}{\fldrslt pagenum}})
, the resulting Makefile might look like {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid SPECTRO_FLAGS=$(shell /opt/spectrodaq/bin/spectrodaq-conf --cflags)\par
SPECTRO_LDFLAGS=$(shell /opt/spectrodaq/bin/spectrodaq-conf --libs)\par
\par
CXXFLAGS=$(SPECTRO_FLAGS) -I/opt/daq/Include -I/usr/X11/include\par
LDFLAGS = $(SPECTRO_LDFLAGS) -L /opt/daq/Lib -L/usr/X11/lib \\\par
         -lEventFramework -ltk -ltcl -lm -lXm -lXt\par
\par
minimal: minimal.o\par
        g++ -o minimal $< $(LDFLAGS)\par
\par
minimal.o: minimal.cpp\par
        g++ -c $< $(CXXFLAGS) -ltcl \par
\par
}
 The first four macro definitions group together the compilation and load flags needed by spectrodaq and the  framework into two macros CXXFLAGS (compile flags), and LDFLAGS (loader  flags).\par
Two dependencies describe how to build the object from the source, and the executable from the object. Note that it may also be wise to  include the -ggdb flag in LDFLAGS so that you can use the gdb debugger.\par
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v General concepts.}
General concepts.\par
{\bkmkstart Concepts}
{\bkmkend Concepts}
}\par
The following is a list of general concepts which are used by the event framework and should be understood.\par
{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Subclassing  a base class to extend or provide functionality.} ({\i p.{\field\fldedit {\*\fldinst PAGEREF Subclassing \\*MERGEFORMAT}{\fldrslt pagenum}}})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Object registries} ({\i p.{\field\fldedit {\*\fldinst PAGEREF Registration \\*MERGEFORMAT}{\fldrslt pagenum}}}) and object naming.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b Event driven programming.} ({\i p.{\field\fldedit {\*\fldinst PAGEREF EventDriven \\*MERGEFORMAT}{\fldrslt pagenum}}})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TCP/IP client/server programming} ({\i p.{\field\fldedit {\*\fldinst PAGEREF TCPIP \\*MERGEFORMAT}{\fldrslt pagenum}}})  with sockets.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The events which are understood by the application framework:{
\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
1.\tab {\b Location monitors:} ({\i p.{\field\fldedit {\*\fldinst PAGEREF LocationMonitors \\*MERGEFORMAT}{\fldrslt pagenum}}}) Low latency monitoring of a volatile memory location.\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
2.\tab {\b File descriptor events:} ({\i p.{\field\fldedit {\*\fldinst PAGEREF FileEvents \\*MERGEFORMAT}{\fldrslt pagenum}}}) Events which occur when a file descriptor is readable or writable or has some other special condition (exception) pending.\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
3.\tab {\b Spectrodaq Buffer Events} ({\i p.{\field\fldedit {\*\fldinst PAGEREF BufferEvent \\*MERGEFORMAT}{\fldrslt pagenum}}}) Events which occur when a spectrodaq makes a buffer available to the application along a link.\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
4.\tab {\b Server accept events:} ({\i p.{\field\fldedit {\*\fldinst PAGEREF ServerEvent \\*MERGEFORMAT}{\fldrslt pagenum}}}) Events which occur when a TCP/IP server receives a connection request from a client.\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
5.\tab {\b Server Instance events:} ({\i p.{\field\fldedit {\*\fldinst PAGEREF SocketEvents \\*MERGEFORMAT}{\fldrslt pagenum}}}) Events which occur when an instance of a TCP/IP server connected to an active client receives a request from the client.\par
}\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Guest event loops including:{
\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
1.\tab {\b Synchronization of guest event loops} ({\i p.{\field\fldedit {\*\fldinst PAGEREF Synchronization \\*MERGEFORMAT}{\fldrslt pagenum}}}) with other framework code.\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
2.\tab {\b Tcl/Tk guest event loops} ({\i p.{\field\fldedit {\*\fldinst PAGEREF TCLGuests \\*MERGEFORMAT}{\fldrslt pagenum}}})\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
3.\tab {\b X11/Xt guest event loops} ({\i p.{\field\fldedit {\*\fldinst PAGEREF XtGuests \\*MERGEFORMAT}{\fldrslt pagenum}}})\par
}\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b The Configuration subsystem.} ({\i p.{\field\fldedit {\*\fldinst PAGEREF configsys \\*MERGEFORMAT}{\fldrslt pagenum}}})\par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Spectrodaq External Event Framework Namespace Index\par \pard\plain 
{\tc \v Namespace Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Spectrodaq External Event Framework Namespace List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all namespaces with brief descriptions:\par
}
{
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b std} } \tab {\field\fldedit {\*\fldinst PAGEREF namespacestd \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Spectrodaq External Event Framework Hierarchical Index\par \pard\plain 
{\tc \v Hierarchical Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Spectrodaq External Event Framework Class Hierarchy\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid This inheritance list is sorted roughly, but not completely, alphabetically:\par
}
{
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
CAlarmLogger\tab {\field\fldedit {\*\fldinst PAGEREF classCAlarmLogger \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Callback_data\tab {\field\fldedit {\*\fldinst PAGEREF structCallback__data \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CApplicationRegistry\tab {\field\fldedit {\*\fldinst PAGEREF classCApplicationRegistry \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CBufferEvent< T >::AddLinkRequest\tab {\field\fldedit {\*\fldinst PAGEREF structCBufferEvent_1_1AddLinkRequest \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CCommit\tab {\field\fldedit {\*\fldinst PAGEREF classCCommit \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CConfigurationManager\tab {\field\fldedit {\*\fldinst PAGEREF classCConfigurationManager \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CDumpBinding\tab {\field\fldedit {\*\fldinst PAGEREF classCDumpBinding \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CEventLoop\tab {\field\fldedit {\*\fldinst PAGEREF classCEventLoop \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
CInterpreterStartup\tab {\field\fldedit {\*\fldinst PAGEREF classCInterpreterStartup \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
CTCLInterpreterStartup\tab {\field\fldedit {\*\fldinst PAGEREF classCTCLInterpreterStartup \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CTKInterpreterStartup\tab {\field\fldedit {\*\fldinst PAGEREF classCTKInterpreterStartup \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}CXtEventLoop\tab {\field\fldedit {\*\fldinst PAGEREF classCXtEventLoop \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}CException\tab {\field\fldedit {\*\fldinst PAGEREF classCException \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
CDuplicateNameException\tab {\field\fldedit {\*\fldinst PAGEREF classCDuplicateNameException \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CDuplicateSingleton\tab {\field\fldedit {\*\fldinst PAGEREF classCDuplicateSingleton \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CErrnoException\tab {\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
CTCPConnectionFailed\tab {\field\fldedit {\*\fldinst PAGEREF classCTCPConnectionFailed \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CTCPConnectionLost\tab {\field\fldedit {\*\fldinst PAGEREF classCTCPConnectionLost \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CTCPNoSuchService\tab {\field\fldedit {\*\fldinst PAGEREF classCTCPNoSuchService \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}CIncompatibleMonitor\tab {\field\fldedit {\*\fldinst PAGEREF classCIncompatibleMonitor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CLinkFailedException\tab {\field\fldedit {\*\fldinst PAGEREF classCLinkFailedException \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CNoSuchLinkException\tab {\field\fldedit {\*\fldinst PAGEREF classCNoSuchLinkException \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CNoSuchObjectException\tab {\field\fldedit {\*\fldinst PAGEREF classCNoSuchObjectException \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CRangeError\tab {\field\fldedit {\*\fldinst PAGEREF classCRangeError \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CStreamIOError\tab {\field\fldedit {\*\fldinst PAGEREF classCStreamIOError \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CTCLException\tab {\field\fldedit {\*\fldinst PAGEREF classCTCLException \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CTCPBadSocketState\tab {\field\fldedit {\*\fldinst PAGEREF classCTCPBadSocketState \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CTCPNoSuchHost\tab {\field\fldedit {\*\fldinst PAGEREF classCTCPNoSuchHost \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}Generic_List< T >\tab {\field\fldedit {\*\fldinst PAGEREF classGeneric__List \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
Generic_List< XMWidget >\tab {\field\fldedit {\*\fldinst PAGEREF classGeneric__List \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
XMWidgetList\tab {\field\fldedit {\*\fldinst PAGEREF classXMWidgetList \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
XMButtonList\tab {\field\fldedit {\*\fldinst PAGEREF classXMButtonList \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}}CInitBinding\tab {\field\fldedit {\*\fldinst PAGEREF classCInitBinding \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
LinkInfo\tab {\field\fldedit {\*\fldinst PAGEREF structLinkInfo \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CLogger\tab {\field\fldedit {\*\fldinst PAGEREF classCLogger \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MatchAll\tab {\field\fldedit {\*\fldinst PAGEREF classMatchAll \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
MatchURL\tab {\field\fldedit {\*\fldinst PAGEREF classMatchURL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CNamedObject\tab {\field\fldedit {\*\fldinst PAGEREF classCNamedObject \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
CClassifiedObjectRegistry\tab {\field\fldedit {\*\fldinst PAGEREF classCClassifiedObjectRegistry \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CObjectRegistry\tab {\field\fldedit {\*\fldinst PAGEREF classCObjectRegistry \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CRegisteredObject\tab {\field\fldedit {\*\fldinst PAGEREF classCRegisteredObject \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
CEvent\tab {\field\fldedit {\*\fldinst PAGEREF classCEvent \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
CBufferEvent< T >\tab {\field\fldedit {\*\fldinst PAGEREF classCBufferEvent \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CFileEvent\tab {\field\fldedit {\*\fldinst PAGEREF classCFileEvent \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
CServerConnectionEvent\tab {\field\fldedit {\*\fldinst PAGEREF classCServerConnectionEvent \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CServerInstance\tab {\field\fldedit {\*\fldinst PAGEREF classCServerInstance \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}CLocationEvent< T >\tab {\field\fldedit {\*\fldinst PAGEREF classCLocationEvent \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CTimerEvent\tab {\field\fldedit {\*\fldinst PAGEREF classCTimerEvent \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}CEventMonitor\tab {\field\fldedit {\*\fldinst PAGEREF classCEventMonitor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
CBufferMonitor< T >\tab {\field\fldedit {\*\fldinst PAGEREF classCBufferMonitor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CFdMonitor\tab {\field\fldedit {\*\fldinst PAGEREF classCFdMonitor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
CServerMonitor\tab {\field\fldedit {\*\fldinst PAGEREF classCServerMonitor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}CLocationMonitor< T >\tab {\field\fldedit {\*\fldinst PAGEREF classCLocationMonitor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CTimerMonitor\tab {\field\fldedit {\*\fldinst PAGEREF classCTimerMonitor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}CPointerPredicate< T >\tab {\field\fldedit {\*\fldinst PAGEREF classCPointerPredicate \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
CChangedPredicate< T >\tab {\field\fldedit {\*\fldinst PAGEREF classCChangedPredicate \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CMaskedValuePredicate< T >\tab {\field\fldedit {\*\fldinst PAGEREF classCMaskedValuePredicate \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}CReactor\tab {\field\fldedit {\*\fldinst PAGEREF classCReactor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
CBufferReactor< T >\tab {\field\fldedit {\*\fldinst PAGEREF classCBufferReactor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CBufferReactor< U >\tab {\field\fldedit {\*\fldinst PAGEREF classCBufferReactor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
CBufferEvent< T >::CGenericBufferReactor< U >\tab {\field\fldedit {\*\fldinst PAGEREF classCBufferEvent_1_1CGenericBufferReactor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}CFdReactor\tab {\field\fldedit {\*\fldinst PAGEREF classCFdReactor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
CFileEventReactor\tab {\field\fldedit {\*\fldinst PAGEREF classCFileEvent_1_1CFileEventReactor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}CLocationReactor< T >\tab {\field\fldedit {\*\fldinst PAGEREF classCLocationReactor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CLocationReactor< U >\tab {\field\fldedit {\*\fldinst PAGEREF classCLocationReactor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s75\li1800\sa15\sb15\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
CLocationEvent< T >::CGenericLocationReactor< U >\tab {\field\fldedit {\*\fldinst PAGEREF classCLocationEvent_1_1CGenericLocationReactor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}CTimerEvent::CTimerGenericReactor\tab {\field\fldedit {\*\fldinst PAGEREF classCTimerEvent_1_1CTimerGenericReactor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}}}CRefcountedPtr< T >\tab {\field\fldedit {\*\fldinst PAGEREF classCRefcountedPtr \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CReferenceCounted< T >\tab {\field\fldedit {\*\fldinst PAGEREF classCReferenceCounted \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CShutdownBinding\tab {\field\fldedit {\*\fldinst PAGEREF classCShutdownBinding \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CSocket\tab {\field\fldedit {\*\fldinst PAGEREF classCSocket \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
StartEventThread\tab {\field\fldedit {\*\fldinst PAGEREF classStartEventThread \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CTCLHashTable< T >\tab {\field\fldedit {\*\fldinst PAGEREF classCTCLHashTable \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CTCLHashTableItem< T >\tab {\field\fldedit {\*\fldinst PAGEREF classCTCLHashTableItem \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CTCLHashTableIterator< T >\tab {\field\fldedit {\*\fldinst PAGEREF classCTCLHashTableIterator \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CTCLInterpreter\tab {\field\fldedit {\*\fldinst PAGEREF classCTCLInterpreter \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CTCLInterpreterObject\tab {\field\fldedit {\*\fldinst PAGEREF classCTCLInterpreterObject \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
CTCLApplication\tab {\field\fldedit {\*\fldinst PAGEREF classCTCLApplication \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CTCLCommandPackage\tab {\field\fldedit {\*\fldinst PAGEREF classCTCLCommandPackage \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CTCLException\tab {\field\fldedit {\*\fldinst PAGEREF classCTCLException \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CTCLFileHandler\tab {\field\fldedit {\*\fldinst PAGEREF classCTCLFileHandler \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CTCLList\tab {\field\fldedit {\*\fldinst PAGEREF classCTCLList \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CTCLObject\tab {\field\fldedit {\*\fldinst PAGEREF classCTCLObject \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CTCLProcessor\tab {\field\fldedit {\*\fldinst PAGEREF classCTCLProcessor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
CDAQTCLProcessor\tab {\field\fldedit {\*\fldinst PAGEREF classCDAQTCLProcessor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
CTCLSynchronizeCommand\tab {\field\fldedit {\*\fldinst PAGEREF classCTCLSynchronizeCommand \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}CTCLPackagedCommand\tab {\field\fldedit {\*\fldinst PAGEREF classCTCLPackagedCommand \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}CTCLResult\tab {\field\fldedit {\*\fldinst PAGEREF classCTCLResult \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CTCLTimer\tab {\field\fldedit {\*\fldinst PAGEREF classCTCLTimer \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
CTCLIdleProcess\tab {\field\fldedit {\*\fldinst PAGEREF classCTCLIdleProcess \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}CTCLVariable\tab {\field\fldedit {\*\fldinst PAGEREF classCTCLVariable \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}CTCLString\tab {\field\fldedit {\*\fldinst PAGEREF classCTCLString \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CThreadRecursiveMutex\tab {\field\fldedit {\*\fldinst PAGEREF classCThreadRecursiveMutex \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
CApplicationSerializer\tab {\field\fldedit {\*\fldinst PAGEREF classCApplicationSerializer \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}Time_t\tab {\field\fldedit {\*\fldinst PAGEREF structTime__t \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CTypeFreeBinding\tab {\field\fldedit {\*\fldinst PAGEREF classCTypeFreeBinding \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
CBinding< T >\tab {\field\fldedit {\*\fldinst PAGEREF classCBinding \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
CArrayBinding< T >\tab {\field\fldedit {\*\fldinst PAGEREF classCArrayBinding \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CAssocArrayBinding< T >\tab {\field\fldedit {\*\fldinst PAGEREF classCAssocArrayBinding \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
CVariableBinding< T >\tab {\field\fldedit {\*\fldinst PAGEREF classCVariableBinding \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}}XMApplication\tab {\field\fldedit {\*\fldinst PAGEREF classXMApplication \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
XMCallback< T >\tab {\field\fldedit {\*\fldinst PAGEREF classXMCallback \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
XMMenuItem\tab {\field\fldedit {\*\fldinst PAGEREF structXMMenuItem \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
XMWidget\tab {\field\fldedit {\*\fldinst PAGEREF classXMWidget \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s72\li720\sa24\sb24\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Shell\tab {\field\fldedit {\*\fldinst PAGEREF classShell \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
TopLevelShell\tab {\field\fldedit {\*\fldinst PAGEREF classTopLevelShell \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}XMListBaseClass\tab {\field\fldedit {\*\fldinst PAGEREF classXMListBaseClass \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
XMList\tab {\field\fldedit {\*\fldinst PAGEREF classXMList \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
XMScrolledList\tab {\field\fldedit {\*\fldinst PAGEREF classXMScrolledList \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}XMManagedWidget\tab {\field\fldedit {\*\fldinst PAGEREF classXMManagedWidget \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
XMButton\tab {\field\fldedit {\*\fldinst PAGEREF classXMButton \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
XMArrowButton\tab {\field\fldedit {\*\fldinst PAGEREF classXMArrowButton \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
XMCascadeButton\tab {\field\fldedit {\*\fldinst PAGEREF classXMCascadeButton \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
XMPushButton\tab {\field\fldedit {\*\fldinst PAGEREF classXMPushButton \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
XMToggleButton\tab {\field\fldedit {\*\fldinst PAGEREF classXMToggleButton \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}XMLabel\tab {\field\fldedit {\*\fldinst PAGEREF classXMLabel \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
XMMenuBar\tab {\field\fldedit {\*\fldinst PAGEREF classXMMenuBar \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
XMPulldown\tab {\field\fldedit {\*\fldinst PAGEREF classXMPulldown \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
XMScale\tab {\field\fldedit {\*\fldinst PAGEREF classXMScale \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
XMText\tab {\field\fldedit {\*\fldinst PAGEREF classXMText \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
XMScrolledText\tab {\field\fldedit {\*\fldinst PAGEREF classXMScrolledText \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}XMTextField\tab {\field\fldedit {\*\fldinst PAGEREF classXMTextField \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}XMManager\tab {\field\fldedit {\*\fldinst PAGEREF classXMManager \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
XMBulletinBoard\tab {\field\fldedit {\*\fldinst PAGEREF classXMBulletinBoard \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s74\li1440\sa18\sb18\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
XMForm\tab {\field\fldedit {\*\fldinst PAGEREF classXMForm \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}XMFrame\tab {\field\fldedit {\*\fldinst PAGEREF classXMFrame \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
XMMainWindow\tab {\field\fldedit {\*\fldinst PAGEREF classXMMainWindow \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
XMPanedWindow\tab {\field\fldedit {\*\fldinst PAGEREF classXMPanedWindow \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
XMRowColumn\tab {\field\fldedit {\*\fldinst PAGEREF classXMRowColumn \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}XMSeparator\tab {\field\fldedit {\*\fldinst PAGEREF classXMSeparator \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{
\pard\plain \s73\li1080\sa21\sb21\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
XMHorizontalSeparator\tab {\field\fldedit {\*\fldinst PAGEREF classXMHorizontalSeparator \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
XMVerticalSeparator\tab {\field\fldedit {\*\fldinst PAGEREF classXMVerticalSeparator \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
}}}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Spectrodaq External Event Framework Compound Index\par \pard\plain 
{\tc \v Compound Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Spectrodaq External Event Framework Compound List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here are the classes, structs, unions and interfaces with brief descriptions:\par
}
{
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b CAlarmLogger} } \tab {\field\fldedit {\*\fldinst PAGEREF classCAlarmLogger \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Callback_data} } \tab {\field\fldedit {\*\fldinst PAGEREF structCallback__data \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CApplicationRegistry} } \tab {\field\fldedit {\*\fldinst PAGEREF classCApplicationRegistry \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CApplicationSerializer} } \tab {\field\fldedit {\*\fldinst PAGEREF classCApplicationSerializer \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CArrayBinding< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF classCArrayBinding \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CAssocArrayBinding< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF classCAssocArrayBinding \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CBinding< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF classCBinding \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CBufferEvent< T >} (\\class: CBufferEvent \\file: {\b CBufferEvent.h})} \tab {\field\fldedit {\*\fldinst PAGEREF classCBufferEvent \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CBufferEvent< T >::AddLinkRequest} (Form of request to add a link to the link manager)} \tab {\field\fldedit {\*\fldinst PAGEREF structCBufferEvent_1_1AddLinkRequest \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CBufferEvent< T >::CGenericBufferReactor< U >} } \tab {\field\fldedit {\*\fldinst PAGEREF classCBufferEvent_1_1CGenericBufferReactor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CBufferMonitor< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF classCBufferMonitor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CBufferReactor< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF classCBufferReactor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CChangedPredicate< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF classCChangedPredicate \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CClassifiedObjectRegistry} } \tab {\field\fldedit {\*\fldinst PAGEREF classCClassifiedObjectRegistry \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CCommit} } \tab {\field\fldedit {\*\fldinst PAGEREF classCCommit \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CConfigurationManager} } \tab {\field\fldedit {\*\fldinst PAGEREF classCConfigurationManager \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CDAQTCLProcessor} } \tab {\field\fldedit {\*\fldinst PAGEREF classCDAQTCLProcessor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CDumpBinding} } \tab {\field\fldedit {\*\fldinst PAGEREF classCDumpBinding \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CDuplicateNameException} } \tab {\field\fldedit {\*\fldinst PAGEREF classCDuplicateNameException \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CDuplicateSingleton} } \tab {\field\fldedit {\*\fldinst PAGEREF classCDuplicateSingleton \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CErrnoException} } \tab {\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CEvent} } \tab {\field\fldedit {\*\fldinst PAGEREF classCEvent \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CEventLoop} } \tab {\field\fldedit {\*\fldinst PAGEREF classCEventLoop \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CEventMonitor} } \tab {\field\fldedit {\*\fldinst PAGEREF classCEventMonitor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CException} } \tab {\field\fldedit {\*\fldinst PAGEREF classCException \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CFdMonitor} } \tab {\field\fldedit {\*\fldinst PAGEREF classCFdMonitor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CFdReactor} } \tab {\field\fldedit {\*\fldinst PAGEREF classCFdReactor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CFileEvent} } \tab {\field\fldedit {\*\fldinst PAGEREF classCFileEvent \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CFileEventReactor} } \tab {\field\fldedit {\*\fldinst PAGEREF classCFileEvent_1_1CFileEventReactor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Generic_List< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF classGeneric__List \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CIncompatibleMonitor} } \tab {\field\fldedit {\*\fldinst PAGEREF classCIncompatibleMonitor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CInitBinding} } \tab {\field\fldedit {\*\fldinst PAGEREF classCInitBinding \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CInterpreterStartup} } \tab {\field\fldedit {\*\fldinst PAGEREF classCInterpreterStartup \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CLinkFailedException} } \tab {\field\fldedit {\*\fldinst PAGEREF classCLinkFailedException \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b LinkInfo} } \tab {\field\fldedit {\*\fldinst PAGEREF structLinkInfo \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CLocationEvent< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF classCLocationEvent \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CLocationEvent< T >::CGenericLocationReactor< U >} } \tab {\field\fldedit {\*\fldinst PAGEREF classCLocationEvent_1_1CGenericLocationReactor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CLocationMonitor< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF classCLocationMonitor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CLocationReactor< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF classCLocationReactor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CLogger} } \tab {\field\fldedit {\*\fldinst PAGEREF classCLogger \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CMaskedValuePredicate< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF classCMaskedValuePredicate \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MatchAll} } \tab {\field\fldedit {\*\fldinst PAGEREF classMatchAll \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b MatchURL} } \tab {\field\fldedit {\*\fldinst PAGEREF classMatchURL \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CNamedObject} } \tab {\field\fldedit {\*\fldinst PAGEREF classCNamedObject \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CNoSuchLinkException} } \tab {\field\fldedit {\*\fldinst PAGEREF classCNoSuchLinkException \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CNoSuchObjectException} } \tab {\field\fldedit {\*\fldinst PAGEREF classCNoSuchObjectException \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CObjectRegistry} } \tab {\field\fldedit {\*\fldinst PAGEREF classCObjectRegistry \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CPointerPredicate< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF classCPointerPredicate \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CRangeError} } \tab {\field\fldedit {\*\fldinst PAGEREF classCRangeError \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CReactor} } \tab {\field\fldedit {\*\fldinst PAGEREF classCReactor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CRefcountedPtr< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF classCRefcountedPtr \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CReferenceCounted< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF classCReferenceCounted \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CRegisteredObject} } \tab {\field\fldedit {\*\fldinst PAGEREF classCRegisteredObject \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CServerConnectionEvent} (\\class: CServerConnectionEvent \\file: {\b CServerConnectionEvent.h})} \tab {\field\fldedit {\*\fldinst PAGEREF classCServerConnectionEvent \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CServerInstance} } \tab {\field\fldedit {\*\fldinst PAGEREF classCServerInstance \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CServerMonitor} (\\class: CServerMonitor \\file: {\b CServerMonitor.h})} \tab {\field\fldedit {\*\fldinst PAGEREF classCServerMonitor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Shell} } \tab {\field\fldedit {\*\fldinst PAGEREF classShell \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CShutdownBinding} } \tab {\field\fldedit {\*\fldinst PAGEREF classCShutdownBinding \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CSocket} } \tab {\field\fldedit {\*\fldinst PAGEREF classCSocket \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b StartEventThread} } \tab {\field\fldedit {\*\fldinst PAGEREF classStartEventThread \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CStreamIOError} } \tab {\field\fldedit {\*\fldinst PAGEREF classCStreamIOError \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCLApplication} } \tab {\field\fldedit {\*\fldinst PAGEREF classCTCLApplication \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCLCommandPackage} } \tab {\field\fldedit {\*\fldinst PAGEREF classCTCLCommandPackage \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCLException} } \tab {\field\fldedit {\*\fldinst PAGEREF classCTCLException \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCLFileHandler} } \tab {\field\fldedit {\*\fldinst PAGEREF classCTCLFileHandler \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCLHashTable< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF classCTCLHashTable \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCLHashTableItem< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF classCTCLHashTableItem \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCLHashTableIterator< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF classCTCLHashTableIterator \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCLIdleProcess} } \tab {\field\fldedit {\*\fldinst PAGEREF classCTCLIdleProcess \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCLInterpreter} } \tab {\field\fldedit {\*\fldinst PAGEREF classCTCLInterpreter \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCLInterpreterObject} } \tab {\field\fldedit {\*\fldinst PAGEREF classCTCLInterpreterObject \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCLInterpreterStartup} } \tab {\field\fldedit {\*\fldinst PAGEREF classCTCLInterpreterStartup \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCLList} } \tab {\field\fldedit {\*\fldinst PAGEREF classCTCLList \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCLObject} } \tab {\field\fldedit {\*\fldinst PAGEREF classCTCLObject \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCLPackagedCommand} } \tab {\field\fldedit {\*\fldinst PAGEREF classCTCLPackagedCommand \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCLProcessor} } \tab {\field\fldedit {\*\fldinst PAGEREF classCTCLProcessor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCLResult} } \tab {\field\fldedit {\*\fldinst PAGEREF classCTCLResult \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCLString} } \tab {\field\fldedit {\*\fldinst PAGEREF classCTCLString \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCLSynchronizeCommand} } \tab {\field\fldedit {\*\fldinst PAGEREF classCTCLSynchronizeCommand \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCLTimer} } \tab {\field\fldedit {\*\fldinst PAGEREF classCTCLTimer \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCLVariable} } \tab {\field\fldedit {\*\fldinst PAGEREF classCTCLVariable \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCPBadSocketState} } \tab {\field\fldedit {\*\fldinst PAGEREF classCTCPBadSocketState \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCPConnectionFailed} } \tab {\field\fldedit {\*\fldinst PAGEREF classCTCPConnectionFailed \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCPConnectionLost} } \tab {\field\fldedit {\*\fldinst PAGEREF classCTCPConnectionLost \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCPNoSuchHost} } \tab {\field\fldedit {\*\fldinst PAGEREF classCTCPNoSuchHost \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCPNoSuchService} } \tab {\field\fldedit {\*\fldinst PAGEREF classCTCPNoSuchService \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CThreadRecursiveMutex} (CThreadRecursiveMutex {\b CThreadRecursiveMutex.h})} \tab {\field\fldedit {\*\fldinst PAGEREF classCThreadRecursiveMutex \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Time_t} } \tab {\field\fldedit {\*\fldinst PAGEREF structTime__t \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTimerEvent} } \tab {\field\fldedit {\*\fldinst PAGEREF classCTimerEvent \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTimerEvent::CTimerGenericReactor} } \tab {\field\fldedit {\*\fldinst PAGEREF classCTimerEvent_1_1CTimerGenericReactor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTimerMonitor} } \tab {\field\fldedit {\*\fldinst PAGEREF classCTimerMonitor \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTKInterpreterStartup} } \tab {\field\fldedit {\*\fldinst PAGEREF classCTKInterpreterStartup \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TopLevelShell} } \tab {\field\fldedit {\*\fldinst PAGEREF classTopLevelShell \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTypeFreeBinding} } \tab {\field\fldedit {\*\fldinst PAGEREF classCTypeFreeBinding \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CVariableBinding< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF classCVariableBinding \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMApplication} } \tab {\field\fldedit {\*\fldinst PAGEREF classXMApplication \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMArrowButton} } \tab {\field\fldedit {\*\fldinst PAGEREF classXMArrowButton \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMBulletinBoard} } \tab {\field\fldedit {\*\fldinst PAGEREF classXMBulletinBoard \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMButton} } \tab {\field\fldedit {\*\fldinst PAGEREF classXMButton \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMButtonList} } \tab {\field\fldedit {\*\fldinst PAGEREF classXMButtonList \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMCallback< T >} } \tab {\field\fldedit {\*\fldinst PAGEREF classXMCallback \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMCascadeButton} } \tab {\field\fldedit {\*\fldinst PAGEREF classXMCascadeButton \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMForm} } \tab {\field\fldedit {\*\fldinst PAGEREF classXMForm \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMFrame} } \tab {\field\fldedit {\*\fldinst PAGEREF classXMFrame \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMHorizontalSeparator} } \tab {\field\fldedit {\*\fldinst PAGEREF classXMHorizontalSeparator \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMLabel} } \tab {\field\fldedit {\*\fldinst PAGEREF classXMLabel \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMList} } \tab {\field\fldedit {\*\fldinst PAGEREF classXMList \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMListBaseClass} } \tab {\field\fldedit {\*\fldinst PAGEREF classXMListBaseClass \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMMainWindow} } \tab {\field\fldedit {\*\fldinst PAGEREF classXMMainWindow \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMManagedWidget} } \tab {\field\fldedit {\*\fldinst PAGEREF classXMManagedWidget \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMManager} } \tab {\field\fldedit {\*\fldinst PAGEREF classXMManager \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMMenuBar} } \tab {\field\fldedit {\*\fldinst PAGEREF classXMMenuBar \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMMenuItem} } \tab {\field\fldedit {\*\fldinst PAGEREF structXMMenuItem \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMPanedWindow} } \tab {\field\fldedit {\*\fldinst PAGEREF classXMPanedWindow \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMPulldown} } \tab {\field\fldedit {\*\fldinst PAGEREF classXMPulldown \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMPushButton} } \tab {\field\fldedit {\*\fldinst PAGEREF classXMPushButton \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMRowColumn} } \tab {\field\fldedit {\*\fldinst PAGEREF classXMRowColumn \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMScale} } \tab {\field\fldedit {\*\fldinst PAGEREF classXMScale \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMScrolledList} } \tab {\field\fldedit {\*\fldinst PAGEREF classXMScrolledList \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMScrolledText} } \tab {\field\fldedit {\*\fldinst PAGEREF classXMScrolledText \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMSeparator} } \tab {\field\fldedit {\*\fldinst PAGEREF classXMSeparator \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMText} } \tab {\field\fldedit {\*\fldinst PAGEREF classXMText \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMTextField} } \tab {\field\fldedit {\*\fldinst PAGEREF classXMTextField \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMToggleButton} } \tab {\field\fldedit {\*\fldinst PAGEREF classXMToggleButton \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMVerticalSeparator} } \tab {\field\fldedit {\*\fldinst PAGEREF classXMVerticalSeparator \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMWidget} } \tab {\field\fldedit {\*\fldinst PAGEREF classXMWidget \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMWidgetList} } \tab {\field\fldedit {\*\fldinst PAGEREF classXMWidgetList \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CXtEventLoop} } \tab {\field\fldedit {\*\fldinst PAGEREF classCXtEventLoop \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Spectrodaq External Event Framework File Index\par \pard\plain 
{\tc \v File Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Spectrodaq External Event Framework File List\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all files with brief descriptions:\par
}
{
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
{\b {\b BufferEvent.oxy} } \tab {\field\fldedit {\*\fldinst PAGEREF BufferEvent_8oxy \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CAlarmLogger.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CAlarmLogger_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CAlarmLogger.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CAlarmLogger_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CApplicationRegistry.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CApplicationRegistry_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CApplicationRegistry.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CApplicationRegistry_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CApplicationSerializer.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CApplicationSerializer_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CApplicationSerializer.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CApplicationSerializer_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CArrayBinding.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CArrayBinding_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CArrayBinding.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CArrayBinding_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CAssocArrayBinding.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CAssocArrayBinding_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CAssocArrayBinding.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CAssocArrayBinding_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CBinding.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CBinding_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CBufferEvent.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CBufferEvent_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CBufferEvent.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CBufferEvent_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CBufferMonitor.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CBufferMonitor_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CBufferMonitor.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CBufferMonitor_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CBufferReactor.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CBufferReactor_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CBufferReactor.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CBufferReactor_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CChangedPredicate.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CChangedPredicate_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CChangedPredicate.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CChangedPredicate_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CClassifiedObjectRegistry.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CClassifiedObjectRegistry_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CClassifiedObjectRegistry.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CClassifiedObjectRegistry_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CConfigurationManager.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CConfigurationManager_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CConfigurationManager.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CConfigurationManager_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CDAQTCLProcessor.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CDAQTCLProcessor_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CDAQTCLProcessor.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CDAQTCLProcessor_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CDuplicateNameException.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CDuplicateNameException_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CDuplicateNameException.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CDuplicateNameException_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CDuplicateSingleton.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CDuplicateSingleton_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CDuplicateSingleton.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CDuplicateSingleton_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CErrnoException.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CErrnoException_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CErrnoException.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CErrnoException_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CEvent.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CEvent_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CEvent.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CEvent_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CEventLoop.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CEventLoop_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CEventLoop.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CEventLoop_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CEventMonitor.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CEventMonitor_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CEventMonitor.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CEventMonitor_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CException.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CException_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CException.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CException_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CFdMonitor.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CFdMonitor_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CFdMonitor.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CFdMonitor_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CFdReactor.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CFdReactor_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CFdReactor.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CFdReactor_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CFileEvent.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CFileEvent_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CFileEvent.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CFileEvent_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CIncompatibleMonitor.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CIncompatibleMonitor_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CIncompatibleMonitor.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CIncompatibleMonitor_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CInterpreterStartup.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CInterpreterStartup_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CInterpreterStartup.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CInterpreterStartup_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CLinkFailedException.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CLinkFailedException_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CLinkFailedException.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CLinkFailedException_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CLocationEvent.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CLocationEvent_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CLocationEvent.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CLocationEvent_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CLocationMonitor.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CLocationMonitor_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ClocationMonitor.h} } \tab {\field\fldedit {\*\fldinst PAGEREF ClocationMonitor_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CLocationMonitor.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CLocationMonitor_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CLocationReactor.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CLocationReactor_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CLocationReactor.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CLocationReactor_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CLogger.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CLogger_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CLogger.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CLogger_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CMaskedValuePredicate.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CMaskedValuePredicate_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CMaskedValuePredicate.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CMaskedValuePredicate_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CNamedObject.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CNamedObject_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CNamedObject.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CNamedObject_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CNoSuchLinkException.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CNoSuchLinkException_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CNoSuchLinkException.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CNoSuchLinkException_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CNoSuchObjectException.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CNoSuchObjectException_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CNoSuchObjectException.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CNoSuchObjectException_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CObjectRegistry.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CObjectRegistry_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CObjectRegistry.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CObjectRegistry_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b configsys.oxy} } \tab {\field\fldedit {\*\fldinst PAGEREF configsys_8oxy \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CPointerPredicate.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CPointerPredicate_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CPointerPredicate.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CPointerPredicate_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CRangeError.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CRangeError_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CRangeError.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CRangeError_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CReactor.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CReactor_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CReactor.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CReactor_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CRefptr.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CRefptr_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CRegisteredObject.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CRegisteredObject_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CRegisteredObject.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CRegisteredObject_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CServerConnectionEvent.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CServerConnectionEvent_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CServerConnectionEvent.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CServerConnectionEvent_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CServerInstance.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CServerInstance_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CServerInstance.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CServerInstance_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CServerMonitor.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CServerMonitor_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CServerMonitor.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CServerMonitor_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CSocket.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CSocket_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CSocket.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CSocket_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CStreamIOError.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CStreamIOError_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CStreamIOError.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CStreamIOError_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCLInterpreterStartup.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CTCLInterpreterStartup_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCLInterpreterStartup.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CTCLInterpreterStartup_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCLSynchronizeCommand.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CTCLSynchronizeCommand_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCLSynchronizeCommand.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CTCLSynchronizeCommand_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCPBadSocketState.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CTCPBadSocketState_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCPBadSocketState.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CTCPBadSocketState_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCPConnectionFailed.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CTCPConnectionFailed_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCPConnectionFailed.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CTCPConnectionFailed_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCPConnectionLost.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CTCPConnectionLost_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCPConnectionLost.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CTCPConnectionLost_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCPNoSuchHost.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CTCPNoSuchHost_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCPNoSuchHost.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CTCPNoSuchHost_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCPNoSuchService.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CTCPNoSuchService_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTCPNoSuchService.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CTCPNoSuchService_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CThreadRecursiveMutex.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CThreadRecursiveMutex_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CThreadRecursiveMutex.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CThreadRecursiveMutex_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTimerEvent.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CTimerEvent_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTimerEvent.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CTimerEvent_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTimerMonitor.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CTimerMonitor_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTimerMonitor.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CTimerMonitor_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTKInterpreterStartup.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CTKInterpreterStartup_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTKInterpreterStartup.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CTKInterpreterStartup_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CTypeFreeBinding.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CTypeFreeBinding_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CVariableBinding.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CVariableBinding_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CVariableBinding.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CVariableBinding_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CXtEventLoop.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF CXtEventLoop_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b CXtEventLoop.h} } \tab {\field\fldedit {\*\fldinst PAGEREF CXtEventLoop_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b EventDriven.oxy} } \tab {\field\fldedit {\*\fldinst PAGEREF EventDriven_8oxy \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b FdMonitorTest.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF FdMonitorTest_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b FileEvents.oxy} } \tab {\field\fldedit {\*\fldinst PAGEREF FileEvents_8oxy \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b histotypes.h} } \tab {\field\fldedit {\*\fldinst PAGEREF histotypes_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b locationmonitor.oxy} } \tab {\field\fldedit {\*\fldinst PAGEREF locationmonitor_8oxy \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b maindocs.oxy} } \tab {\field\fldedit {\*\fldinst PAGEREF maindocs_8oxy \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Registration.oxy} } \tab {\field\fldedit {\*\fldinst PAGEREF Registration_8oxy \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b ServerEvent.oxy} } \tab {\field\fldedit {\*\fldinst PAGEREF ServerEvent_8oxy \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SocketEvents.oxy} } \tab {\field\fldedit {\*\fldinst PAGEREF SocketEvents_8oxy \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b SpectroFramework.h} } \tab {\field\fldedit {\*\fldinst PAGEREF SpectroFramework_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Subclassing.oxy} } \tab {\field\fldedit {\*\fldinst PAGEREF Subclassing_8oxy \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b Synchronization.oxy} } \tab {\field\fldedit {\*\fldinst PAGEREF Synchronization_8oxy \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLApplication.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLApplication_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLApplication.h} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLApplication_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLCommandPackage.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLCommandPackage_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLCommandPackage.h} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLCommandPackage_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLException.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLException_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLException.h} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLException_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLFileHandler.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLFileHandler_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLFileHandler.h} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLFileHandler_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLGuests.oxy} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLGuests_8oxy \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLHashTable.h} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLHashTable_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLHashTableItem.h} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLHashTableItem_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLHashTableIterator.h} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLHashTableIterator_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLIdleProcess.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLIdleProcess_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLIdleProcess.h} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLIdleProcess_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLInterpreter.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLInterpreter_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLInterpreter.h} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLInterpreter_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLInterpreterObject.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLInterpreterObject_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLInterpreterObject.h} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLInterpreterObject_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLList.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLList_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLList.h} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLList_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLObject.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLObject_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLObject.h} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLObject_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLPackagedCommand.h} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLPackagedCommand_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLProcessor.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLProcessor_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLProcessor.h} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLProcessor_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLResult.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLResult_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLResult.h} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLResult_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLString.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLString_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLString.h} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLString_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLTimer.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLTimer_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLTimer.h} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLTimer_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLVariable.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLVariable_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TCLVariable.h} } \tab {\field\fldedit {\*\fldinst PAGEREF TCLVariable_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b tcpip.oxy} } \tab {\field\fldedit {\*\fldinst PAGEREF tcpip_8oxy \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b TimerEventTest.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF TimerEventTest_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMCallback.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF XMCallback_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMcallback.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF XMcallback_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMCallback.h} } \tab {\field\fldedit {\*\fldinst PAGEREF XMCallback_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMDialogs.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF XMDialogs_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMDialogs.h} } \tab {\field\fldedit {\*\fldinst PAGEREF XMDialogs_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMHelp.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF XMHelp_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMLabel.h} } \tab {\field\fldedit {\*\fldinst PAGEREF XMLabel_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMList.h} } \tab {\field\fldedit {\*\fldinst PAGEREF XMList_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMManagers.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF XMManagers_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMManagers.h} } \tab {\field\fldedit {\*\fldinst PAGEREF XMManagers_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMMenubar.h} } \tab {\field\fldedit {\*\fldinst PAGEREF XMMenubar_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMMenus.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF XMMenus_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMMenus.h} } \tab {\field\fldedit {\*\fldinst PAGEREF XMMenus_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMPushbutton.h} } \tab {\field\fldedit {\*\fldinst PAGEREF XMPushbutton_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMScale.h} } \tab {\field\fldedit {\*\fldinst PAGEREF XMScale_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMSeparators.h} } \tab {\field\fldedit {\*\fldinst PAGEREF XMSeparators_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMShell.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF XMShell_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMShell.h} } \tab {\field\fldedit {\*\fldinst PAGEREF XMShell_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMText.h} } \tab {\field\fldedit {\*\fldinst PAGEREF XMText_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMWidget.h} } \tab {\field\fldedit {\*\fldinst PAGEREF XMWidget_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMWlist.cpp} } \tab {\field\fldedit {\*\fldinst PAGEREF XMWlist_8cpp \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XMWlist.h} } \tab {\field\fldedit {\*\fldinst PAGEREF XMWlist_8h \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
{\b {\b XtGuests.oxy} } \tab {\field\fldedit {\*\fldinst PAGEREF XtGuests_8oxy \\*MERGEFORMAT}{\fldrslt pagenum}}
\par
\par
}
\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Spectrodaq External Event Framework Page Index\par \pard\plain 
{\tc \v Page Index}
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Spectrodaq External Event Framework Related Pages\par \pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Here is a list of all related documentation pages:\par
}
{
\pard\plain \s71\li360\sa27\sb27\widctlpar\tqr\tldot\tx8640\adjustright \fs20\cgrid 
Buffer arrival events\tab {\field\fldedit {\*\fldinst PAGEREF BufferEvent \\*MERGEFORMAT}{\fldrslt pagenum}}
\par

Configuration subsystem\tab {\field\fldedit {\*\fldinst PAGEREF configsys \\*MERGEFORMAT}{\fldrslt pagenum}}
\par

Event Driven Programming model\tab {\field\fldedit {\*\fldinst PAGEREF EventDriven \\*MERGEFORMAT}{\fldrslt pagenum}}
\par

Reacting to file events.\tab {\field\fldedit {\*\fldinst PAGEREF FileEvents \\*MERGEFORMAT}{\fldrslt pagenum}}
\par

Location monitors.\tab {\field\fldedit {\*\fldinst PAGEREF LocationMonitors \\*MERGEFORMAT}{\fldrslt pagenum}}
\par

TCL/Tk Guest event loops.\tab {\field\fldedit {\*\fldinst PAGEREF TCLGuests \\*MERGEFORMAT}{\fldrslt pagenum}}
\par

Object Registries names and descriptions.\tab {\field\fldedit {\*\fldinst PAGEREF Registration \\*MERGEFORMAT}{\fldrslt pagenum}}
\par

Server accept events.\tab {\field\fldedit {\*\fldinst PAGEREF ServerEvent \\*MERGEFORMAT}{\fldrslt pagenum}}
\par

Server Instance events.\tab {\field\fldedit {\*\fldinst PAGEREF SocketEvents \\*MERGEFORMAT}{\fldrslt pagenum}}
\par

Sub-classing in object frameworks\tab {\field\fldedit {\*\fldinst PAGEREF Subclassing \\*MERGEFORMAT}{\fldrslt pagenum}}
\par

Guest event loop synchronization\tab {\field\fldedit {\*\fldinst PAGEREF Synchronization \\*MERGEFORMAT}{\fldrslt pagenum}}
\par

TCP/IP client server programming\tab {\field\fldedit {\*\fldinst PAGEREF TCPIP \\*MERGEFORMAT}{\fldrslt pagenum}}
\par

Xt/X11 event loops.\tab {\field\fldedit {\*\fldinst PAGEREF XtGuests \\*MERGEFORMAT}{\fldrslt pagenum}}
\par

Bug List\tab {\field\fldedit {\*\fldinst PAGEREF bug \\*MERGEFORMAT}{\fldrslt pagenum}}
\par

}\sect \sbkpage \pgnrestart
\sect \sectd \sbknone \pgndec
{\footer \s29\widctlpar\tqc\tx4320\tqr\tx8640\qr\adjustright \fs20\cgrid {\chpgn}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Spectrodaq External Event Framework Namespace Documentation\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
std Namespace Reference\par \pard\plain 
{\tc\tcl2 \v std}
{\xe \v std}
{\bkmkstart namespacestd}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
\par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Spectrodaq External Event Framework Class Documentation{\tc \v Class Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CAlarmLogger  Class Reference\par \pard\plain 
{\tc\tcl2 \v CAlarmLogger}
{\xe \v CAlarmLogger}
{\bkmkstart classCAlarmLogger}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CAlarmLogger.h>}\par
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CAlarmLogger} (string facility, string expid, string host="localhost", string port="daqalarm")\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i The experiment id to log this alarm to.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CAlarmLogger} (const CAlarmLogger &aCAlarmLogger)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CAlarmLogger} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b getFacility} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b getHost} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b getPort} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b getId} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Log} (string message)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setFacility} (string fac)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setHost} (const string &host)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPort} (const string &port)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setIf} (const string &id)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_sFacility}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_sHost}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i The facility name that's doing the logging.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_sPort}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i The host to log to (server host).}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_sExpId}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i The port to log to (server port).}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
CAlarmLogger encapsulates an alarm logger object. CAlarmLoggers are created with the name of the facility doing the logging, a host and port number of the place to do the logging to. Typically, this is the host and port of the machine that the alarm displayer is running on. \par
\par
Definition at line 323 of file CAlarmLogger.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CAlarmLogger\:CAlarmLogger}
{\xe \v CAlarmLogger\:CAlarmLogger}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CAlarmLogger::CAlarmLogger (string {\i facility}, string {\i expid}, string {\i host} = "localhost", string {\i port} = "daqalarm")}
}\par
{\bkmkstart classCAlarmLogger_a0}
{\bkmkend classCAlarmLogger_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
The experiment id to log this alarm to.\par
"Default Constructor" This is the default constructor which constructs a CAlarmLogger given a list of hosts to which it will form socket connections when logging events, and a facility name which will be the name of the facility doing the logging.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i facility}}  - the name of the facility doing the logging \par
}\par
Definition at line 308 of file CAlarmLogger.cpp.\par
\par
References Int_t, and m_sPort.}
{\xe \v CAlarmLogger\:CAlarmLogger}
{\xe \v CAlarmLogger\:CAlarmLogger}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CAlarmLogger::CAlarmLogger (const CAlarmLogger & {\i aCAlarmLogger})}
}\par
{\bkmkstart classCAlarmLogger_a1}
{\bkmkend classCAlarmLogger_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
"Copy Constructor" This is the copy constructor. It creates a new object by copying the information of the reference object which is its parameter.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i aCAlarmLogger}}  - the reference object whose attributes will be copied. \par
}\par
Definition at line 336 of file CAlarmLogger.cpp.\par
}
{\xe \v ~CAlarmLogger\:CAlarmLogger}
{\xe \v CAlarmLogger\:~CAlarmLogger}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CAlarmLogger::~CAlarmLogger ()}
}\par
{\bkmkstart classCAlarmLogger_a2}
{\bkmkend classCAlarmLogger_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
"Destructor" Called when an object goes out of scope, or when execution of the program is terminated. Destroys the object, and frees up space. \par
\par
Definition at line 347 of file CAlarmLogger.cpp.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getFacility\:CAlarmLogger}
{\xe \v CAlarmLogger\:getFacility}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CAlarmLogger::getFacility (){\f2  [inline]}}
}\par
{\bkmkstart classCAlarmLogger_a3}
{\bkmkend classCAlarmLogger_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 345 of file CAlarmLogger.h.\par
\par
References m_sFacility.}
{\xe \v getHost\:CAlarmLogger}
{\xe \v CAlarmLogger\:getHost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CAlarmLogger::getHost (){\f2  [inline]}}
}\par
{\bkmkstart classCAlarmLogger_a4}
{\bkmkend classCAlarmLogger_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 346 of file CAlarmLogger.h.\par
\par
References m_sHost.}
{\xe \v getId\:CAlarmLogger}
{\xe \v CAlarmLogger\:getId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CAlarmLogger::getId (){\f2  [inline]}}
}\par
{\bkmkstart classCAlarmLogger_a6}
{\bkmkend classCAlarmLogger_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 348 of file CAlarmLogger.h.\par
\par
References m_sExpId.}
{\xe \v getPort\:CAlarmLogger}
{\xe \v CAlarmLogger\:getPort}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CAlarmLogger::getPort (){\f2  [inline]}}
}\par
{\bkmkstart classCAlarmLogger_a5}
{\bkmkend classCAlarmLogger_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 347 of file CAlarmLogger.h.\par
\par
References m_sPort.}
{\xe \v Log\:CAlarmLogger}
{\xe \v CAlarmLogger\:Log}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CAlarmLogger::Log (string {\i message})}
}\par
{\bkmkstart classCAlarmLogger_a7}
{\bkmkend classCAlarmLogger_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Log to file and screen\par
Attempts to log a message (facility, severity, message, date) to  EventLog.tcl by opening a socket connection to each of the hosts in m_HostList. The first connection logs the message which consists of the facility, severity, and message to the log file via a call to the tcl procedure Logger::Log. This only needs to be written once, since the same log file will be used by each displayer. The Logger::Log tcl procedure obtains the exact time of the event via a call to date(1). It then returns the date string through the socket (which we read) and that string is what is displayed on the GUI via a call to Logger::Display_Event. In this way, the date on each display will be exactly the same. NOTE: If {\b Log}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCAlarmLogger_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}) fails for the first host in the list, then the event will not be written to the log file and will not be displayed anywhere.  If connection to the first host succeeds, but fails on a subsequent host, the event will be logged to file but will not be displayed on whichever host connection failed. It will, however, be displayed on all hosts (including subsequent hosts) to which connection does not fail.{{{\b \par
Exceptions: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i {\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}})}}   - Errno exception occurred \par
{\b {\i {\b CTCPBadSocketState} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPBadSocketState \\*MERGEFORMAT}{\fldrslt pagenum}}})}}   - {\b CSocket::m_State} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCSocket_o1 \\*MERGEFORMAT}{\fldrslt pagenum}}}) was not disconnected \par
{\b {\i {\b CTCPNoSuchHost} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPNoSuchHost \\*MERGEFORMAT}{\fldrslt pagenum}}})}}   - Host not in DNS or nonexistent \par
{\b {\i {\b CTCPNoSuchService} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPNoSuchService \\*MERGEFORMAT}{\fldrslt pagenum}}})}}   - Named service does not translate. \par
{\b {\i {\b CTCPConnectionFailed} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPConnectionFailed \\*MERGEFORMAT}{\fldrslt pagenum}}})}}   - Connection refused by remote host \par
{\b {\i {\b CTCPConnectionLost} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPConnectionLost \\*MERGEFORMAT}{\fldrslt pagenum}}})}}   - Connection terminated by remote host\par
}{{{\b Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i sev}}  - This is an enumerated value which represent the severity of the event. \par
{\b {\i message}}  - This is the message which the caller wants to log. \par
}\par
Definition at line 383 of file CAlarmLogger.cpp.\par
\par
References CSocket::Connect(), m_sExpId, m_sFacility, m_sHost, m_sPort, CSocket::Shutdown(), and CSocket::Write().}
{\xe \v setFacility\:CAlarmLogger}
{\xe \v CAlarmLogger\:setFacility}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CAlarmLogger::setFacility (string {\i fac}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCAlarmLogger_b0}
{\bkmkend classCAlarmLogger_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 352 of file CAlarmLogger.h.\par
\par
References m_sFacility.}
{\xe \v setHost\:CAlarmLogger}
{\xe \v CAlarmLogger\:setHost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CAlarmLogger::setHost (const string & {\i host}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCAlarmLogger_b1}
{\bkmkend classCAlarmLogger_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 356 of file CAlarmLogger.h.\par
\par
References m_sHost.}
{\xe \v setIf\:CAlarmLogger}
{\xe \v CAlarmLogger\:setIf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CAlarmLogger::setIf (const string & {\i id}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCAlarmLogger_b3}
{\bkmkend classCAlarmLogger_b3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 364 of file CAlarmLogger.h.\par
\par
References m_sExpId.}
{\xe \v setPort\:CAlarmLogger}
{\xe \v CAlarmLogger\:setPort}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CAlarmLogger::setPort (const string & {\i port}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCAlarmLogger_b2}
{\bkmkend classCAlarmLogger_b2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 360 of file CAlarmLogger.h.\par
\par
References m_sPort.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_sExpId\:CAlarmLogger}
{\xe \v CAlarmLogger\:m_sExpId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CAlarmLogger::m_sExpId{\f2  [private]}}
}\par
{\bkmkstart classCAlarmLogger_o3}
{\bkmkend classCAlarmLogger_o3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
The port to log to (server port).\par
\par
Definition at line 328 of file CAlarmLogger.h.\par
\par
Referenced by getId(), Log(), and setIf().}
{\xe \v m_sFacility\:CAlarmLogger}
{\xe \v CAlarmLogger\:m_sFacility}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CAlarmLogger::m_sFacility{\f2  [private]}}
}\par
{\bkmkstart classCAlarmLogger_o0}
{\bkmkend classCAlarmLogger_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 325 of file CAlarmLogger.h.\par
\par
Referenced by getFacility(), Log(), and setFacility().}
{\xe \v m_sHost\:CAlarmLogger}
{\xe \v CAlarmLogger\:m_sHost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CAlarmLogger::m_sHost{\f2  [private]}}
}\par
{\bkmkstart classCAlarmLogger_o1}
{\bkmkend classCAlarmLogger_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
The facility name that's doing the logging.\par
\par
Definition at line 326 of file CAlarmLogger.h.\par
\par
Referenced by getHost(), Log(), and setHost().}
{\xe \v m_sPort\:CAlarmLogger}
{\xe \v CAlarmLogger\:m_sPort}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CAlarmLogger::m_sPort{\f2  [private]}}
}\par
{\bkmkstart classCAlarmLogger_o2}
{\bkmkend classCAlarmLogger_o2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
The host to log to (server host).\par
\par
Definition at line 327 of file CAlarmLogger.h.\par
\par
Referenced by CAlarmLogger(), getPort(), Log(), and setPort().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CAlarmLogger.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CAlarmLogger.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Callback_data  Struct Reference\par \pard\plain 
{\tc\tcl2 \v Callback_data}
{\xe \v Callback_data}
{\bkmkstart structCallback__data}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMWidget.h>}\par
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMWidget} * {\b object}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void(* {\b function} )({\b XMWidget} *, XtPointer, XtPointer)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
XtPointer {\b client_data}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b reason}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v client_data\:Callback_data}
{\xe \v Callback_data\:client_data}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XtPointer Callback_data::client_data}
}\par
{\bkmkstart structCallback__data_m2}
{\bkmkend structCallback__data_m2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 464 of file XMWidget.h.\par
\par
Referenced by XMAddCallback(), and XMDispatchCallback().}
{\xe \v function\:Callback_data}
{\xe \v Callback_data\:function}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void(* Callback_data::function)({\b XMWidget} *, XtPointer, XtPointer)}
}\par
{\bkmkstart structCallback__data_m1}
{\bkmkend structCallback__data_m1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Referenced by XMAddCallback(), and XMDispatchCallback().}
{\xe \v object\:Callback_data}
{\xe \v Callback_data\:object}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMWidget}* Callback_data::object}
}\par
{\bkmkstart structCallback__data_m0}
{\bkmkend structCallback__data_m0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 460 of file XMWidget.h.\par
\par
Referenced by XMAddCallback(), XMDispatchCallback(), and XMRemoveCallback().}
{\xe \v reason\:Callback_data}
{\xe \v Callback_data\:reason}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
String Callback_data::reason}
}\par
{\bkmkstart structCallback__data_m3}
{\bkmkend structCallback__data_m3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 465 of file XMWidget.h.\par
\par
Referenced by XMAddCallback(), and XMRemoveCallback().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMWidget.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CApplicationRegistry  Class Reference\par \pard\plain 
{\tc\tcl2 \v CApplicationRegistry}
{\xe \v CApplicationRegistry}
{\bkmkstart classCApplicationRegistry}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CApplicationRegistry.h>}\par
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CApplicationRegistry} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CApplicationRegistry} (const CApplicationRegistry &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CApplicationRegistry} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CApplicationRegistry & {\b operator=} (const CApplicationRegistry &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CApplicationRegistry &rhs)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CClassifiedObjectRegistry} * {\b getInstance} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setInstance} ({\b CClassifiedObjectRegistry} *p)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set a new value for the instance (should not be done).}\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CClassifiedObjectRegistry} * {\b m_pInstance}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
Encapsulates a singleton {\b CClassifiedObjectRegistry} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCClassifiedObjectRegistry \\*MERGEFORMAT}{\fldrslt pagenum}}}) which contains the names of all objects registered by the application. \par
\par
Definition at line 301 of file CApplicationRegistry.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CApplicationRegistry\:CApplicationRegistry}
{\xe \v CApplicationRegistry\:CApplicationRegistry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CApplicationRegistry::CApplicationRegistry ()}
}\par
{\bkmkstart classCApplicationRegistry_a0}
{\bkmkend classCApplicationRegistry_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct the application registry. Normally this does not need to be used, just call {\b CApplicationRegistry::getInstance}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCApplicationRegistry_d0 \\*MERGEFORMAT}{\fldrslt pagenum}}}). \par
\par
Definition at line 302 of file CApplicationRegistry.cpp.\par
\par
References getInstance().}
{\xe \v CApplicationRegistry\:CApplicationRegistry}
{\xe \v CApplicationRegistry\:CApplicationRegistry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CApplicationRegistry::CApplicationRegistry (const CApplicationRegistry & {\i rhs})}
}\par
{\bkmkstart classCApplicationRegistry_a1}
{\bkmkend classCApplicationRegistry_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Copy construction: \par
\par
Definition at line 307 of file CApplicationRegistry.cpp.\par
\par
References getInstance().}
{\xe \v ~CApplicationRegistry\:CApplicationRegistry}
{\xe \v CApplicationRegistry\:~CApplicationRegistry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CApplicationRegistry::~CApplicationRegistry (){\f2  [inline]}}
}\par
{\bkmkstart classCApplicationRegistry_a2}
{\bkmkend classCApplicationRegistry_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 311 of file CApplicationRegistry.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getInstance\:CApplicationRegistry}
{\xe \v CApplicationRegistry\:getInstance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CClassifiedObjectRegistry} * CApplicationRegistry::getInstance (){\f2  [static]}}
}\par
{\bkmkstart classCApplicationRegistry_d0}
{\bkmkend classCApplicationRegistry_d0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get the singleton instance of the application registry: \par
\par
Definition at line 334 of file CApplicationRegistry.cpp.\par
\par
References m_pInstance.\par
Referenced by CApplicationRegistry(), operator=(), and CReactor::~CReactor().}
{\xe \v operator=\:CApplicationRegistry}
{\xe \v CApplicationRegistry\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CApplicationRegistry & CApplicationRegistry::operator= (const CApplicationRegistry & {\i rhs})}
}\par
{\bkmkstart classCApplicationRegistry_a3}
{\bkmkend classCApplicationRegistry_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Assignment: \par
\par
Definition at line 315 of file CApplicationRegistry.cpp.\par
\par
References getInstance(), and m_pInstance.}
{\xe \v operator==\:CApplicationRegistry}
{\xe \v CApplicationRegistry\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CApplicationRegistry::operator== (const CApplicationRegistry & {\i rhs})}
}\par
{\bkmkstart classCApplicationRegistry_a4}
{\bkmkend classCApplicationRegistry_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Equality compare: All application registries are equal. \par
\par
Definition at line 325 of file CApplicationRegistry.cpp.\par
}
{\xe \v setInstance\:CApplicationRegistry}
{\xe \v CApplicationRegistry\:setInstance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CApplicationRegistry::setInstance ({\b CClassifiedObjectRegistry} * {\i p}){\f2  [inline, static, protected]}}
}\par
{\bkmkstart classCApplicationRegistry_e0}
{\bkmkend classCApplicationRegistry_e0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set a new value for the instance (should not be done).\par
\par
Definition at line 322 of file CApplicationRegistry.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_pInstance\:CApplicationRegistry}
{\xe \v CApplicationRegistry\:m_pInstance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CClassifiedObjectRegistry} * CApplicationRegistry::m_pInstance{\f2  [static, private]}}
}\par
{\bkmkstart classCApplicationRegistry_r0}
{\bkmkend classCApplicationRegistry_r0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Referenced by getInstance(), and operator=().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CApplicationRegistry.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CApplicationRegistry.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CApplicationSerializer  Class Reference\par \pard\plain 
{\tc\tcl2 \v CApplicationSerializer}
{\xe \v CApplicationSerializer}
{\bkmkstart classCApplicationSerializer}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CApplicationSerializer.h>}\par
Inheritance diagram for CApplicationSerializer:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCApplicationSerializer.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CApplicationSerializer * {\b getInstance} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CApplicationSerializer} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CApplicationSerializer} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CApplicationSerializer * {\b m_pTheInstance} = (CApplicationSerializer*)NULL\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i the only allowed instance.}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
Provides a singleton mutex to serialize threads within an application. The idea is that threads will typically be waiting for something to happen (an event), once the thread becomes unblocked and begins to perform application specific code, it will lock the synchronization mutex. This effectively hides the threaded nature of the application from the programmer. \par
\par
Definition at line 304 of file CApplicationSerializer.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CApplicationSerializer\:CApplicationSerializer}
{\xe \v CApplicationSerializer\:CApplicationSerializer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CApplicationSerializer::CApplicationSerializer (){\f2  [private]}}
}\par
{\bkmkstart classCApplicationSerializer_c0}
{\bkmkend classCApplicationSerializer_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
The constructor of CApplicationSerializer is private. Only one object will come into existence, and that as a result of the first  getInstance call in the application. All we do is call the base class constructor and set m_pTheInstance to this. \par
\par
Definition at line 297 of file CApplicationSerializer.cpp.\par
\par
References m_pTheInstance, and NULL.}
{\xe \v ~CApplicationSerializer\:CApplicationSerializer}
{\xe \v CApplicationSerializer\:~CApplicationSerializer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CApplicationSerializer::~CApplicationSerializer (){\f2  [private]}}
}\par
{\bkmkstart classCApplicationSerializer_c1}
{\bkmkend classCApplicationSerializer_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
The destructor simply nulls m_pTheInstance. In theory it will never get called. \par
\par
Definition at line 308 of file CApplicationSerializer.cpp.\par
\par
References m_pTheInstance, and NULL.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getInstance\:CApplicationSerializer}
{\xe \v CApplicationSerializer\:getInstance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CApplicationSerializer * CApplicationSerializer::getInstance (){\f2  [static]}}
}\par
{\bkmkstart classCApplicationSerializer_d0}
{\bkmkend classCApplicationSerializer_d0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
getInstance returns an assured non-null pointer to the singleton application serialization mutex: \par
\par
Definition at line 317 of file CApplicationSerializer.cpp.\par
\par
References m_pTheInstance.\par
Referenced by CBufferEvent< T >::AddLink(), CSocket::AddressToHostString(), CSocket::Connect(), CBufferEvent< T >::DeleteLink(), CDAQTCLProcessor::DeleteRelay(), CEvent::Disable(), CEvent::Enable(), CDAQTCLProcessor::EvalRelay(), CFileEvent::Exit(), CBufferEvent< U >::getPendingAddQueue(), CBufferEvent< U >::getPendingDeleteQueue(), CTCPConnectionLost::Host(), CEvent::OnEvent(), CSocket::OpenSocket(), CXtEventLoop::operator()(), CTCPConnectionLost::Port(), CBufferEvent< T >::ProcessAddQueue(), CBufferEvent< T >::ProcessDelQueue(), CServerConnectionEvent::Protocol(), and CSocket::Service().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_pTheInstance\:CApplicationSerializer}
{\xe \v CApplicationSerializer\:m_pTheInstance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CApplicationSerializer * CApplicationSerializer::m_pTheInstance = (CApplicationSerializer*)NULL{\f2  [static, private]}}
}\par
{\bkmkstart classCApplicationSerializer_r0}
{\bkmkend classCApplicationSerializer_r0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
the only allowed instance.\par
\par
Definition at line 289 of file CApplicationSerializer.cpp.\par
\par
Referenced by CApplicationSerializer(), getInstance(), and ~CApplicationSerializer().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CApplicationSerializer.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CApplicationSerializer.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CArrayBinding< T >  Class Template Reference\par \pard\plain 
{\tc\tcl2 \v CArrayBinding}
{\xe \v CArrayBinding}
{\bkmkstart classCArrayBinding}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CArrayBinding.h>}\par
Inheritance diagram for CArrayBinding< T >:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCArrayBinding.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CArrayBinding} (T *pArray, int nFirst, int nLast, const string &{\b m_sName}, T *Defaults=NULL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CArrayBinding} (T *pArray, int nFirst, int nLast, const char *{\b m_sName}, T *Defaults=NULL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CArrayBinding} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b getValue} (int n) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T * {\b getPointer} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getFirstIndex} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getLastIndex} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b getArrayName} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b getDefault} (int n) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getVariableType} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b InitBindings} ({\b CTCLInterpreter} &rInterp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b Commit} ({\b CTCLInterpreter} &rInterp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b ShutdownBindings} ({\b CTCLInterpreter} &rInterp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b Dump} (int fd)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setValue} (int n, T value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setArrayBase} (T *pBase)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setFirstIndex} (int n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLastIndex} (int n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setName} (const string &rName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setDefaults} (T *pDefaults)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setVariableType} (int nType)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CArrayBinding} (const CArrayBinding &rhs)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Forbidden.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CArrayBinding & {\b operator=} (const CArrayBinding &rhs)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Forbidden.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CArrayBinding &rhs)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Forbidden.}\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T * {\b m_pArrayBase}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Pointer to the configured array.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b m_nFirstIndex}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Low index of the binding.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b m_nLastIndex}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i High index of the binding.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_sName}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Name of the Tcl array.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T * {\b m_pInitialValues}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Optional array of initial values.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b m_TCLVariableType}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Type of the variable.}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class T> class CArrayBinding< T >\par
}

\par
Binds an array of configuration values to a slice of a numerically indexed array of TCL variables. When the configuration file is  read the tcl array is checked for the slice of indices provided. any defined indices result in an overwrite of the corresponding configuration array element.  The member data of this class are:\par
{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
m_pArrayBase - Points to the base of the array to be configured.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
m_nFirstIndex - The base index of the slice to be configured. This index is both the index whithin the array defined by m_pArrayBase and the index within the Tcl array.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
m_nLastIndex - The last index in the configured slice. Indexing is relative to both the start of m_pArrayBase and the TCL variable.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
m_sName - Name of the tcl array providing the configuration information.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
m_pInitialValues - If this is a non null pointer, it points to a set of initial values which are loaded into the of m_pArrayBase prior to processing the configuration file(s).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
m_TCLVariableType - The variable type which can be any of:{
\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
1.\tab TCL_LINK_INT - Integer varliable.\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
2.\tab TCL_LINK_DOUBLE - Floating point double.\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
3.\tab TCL_LINK_BOOLEAN - int as boolean.\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
4.\tab TCL_LINK_STRING - asciz string. \par
}}\par
Definition at line 335 of file CArrayBinding.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CArrayBinding\:CArrayBinding}
{\xe \v CArrayBinding\:CArrayBinding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CArrayBinding< T >::CArrayBinding (T * {\i pArray}, int {\i nFirst}, int {\i nLast}, const string & {\i rsName}, T * {\i Defaults} = NULL)}
}\par
{\bkmkstart classCArrayBinding_a0}
{\bkmkend classCArrayBinding_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct an array binding from a TCL Variable as an STL String:{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i pArray}}  - Pointer to the base of the array. \par
{\b {\i nFirst,nLast}}  - Slice of array to configure. \par
{\b {\i rsName}}  - Name of Tcl array to configure from. \par
{\b {\i Defaults}}  - Optional pointer to defautls array. \par
}\par
Definition at line 305 of file CArrayBinding.cpp.\par
}
{\xe \v CArrayBinding\:CArrayBinding}
{\xe \v CArrayBinding\:CArrayBinding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CArrayBinding< T >::CArrayBinding (T * {\i pArray}, int {\i nFirst}, int {\i nLast}, const char * {\i pName}, T * {\i Defaults} = NULL)}
}\par
{\bkmkstart classCArrayBinding_a1}
{\bkmkend classCArrayBinding_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct an array binding from a TCL Variable name given as a char*: {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i pArray}}  - Pointer to the base of the array. \par
{\b {\i nFirst,nLast}}  - Slice of array to configure. \par
{\b {\i pName}}  - Name of Tcl array to configure from. \par
{\b {\i Defaults}}  - Optional pointer to defautls array. \par
}\par
Definition at line 324 of file CArrayBinding.cpp.\par
}
{\xe \v ~CArrayBinding\:CArrayBinding}
{\xe \v CArrayBinding\:~CArrayBinding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CArrayBinding< T >::~CArrayBinding (){\f2  [inline]}}
}\par
{\bkmkstart classCArrayBinding_a2}
{\bkmkend classCArrayBinding_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 353 of file CArrayBinding.h.\par
}
{\xe \v CArrayBinding\:CArrayBinding}
{\xe \v CArrayBinding\:CArrayBinding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CArrayBinding< T >::CArrayBinding (const CArrayBinding< T > & {\i rhs}){\f2  [private]}}
}\par
{\bkmkstart classCArrayBinding_c0}
{\bkmkend classCArrayBinding_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Forbidden.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Commit\:CArrayBinding}
{\xe \v CArrayBinding\:Commit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CArrayBinding< T >::Commit ({\b CTCLInterpreter} & {\i rInterp}){\f2  [virtual]}}
}\par
{\bkmkstart classCArrayBinding_a11}
{\bkmkend classCArrayBinding_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Commits the changes from the TCL array to the configured array. This is done by sequentially attempting to read the TCL array with textual indices that are encoded integers in the range [m_nFirstIndex, m_nLastIndex). For each succesful read of a variable and decode of an integer value from it, the corresponding configured array element is set. Note that strings (T == char* are handled specially. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i {\b CTCLInterpreter} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCLInterpreter \\*MERGEFORMAT}{\fldrslt pagenum}}})&}}  rInterp - the interpreter which read in the configuration file. \par
}\par
Implements {\b CBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBinding_a1 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 364 of file CArrayBinding.cpp.\par
\par
References CTCLInterpreter::ExprBoolean(), CTCLInterpreter::ExprDouble(), CTCLInterpreter::ExprLong(), CTCLVariable::Get(), CArrayBinding< T >::m_nFirstIndex, CArrayBinding< T >::m_nLastIndex, CArrayBinding< T >::m_pArrayBase, and CArrayBinding< T >::m_sName.}
{\xe \v Dump\:CArrayBinding}
{\xe \v CArrayBinding\:Dump}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CArrayBinding< T >::Dump (int {\i fd}){\f2  [virtual]}}
}\par
{\bkmkstart classCArrayBinding_a13}
{\bkmkend classCArrayBinding_a13}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Dumps the contents of the array to a file in TCL Script form. Since spaces are possible, this cannot be done straightforwardly. We will build (for each line in the file): a list containing the set command, the variable, and index name, and the stringified array value. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i fd}}  - File descriptor to which to write this. \par
}\par
Implements {\b CBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBinding_a2 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 437 of file CArrayBinding.cpp.\par
\par
References CTCLString::AppendElement(), CBinding< T >::ItemToString(), CArrayBinding< T >::m_nFirstIndex, CArrayBinding< T >::m_nLastIndex, CArrayBinding< T >::m_pArrayBase, and CArrayBinding< T >::m_sName.}
{\xe \v getArrayName\:CArrayBinding}
{\xe \v CArrayBinding\:getArrayName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> string CArrayBinding< T >::getArrayName () const{\f2  [inline]}}
}\par
{\bkmkstart classCArrayBinding_a7}
{\bkmkend classCArrayBinding_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 375 of file CArrayBinding.h.\par
\par
References CArrayBinding< T >::m_sName.}
{\xe \v getDefault\:CArrayBinding}
{\xe \v CArrayBinding\:getDefault}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> T CArrayBinding< T >::getDefault (int {\i n}) const{\f2  [inline]}}
}\par
{\bkmkstart classCArrayBinding_a8}
{\bkmkend classCArrayBinding_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 378 of file CArrayBinding.h.\par
}
{\xe \v getFirstIndex\:CArrayBinding}
{\xe \v CArrayBinding\:getFirstIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int CArrayBinding< T >::getFirstIndex () const{\f2  [inline]}}
}\par
{\bkmkstart classCArrayBinding_a5}
{\bkmkend classCArrayBinding_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 369 of file CArrayBinding.h.\par
\par
References CArrayBinding< T >::m_nFirstIndex.}
{\xe \v getLastIndex\:CArrayBinding}
{\xe \v CArrayBinding\:getLastIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int CArrayBinding< T >::getLastIndex () const{\f2  [inline]}}
}\par
{\bkmkstart classCArrayBinding_a6}
{\bkmkend classCArrayBinding_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 372 of file CArrayBinding.h.\par
\par
References CArrayBinding< T >::m_nLastIndex.}
{\xe \v getPointer\:CArrayBinding}
{\xe \v CArrayBinding\:getPointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> T* CArrayBinding< T >::getPointer (){\f2  [inline]}}
}\par
{\bkmkstart classCArrayBinding_a4}
{\bkmkend classCArrayBinding_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 366 of file CArrayBinding.h.\par
\par
References CArrayBinding< T >::m_pArrayBase.}
{\xe \v getValue\:CArrayBinding}
{\xe \v CArrayBinding\:getValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> T CArrayBinding< T >::getValue (int {\i n}) const{\f2  [inline]}}
}\par
{\bkmkstart classCArrayBinding_a3}
{\bkmkend classCArrayBinding_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 363 of file CArrayBinding.h.\par
\par
References CArrayBinding< T >::m_pArrayBase.}
{\xe \v getVariableType\:CArrayBinding}
{\xe \v CArrayBinding\:getVariableType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int CArrayBinding< T >::getVariableType () const{\f2  [inline]}}
}\par
{\bkmkstart classCArrayBinding_a9}
{\bkmkend classCArrayBinding_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 386 of file CArrayBinding.h.\par
\par
References CArrayBinding< T >::m_TCLVariableType.}
{\xe \v InitBindings\:CArrayBinding}
{\xe \v CArrayBinding\:InitBindings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CArrayBinding< T >::InitBindings ({\b CTCLInterpreter} & {\i rInterp}){\f2  [virtual]}}
}\par
{\bkmkstart classCArrayBinding_a10}
{\bkmkend classCArrayBinding_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initializes the objects prior to reading in the  configuration file. For arrays, what we do is just initialize the configured array slice.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rInterp}}  - The TCL interpreter which will be used to configure the array. \par
}\par
Implements {\b CBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBinding_a0 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 344 of file CArrayBinding.cpp.\par
\par
References CArrayBinding< T >::m_nFirstIndex, CArrayBinding< T >::m_nLastIndex, CArrayBinding< T >::m_pArrayBase, and CArrayBinding< T >::m_pInitialValues.}
{\xe \v operator=\:CArrayBinding}
{\xe \v CArrayBinding\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CArrayBinding& CArrayBinding< T >::operator= (const CArrayBinding< T > & {\i rhs}){\f2  [private]}}
}\par
{\bkmkstart classCArrayBinding_c1}
{\bkmkend classCArrayBinding_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Forbidden.\par
}
{\xe \v operator==\:CArrayBinding}
{\xe \v CArrayBinding\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int CArrayBinding< T >::operator== (const CArrayBinding< T > & {\i rhs}){\f2  [private]}}
}\par
{\bkmkstart classCArrayBinding_c2}
{\bkmkend classCArrayBinding_c2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Forbidden.\par
}
{\xe \v setArrayBase\:CArrayBinding}
{\xe \v CArrayBinding\:setArrayBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CArrayBinding< T >::setArrayBase (T * {\i pBase}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCArrayBinding_b1}
{\bkmkend classCArrayBinding_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 395 of file CArrayBinding.h.\par
\par
References CArrayBinding< T >::m_pArrayBase.}
{\xe \v setDefaults\:CArrayBinding}
{\xe \v CArrayBinding\:setDefaults}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CArrayBinding< T >::setDefaults (T * {\i pDefaults}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCArrayBinding_b5}
{\bkmkend classCArrayBinding_b5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 407 of file CArrayBinding.h.\par
\par
References CArrayBinding< T >::m_pInitialValues.}
{\xe \v setFirstIndex\:CArrayBinding}
{\xe \v CArrayBinding\:setFirstIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CArrayBinding< T >::setFirstIndex (int {\i n}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCArrayBinding_b2}
{\bkmkend classCArrayBinding_b2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 398 of file CArrayBinding.h.\par
\par
References CArrayBinding< T >::m_nFirstIndex.}
{\xe \v setLastIndex\:CArrayBinding}
{\xe \v CArrayBinding\:setLastIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CArrayBinding< T >::setLastIndex (int {\i n}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCArrayBinding_b3}
{\bkmkend classCArrayBinding_b3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 401 of file CArrayBinding.h.\par
\par
References CArrayBinding< T >::m_nLastIndex.}
{\xe \v setName\:CArrayBinding}
{\xe \v CArrayBinding\:setName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CArrayBinding< T >::setName (const string & {\i rName}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCArrayBinding_b4}
{\bkmkend classCArrayBinding_b4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 404 of file CArrayBinding.h.\par
\par
References CArrayBinding< T >::m_sName.}
{\xe \v setValue\:CArrayBinding}
{\xe \v CArrayBinding\:setValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CArrayBinding< T >::setValue (int {\i n}, T {\i value}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCArrayBinding_b0}
{\bkmkend classCArrayBinding_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 392 of file CArrayBinding.h.\par
\par
References CArrayBinding< T >::m_pArrayBase.}
{\xe \v setVariableType\:CArrayBinding}
{\xe \v CArrayBinding\:setVariableType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CArrayBinding< T >::setVariableType (int {\i nType}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCArrayBinding_b6}
{\bkmkend classCArrayBinding_b6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 410 of file CArrayBinding.h.\par
\par
References CArrayBinding< T >::m_TCLVariableType.}
{\xe \v ShutdownBindings\:CArrayBinding}
{\xe \v CArrayBinding\:ShutdownBindings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CArrayBinding< T >::ShutdownBindings ({\b CTCLInterpreter} & {\i rInterp}){\f2  [virtual]}}
}\par
{\bkmkstart classCArrayBinding_a12}
{\bkmkend classCArrayBinding_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Terminates any linkages to the Tcl variable space.. this is a no-op for this class.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rInterp}}  - interpreter about to be shutdown. \par
}\par
Implements {\b CTypeFreeBinding} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTypeFreeBinding_a2 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 421 of file CArrayBinding.cpp.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_nFirstIndex\:CArrayBinding}
{\xe \v CArrayBinding\:m_nFirstIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int CArrayBinding< T >::m_nFirstIndex{\f2  [private]}}
}\par
{\bkmkstart classCArrayBinding_o1}
{\bkmkend classCArrayBinding_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Low index of the binding.\par
\par
Definition at line 340 of file CArrayBinding.h.\par
\par
Referenced by CArrayBinding< T >::Commit(), CArrayBinding< T >::Dump(), CArrayBinding< T >::getFirstIndex(), CArrayBinding< T >::InitBindings(), and CArrayBinding< T >::setFirstIndex().}
{\xe \v m_nLastIndex\:CArrayBinding}
{\xe \v CArrayBinding\:m_nLastIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int CArrayBinding< T >::m_nLastIndex{\f2  [private]}}
}\par
{\bkmkstart classCArrayBinding_o2}
{\bkmkend classCArrayBinding_o2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
High index of the binding.\par
\par
Definition at line 341 of file CArrayBinding.h.\par
\par
Referenced by CArrayBinding< T >::Commit(), CArrayBinding< T >::Dump(), CArrayBinding< T >::getLastIndex(), CArrayBinding< T >::InitBindings(), and CArrayBinding< T >::setLastIndex().}
{\xe \v m_pArrayBase\:CArrayBinding}
{\xe \v CArrayBinding\:m_pArrayBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> T* CArrayBinding< T >::m_pArrayBase{\f2  [private]}}
}\par
{\bkmkstart classCArrayBinding_o0}
{\bkmkend classCArrayBinding_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Pointer to the configured array.\par
\par
Definition at line 339 of file CArrayBinding.h.\par
\par
Referenced by CArrayBinding< T >::Commit(), CArrayBinding< T >::Dump(), CArrayBinding< T >::getPointer(), CArrayBinding< T >::getValue(), CArrayBinding< T >::InitBindings(), CArrayBinding< T >::setArrayBase(), and CArrayBinding< T >::setValue().}
{\xe \v m_pInitialValues\:CArrayBinding}
{\xe \v CArrayBinding\:m_pInitialValues}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> T* CArrayBinding< T >::m_pInitialValues{\f2  [private]}}
}\par
{\bkmkstart classCArrayBinding_o4}
{\bkmkend classCArrayBinding_o4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Optional array of initial values.\par
\par
Definition at line 343 of file CArrayBinding.h.\par
\par
Referenced by CArrayBinding< T >::InitBindings(), and CArrayBinding< T >::setDefaults().}
{\xe \v m_sName\:CArrayBinding}
{\xe \v CArrayBinding\:m_sName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> string CArrayBinding< T >::m_sName{\f2  [private]}}
}\par
{\bkmkstart classCArrayBinding_o3}
{\bkmkend classCArrayBinding_o3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Name of the Tcl array.\par
\par
Definition at line 342 of file CArrayBinding.h.\par
\par
Referenced by CArrayBinding< T >::Commit(), CArrayBinding< T >::Dump(), CArrayBinding< T >::getArrayName(), and CArrayBinding< T >::setName().}
{\xe \v m_TCLVariableType\:CArrayBinding}
{\xe \v CArrayBinding\:m_TCLVariableType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int CArrayBinding< T >::m_TCLVariableType{\f2  [private]}}
}\par
{\bkmkstart classCArrayBinding_o5}
{\bkmkend classCArrayBinding_o5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Type of the variable.\par
\par
Definition at line 344 of file CArrayBinding.h.\par
\par
Referenced by CArrayBinding< T >::getVariableType(), and CArrayBinding< T >::setVariableType().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CArrayBinding.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CArrayBinding.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CAssocArrayBinding< T >  Class Template Reference\par \pard\plain 
{\tc\tcl2 \v CAssocArrayBinding}
{\xe \v CAssocArrayBinding}
{\bkmkstart classCAssocArrayBinding}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CAssocArrayBinding.h>}\par
Inheritance diagram for CAssocArrayBinding< T >:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCAssocArrayBinding.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CAssocArrayBinding} (const string &rName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CAssocArrayBinding} (const char *pName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CAssocArrayBinding} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
map< string, T > {\b getArray} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i < Get entire map.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
map< string, T >::iterator {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
map< string, T >::iterator {\b end} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T & {\b operator[]} (const char *pName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T & {\b operator[]} (const string &rName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
map< string, T >::iterator {\b find} (const char *pName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
map< string, T >::iterator {\b find} (const string &rName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b getName} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getType} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b InitBindings} ({\b CTCLInterpreter} &rInterp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b Commit} ({\b CTCLInterpreter} &rInterp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b ShutdownBindings} ({\b CTCLInterpreter} &rInterp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b Dump} (int fd)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CAssocArrayBinding} (const CAssocArrayBinding &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CAssocArrayBinding & {\b operator=} (const CAssocArrayBinding &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CAssocArrayBinding &rhs)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
map< string, T > {\b m_Array}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Data stored in this map.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_sName}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i TCL Name of array.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b m_TCLVariableType}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Type of data in the array.}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class T> class CAssocArrayBinding< T >\par
}

\par
Encapsulates the configuration of an associative array. Associative arrays are arrays whose indices are strings rather than numbers. One use of associative arrays is to provide meaningful subscripts to configuration items. For example, suppose I want to store the thresholds for all of my 'detector' adc's. I might have an associative array named thresholds with subscripts which indicate detector segment and  subtype e.g. "seg1,de" could be an index. Some key properties of  associative arrays:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
One can iterate through the elements which have been given a value\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
One can index by subscript, however if the element does not yet exist, it will be generated and the value will be that provided by the default constructor. Note that this is a null pointer for characters.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
There is no way to provide default values to elements in this clas. \par
}\par
Definition at line 326 of file CAssocArrayBinding.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CAssocArrayBinding\:CAssocArrayBinding}
{\xe \v CAssocArrayBinding\:CAssocArrayBinding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CAssocArrayBinding< T >::CAssocArrayBinding (const string & {\i rName})}
}\par
{\bkmkstart classCAssocArrayBinding_a0}
{\bkmkend classCAssocArrayBinding_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Constructs an associative array configured from a TCL array. The TCL array name is specified by a const string& {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rName}}  - Name of the configuration array. \par
}\par
Definition at line 309 of file CAssocArrayBinding.cpp.\par
\par
References CAssocArrayBinding< T >::m_TCLVariableType, and CBinding< T >::VariableType().}
{\xe \v CAssocArrayBinding\:CAssocArrayBinding}
{\xe \v CAssocArrayBinding\:CAssocArrayBinding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CAssocArrayBinding< T >::CAssocArrayBinding (const char * {\i pName})}
}\par
{\bkmkstart classCAssocArrayBinding_a1}
{\bkmkend classCAssocArrayBinding_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Constructs an associative array configured from a TCL array. The TCL array name is speicified by a const char* {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i pName}}  - Name of the configuration array. \par
}\par
Definition at line 322 of file CAssocArrayBinding.cpp.\par
\par
References CAssocArrayBinding< T >::m_TCLVariableType, and CBinding< T >::VariableType().}
{\xe \v ~CAssocArrayBinding\:CAssocArrayBinding}
{\xe \v CAssocArrayBinding\:~CAssocArrayBinding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CAssocArrayBinding< T >::~CAssocArrayBinding ()}
}\par
{\bkmkstart classCAssocArrayBinding_a2}
{\bkmkend classCAssocArrayBinding_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
The destructor will need to delete storage associated with character entries in the map. \par
\par
Definition at line 334 of file CAssocArrayBinding.cpp.\par
\par
References CAssocArrayBinding< T >::m_Array, and CAssocArrayBinding< T >::m_TCLVariableType.}
{\xe \v CAssocArrayBinding\:CAssocArrayBinding}
{\xe \v CAssocArrayBinding\:CAssocArrayBinding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CAssocArrayBinding< T >::CAssocArrayBinding (const CAssocArrayBinding< T > & {\i rhs}){\f2  [private]}}
}\par
{\bkmkstart classCAssocArrayBinding_c0}
{\bkmkend classCAssocArrayBinding_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:CAssocArrayBinding}
{\xe \v CAssocArrayBinding\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> map<string,T>::iterator CAssocArrayBinding< T >::begin (){\f2  [inline]}}
}\par
{\bkmkstart classCAssocArrayBinding_a4}
{\bkmkend classCAssocArrayBinding_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 350 of file CAssocArrayBinding.h.\par
\par
References CAssocArrayBinding< T >::m_Array.}
{\xe \v Commit\:CAssocArrayBinding}
{\xe \v CAssocArrayBinding\:Commit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CAssocArrayBinding< T >::Commit ({\b CTCLInterpreter} & {\i rInterp}){\f2  [virtual]}}
}\par
{\bkmkstart classCAssocArrayBinding_a13}
{\bkmkend classCAssocArrayBinding_a13}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Commits the bindings to the array. In this case we will determine the set of indices the variable has (by running a string script of the form "array names m_sName", and fetching the results from the result string. For each item in the TCL array an item is created in the  m_Array. Note that if the type is TCL_BIND_STRING, dynamic memory is allocated to hold the result string. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rInterp}}  - the interpreter which read in the config file. Used to fetch variable strings etc. \par
}\par
Implements {\b CBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBinding_a1 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 371 of file CAssocArrayBinding.cpp.\par
\par
References CTCLInterpreter::ExprBoolean(), CTCLInterpreter::ExprDouble(), CTCLInterpreter::ExprLong(), CTCLInterpreter::getInterpreter(), CTCLInterpreter::GlobalEval(), CAssocArrayBinding< T >::m_Array, CAssocArrayBinding< T >::m_sName, CTCLList::Split(), and StringArray.}
{\xe \v Dump\:CAssocArrayBinding}
{\xe \v CAssocArrayBinding\:Dump}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CAssocArrayBinding< T >::Dump (int {\i fd}){\f2  [virtual]}}
}\par
{\bkmkstart classCAssocArrayBinding_a15}
{\bkmkend classCAssocArrayBinding_a15}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Dumps the contents of the array out in a form which allows the array to be recovered by reading the file. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i fd}}  - A file descriptor on which to write this data. \par
}\par
Implements {\b CBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBinding_a2 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 469 of file CAssocArrayBinding.cpp.\par
\par
References CBinding< T >::ItemToString(), CAssocArrayBinding< T >::m_Array, and CAssocArrayBinding< T >::m_sName.}
{\xe \v end\:CAssocArrayBinding}
{\xe \v CAssocArrayBinding\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> map<string,T>::iterator CAssocArrayBinding< T >::end (){\f2  [inline]}}
}\par
{\bkmkstart classCAssocArrayBinding_a5}
{\bkmkend classCAssocArrayBinding_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 353 of file CAssocArrayBinding.h.\par
\par
References CAssocArrayBinding< T >::m_Array.}
{\xe \v find\:CAssocArrayBinding}
{\xe \v CAssocArrayBinding\:find}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> map<string,T>::iterator CAssocArrayBinding< T >::find (const string & {\i rName}){\f2  [inline]}}
}\par
{\bkmkstart classCAssocArrayBinding_a9}
{\bkmkend classCAssocArrayBinding_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 366 of file CAssocArrayBinding.h.\par
\par
References CAssocArrayBinding< T >::m_Array.}
{\xe \v find\:CAssocArrayBinding}
{\xe \v CAssocArrayBinding\:find}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> map<string,T>::iterator CAssocArrayBinding< T >::find (const char * {\i pName}){\f2  [inline]}}
}\par
{\bkmkstart classCAssocArrayBinding_a8}
{\bkmkend classCAssocArrayBinding_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 363 of file CAssocArrayBinding.h.\par
\par
References CAssocArrayBinding< T >::m_Array.}
{\xe \v getArray\:CAssocArrayBinding}
{\xe \v CAssocArrayBinding\:getArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> map<string,T> CAssocArrayBinding< T >::getArray () const{\f2  [inline]}}
}\par
{\bkmkstart classCAssocArrayBinding_a3}
{\bkmkend classCAssocArrayBinding_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
< Get entire map.\par
\par
Definition at line 346 of file CAssocArrayBinding.h.\par
\par
References CAssocArrayBinding< T >::m_Array.}
{\xe \v getName\:CAssocArrayBinding}
{\xe \v CAssocArrayBinding\:getName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> string CAssocArrayBinding< T >::getName () const{\f2  [inline]}}
}\par
{\bkmkstart classCAssocArrayBinding_a10}
{\bkmkend classCAssocArrayBinding_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 370 of file CAssocArrayBinding.h.\par
\par
References CAssocArrayBinding< T >::m_sName.}
{\xe \v getType\:CAssocArrayBinding}
{\xe \v CAssocArrayBinding\:getType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int CAssocArrayBinding< T >::getType () const{\f2  [inline]}}
}\par
{\bkmkstart classCAssocArrayBinding_a11}
{\bkmkend classCAssocArrayBinding_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 374 of file CAssocArrayBinding.h.\par
\par
References CAssocArrayBinding< T >::m_TCLVariableType.}
{\xe \v InitBindings\:CAssocArrayBinding}
{\xe \v CAssocArrayBinding\:InitBindings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CAssocArrayBinding< T >::InitBindings ({\b CTCLInterpreter} & {\i rInterp}){\f2  [virtual]}}
}\par
{\bkmkstart classCAssocArrayBinding_a12}
{\bkmkend classCAssocArrayBinding_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize the bindings prior to reading in the configuration file. for this class the actual binding operation is done in the commit phase so this is a no-op. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rInterp}}  - Referencers the TCL interpreter which will be used to read in the configuration file. \par
}\par
Implements {\b CBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBinding_a0 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 354 of file CAssocArrayBinding.cpp.\par
}
{\xe \v operator=\:CAssocArrayBinding}
{\xe \v CAssocArrayBinding\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CAssocArrayBinding& CAssocArrayBinding< T >::operator= (const CAssocArrayBinding< T > & {\i rhs}){\f2  [private]}}
}\par
{\bkmkstart classCAssocArrayBinding_c1}
{\bkmkend classCAssocArrayBinding_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:CAssocArrayBinding}
{\xe \v CAssocArrayBinding\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int CAssocArrayBinding< T >::operator== (const CAssocArrayBinding< T > & {\i rhs}){\f2  [private]}}
}\par
{\bkmkstart classCAssocArrayBinding_c2}
{\bkmkend classCAssocArrayBinding_c2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator[]\:CAssocArrayBinding}
{\xe \v CAssocArrayBinding\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> T& CAssocArrayBinding< T >::operator[] (const string & {\i rName}){\f2  [inline]}}
}\par
{\bkmkstart classCAssocArrayBinding_a7}
{\bkmkend classCAssocArrayBinding_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 360 of file CAssocArrayBinding.h.\par
\par
References CAssocArrayBinding< T >::m_Array.}
{\xe \v operator[]\:CAssocArrayBinding}
{\xe \v CAssocArrayBinding\:operator[]}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> T& CAssocArrayBinding< T >::operator[] (const char * {\i pName}){\f2  [inline]}}
}\par
{\bkmkstart classCAssocArrayBinding_a6}
{\bkmkend classCAssocArrayBinding_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 356 of file CAssocArrayBinding.h.\par
\par
References CAssocArrayBinding< T >::m_Array.}
{\xe \v ShutdownBindings\:CAssocArrayBinding}
{\xe \v CAssocArrayBinding\:ShutdownBindings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CAssocArrayBinding< T >::ShutdownBindings ({\b CTCLInterpreter} & {\i rInterp}){\f2  [virtual]}}
}\par
{\bkmkstart classCAssocArrayBinding_a14}
{\bkmkend classCAssocArrayBinding_a14}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Closes out whatever needs closing prior to deleting the interpreter which was used to read the configuration file. In this case, no action is taken as the 'binding' is done at commit time and no real connection is made between the interpreter and the array. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rInterp}}  - Interpreter which read the config file. \par
}\par
Implements {\b CTypeFreeBinding} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTypeFreeBinding_a2 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 459 of file CAssocArrayBinding.cpp.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_Array\:CAssocArrayBinding}
{\xe \v CAssocArrayBinding\:m_Array}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> map<string,T> CAssocArrayBinding< T >::m_Array{\f2  [private]}}
}\par
{\bkmkstart classCAssocArrayBinding_o0}
{\bkmkend classCAssocArrayBinding_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Data stored in this map.\par
\par
Definition at line 330 of file CAssocArrayBinding.h.\par
\par
Referenced by CAssocArrayBinding< T >::begin(), CAssocArrayBinding< T >::Commit(), CAssocArrayBinding< T >::Dump(), CAssocArrayBinding< T >::end(), CAssocArrayBinding< T >::find(), CAssocArrayBinding< T >::getArray(), CAssocArrayBinding< T >::operator[](), and CAssocArrayBinding< T >::~CAssocArrayBinding().}
{\xe \v m_sName\:CAssocArrayBinding}
{\xe \v CAssocArrayBinding\:m_sName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> string CAssocArrayBinding< T >::m_sName{\f2  [private]}}
}\par
{\bkmkstart classCAssocArrayBinding_o1}
{\bkmkend classCAssocArrayBinding_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
TCL Name of array.\par
\par
Definition at line 331 of file CAssocArrayBinding.h.\par
\par
Referenced by CAssocArrayBinding< T >::Commit(), CAssocArrayBinding< T >::Dump(), and CAssocArrayBinding< T >::getName().}
{\xe \v m_TCLVariableType\:CAssocArrayBinding}
{\xe \v CAssocArrayBinding\:m_TCLVariableType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int CAssocArrayBinding< T >::m_TCLVariableType{\f2  [private]}}
}\par
{\bkmkstart classCAssocArrayBinding_o2}
{\bkmkend classCAssocArrayBinding_o2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Type of data in the array.\par
\par
Definition at line 332 of file CAssocArrayBinding.h.\par
\par
Referenced by CAssocArrayBinding< T >::CAssocArrayBinding(), CAssocArrayBinding< T >::getType(), and CAssocArrayBinding< T >::~CAssocArrayBinding().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CAssocArrayBinding.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CAssocArrayBinding.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CBinding< T >  Class Template Reference\par \pard\plain 
{\tc\tcl2 \v CBinding}
{\xe \v CBinding}
{\bkmkstart classCBinding}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CBinding.h>}\par
Inheritance diagram for CBinding< T >:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCBinding.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b InitBindings} ({\b CTCLInterpreter} &rInterp)=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b Commit} ({\b CTCLInterpreter} &rInterp)=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b Dump} (int fd)=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b VariableType} (T item)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b ItemToString} (T Item)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class T> class CBinding< T >\par
}

\par
This is an abstract base class for the Tcl configuration manager's bindings subsystem. interfaces for the functions required of all bindings objects are defined as pure virtual member functions. \par
\par
Definition at line 322 of file CBinding.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Commit\:CBinding}
{\xe \v CBinding\:Commit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> virtual void CBinding< T >::Commit ({\b CTCLInterpreter} & {\i rInterp}){\f2  [pure virtual]}}
}\par
{\bkmkstart classCBinding_a1}
{\bkmkend classCBinding_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
This function is called just after a configuration script or set of  configuration scripts have been read to perform any actions required to commit the read in Tcl values to the variables. For example, an associative array bindings might need to fetch the individual values from Tcl array elements. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rInterp}}  - The interpreter in which the config script was read. \par
}\par
Implements {\b CTypeFreeBinding} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTypeFreeBinding_a1 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Implemented in {\b CArrayBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCArrayBinding_a11 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CAssocArrayBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCAssocArrayBinding_a13 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b CVariableBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCVariableBinding_a14 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
}
{\xe \v Dump\:CBinding}
{\xe \v CBinding\:Dump}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> virtual void CBinding< T >::Dump (int {\i fd}){\f2  [pure virtual]}}
}\par
{\bkmkstart classCBinding_a2}
{\bkmkend classCBinding_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
This function is called just prior to deleting the interpreter. Any cleanup actions required by the binding should be done at this point. For example, if Init mapped a C variable to a TCL variable, that mapping should be broken. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rInterp}}  - The interpreter about to be deleted. virtual void {\b ShutdownBindings}(CTCLInterpreter& rInterp) ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTypeFreeBinding_a2 \\*MERGEFORMAT}{\fldrslt pagenum}}})= 0; /*! This function is called to write the set of Tcl commands required to duplicate the current state. Note that this may not be identical to the set of commands which produced the configuration. \par
}\par
Implements {\b CTypeFreeBinding} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTypeFreeBinding_a3 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Implemented in {\b CArrayBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCArrayBinding_a13 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CAssocArrayBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCAssocArrayBinding_a15 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b CVariableBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCVariableBinding_a16 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
}
{\xe \v InitBindings\:CBinding}
{\xe \v CBinding\:InitBindings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> virtual void CBinding< T >::InitBindings ({\b CTCLInterpreter} & {\i rInterp}){\f2  [pure virtual]}}
}\par
{\bkmkstart classCBinding_a0}
{\bkmkend classCBinding_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
This function will be called just prior to reading in a configuration file. The Tcl Interpreter has been set up and initialized. The Init function can do any preparation required by the binding prior to readin (e.g. a simple binding >might< bind the contained variable to a Tcl variable {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rInterp}}  - The interpreter on which the config script will be read. \par
}\par
Implements {\b CTypeFreeBinding} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTypeFreeBinding_a0 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Implemented in {\b CArrayBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCArrayBinding_a10 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CAssocArrayBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCAssocArrayBinding_a12 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b CVariableBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCVariableBinding_a13 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
}
{\xe \v ItemToString\:CBinding}
{\xe \v CBinding\:ItemToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> string CBinding< T >::ItemToString (T {\i Item}){\f2  [inline]}}
}\par
{\bkmkstart classCBinding_a4}
{\bkmkend classCBinding_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Item to string conversion: Converts an item of type T to  its string representation.  {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i item}}  - item to convert. \par
}{{{\b Exceptions: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i {\b CRangeError} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCRangeError \\*MERGEFORMAT}{\fldrslt pagenum}}})}}   - no type match \par
}{{{\b {\b Bug: }}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid  Should invent a bad type exception and throw it. \par
} \par
\par
Definition at line 390 of file CBinding.h.\par
\par
Referenced by CVariableBinding< T >::Dump(), CAssocArrayBinding< T >::Dump(), and CArrayBinding< T >::Dump().}
{\xe \v VariableType\:CBinding}
{\xe \v CBinding\:VariableType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int CBinding< T >::VariableType (T {\i item}){\f2  [inline]}}
}\par
{\bkmkstart classCBinding_a3}
{\bkmkend classCBinding_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns the TCL code for the type of variable being bound to: This can be one of:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
TCL_LINK_INT - Variable is an integer.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
TCL_LINK_DOUBLE - Variable is a double precision.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
TCL_LINK_BOOLEAN - Variable is a boolean.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
TCL_LINK_STRING - Variable is a char*.\par
}{{{\b Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i item}}  - A variable of type T.\par
}{{{\b Exceptions: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i {\b CRangeError} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCRangeError \\*MERGEFORMAT}{\fldrslt pagenum}}})}}   - no neat match.\par
}{{{\b \par
{\b Bug: }}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Really should invent a bad type exception and throw it instead\par
} \par
\par
Definition at line 372 of file CBinding.h.\par
\par
Referenced by CAssocArrayBinding< T >::CAssocArrayBinding().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CBinding.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CBufferEvent< T >  Class Template Reference\par \pard\plain 
{\tc\tcl2 \v CBufferEvent}
{\xe \v CBufferEvent}
{\bkmkstart classCBufferEvent}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \\class: CBufferEvent \\file: {\b CBufferEvent.h}. 
\par
{\f2 #include <CBufferEvent.h>}\par
Inheritance diagram for CBufferEvent< T >:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCBufferEvent.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CBufferEvent} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Anonymous buffer event.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CBufferEvent} (const char *pName)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Named event with char* name.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CBufferEvent} (const string &rName)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Named event with string name.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CBufferEvent} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Destroy the event.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
list< {\b AddLinkRequest} > {\b getPendingAddQueue} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
list< {\b AddLinkRequest} > {\b getPendingDeleteQueue} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CBufferMonitor}< T > & {\b getMonitor} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Allow manipulation of the event monitor:.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CBufferReactor}< T > & {\b getReactor} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Allow manipulation of the event reactor:.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddLink} (const string &url, unsigned int tag, unsigned int mask=ALLBITS_MASK, int reliability=COS_RELIABLE)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DeleteLink} (const string &url, unsigned int tag, unsigned int mask=ALLBITS_MASK, int reliability=COS_RELIABLE)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnBuffer} (Pointer< DAQBuffer< T >, T > &pBuffer)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTimeout} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b setBufferTag} (int tag)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b setBufferMask} (int mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual string {\b DescribeSelf} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b ProcessQueues} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ProcessAddQueue} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ProcessDelQueue} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b QueueEntryToString} ({\b AddLinkRequest} &rEntry)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CBufferEvent} (const CBufferEvent &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CBufferEvent & {\b operator=} (const CBufferEvent &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CBufferEvent &rhs)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
list< {\b AddLinkRequest} > {\b m_AddQueue}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Requests to add links go here.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
list< {\b AddLinkRequest} > {\b m_DelQueue}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Requests to delete links go here.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CBufferMonitor}< T > & {\b m_rMonitor}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Monitors the input links.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CGenericBufferReactor}< T > & {\b m_rReactor}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Reacts to the input links.}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class T> class CBufferEvent< T >\par
}

\\class: CBufferEvent \\file: {\b CBufferEvent.h}.\par
\par
Provides an ABC for building application level objects to react to SpectroDaq Buffers. This is an abstract, templated class which is templated by the type of buffer whch can be received. Note that depending on how this is constructed,, The object can handle alarm events instead of data buffers. \par
\par
Definition at line 342 of file CBufferEvent.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CBufferEvent\:CBufferEvent}
{\xe \v CBufferEvent\:CBufferEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CBufferEvent< T >::CBufferEvent ()}
}\par
{\bkmkstart classCBufferEvent_a0}
{\bkmkend classCBufferEvent_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Anonymous buffer event.\par
Construct an anonymous event. The monitor is a standard buffer monitor, the event readctor is a {\b CGenericBufferReactor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferEvent_1_1CGenericBufferReactor \\*MERGEFORMAT}{\fldrslt pagenum}}}). \par
\par
Definition at line 359 of file CBufferEvent.cpp.\par
\par
References CBufferEvent< T >::getMonitor(), CBufferEvent< T >::getReactor(), CBufferEvent< T >::m_rMonitor, and CBufferEvent< T >::m_rReactor.}
{\xe \v CBufferEvent\:CBufferEvent}
{\xe \v CBufferEvent\:CBufferEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CBufferEvent< T >::CBufferEvent (const char * {\i pName})}
}\par
{\bkmkstart classCBufferEvent_a1}
{\bkmkend classCBufferEvent_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Named event with char* name.\par
Called to create a named buffer event when the name is a char* string: \par
\par
Definition at line 371 of file CBufferEvent.cpp.\par
}
{\xe \v CBufferEvent\:CBufferEvent}
{\xe \v CBufferEvent\:CBufferEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CBufferEvent< T >::CBufferEvent (const string & {\i rName})}
}\par
{\bkmkstart classCBufferEvent_a2}
{\bkmkend classCBufferEvent_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Named event with string name.\par
Called to create a named buffer event when the name is an stl string. \par
\par
Definition at line 383 of file CBufferEvent.cpp.\par
}
{\xe \v ~CBufferEvent\:CBufferEvent}
{\xe \v CBufferEvent\:~CBufferEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CBufferEvent< T >::~CBufferEvent ()}
}\par
{\bkmkstart classCBufferEvent_a3}
{\bkmkend classCBufferEvent_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Destroy the event.\par
Destroy the buffer event: \par
\par
Definition at line 395 of file CBufferEvent.cpp.\par
\par
References CBufferEvent< T >::m_rMonitor, and CBufferEvent< T >::m_rReactor.}
{\xe \v CBufferEvent\:CBufferEvent}
{\xe \v CBufferEvent\:CBufferEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CBufferEvent< T >::CBufferEvent (const CBufferEvent< T > & {\i rhs}){\f2  [private]}}
}\par
{\bkmkstart classCBufferEvent_c0}
{\bkmkend classCBufferEvent_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddLink\:CBufferEvent}
{\xe \v CBufferEvent\:AddLink}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CBufferEvent< T >::AddLink (const string & {\i url}, unsigned int {\i tag}, unsigned int {\i mask} = ALLBITS_MASK, int {\i reliability} = COS_RELIABLE)}
}\par
{\bkmkstart classCBufferEvent_a8}
{\bkmkend classCBufferEvent_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called to add a link. The link must be added in the context of the event's thread or else buffers will not be received. The link addition requests, are therefore queued to the list of pending link add requests m_AddQueue. This must be done in a globally synchronized way. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i url}}  - The url of the host to link data from. \par
{\b {\i tag}}  - The match tag (after mask has been applied). \par
{\b {\i mask}}  - Receive mask to be anded with the buffer type. \par
{\b {\i reliability}}  - Can be:{\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
COS_RELIABLE - Indicates the link should recieve all buffers.\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
COS_UNRELIABLE - Indicates the link need not receive all buffers. \par
}}\par
Definition at line 415 of file CBufferEvent.cpp.\par
\par
References CApplicationSerializer::getInstance(), CThreadRecursiveMutex::Lock(), CBufferEvent< T >::m_AddQueue, and CThreadRecursiveMutex::UnLock().}
{\xe \v DeleteLink\:CBufferEvent}
{\xe \v CBufferEvent\:DeleteLink}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CBufferEvent< T >::DeleteLink (const string & {\i url}, unsigned int {\i tag}, unsigned int {\i mask} = ALLBITS_MASK, int {\i reliability} = COS_RELIABLE)}
}\par
{\bkmkstart classCBufferEvent_a9}
{\bkmkend classCBufferEvent_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Queues a link deletion. Links are deleted by matching URL, mask and  reliabilities. The deletion must be done in the context of the thread receiving buffers. Therefore, this member just synchronizes with the application global mutex, and adds the link description to the pending deletion queue. Next time the buffer receiving thread executes (either because a buffer arrives or because the wait times out), new links will be made and old links deleted.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i url}}  - The URL describing the server which we will be getting buffers from. \par
{\b {\i tag}}  - The buffer tag. \par
{\b {\i mask}}  - Mask to be applied to the inbound buffer. \par
{\b {\i reliability}}  - Can be any of:{\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
COS_RELIABLE - All matching buffers are delivered.\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
COS_UNRELIABLE - Matching buffers are only deliverd if receive has no 'active' buffers. \par
}}\par
Definition at line 451 of file CBufferEvent.cpp.\par
\par
References CApplicationSerializer::getInstance(), CThreadRecursiveMutex::Lock(), CBufferEvent< T >::m_DelQueue, CBufferEvent< T >::AddLinkRequest::s_mask, CBufferEvent< T >::AddLinkRequest::s_tag, CBufferEvent< T >::AddLinkRequest::s_url, and CThreadRecursiveMutex::UnLock().}
{\xe \v DescribeSelf\:CBufferEvent}
{\xe \v CBufferEvent\:DescribeSelf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> string CBufferEvent< T >::DescribeSelf (){\f2  [virtual]}}
}\par
{\bkmkstart classCBufferEvent_a14}
{\bkmkend classCBufferEvent_a14}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called to get a description of this type of event. \par
\par
Reimplemented from {\b CEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent_a16 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 556 of file CBufferEvent.cpp.\par
\par
References CEvent::DescribeSelf(), CBufferEvent< T >::m_AddQueue, CBufferEvent< T >::m_DelQueue, and CBufferEvent< T >::QueueEntryToString().}
{\xe \v getMonitor\:CBufferEvent}
{\xe \v CBufferEvent\:getMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> {\b CBufferMonitor}<T>& CBufferEvent< T >::getMonitor (){\f2  [inline]}}
}\par
{\bkmkstart classCBufferEvent_a6}
{\bkmkend classCBufferEvent_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Allow manipulation of the event monitor:.\par
\par
Reimplemented from {\b CEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 412 of file CBufferEvent.h.\par
\par
Referenced by CBufferEvent< T >::CBufferEvent().}
{\xe \v getPendingAddQueue\:CBufferEvent}
{\xe \v CBufferEvent\:getPendingAddQueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> list<{\b AddLinkRequest}> CBufferEvent< T >::getPendingAddQueue () const{\f2  [inline]}}
}\par
{\bkmkstart classCBufferEvent_a4}
{\bkmkend classCBufferEvent_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 400 of file CBufferEvent.h.\par
}
{\xe \v getPendingDeleteQueue\:CBufferEvent}
{\xe \v CBufferEvent\:getPendingDeleteQueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> list<{\b AddLinkRequest}> CBufferEvent< T >::getPendingDeleteQueue () const{\f2  [inline]}}
}\par
{\bkmkstart classCBufferEvent_a5}
{\bkmkend classCBufferEvent_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 406 of file CBufferEvent.h.\par
}
{\xe \v getReactor\:CBufferEvent}
{\xe \v CBufferEvent\:getReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> {\b CBufferReactor}<T>& CBufferEvent< T >::getReactor (){\f2  [inline]}}
}\par
{\bkmkstart classCBufferEvent_a7}
{\bkmkend classCBufferEvent_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Allow manipulation of the event reactor:.\par
\par
Reimplemented from {\b CEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent_a9 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 415 of file CBufferEvent.h.\par
\par
Referenced by CBufferEvent< T >::CBufferEvent().}
{\xe \v OnBuffer\:CBufferEvent}
{\xe \v CBufferEvent\:OnBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CBufferEvent< T >::OnBuffer (Pointer< DAQBuffer< T >, T > & {\i pBuffer}){\f2  [virtual]}}
}\par
{\bkmkstart classCBufferEvent_a10}
{\bkmkend classCBufferEvent_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
This member function is the default (no-op) action when a buffer has been received on the link.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i pBuffer}}  - A `pointer' into the DAQBuffer<T> \par
}\par
Definition at line 477 of file CBufferEvent.cpp.\par
}
{\xe \v OnTimeout\:CBufferEvent}
{\xe \v CBufferEvent\:OnTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CBufferEvent< T >::OnTimeout (){\f2  [virtual]}}
}\par
{\bkmkstart classCBufferEvent_a11}
{\bkmkend classCBufferEvent_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
This member function is the default (no-op) action when waiting for buffers has timed out and timeout delivery is enabled. \par
\par
Definition at line 487 of file CBufferEvent.cpp.\par
}
{\xe \v operator=\:CBufferEvent}
{\xe \v CBufferEvent\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CBufferEvent& CBufferEvent< T >::operator= (const CBufferEvent< T > & {\i rhs}){\f2  [private]}}
}\par
{\bkmkstart classCBufferEvent_c1}
{\bkmkend classCBufferEvent_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:CBufferEvent}
{\xe \v CBufferEvent\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int CBufferEvent< T >::operator== (const CBufferEvent< T > & {\i rhs}){\f2  [private]}}
}\par
{\bkmkstart classCBufferEvent_c2}
{\bkmkend classCBufferEvent_c2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ProcessAddQueue\:CBufferEvent}
{\xe \v CBufferEvent\:ProcessAddQueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CBufferEvent< T >::ProcessAddQueue (){\f2  [protected]}}
}\par
{\bkmkstart classCBufferEvent_b1}
{\bkmkend classCBufferEvent_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
This utility function is called to take all of the elements in the  Add queue and create links corresponding to them. It should be called only in the context of the executing event thread. \par
\par
Definition at line 515 of file CBufferEvent.cpp.\par
\par
References CApplicationSerializer::getInstance(), CThreadRecursiveMutex::Lock(), CBufferEvent< T >::m_AddQueue, CBufferEvent< T >::m_rMonitor, CBufferEvent< T >::AddLinkRequest::s_linktype, CBufferEvent< T >::AddLinkRequest::s_mask, CBufferEvent< T >::AddLinkRequest::s_tag, CBufferEvent< T >::AddLinkRequest::s_url, and CThreadRecursiveMutex::UnLock().\par
Referenced by CBufferEvent< T >::ProcessQueues().}
{\xe \v ProcessDelQueue\:CBufferEvent}
{\xe \v CBufferEvent\:ProcessDelQueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CBufferEvent< T >::ProcessDelQueue (){\f2  [protected]}}
}\par
{\bkmkstart classCBufferEvent_b2}
{\bkmkend classCBufferEvent_b2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
This utility function is called periodically in the context of the event thread. It dequeues each element from the delete link request queue and deletes the corresponding link. \par
\par
Definition at line 535 of file CBufferEvent.cpp.\par
\par
References CApplicationSerializer::getInstance(), LinkIterator, CThreadRecursiveMutex::Lock(), CBufferEvent< T >::m_DelQueue, CBufferEvent< T >::m_rMonitor, CBufferEvent< T >::AddLinkRequest::s_mask, CBufferEvent< T >::AddLinkRequest::s_tag, CBufferEvent< T >::AddLinkRequest::s_url, and CThreadRecursiveMutex::UnLock().\par
Referenced by CBufferEvent< T >::ProcessQueues().}
{\xe \v ProcessQueues\:CBufferEvent}
{\xe \v CBufferEvent\:ProcessQueues}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CBufferEvent< T >::ProcessQueues (){\f2  [protected, virtual]}}
}\par
{\bkmkstart classCBufferEvent_b0}
{\bkmkend classCBufferEvent_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called periodically at event thread context to process any ITC's (inter thread communication) primitives which are required by the event. In this case, we need to process the two link request queues:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
m_AddQueue - queue of links to add.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
m_DelQueue - queue of links to delete.\par
}since context switches are in theory unpredictable, it's possible to  queue a deletion on an add request which has not yet been processed.  Therefore, the add queue is processed first and then the delete queue. \par
\par
Reimplemented from {\b CEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent_b5 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 503 of file CBufferEvent.cpp.\par
\par
References CBufferEvent< T >::ProcessAddQueue(), and CBufferEvent< T >::ProcessDelQueue().}
{\xe \v QueueEntryToString\:CBufferEvent}
{\xe \v CBufferEvent\:QueueEntryToString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> string CBufferEvent< T >::QueueEntryToString (CBufferEvent< T >::{\b AddLinkRequest} & {\i rEntry}){\f2  [protected]}}
}\par
{\bkmkstart classCBufferEvent_b3}
{\bkmkend classCBufferEvent_b3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Represent the contents of a Link request entry (CBufferEvent<T>::AddLinkRequest&) as a string. This is intended to be used by DescribSelf() when dumping the queues. \par
\par
Definition at line 592 of file CBufferEvent.cpp.\par
\par
Referenced by CBufferEvent< T >::DescribeSelf().}
{\xe \v setBufferMask\:CBufferEvent}
{\xe \v CBufferEvent\:setBufferMask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> virtual void CBufferEvent< T >::setBufferMask (int {\i mask}){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCBufferEvent_a13}
{\bkmkend classCBufferEvent_a13}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 434 of file CBufferEvent.h.\par
}
{\xe \v setBufferTag\:CBufferEvent}
{\xe \v CBufferEvent\:setBufferTag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> virtual void CBufferEvent< T >::setBufferTag (int {\i tag}){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCBufferEvent_a12}
{\bkmkend classCBufferEvent_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 431 of file CBufferEvent.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_AddQueue\:CBufferEvent}
{\xe \v CBufferEvent\:m_AddQueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> list<{\b AddLinkRequest}> CBufferEvent< T >::m_AddQueue{\f2  [private]}}
}\par
{\bkmkstart classCBufferEvent_o0}
{\bkmkend classCBufferEvent_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Requests to add links go here.\par
\par
Definition at line 375 of file CBufferEvent.h.\par
\par
Referenced by CBufferEvent< T >::AddLink(), CBufferEvent< T >::DescribeSelf(), CBufferEvent< U >::getPendingAddQueue(), and CBufferEvent< T >::ProcessAddQueue().}
{\xe \v m_DelQueue\:CBufferEvent}
{\xe \v CBufferEvent\:m_DelQueue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> list<{\b AddLinkRequest}> CBufferEvent< T >::m_DelQueue{\f2  [private]}}
}\par
{\bkmkstart classCBufferEvent_o1}
{\bkmkend classCBufferEvent_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Requests to delete links go here.\par
\par
Definition at line 376 of file CBufferEvent.h.\par
\par
Referenced by CBufferEvent< T >::DeleteLink(), CBufferEvent< T >::DescribeSelf(), CBufferEvent< U >::getPendingDeleteQueue(), and CBufferEvent< T >::ProcessDelQueue().}
{\xe \v m_rMonitor\:CBufferEvent}
{\xe \v CBufferEvent\:m_rMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> {\b CBufferMonitor}<T>& CBufferEvent< T >::m_rMonitor{\f2  [private]}}
}\par
{\bkmkstart classCBufferEvent_o2}
{\bkmkend classCBufferEvent_o2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Monitors the input links.\par
\par
Reimplemented from {\b CEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent_o4 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 378 of file CBufferEvent.h.\par
\par
Referenced by CBufferEvent< T >::CBufferEvent(), CBufferEvent< T >::ProcessAddQueue(), CBufferEvent< T >::ProcessDelQueue(), and CBufferEvent< T >::~CBufferEvent().}
{\xe \v m_rReactor\:CBufferEvent}
{\xe \v CBufferEvent\:m_rReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> {\b CGenericBufferReactor}<T>& CBufferEvent< T >::m_rReactor{\f2  [private]}}
}\par
{\bkmkstart classCBufferEvent_o3}
{\bkmkend classCBufferEvent_o3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Reacts to the input links.\par
\par
Reimplemented from {\b CEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent_o5 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 379 of file CBufferEvent.h.\par
\par
Referenced by CBufferEvent< T >::CBufferEvent(), CBufferEvent< U >::getReactor(), and CBufferEvent< T >::~CBufferEvent().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CBufferEvent.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CBufferEvent.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CBufferEvent< T >::AddLinkRequest  Struct Template Reference\par \pard\plain 
{\tc\tcl2 \v CBufferEvent::AddLinkRequest}
{\xe \v CBufferEvent::AddLinkRequest}
{\bkmkstart structCBufferEvent_1_1AddLinkRequest}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Form of request to add a link to the link manager. 
\par
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b s_url}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i URL of source system.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b s_tag}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i tag to match against.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b s_mask}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Accpetance mask to apply to tags.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b s_linktype}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Type of link (COS_RELIABLE e.g.).}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class T> struct CBufferEvent< T >::AddLinkRequest\par
}

Form of request to add a link to the link manager.\par
\par
Definition at line 347 of file CBufferEvent.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v s_linktype\:CBufferEvent::AddLinkRequest}
{\xe \v CBufferEvent::AddLinkRequest\:s_linktype}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> unsigned int {\b CBufferEvent}< T >::AddLinkRequest::s_linktype}
}\par
{\bkmkstart structCBufferEvent_1_1AddLinkRequest_m3}
{\bkmkend structCBufferEvent_1_1AddLinkRequest_m3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Type of link (COS_RELIABLE e.g.).\par
\par
Definition at line 351 of file CBufferEvent.h.\par
\par
Referenced by CBufferEvent< T >::ProcessAddQueue().}
{\xe \v s_mask\:CBufferEvent::AddLinkRequest}
{\xe \v CBufferEvent::AddLinkRequest\:s_mask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> unsigned int {\b CBufferEvent}< T >::AddLinkRequest::s_mask}
}\par
{\bkmkstart structCBufferEvent_1_1AddLinkRequest_m2}
{\bkmkend structCBufferEvent_1_1AddLinkRequest_m2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Accpetance mask to apply to tags.\par
\par
Definition at line 350 of file CBufferEvent.h.\par
\par
Referenced by CBufferEvent< T >::DeleteLink(), CBufferEvent< T >::ProcessAddQueue(), and CBufferEvent< T >::ProcessDelQueue().}
{\xe \v s_tag\:CBufferEvent::AddLinkRequest}
{\xe \v CBufferEvent::AddLinkRequest\:s_tag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> unsigned int {\b CBufferEvent}< T >::AddLinkRequest::s_tag}
}\par
{\bkmkstart structCBufferEvent_1_1AddLinkRequest_m1}
{\bkmkend structCBufferEvent_1_1AddLinkRequest_m1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
tag to match against.\par
\par
Definition at line 349 of file CBufferEvent.h.\par
\par
Referenced by CBufferEvent< T >::DeleteLink(), CBufferEvent< T >::ProcessAddQueue(), and CBufferEvent< T >::ProcessDelQueue().}
{\xe \v s_url\:CBufferEvent::AddLinkRequest}
{\xe \v CBufferEvent::AddLinkRequest\:s_url}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> string {\b CBufferEvent}< T >::AddLinkRequest::s_url}
}\par
{\bkmkstart structCBufferEvent_1_1AddLinkRequest_m0}
{\bkmkend structCBufferEvent_1_1AddLinkRequest_m0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
URL of source system.\par
\par
Definition at line 348 of file CBufferEvent.h.\par
\par
Referenced by CBufferEvent< T >::DeleteLink(), CBufferEvent< T >::ProcessAddQueue(), and CBufferEvent< T >::ProcessDelQueue().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CBufferEvent.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CBufferEvent< T >::CGenericBufferReactor< U >  Class Template Reference\par \pard\plain 
{\tc\tcl2 \v CBufferEvent::CGenericBufferReactor}
{\xe \v CBufferEvent::CGenericBufferReactor}
{\bkmkstart classCBufferEvent_1_1CGenericBufferReactor}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Inheritance diagram for CBufferEvent< T >::CGenericBufferReactor< U >:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCBufferEvent_1_1CGenericBufferReactor.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CGenericBufferReactor} ({\b CBufferEvent}< U > &owner)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnBuffer} ({\b CBufferMonitor}< T > &rMonitor, Pointer< DAQBuffer< T >, T > pBuffer)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTimeout} ({\b CEventMonitor} &rMonitor)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CBufferEvent}< U > & {\b m_rOwner}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class T>template<class U> class CBufferEvent< T >::CGenericBufferReactor< U >\par
}

\par
The buffer reactor for {\b CBufferEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferEvent \\*MERGEFORMAT}{\fldrslt pagenum}}}) is actually a nested class: It relays all of the calls back to the event's virtual functions. this allows the presentation of a monolithic model for managing the  events. \par
\par
Definition at line 360 of file CBufferEvent.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CGenericBufferReactor\:CBufferEvent::CGenericBufferReactor}
{\xe \v CBufferEvent::CGenericBufferReactor\:CGenericBufferReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> template<class U> {\b CBufferEvent}< T >::CGenericBufferReactor< U >::CGenericBufferReactor< U > ({\b CBufferEvent}< U > & {\i Owner})}
}\par
{\bkmkstart classCBufferEvent_1_1CGenericBufferReactor_a0}
{\bkmkend classCBufferEvent_1_1CGenericBufferReactor_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct a Generic Buffer Reactor. This is the sort of buffer reactor which is associated with a {\b CBufferEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferEvent \\*MERGEFORMAT}{\fldrslt pagenum}}}). {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i Owner}}  - Owning event. \par
}}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v OnBuffer\:CBufferEvent::CGenericBufferReactor}
{\xe \v CBufferEvent::CGenericBufferReactor\:OnBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> template<class U> void {\b CBufferEvent}< T >::CGenericBufferReactor< U >::OnBuffer ({\b CBufferMonitor}< T > & {\i rMOnitor}, Pointer< DAQBuffer< T >, T > {\i pBuffer}){\f2  [virtual]}}
}\par
{\bkmkstart classCBufferEvent_1_1CGenericBufferReactor_a1}
{\bkmkend classCBufferEvent_1_1CGenericBufferReactor_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called when a buffer arrives. The Event's OnBuffer is called with the pointer to the buffer.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rMonitor}}  - reference to the monitor which fired the event. \par
{\b {\i pBuffer}}  - `Pointer' to the event buffer. \par
}\par
Definition at line 327 of file CBufferEvent.cpp.\par
\par
References CBufferEvent< T >::CGenericBufferReactor< U >::m_rOwner, and CBufferEvent< U >::OnBuffer().}
{\xe \v OnTimeout\:CBufferEvent::CGenericBufferReactor}
{\xe \v CBufferEvent::CGenericBufferReactor\:OnTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> template<class U> void {\b CBufferEvent}< T >::CGenericBufferReactor< U >::OnTimeout ({\b CEventMonitor} & {\i rMonitor}){\f2  [virtual]}}
}\par
{\bkmkstart classCBufferEvent_1_1CGenericBufferReactor_a2}
{\bkmkend classCBufferEvent_1_1CGenericBufferReactor_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called when the buffer monitor times out, but only if the buffer event has been programmed to pass timeouts on to user code. Again, this call is relayed to the Event's OnTimeout function. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rMonitor}}  - Reference to the event monitor (unused). \par
}\par
Reimplemented from {\b CReactor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCReactor_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 344 of file CBufferEvent.cpp.\par
\par
References CBufferEvent< T >::CGenericBufferReactor< U >::m_rOwner, and CBufferEvent< U >::OnTimeout().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_rOwner\:CBufferEvent::CGenericBufferReactor}
{\xe \v CBufferEvent::CGenericBufferReactor\:m_rOwner}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> template<class U> {\b CBufferEvent}<U>& {\b CBufferEvent}< T >::CGenericBufferReactor< U >::m_rOwner{\f2  [private]}}
}\par
{\bkmkstart classCBufferEvent_1_1CGenericBufferReactor_o0}
{\bkmkend classCBufferEvent_1_1CGenericBufferReactor_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 362 of file CBufferEvent.h.\par
\par
Referenced by CBufferEvent< T >::CGenericBufferReactor< U >::OnBuffer(), and CBufferEvent< T >::CGenericBufferReactor< U >::OnTimeout().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CBufferEvent.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CBufferEvent.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CBufferMonitor< T >  Class Template Reference\par \pard\plain 
{\tc\tcl2 \v CBufferMonitor}
{\xe \v CBufferMonitor}
{\bkmkstart classCBufferMonitor}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CBufferMonitor.h>}\par
Inheritance diagram for CBufferMonitor< T >:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCBufferMonitor.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CBufferMonitor} (bool am_fTimedWait=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CBufferMonitor} (const string &rName, bool am_fTimedWait=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CBufferMonitor} (const char *pName, bool am_fTimedWait=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CBufferMonitor} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
DAQBuffer< T > & {\b getBuffer} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
list< {\b LinkInfo} > {\b getLinks} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
DAQLinkMgr {\b getLinkMgr} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b CEventMonitor::result} {\b operator()} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b AddLink} (const string &URL, int tag={\b COS_MAXBUFTAG}, int mask={\b COS_ALLBITS}, bool fReliable=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b RemoveLink} (int linkid)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b RemoveLink} ({\b LinkIterator} link)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<typename LinkMatchPredicate> {\b LinkIterator} {\b FindLink} (LinkMatchPredicate &rPredicate, {\b LinkIterator} startat)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LinkIterator} {\b beginLinks} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b LinkIterator} {\b endLinks} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Pointer< DAQBuffer< T >, T > {\b getBufferPointer} (int nOffset=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetBufferTag} (int tag={\b COS_ALLBITS})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetBufferMask} (int nMask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b DescribeSelf} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBuffer} (const DAQBuffer< T > am_Buffer)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLinks} (const list< {\b LinkInfo} > am_lLinks)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLinkMgr} (const DAQLinkMgr am_daq_link_mgr)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CBufferMonitor} (const CBufferMonitor< T > &aCBufferMonitor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CBufferMonitor< T > {\b operator=} (const CBufferMonitor< T > &aCBufferMonitor)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
DAQBuffer< T > {\b m_Buffer}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
list< {\b LinkInfo} > {\b m_lLinks}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
DAQLinkMgr {\b daq_link_mgr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b m_nTag}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b m_nMask}\par
}

{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class T> class CBufferMonitor< T >\par
}

{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CBufferMonitor\:CBufferMonitor}
{\xe \v CBufferMonitor\:CBufferMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CBufferMonitor< T >::CBufferMonitor (bool {\i am_fTimedWait} = true){\f2  [inline]}}
}\par
{\bkmkstart classCBufferMonitor_a0}
{\bkmkend classCBufferMonitor_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CBufferMonitor\:CBufferMonitor}
{\xe \v CBufferMonitor\:CBufferMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CBufferMonitor< T >::CBufferMonitor (const string & {\i rName}, bool {\i am_fTimedWait} = true){\f2  [inline]}}
}\par
{\bkmkstart classCBufferMonitor_a1}
{\bkmkend classCBufferMonitor_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CBufferMonitor\:CBufferMonitor}
{\xe \v CBufferMonitor\:CBufferMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CBufferMonitor< T >::CBufferMonitor (const char * {\i pName}, bool {\i am_fTimedWait} = true){\f2  [inline]}}
}\par
{\bkmkstart classCBufferMonitor_a2}
{\bkmkend classCBufferMonitor_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~CBufferMonitor\:CBufferMonitor}
{\xe \v CBufferMonitor\:~CBufferMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CBufferMonitor< T >::~CBufferMonitor (){\f2  [inline]}}
}\par
{\bkmkstart classCBufferMonitor_a3}
{\bkmkend classCBufferMonitor_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CBufferMonitor\:CBufferMonitor}
{\xe \v CBufferMonitor\:CBufferMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CBufferMonitor< T >::CBufferMonitor (const CBufferMonitor< T > & {\i aCBufferMonitor}){\f2  [private]}}
}\par
{\bkmkstart classCBufferMonitor_c0}
{\bkmkend classCBufferMonitor_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddLink\:CBufferMonitor}
{\xe \v CBufferMonitor\:AddLink}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int CBufferMonitor< T >::AddLink (const string & {\i URL}, int {\i tag} = {\b COS_MAXBUFTAG}, int {\i mask} = {\b COS_ALLBITS}, bool {\i fReliable} = true){\f2  [virtual]}}
}\par
{\bkmkstart classCBufferMonitor_a8}
{\bkmkend classCBufferMonitor_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Mutator\par
Purpose: Adds a link to the link manager. The link id is returned. On failure, a {\b CLinkFailedException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCLinkFailedException \\*MERGEFORMAT}{\fldrslt pagenum}}}) is thrown. \par
\par
Definition at line 337 of file CBufferMonitor.cpp.\par
\par
References CBufferMonitor< T >::daq_link_mgr, LinkInfo::linkid, CBufferMonitor< T >::m_lLinks, LinkInfo::Mask, LinkInfo::Tag, and LinkInfo::URL.}
{\xe \v beginLinks\:CBufferMonitor}
{\xe \v CBufferMonitor\:beginLinks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> {\b LinkIterator} CBufferMonitor< T >::beginLinks ()}
}\par
{\bkmkstart classCBufferMonitor_a12}
{\bkmkend classCBufferMonitor_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Selector\par
Purpose: Returns an iterator to the beginning of the link list. \par
\par
Definition at line 458 of file CBufferMonitor.cpp.\par
\par
References CBufferMonitor< T >::m_lLinks.\par
Referenced by CBufferMonitor< T >::DescribeSelf().}
{\xe \v DescribeSelf\:CBufferMonitor}
{\xe \v CBufferMonitor\:DescribeSelf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> string CBufferMonitor< T >::DescribeSelf (){\f2  [virtual]}}
}\par
{\bkmkstart classCBufferMonitor_a17}
{\bkmkend classCBufferMonitor_a17}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Selector\par
Purpose: Produces a desciprtion string of the object. This includes 1. Calling CEventManager::DescribeSelf() 2. Putting out the tag and mask of the buffer. 3. Listing the links and their information. \par
\par
Reimplemented from {\b CNamedObject} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNamedObject_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 572 of file CBufferMonitor.cpp.\par
\par
References CBufferMonitor< T >::beginLinks(), CNamedObject::DescribeSelf(), CBufferMonitor< T >::endLinks(), LinkIterator, CBufferMonitor< T >::m_Buffer, and CBufferMonitor< T >::m_lLinks.}
{\xe \v endLinks\:CBufferMonitor}
{\xe \v CBufferMonitor\:endLinks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> {\b LinkIterator} CBufferMonitor< T >::endLinks ()}
}\par
{\bkmkstart classCBufferMonitor_a13}
{\bkmkend classCBufferMonitor_a13}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Selector\par
Purpose: Returns an iterator suitable for determining end of iteration through the link list. \par
\par
Definition at line 475 of file CBufferMonitor.cpp.\par
\par
References CBufferMonitor< T >::m_lLinks.\par
Referenced by CBufferMonitor< T >::DescribeSelf().}
{\xe \v FindLink\:CBufferMonitor}
{\xe \v CBufferMonitor\:FindLink}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> template<class LinkMatchPredicate> {\b LinkIterator} CBufferMonitor< T >::FindLink (LinkMatchPredicate & {\i rPredicate}, {\b LinkIterator} {\i startat})}
}\par
{\bkmkstart classCBufferMonitor_a11}
{\bkmkend classCBufferMonitor_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Selector\par
Purpose: Locates the first link that satisfies a given predicate. Predefined predicates include: {\b MatchURL} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classMatchURL \\*MERGEFORMAT}{\fldrslt pagenum}}}) - matches URL only {\b MatchAll} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classMatchAll \\*MERGEFORMAT}{\fldrslt pagenum}}}) - Matches URL, tag and mask. A LinkMatchPredicate is a function object implementing: bool operator()(LinkInfo) which returns TRUE if the link satisfies the predicate. Returns an iterator 'pointing' to the first match, or end() if there is no match. \par
\par
Definition at line 436 of file CBufferMonitor.cpp.\par
\par
References LinkIterator, and CBufferMonitor< T >::m_lLinks.}
{\xe \v getBuffer\:CBufferMonitor}
{\xe \v CBufferMonitor\:getBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> DAQBuffer<T>& CBufferMonitor< T >::getBuffer (){\f2  [inline]}}
}\par
{\bkmkstart classCBufferMonitor_a4}
{\bkmkend classCBufferMonitor_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 432 of file CBufferMonitor.h.\par
}
{\xe \v getBufferPointer\:CBufferMonitor}
{\xe \v CBufferMonitor\:getBufferPointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> Pointer< DAQBuffer< T >, T > CBufferMonitor< T >::getBufferPointer (int {\i nOffset} = 0)}
}\par
{\bkmkstart classCBufferMonitor_a14}
{\bkmkend classCBufferMonitor_a14}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Selector\par
Purpose: Returns a pointer to the DAQ Buffer. \par
\par
Definition at line 492 of file CBufferMonitor.cpp.\par
\par
References CBufferMonitor< T >::m_Buffer.\par
Referenced by CBufferReactor< T >::OnEvent().}
{\xe \v getLinkMgr\:CBufferMonitor}
{\xe \v CBufferMonitor\:getLinkMgr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> DAQLinkMgr CBufferMonitor< T >::getLinkMgr () const{\f2  [inline]}}
}\par
{\bkmkstart classCBufferMonitor_a6}
{\bkmkend classCBufferMonitor_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 442 of file CBufferMonitor.h.\par
}
{\xe \v getLinks\:CBufferMonitor}
{\xe \v CBufferMonitor\:getLinks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> list<{\b LinkInfo}> CBufferMonitor< T >::getLinks () const{\f2  [inline]}}
}\par
{\bkmkstart classCBufferMonitor_a5}
{\bkmkend classCBufferMonitor_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 437 of file CBufferMonitor.h.\par
}
{\xe \v operator()\:CBufferMonitor}
{\xe \v CBufferMonitor\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> {\b CEventMonitor::result} CBufferMonitor< T >::operator() (){\f2  [virtual]}}
}\par
{\bkmkstart classCBufferMonitor_a7}
{\bkmkend classCBufferMonitor_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: override\par
Purpose: Waits for a buffer to be received. Returns one of the following:  Occurred - a buffer was received into m_Buffer TimedOut - Timeouts were enabled and no buffer was received during the timeout interval. \par
\par
Implements {\b CEventMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEventMonitor_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 300 of file CBufferMonitor.cpp.\par
\par
References CEventMonitor::getTimedWait(), CEventMonitor::getTimeout(), CBufferMonitor< T >::m_Buffer, CBufferMonitor< T >::m_nMask, CBufferMonitor< T >::m_nTag, CEventMonitor::Occurred, and CEventMonitor::TimedOut.}
{\xe \v operator=\:CBufferMonitor}
{\xe \v CBufferMonitor\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CBufferMonitor<T> CBufferMonitor< T >::operator= (const CBufferMonitor< T > & {\i aCBufferMonitor}){\f2  [private]}}
}\par
{\bkmkstart classCBufferMonitor_c1}
{\bkmkend classCBufferMonitor_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v RemoveLink\:CBufferMonitor}
{\xe \v CBufferMonitor\:RemoveLink}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CBufferMonitor< T >::RemoveLink ({\b LinkIterator} {\i link})}
}\par
{\bkmkstart classCBufferMonitor_a10}
{\bkmkend classCBufferMonitor_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Mutator\par
Purpose: Removes a link given the iterator to its link structure in the link list. If the iterator is end(), a {\b CNoSuchLinkException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNoSuchLinkException \\*MERGEFORMAT}{\fldrslt pagenum}}}) is thrown. \par
\par
Definition at line 401 of file CBufferMonitor.cpp.\par
\par
References CBufferMonitor< T >::daq_link_mgr, LinkIterator, and CBufferMonitor< T >::m_lLinks.}
{\xe \v RemoveLink\:CBufferMonitor}
{\xe \v CBufferMonitor\:RemoveLink}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CBufferMonitor< T >::RemoveLink (int {\i linkid})}
}\par
{\bkmkstart classCBufferMonitor_a9}
{\bkmkend classCBufferMonitor_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Mutator\par
Purpose: If the specified link exists, it is removed from the link list and deleted from the spectrodaq link manager. If the link does not exist, a {\b CNoSuchLinkException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNoSuchLinkException \\*MERGEFORMAT}{\fldrslt pagenum}}}) is thrown. \par
\par
Definition at line 370 of file CBufferMonitor.cpp.\par
\par
References CBufferMonitor< T >::daq_link_mgr, LinkIterator, and CBufferMonitor< T >::m_lLinks.}
{\xe \v setBuffer\:CBufferMonitor}
{\xe \v CBufferMonitor\:setBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CBufferMonitor< T >::setBuffer (const DAQBuffer< T > {\i am_Buffer}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCBufferMonitor_b0}
{\bkmkend classCBufferMonitor_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 450 of file CBufferMonitor.h.\par
}
{\xe \v SetBufferMask\:CBufferMonitor}
{\xe \v CBufferMonitor\:SetBufferMask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CBufferMonitor< T >::SetBufferMask (int {\i nMask})}
}\par
{\bkmkstart classCBufferMonitor_a16}
{\bkmkend classCBufferMonitor_a16}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Mutator\par
Purpose: Sets the receive mask associated with the buffer. See SetBufferTag for an explanation of tags and masks and how they interact with link tags and masks and the tag of the incomming buffer to determine receipt. \par
\par
Definition at line 547 of file CBufferMonitor.cpp.\par
\par
References CBufferMonitor< T >::m_Buffer, and CBufferMonitor< T >::m_nMask.\par
Referenced by CBufferEvent< U >::setBufferMask().}
{\xe \v SetBufferTag\:CBufferMonitor}
{\xe \v CBufferMonitor\:SetBufferTag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CBufferMonitor< T >::SetBufferTag (int {\i tag} = {\b COS_ALLBITS})}
}\par
{\bkmkstart classCBufferMonitor_a15}
{\bkmkend classCBufferMonitor_a15}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Mutator\par
Purpose: Sets the tag matched on receives into the buffer. For each link/buffer pair, tags are used to determine which buffers routed through SpectroDaq will be received by a link or buffer. The logic is that at each stage, the routed buffer's tag is anded with the receiving entity's mask. If this is equal to the receiving entity's tag, the buffer is accepted. So, for a given link (link.mask, link.tag), and our buffer (buffer.mask, buffer.tag): A routed buffer rbuffer.tag is received when:\par
((rbuffer.tag & link.mask) == link.tag) && ((rbuffer.tag & buffer.mask) == buffer.tag) \par
\par
Definition at line 522 of file CBufferMonitor.cpp.\par
\par
References CBufferMonitor< T >::m_Buffer, and CBufferMonitor< T >::m_nTag.\par
Referenced by CBufferEvent< U >::setBufferTag().}
{\xe \v setLinkMgr\:CBufferMonitor}
{\xe \v CBufferMonitor\:setLinkMgr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CBufferMonitor< T >::setLinkMgr (const DAQLinkMgr {\i am_daq_link_mgr}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCBufferMonitor_b2}
{\bkmkend classCBufferMonitor_b2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 460 of file CBufferMonitor.h.\par
}
{\xe \v setLinks\:CBufferMonitor}
{\xe \v CBufferMonitor\:setLinks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CBufferMonitor< T >::setLinks (const list< {\b LinkInfo} > {\i am_lLinks}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCBufferMonitor_b1}
{\bkmkend classCBufferMonitor_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 455 of file CBufferMonitor.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v daq_link_mgr\:CBufferMonitor}
{\xe \v CBufferMonitor\:daq_link_mgr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> DAQLinkMgr CBufferMonitor< T >::daq_link_mgr{\f2  [private]}}
}\par
{\bkmkstart classCBufferMonitor_o2}
{\bkmkend classCBufferMonitor_o2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
List of links. \par
\par
Definition at line 376 of file CBufferMonitor.h.\par
\par
Referenced by CBufferMonitor< T >::AddLink(), CBufferMonitor< U >::getLinkMgr(), CBufferMonitor< T >::RemoveLink(), and CBufferMonitor< U >::setLinkMgr().}
{\xe \v m_Buffer\:CBufferMonitor}
{\xe \v CBufferMonitor\:m_Buffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> DAQBuffer<T> CBufferMonitor< T >::m_Buffer{\f2  [private]}}
}\par
{\bkmkstart classCBufferMonitor_o0}
{\bkmkend classCBufferMonitor_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 374 of file CBufferMonitor.h.\par
\par
Referenced by CBufferMonitor< T >::DescribeSelf(), CBufferMonitor< U >::getBuffer(), CBufferMonitor< T >::getBufferPointer(), CBufferMonitor< T >::operator()(), CBufferMonitor< U >::setBuffer(), CBufferMonitor< T >::SetBufferMask(), and CBufferMonitor< T >::SetBufferTag().}
{\xe \v m_lLinks\:CBufferMonitor}
{\xe \v CBufferMonitor\:m_lLinks}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> list<{\b LinkInfo}> CBufferMonitor< T >::m_lLinks{\f2  [private]}}
}\par
{\bkmkstart classCBufferMonitor_o1}
{\bkmkend classCBufferMonitor_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Encapsulated buffer \par
\par
Definition at line 375 of file CBufferMonitor.h.\par
\par
Referenced by CBufferMonitor< T >::AddLink(), CBufferMonitor< T >::beginLinks(), CBufferMonitor< T >::DescribeSelf(), CBufferMonitor< T >::endLinks(), CBufferMonitor< T >::FindLink(), CBufferMonitor< U >::getLinks(), CBufferMonitor< T >::RemoveLink(), and CBufferMonitor< U >::setLinks().}
{\xe \v m_nMask\:CBufferMonitor}
{\xe \v CBufferMonitor\:m_nMask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int CBufferMonitor< T >::m_nMask{\f2  [private]}}
}\par
{\bkmkstart classCBufferMonitor_o4}
{\bkmkend classCBufferMonitor_o4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 378 of file CBufferMonitor.h.\par
\par
Referenced by CBufferMonitor< T >::operator()(), and CBufferMonitor< T >::SetBufferMask().}
{\xe \v m_nTag\:CBufferMonitor}
{\xe \v CBufferMonitor\:m_nTag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int CBufferMonitor< T >::m_nTag{\f2  [private]}}
}\par
{\bkmkstart classCBufferMonitor_o3}
{\bkmkend classCBufferMonitor_o3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
A link manager \par
\par
Definition at line 377 of file CBufferMonitor.h.\par
\par
Referenced by CBufferMonitor< T >::operator()(), and CBufferMonitor< T >::SetBufferTag().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CBufferMonitor.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CBufferMonitor.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CBufferReactor< T >  Class Template Reference\par \pard\plain 
{\tc\tcl2 \v CBufferReactor}
{\xe \v CBufferReactor}
{\bkmkstart classCBufferReactor}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CBufferReactor.h>}\par
Inheritance diagram for CBufferReactor< T >:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCBufferReactor.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CBufferReactor} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CBufferReactor} (const string &rName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CBufferReactor} (const char *pName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CBufferReactor} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class U> int {\b operator==} (const CBufferReactor< U > &aCBufferReactor) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Operator== Equality comparison:.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnEvent} ({\b CEventMonitor} &rMonitor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnBuffer} ({\b CBufferMonitor}< T > &rMonitor, Pointer< DAQBuffer< T >, T > pBuffer)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CBufferReactor} (const CBufferReactor &aCBufferReactor)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Copy Constructor disallowed.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CBufferReactor & {\b operator=} (const CBufferReactor &aCBufferReactor)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Operator= Assignment Operator disallowed.}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class T> class CBufferReactor< T >\par
}

\par
Base class for SpectroDaq buffer receipt. This object must be subclassed to provide application specific processing. \par
\par
Definition at line 327 of file CBufferReactor.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CBufferReactor\:CBufferReactor}
{\xe \v CBufferReactor\:CBufferReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CBufferReactor< T >::CBufferReactor ()}
}\par
{\bkmkstart classCBufferReactor_a0}
{\bkmkend classCBufferReactor_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct a buffer reactor with a default name. Note that buffer reactors are templated by the type of data contained in the buffer. \par
\par
Definition at line 310 of file CBufferReactor.cpp.\par
\par
References CNamedObject::AppendClassInfo().}
{\xe \v CBufferReactor\:CBufferReactor}
{\xe \v CBufferReactor\:CBufferReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CBufferReactor< T >::CBufferReactor (const string & {\i rName})}
}\par
{\bkmkstart classCBufferReactor_a1}
{\bkmkend classCBufferReactor_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct a named buffer reactor using an STL string parameter for the object name. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rName}}  - the name of the reactor. \par
}\par
Definition at line 322 of file CBufferReactor.cpp.\par
\par
References CNamedObject::AppendClassInfo().}
{\xe \v CBufferReactor\:CBufferReactor}
{\xe \v CBufferReactor\:CBufferReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CBufferReactor< T >::CBufferReactor (const char * {\i pName})}
}\par
{\bkmkstart classCBufferReactor_a2}
{\bkmkend classCBufferReactor_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct a named buffer reactor using a ASCIZ (C) string parameter for the object name. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i pName}}  - Pointer to an ASCIZ string naming the buffer. \par
}\par
Definition at line 334 of file CBufferReactor.cpp.\par
\par
References CNamedObject::AppendClassInfo().}
{\xe \v ~CBufferReactor\:CBufferReactor}
{\xe \v CBufferReactor\:~CBufferReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CBufferReactor< T >::~CBufferReactor ()}
}\par
{\bkmkstart classCBufferReactor_a3}
{\bkmkend classCBufferReactor_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 340 of file CBufferReactor.cpp.\par
}
{\xe \v CBufferReactor\:CBufferReactor}
{\xe \v CBufferReactor\:CBufferReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CBufferReactor< T >::CBufferReactor (const CBufferReactor< T > & {\i aCBufferReactor}){\f2  [private]}}
}\par
{\bkmkstart classCBufferReactor_c0}
{\bkmkend classCBufferReactor_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Copy Constructor disallowed.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v OnBuffer\:CBufferReactor}
{\xe \v CBufferReactor\:OnBuffer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CBufferReactor< T >::OnBuffer ({\b CBufferMonitor}< T > & {\i rMonitor}, Pointer< DAQBuffer< T >, T > {\i pBuffer}){\f2  [virtual]}}
}\par
{\bkmkstart classCBufferReactor_a6}
{\bkmkend classCBufferReactor_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called when a buffer has been received by a buffer monitor. In normal use, the user will subclass CBufferReactor and override this no-op member. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rMonitor}}  - The buffer monitor which received the buffer. \par
{\b {\i pBuffer}}  - A DAQBufferPtr of the appropriate type into the buffer received. \par
}\par
Reimplemented in {\b CBufferEvent< T >::CGenericBufferReactor< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferEvent_1_1CGenericBufferReactor_a1 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 389 of file CBufferReactor.cpp.\par
\par
Referenced by CBufferReactor< T >::OnEvent().}
{\xe \v OnEvent\:CBufferReactor}
{\xe \v CBufferReactor\:OnEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CBufferReactor< T >::OnEvent ({\b CEventMonitor} & {\i rMonitor}){\f2  [virtual]}}
}\par
{\bkmkstart classCBufferReactor_a5}
{\bkmkend classCBufferReactor_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called when the event monitor declares an event. The event monitor must be descended from {\b CBufferMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferMonitor \\*MERGEFORMAT}{\fldrslt pagenum}}}) or  this function will throw a {\b CIncompatibleMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCIncompatibleMonitor \\*MERGEFORMAT}{\fldrslt pagenum}}}) exception. The OnBuffer virtual member is called with a pointer to the buffer. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rMonitor}}  - Reference to the monitor which declared the event. \par
}\par
Reimplemented from {\b CReactor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCReactor_a6 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 365 of file CBufferReactor.cpp.\par
\par
References CBufferMonitor< T >::getBufferPointer(), and CBufferReactor< T >::OnBuffer().}
{\xe \v operator=\:CBufferReactor}
{\xe \v CBufferReactor\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CBufferReactor& CBufferReactor< T >::operator= (const CBufferReactor< T > & {\i aCBufferReactor}){\f2  [private]}}
}\par
{\bkmkstart classCBufferReactor_c1}
{\bkmkend classCBufferReactor_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operator= Assignment Operator disallowed.\par
}
{\xe \v operator==\:CBufferReactor}
{\xe \v CBufferReactor\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> template<class U> int CBufferReactor< T >::operator== (const CBufferReactor< U > & {\i aCBufferReactor}) const}
}\par
{\bkmkstart classCBufferReactor_a4}
{\bkmkend classCBufferReactor_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operator== Equality comparison:.\par
\par
Definition at line 349 of file CBufferReactor.cpp.\par
\par
References CReactor::operator==().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CBufferReactor.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CBufferReactor.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CChangedPredicate< T >  Class Template Reference\par \pard\plain 
{\tc\tcl2 \v CChangedPredicate}
{\xe \v CChangedPredicate}
{\bkmkstart classCChangedPredicate}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CChangedPredicate.h>}\par
Inheritance diagram for CChangedPredicate< T >:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCChangedPredicate.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CChangedPredicate} (T am_TOldValue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CChangedPredicate} (const string &rName, T am_TOldValue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CChangedPredicate} (const char *pName, T am_TOldValue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CChangedPredicate} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CChangedPredicate< T > &aCChangedPredicate) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b getOldValue} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b operator()} (T nValue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual string {\b DescribeSelf} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setOldValue} (const T am_TOldValue)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CChangedPredicate} (const CChangedPredicate< T > &aCChangedPredicate)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CChangedPredicate< T > {\b operator=} (const CChangedPredicate< T > &aCChangedPredicate)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b m_TOldValue}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T> class CChangedPredicate< T >\par
}

\par
\\class: CChangedPredicate\par
Defines a pointer predicate which is satisfied whenever the current value changes.\par
Author: Jason Venema NSCL Michigan State University East Lansing, MI 48824-1321 mailto: {\f2 venemaja@msu.edu} \par
\par
Definition at line 301 of file CChangedPredicate.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CChangedPredicate\:CChangedPredicate}
{\xe \v CChangedPredicate\:CChangedPredicate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> CChangedPredicate< T >::CChangedPredicate (T {\i am_TOldValue}){\f2  [inline]}}
}\par
{\bkmkstart classCChangedPredicate_a0}
{\bkmkend classCChangedPredicate_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Prior value \par
}
{\xe \v CChangedPredicate\:CChangedPredicate}
{\xe \v CChangedPredicate\:CChangedPredicate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> CChangedPredicate< T >::CChangedPredicate (const string & {\i rName}, T {\i am_TOldValue}){\f2  [inline]}}
}\par
{\bkmkstart classCChangedPredicate_a1}
{\bkmkend classCChangedPredicate_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CChangedPredicate\:CChangedPredicate}
{\xe \v CChangedPredicate\:CChangedPredicate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> CChangedPredicate< T >::CChangedPredicate (const char * {\i pName}, T {\i am_TOldValue}){\f2  [inline]}}
}\par
{\bkmkstart classCChangedPredicate_a2}
{\bkmkend classCChangedPredicate_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~CChangedPredicate\:CChangedPredicate}
{\xe \v CChangedPredicate\:~CChangedPredicate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> CChangedPredicate< T >::~CChangedPredicate (){\f2  [inline]}}
}\par
{\bkmkstart classCChangedPredicate_a3}
{\bkmkend classCChangedPredicate_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CChangedPredicate\:CChangedPredicate}
{\xe \v CChangedPredicate\:CChangedPredicate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> CChangedPredicate< T >::CChangedPredicate (const CChangedPredicate< T > & {\i aCChangedPredicate}){\f2  [private]}}
}\par
{\bkmkstart classCChangedPredicate_c0}
{\bkmkend classCChangedPredicate_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v DescribeSelf\:CChangedPredicate}
{\xe \v CChangedPredicate\:DescribeSelf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> string CChangedPredicate< T >::DescribeSelf (){\f2  [virtual]}}
}\par
{\bkmkstart classCChangedPredicate_a7}
{\bkmkend classCChangedPredicate_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Describes the named object. The information given is the object type given by m_sClassPath, and the object name. \par
\par
Implements {\b CPointerPredicate< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCPointerPredicate_a6 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 319 of file CChangedPredicate.cpp.\par
\par
References CChangedPredicate< T >::m_TOldValue.}
{\xe \v getOldValue\:CChangedPredicate}
{\xe \v CChangedPredicate\:getOldValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> T CChangedPredicate< T >::getOldValue () const{\f2  [inline]}}
}\par
{\bkmkstart classCChangedPredicate_a5}
{\bkmkend classCChangedPredicate_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 344 of file CChangedPredicate.h.\par
}
{\xe \v operator()\:CChangedPredicate}
{\xe \v CChangedPredicate\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> bool CChangedPredicate< T >::operator() (T {\i nValue}){\f2  [virtual]}}
}\par
{\bkmkstart classCChangedPredicate_a6}
{\bkmkend classCChangedPredicate_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Implements {\b CPointerPredicate< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCPointerPredicate_a5 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 300 of file CChangedPredicate.cpp.\par
\par
References CChangedPredicate< T >::m_TOldValue.}
{\xe \v operator=\:CChangedPredicate}
{\xe \v CChangedPredicate\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> CChangedPredicate<T> CChangedPredicate< T >::operator= (const CChangedPredicate< T > & {\i aCChangedPredicate}){\f2  [private]}}
}\par
{\bkmkstart classCChangedPredicate_c1}
{\bkmkend classCChangedPredicate_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:CChangedPredicate}
{\xe \v CChangedPredicate\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> int CChangedPredicate< T >::operator== (const CChangedPredicate< T > & {\i aCChangedPredicate}) const{\f2  [inline]}}
}\par
{\bkmkstart classCChangedPredicate_a4}
{\bkmkend classCChangedPredicate_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 327 of file CChangedPredicate.h.\par
\par
References CChangedPredicate< T >::m_TOldValue, and CPointerPredicate< T >::operator==().}
{\xe \v setOldValue\:CChangedPredicate}
{\xe \v CChangedPredicate\:setOldValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> void CChangedPredicate< T >::setOldValue (const T {\i am_TOldValue}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCChangedPredicate_b0}
{\bkmkend classCChangedPredicate_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 352 of file CChangedPredicate.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_TOldValue\:CChangedPredicate}
{\xe \v CChangedPredicate\:m_TOldValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> T CChangedPredicate< T >::m_TOldValue{\f2  [private]}}
}\par
{\bkmkstart classCChangedPredicate_o0}
{\bkmkend classCChangedPredicate_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 303 of file CChangedPredicate.h.\par
\par
Referenced by CChangedPredicate< T >::DescribeSelf(), CChangedPredicate< T >::operator()(), and CChangedPredicate< T >::operator==().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CChangedPredicate.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CChangedPredicate.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CClassifiedObjectRegistry  Class Reference\par \pard\plain 
{\tc\tcl2 \v CClassifiedObjectRegistry}
{\xe \v CClassifiedObjectRegistry}
{\bkmkstart classCClassifiedObjectRegistry}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CClassifiedObjectRegistry.h>}\par
Inheritance diagram for CClassifiedObjectRegistry:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCClassifiedObjectRegistry.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CClassifiedObjectRegistry} (string am_sName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CClassifiedObjectRegistry} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
map< string, {\b CObjectRegistry} > {\b getRegistries} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b CreateRegistry} (const string &{\b RegistryName})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DeleteRegistry} (const string &{\b RegistryName})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Add} (const string &{\b RegistryName}, {\b CNamedObject} &rObject)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Remove} (const string &{\b RegistryName}, {\b CNamedObject} &Object)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ObjectIterator} {\b Find} (const string &{\b RegistryName}, const string &ObjectName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CRefcountedPtr}< {\b ObjectList} > {\b Find} (const string &ObjectName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RegistryIterator} {\b beginregistry} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b RegistryIterator} {\b endregistry} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual string {\b DescribeSelf} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRegistries} (map< string, {\b CObjectRegistry} > am_Registries)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
map< string, {\b CObjectRegistry} > {\b m_Registries}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CClassifiedObjectRegistry\:CClassifiedObjectRegistry}
{\xe \v CClassifiedObjectRegistry\:CClassifiedObjectRegistry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CClassifiedObjectRegistry::CClassifiedObjectRegistry (string {\i am_sName}){\f2  [inline]}}
}\par
{\bkmkstart classCClassifiedObjectRegistry_a0}
{\bkmkend classCClassifiedObjectRegistry_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
map containing the type key and object registry \par
\par
Definition at line 332 of file CClassifiedObjectRegistry.h.\par
\par
References CNamedObject::AppendClassInfo().}
{\xe \v ~CClassifiedObjectRegistry\:CClassifiedObjectRegistry}
{\xe \v CClassifiedObjectRegistry\:~CClassifiedObjectRegistry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual CClassifiedObjectRegistry::~CClassifiedObjectRegistry (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCClassifiedObjectRegistry_a1}
{\bkmkend classCClassifiedObjectRegistry_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 337 of file CClassifiedObjectRegistry.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Add\:CClassifiedObjectRegistry}
{\xe \v CClassifiedObjectRegistry\:Add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CClassifiedObjectRegistry::Add (const string & {\i RegistryName}, {\b CNamedObject} & {\i rObject})}
}\par
{\bkmkstart classCClassifiedObjectRegistry_a5}
{\bkmkend classCClassifiedObjectRegistry_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Adds an object to a registry. If the item already exists in that registry, a  {\b CDuplicateNameException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDuplicateNameException \\*MERGEFORMAT}{\fldrslt pagenum}}}) is thrown. If the registry does not exist, a {\b CNoSuchObjectException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNoSuchObjectException \\*MERGEFORMAT}{\fldrslt pagenum}}}) is thrown.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i RegistryName}}  The name of the registry to add the item to. \par
{\b {\i rObject}}  A reference to the object to add to the registry. \par
}\par
Definition at line 353 of file CClassifiedObjectRegistry.cpp.\par
\par
References endregistry(), m_Registries, and RegistryIterator.\par
Referenced by CRegisteredObject::RegisterSelf().}
{\xe \v beginregistry\:CClassifiedObjectRegistry}
{\xe \v CClassifiedObjectRegistry\:beginregistry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RegistryIterator} CClassifiedObjectRegistry::beginregistry ()}
}\par
{\bkmkstart classCClassifiedObjectRegistry_a9}
{\bkmkend classCClassifiedObjectRegistry_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns an iterator into the registries which are contained by this object. Note that iterating returns registries, not objects. \par
\par
Definition at line 469 of file CClassifiedObjectRegistry.cpp.\par
\par
References m_Registries.\par
Referenced by DescribeSelf(), and Find().}
{\xe \v CreateRegistry\:CClassifiedObjectRegistry}
{\xe \v CClassifiedObjectRegistry\:CreateRegistry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CClassifiedObjectRegistry::CreateRegistry (const string & {\i RegistryName})}
}\par
{\bkmkstart classCClassifiedObjectRegistry_a3}
{\bkmkend classCClassifiedObjectRegistry_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Creates a new registry. It is not an error to create a registry which already exists. If this is attempted, the function is a no-op.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i RegistryName}}  The name of the registry being created. \par
}\par
Definition at line 314 of file CClassifiedObjectRegistry.cpp.\par
\par
References m_Registries.\par
Referenced by CRegisteredObject::RegisterSelf().}
{\xe \v DeleteRegistry\:CClassifiedObjectRegistry}
{\xe \v CClassifiedObjectRegistry\:DeleteRegistry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CClassifiedObjectRegistry::DeleteRegistry (const string & {\i RegistryName})}
}\par
{\bkmkstart classCClassifiedObjectRegistry_a4}
{\bkmkend classCClassifiedObjectRegistry_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Deletes an existing registry. Any registry entries are destroyed, however the objects they point to are not. If the registry does not exist, a {\b CNoSuchObjectException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNoSuchObjectException \\*MERGEFORMAT}{\fldrslt pagenum}}}) is thrown.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i RegistryName}}  The name of the registry being destroyed. \par
}\par
Definition at line 334 of file CClassifiedObjectRegistry.cpp.\par
\par
References m_Registries.}
{\xe \v DescribeSelf\:CClassifiedObjectRegistry}
{\xe \v CClassifiedObjectRegistry\:DescribeSelf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CClassifiedObjectRegistry::DescribeSelf (){\f2  [virtual]}}
}\par
{\bkmkstart classCClassifiedObjectRegistry_a11}
{\bkmkend classCClassifiedObjectRegistry_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Produces a string containing the class path and name of the CClassifiedObjectRegistry, the class path and name of all of the {\b CObjectRegistry} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCObjectRegistry \\*MERGEFORMAT}{\fldrslt pagenum}}})'s contained therein, and the class path and name of all of the {\b CNamedObject} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNamedObject \\*MERGEFORMAT}{\fldrslt pagenum}}})'s contained within the registries. \par
\par
Reimplemented from {\b CNamedObject} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNamedObject_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 492 of file CClassifiedObjectRegistry.cpp.\par
\par
References beginregistry(), CNamedObject::DescribeSelf(), endregistry(), and RegistryIterator.}
{\xe \v endregistry\:CClassifiedObjectRegistry}
{\xe \v CClassifiedObjectRegistry\:endregistry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b RegistryIterator} CClassifiedObjectRegistry::endregistry ()}
}\par
{\bkmkstart classCClassifiedObjectRegistry_a10}
{\bkmkend classCClassifiedObjectRegistry_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns a registry iterator suitable for determining when iteration has been completed. \par
\par
Definition at line 479 of file CClassifiedObjectRegistry.cpp.\par
\par
References m_Registries.\par
Referenced by Add(), DescribeSelf(), and Find().}
{\xe \v Find\:CClassifiedObjectRegistry}
{\xe \v CClassifiedObjectRegistry\:Find}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CRefcountedPtr}< {\b ObjectList} > CClassifiedObjectRegistry::Find (const string & {\i ObjectName})}
}\par
{\bkmkstart classCClassifiedObjectRegistry_a8}
{\bkmkend classCClassifiedObjectRegistry_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns a reference counted pointer to a dynamically allocated list of Objects which match the name requested. The list is drawn from all of the registries. If no registries contain the requested name, an empty list is returned.  Note: A reference counted pointer is returned so that the client does not have to remember to delete the list when they are done with it.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i ObjectName}}  The name of the object to search for. \par
}\par
Definition at line 449 of file CClassifiedObjectRegistry.cpp.\par
\par
References beginregistry(), endregistry(), ObjectIterator, ObjectList, and RegistryIterator.}
{\xe \v Find\:CClassifiedObjectRegistry}
{\xe \v CClassifiedObjectRegistry\:Find}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ObjectIterator} CClassifiedObjectRegistry::Find (const string & {\i RegistryName}, const string & {\i ObjectName})}
}\par
{\bkmkstart classCClassifiedObjectRegistry_a7}
{\bkmkend classCClassifiedObjectRegistry_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Locates an object in a specific registry. If the registry or object do not exist, a {\b CNoSuchObjectException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNoSuchObjectException \\*MERGEFORMAT}{\fldrslt pagenum}}}) is thrown. The name embedded in the exception differentiates between these two cases.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i RegistryName}}  The name of the registry to search for the object in. \par
{\b {\i ObjectName}}  The name of the object to search for. \par
}\par
Definition at line 415 of file CClassifiedObjectRegistry.cpp.\par
\par
References m_Registries, ObjectIterator, and RegistryIterator.}
{\xe \v getRegistries\:CClassifiedObjectRegistry}
{\xe \v CClassifiedObjectRegistry\:getRegistries}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
map<string, {\b CObjectRegistry}> CClassifiedObjectRegistry::getRegistries () const{\f2  [inline]}}
}\par
{\bkmkstart classCClassifiedObjectRegistry_a2}
{\bkmkend classCClassifiedObjectRegistry_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 342 of file CClassifiedObjectRegistry.h.\par
\par
References m_Registries.}
{\xe \v Remove\:CClassifiedObjectRegistry}
{\xe \v CClassifiedObjectRegistry\:Remove}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CClassifiedObjectRegistry::Remove (const string & {\i RegistryName}, {\b CNamedObject} & {\i Object})}
}\par
{\bkmkstart classCClassifiedObjectRegistry_a6}
{\bkmkend classCClassifiedObjectRegistry_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Removes an object from a registry. The named object is removed from the designated registry. If the object does not exist, or the registry does not exist, a {\b CNoSuchObjectException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNoSuchObjectException \\*MERGEFORMAT}{\fldrslt pagenum}}}) is thrown. The name embedded in the exception differentiates between these two cases.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i RegistryName}}  The name of the registry containing the object to remove. \par
{\b {\i Object}}  A reference to the object being removed. \par
}\par
Definition at line 384 of file CClassifiedObjectRegistry.cpp.\par
\par
References CNamedObject::getName(), m_Registries, and RegistryIterator.\par
Referenced by CEventMonitor::~CEventMonitor(), and CReactor::~CReactor().}
{\xe \v setRegistries\:CClassifiedObjectRegistry}
{\xe \v CClassifiedObjectRegistry\:setRegistries}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CClassifiedObjectRegistry::setRegistries (map< string, {\b CObjectRegistry} > {\i am_Registries}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCClassifiedObjectRegistry_b0}
{\bkmkend classCClassifiedObjectRegistry_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 350 of file CClassifiedObjectRegistry.h.\par
\par
References m_Registries.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_Registries\:CClassifiedObjectRegistry}
{\xe \v CClassifiedObjectRegistry\:m_Registries}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
map<string, {\b CObjectRegistry}> CClassifiedObjectRegistry::m_Registries{\f2  [private]}}
}\par
{\bkmkstart classCClassifiedObjectRegistry_o0}
{\bkmkend classCClassifiedObjectRegistry_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 326 of file CClassifiedObjectRegistry.h.\par
\par
Referenced by Add(), beginregistry(), CreateRegistry(), DeleteRegistry(), endregistry(), Find(), getRegistries(), Remove(), and setRegistries().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CClassifiedObjectRegistry.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CClassifiedObjectRegistry.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CCommit  Class Reference\par \pard\plain 
{\tc\tcl2 \v CCommit}
{\xe \v CCommit}
{\bkmkstart classCCommit}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CCommit} ({\b CTCLInterpreter} &rInterp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b operator()} ({\b CTypeFreeBinding} *pBinding)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLInterpreter} & {\b m_rInterp}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CCommit\:CCommit}
{\xe \v CCommit\:CCommit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CCommit::CCommit ({\b CTCLInterpreter} & {\i rInterp}){\f2  [inline]}}
}\par
{\bkmkstart classCCommit_a0}
{\bkmkend classCCommit_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 320 of file CConfigurationManager.cpp.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator()\:CCommit}
{\xe \v CCommit\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CCommit::operator() ({\b CTypeFreeBinding} * {\i pBinding}){\f2  [inline]}}
}\par
{\bkmkstart classCCommit_a1}
{\bkmkend classCCommit_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 321 of file CConfigurationManager.cpp.\par
\par
References CTypeFreeBinding::Commit().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_rInterp\:CCommit}
{\xe \v CCommit\:m_rInterp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CTCLInterpreter}& CCommit::m_rInterp{\f2  [private]}}
}\par
{\bkmkstart classCCommit_o0}
{\bkmkend classCCommit_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 318 of file CConfigurationManager.cpp.\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CConfigurationManager.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CConfigurationManager  Class Reference\par \pard\plain 
{\tc\tcl2 \v CConfigurationManager}
{\xe \v CConfigurationManager}
{\bkmkstart classCConfigurationManager}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CConfigurationManager.h>}\par
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CConfigurationManager} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Default construtor.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CConfigurationManager} (list< {\b CTypeFreeBinding} * > &rBindings)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Prestocked configuration.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CConfigurationManager} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Destruction requires nothing special.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CConfigurationManager} (const CConfigurationManager &rhs)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Copy constructor.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CConfigurationManager & {\b operator=} (const CConfigurationManager &rhs)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Assignment operator.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CConfigurationManager &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator!=} (const CConfigurationManager &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
list< {\b CTypeFreeBinding} * > {\b getBindings} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBindings} (list< {\b CTypeFreeBinding} * > newBindings)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Replace all bindings.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddBinding} ({\b CTypeFreeBinding} &rBinding)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddBinding} (list< {\b CTypeFreeBinding} * > addlist)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ReadConfigFile} (const char *pName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ReadConfigFile} (const string &rName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ReadConfigFile} (int fd)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Read1stConfigFile} (const vector< string > &Names)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Read1stConfigFile} (const vector< string > &Paths, const char *pName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Read1stConfigFile} (const vector< string > &Paths, const string &rName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ReadAllConfigFiles} (const vector< string > &Name)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ReadAllConfigFiles} (const vector< string > &Paths, const char *pName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ReadAllConfigFiles} (const vector< string > &Paths, const string &rName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b WriteConfigFile} (const char *pName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b WriteConfigFile} (const string &rName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b WriteConfigFile} (int fd)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InternalReadConfigFile} ({\b CTCLInterpreter} &rInterp, int fd)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
list< {\b CTypeFreeBinding} * > {\b m_lBindings}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i List of configuration bindings.}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
ConfigurationManager provides a flexible scheme for configuring  various application parameters. The idea is that a script or set of scripts will hold configuration information (variable sets e.g.). These configuration scripts are linked to application variables via instances of subclasses of {\b CBinding} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBinding \\*MERGEFORMAT}{\fldrslt pagenum}}}). The configuration manager is asked to read a set of configuration files, it instantiates a TCLInterpreter with which to interpret the files. Folowing this, the application has its configuration variable set as a result of this script exeuction and the set of defined bindings between TCL variables and application variables.\par
The following bindings are supported:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CVariableBinding} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCVariableBinding \\*MERGEFORMAT}{\fldrslt pagenum}}}) - Binds a single C/C++ variable location to a TCL variable. After the configuration completes, this variable will contain the value which was set in the corresponding TCL variable, or a default value if the variable was not set during configuration.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CArrayBinding} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCArrayBinding \\*MERGEFORMAT}{\fldrslt pagenum}}}) - Binds a slice of a C/C++ array to a TCL array which is assumed to be indexed by numerically encoded indices. After configuration completes, the slice contains the corresponding values from the TCL array or an optional default value if element(s) were not set.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CAssocArrayBinding} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCAssocArrayBinding \\*MERGEFORMAT}{\fldrslt pagenum}}}) - Encapsulates an associative array (STL map<string,T>). and binds it to a corresponding TCL array which is assumed to have arbitrary indices. After the configuration is done, TCL array elements are copied to corresponding Map entries, creating new entries as needed.\par
}All of the bindings types are templated types. However due to TCL  restrictions, only some type parameterizations are allowed:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
int - corresponds to TCL_LINK_INT in Tcl_LinkVar e.g.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
double - Corresponds to TCL_LINK_DOUBLE in Tcl_LinkVar e.g.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
bool - Corresponds to TCL_LINK_BOOLEAN in Tcl_LinkVar e.g.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
char* - Corresponds to TCL_LINK_STRING in Tcl_LinkVar e.g.\par
}All of these type parameterizations are straightforward with the exception of char* char* variables are filled in with pointers to malloc'd copies of the contents of the variable after configuration is done. In practice this is only an issue if multiple configurations reads members are performed (e.g. reconfiguration after complete configuration).\par
The major member functions supported by this class are:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
ReadConfigFile - Reads in a single configuration file.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Read1stConfigFile - Reads in a single config file searched from path.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
ReadConfigFiles - Reads in a set of configuration files.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
WriteConfigFile - Writes a file which can recover the current  configuration. \par
}\par
Definition at line 357 of file CConfigurationManager.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CConfigurationManager\:CConfigurationManager}
{\xe \v CConfigurationManager\:CConfigurationManager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CConfigurationManager::CConfigurationManager (){\f2  [inline]}}
}\par
{\bkmkstart classCConfigurationManager_a0}
{\bkmkend classCConfigurationManager_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Default construtor.\par
\par
Definition at line 365 of file CConfigurationManager.h.\par
}
{\xe \v CConfigurationManager\:CConfigurationManager}
{\xe \v CConfigurationManager\:CConfigurationManager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CConfigurationManager::CConfigurationManager (list< {\b CTypeFreeBinding} * > & {\i rBindings}){\f2  [inline]}}
}\par
{\bkmkstart classCConfigurationManager_a1}
{\bkmkend classCConfigurationManager_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Prestocked configuration.\par
\par
Definition at line 366 of file CConfigurationManager.h.\par
\par
References m_lBindings.}
{\xe \v ~CConfigurationManager\:CConfigurationManager}
{\xe \v CConfigurationManager\:~CConfigurationManager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CConfigurationManager::~CConfigurationManager (){\f2  [inline]}}
}\par
{\bkmkstart classCConfigurationManager_a2}
{\bkmkend classCConfigurationManager_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Destruction requires nothing special.\par
\par
Definition at line 368 of file CConfigurationManager.h.\par
}
{\xe \v CConfigurationManager\:CConfigurationManager}
{\xe \v CConfigurationManager\:CConfigurationManager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CConfigurationManager::CConfigurationManager (const CConfigurationManager & {\i rhs}){\f2  [inline]}}
}\par
{\bkmkstart classCConfigurationManager_a3}
{\bkmkend classCConfigurationManager_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Copy constructor.\par
\par
Definition at line 374 of file CConfigurationManager.h.\par
\par
References m_lBindings.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddBinding\:CConfigurationManager}
{\xe \v CConfigurationManager\:AddBinding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CConfigurationManager::AddBinding (list< {\b CTypeFreeBinding} * > {\i addlist}){\f2  [inline]}}
}\par
{\bkmkstart classCConfigurationManager_a10}
{\bkmkend classCConfigurationManager_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i addlist}}  Append list of bindings \par
}Definition at line 401 of file CConfigurationManager.h.\par
\par
References m_lBindings.}
{\xe \v AddBinding\:CConfigurationManager}
{\xe \v CConfigurationManager\:AddBinding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CConfigurationManager::AddBinding ({\b CTypeFreeBinding} & {\i rBinding}){\f2  [inline]}}
}\par
{\bkmkstart classCConfigurationManager_a9}
{\bkmkend classCConfigurationManager_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 398 of file CConfigurationManager.h.\par
\par
References m_lBindings.}
{\xe \v getBindings\:CConfigurationManager}
{\xe \v CConfigurationManager\:getBindings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
list<{\b CTypeFreeBinding}*> CConfigurationManager::getBindings () const{\f2  [inline]}}
}\par
{\bkmkstart classCConfigurationManager_a7}
{\bkmkend classCConfigurationManager_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 388 of file CConfigurationManager.h.\par
\par
References m_lBindings.}
{\xe \v InternalReadConfigFile\:CConfigurationManager}
{\xe \v CConfigurationManager\:InternalReadConfigFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CConfigurationManager::InternalReadConfigFile ({\b CTCLInterpreter} & {\i rInterp}, int {\i fd}){\f2  [protected]}}
}\par
{\bkmkstart classCConfigurationManager_b0}
{\bkmkend classCConfigurationManager_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Internal function to read a configuration file and execute it. since the lowest common denominator is a file descriptor and  Tcl/Tk doesn't have a function to process a script given an fd, we'll read the entire file into a buffer and process the file from that string. In practice, configuration files will not be too large so this will not be a serious problem.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rInterp}}  - Tcl Interpreter which will interpret the file. \par
{\b {\i fd}}  - File descriptor already open on the file.\par
}{{{\b Exceptions: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i {\b CTCLException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCLException \\*MERGEFORMAT}{\fldrslt pagenum}}})}}   - if the script does not parse properly etc. \par
{\b {\i {\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}})}}   - if unable to determine file size.\par
}{{{\b Note: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid It is the caller's responsibility to close the file. \par
}\par
Definition at line 678 of file CConfigurationManager.cpp.\par
\par
References CTCLInterpreter::GlobalEval().\par
Referenced by ReadAllConfigFiles(), and ReadConfigFile().}
{\xe \v operator!=\:CConfigurationManager}
{\xe \v CConfigurationManager\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CConfigurationManager::operator!= (const CConfigurationManager & {\i rhs}){\f2  [inline]}}
}\par
{\bkmkstart classCConfigurationManager_a6}
{\bkmkend classCConfigurationManager_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 382 of file CConfigurationManager.h.\par
\par
References operator==().}
{\xe \v operator=\:CConfigurationManager}
{\xe \v CConfigurationManager\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CConfigurationManager& CConfigurationManager::operator= (const CConfigurationManager & {\i rhs}){\f2  [inline]}}
}\par
{\bkmkstart classCConfigurationManager_a4}
{\bkmkend classCConfigurationManager_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Assignment operator.\par
\par
Definition at line 376 of file CConfigurationManager.h.\par
\par
References m_lBindings.}
{\xe \v operator==\:CConfigurationManager}
{\xe \v CConfigurationManager\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CConfigurationManager::operator== (const CConfigurationManager & {\i rhs}){\f2  [inline]}}
}\par
{\bkmkstart classCConfigurationManager_a5}
{\bkmkend classCConfigurationManager_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 379 of file CConfigurationManager.h.\par
\par
References m_lBindings.\par
Referenced by operator!=().}
{\xe \v Read1stConfigFile\:CConfigurationManager}
{\xe \v CConfigurationManager\:Read1stConfigFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CConfigurationManager::Read1stConfigFile (const vector< string > & {\i Paths}, const string & {\i rName})}
}\par
{\bkmkstart classCConfigurationManager_a16}
{\bkmkend classCConfigurationManager_a16}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Reads the first configuration file which can be opened from a vector of path strings and a string filename. We just call the previous member fucnction passing the c_str() of the filename. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i Paths}}  - STL String vector of paths. \par
{\b {\i rName}}  - STL string filename. \par
}\par
Definition at line 490 of file CConfigurationManager.cpp.\par
\par
References Read1stConfigFile().}
{\xe \v Read1stConfigFile\:CConfigurationManager}
{\xe \v CConfigurationManager\:Read1stConfigFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CConfigurationManager::Read1stConfigFile (const vector< string > & {\i Paths}, const char * {\i pName})}
}\par
{\bkmkstart classCConfigurationManager_a15}
{\bkmkend classCConfigurationManager_a15}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Given a set of directory paths, and a filename which is appended to the path, this member locates the first filename path / filename which can be opened for read and runs it as a configuration file.\par
What really happens is that the path vector and filename are used to create a vector of filenames to try and then the previous member function is called to do the rest. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i Paths}}  - Set of paths within which to search for the filename. \par
{\b {\i pName}}  - Cstring pointer to the filename. \par
}\par
Definition at line 465 of file CConfigurationManager.cpp.\par
\par
References PathSep, and Read1stConfigFile().}
{\xe \v Read1stConfigFile\:CConfigurationManager}
{\xe \v CConfigurationManager\:Read1stConfigFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CConfigurationManager::Read1stConfigFile (const vector< string > & {\i rNames})}
}\par
{\bkmkstart classCConfigurationManager_a14}
{\bkmkend classCConfigurationManager_a14}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Executes the first configuration file which can be successfully opened from a list of configuration files. Note that if none of the configuration files can be located or opened, this function is a silent no-op. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i Names}}  - An STL vector of filenames to search. Names are searched for in vector order.\par
}{{{\b Exceptions: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i {\b CTCLException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCLException \\*MERGEFORMAT}{\fldrslt pagenum}}})}}   - if there was an error executing the script. \par
}\par
Definition at line 434 of file CConfigurationManager.cpp.\par
\par
References ReadConfigFile().\par
Referenced by Read1stConfigFile().}
{\xe \v ReadAllConfigFiles\:CConfigurationManager}
{\xe \v CConfigurationManager\:ReadAllConfigFiles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CConfigurationManager::ReadAllConfigFiles (const vector< string > & {\i rPaths}, const string & {\i rFilename})}
}\par
{\bkmkstart classCConfigurationManager_a19}
{\bkmkend classCConfigurationManager_a19}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Reads all of the configuration files which can be found that are built by concatenating path names with a path separator and a filename. This is done by simply building a vector of the resulting filenames and passing it to the previous member {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rPaths}}  - STL Vector of STL strings which represent filesystem paths in which the file could live. \par
{\b {\i rFilename}}  - STL String which is the filename to execute. \par
}\par
Definition at line 550 of file CConfigurationManager.cpp.\par
\par
References PathSep, and ReadAllConfigFiles().}
{\xe \v ReadAllConfigFiles\:CConfigurationManager}
{\xe \v CConfigurationManager\:ReadAllConfigFiles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CConfigurationManager::ReadAllConfigFiles (const vector< string > & {\i rPaths}, const char * {\i pFilename})}
}\par
{\bkmkstart classCConfigurationManager_a18}
{\bkmkend classCConfigurationManager_a18}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Reads in all files which can be found from the filenames constructed by contcatenating a filename with set of paths. The only difference from the previous member is that the filename is represented as a C null terminated string. We'll generate an STL string from it and delegate to the previous overload. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rPaths}}  - STL vector of STL strings which give the list of paths to search. \par
{\b {\i pFilename}}  - Pointer to a null terminated string of characters which will be appended to each path in turn to generate the names of the script files which will be executed. \par
}\par
Definition at line 579 of file CConfigurationManager.cpp.\par
\par
References ReadAllConfigFiles().}
{\xe \v ReadAllConfigFiles\:CConfigurationManager}
{\xe \v CConfigurationManager\:ReadAllConfigFiles}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CConfigurationManager::ReadAllConfigFiles (const vector< string > & {\i Names})}
}\par
{\bkmkstart classCConfigurationManager_a17}
{\bkmkend classCConfigurationManager_a17}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Reads all configuration files which can be found from a set of filenames. If any filename cannot be found it is silently ignored. Files are executed in vector order.\par
Note that all configuration files are taken as a single configuration. An error in a single configuration script results in an exception which  terminates the search.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i Names}}  - STL vector of STL strings which contains the set of  filenames to try to open.\par
}{{{\b Exceptions: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i {\b CTCLException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCLException \\*MERGEFORMAT}{\fldrslt pagenum}}})}}   - If there is an error executing a script (e.g. syntax). \par
}\par
Definition at line 511 of file CConfigurationManager.cpp.\par
\par
References InternalReadConfigFile(), and m_lBindings.\par
Referenced by ReadAllConfigFiles().}
{\xe \v ReadConfigFile\:CConfigurationManager}
{\xe \v CConfigurationManager\:ReadConfigFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CConfigurationManager::ReadConfigFile (int {\i fd})}
}\par
{\bkmkstart classCConfigurationManager_a13}
{\bkmkend classCConfigurationManager_a13}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Reads a configuration file given that it is open on a file descriptor. The file is interpreted from its current location until end of file. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i fd}}  - File descriptor open on the file.\par
}{{{\b Exceptions: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i {\b CTCLException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCLException \\*MERGEFORMAT}{\fldrslt pagenum}}})}}   - if there was a problem interpreting the script e.g. \par
}\par
Definition at line 399 of file CConfigurationManager.cpp.\par
\par
References InternalReadConfigFile(), and m_lBindings.}
{\xe \v ReadConfigFile\:CConfigurationManager}
{\xe \v CConfigurationManager\:ReadConfigFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CConfigurationManager::ReadConfigFile (const string & {\i rName})}
}\par
{\bkmkstart classCConfigurationManager_a12}
{\bkmkend classCConfigurationManager_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Reads a single configuration file specified by an stl string. Just calls the previous function with the name passed by cstring. See the documentation of the above function for more information. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rName}}  - stl string containing the filename of the configuration script. \par
}\par
Definition at line 387 of file CConfigurationManager.cpp.\par
\par
References ReadConfigFile().}
{\xe \v ReadConfigFile\:CConfigurationManager}
{\xe \v CConfigurationManager\:ReadConfigFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CConfigurationManager::ReadConfigFile (const char * {\i pName})}
}\par
{\bkmkstart classCConfigurationManager_a11}
{\bkmkend classCConfigurationManager_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Reads a single configuration file. This involves:{
\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
1.\tab Ensuring the file exists.\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
2.\tab Creating a {\b CTCLInterpreter} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCLInterpreter \\*MERGEFORMAT}{\fldrslt pagenum}}}) on which to interpret the config file.\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
3.\tab Initializing all bindings on the interpreter.\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
4.\tab Interpreting the script file.\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
5.\tab Committing all bindings on the interpreter.\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
6.\tab Shutting down all bindings on the interpreter.\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
7.\tab Destroying the CTCLIntpereter.\par
}{{{\b Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i pName}}  - Pointer to the name of the file to read. This must be fully specified (absolute or relative path).\par
}{{{\b Exceptions: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i {\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}})}}   - if e.g. file cannot be opened for read. \par
{\b {\i {\b CTCLException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCLException \\*MERGEFORMAT}{\fldrslt pagenum}}})}}   - if there was a problem (e.g. syntax error) interpreting the configuration script. \par
}\par
Definition at line 364 of file CConfigurationManager.cpp.\par
\par
Referenced by Read1stConfigFile(), and ReadConfigFile().}
{\xe \v setBindings\:CConfigurationManager}
{\xe \v CConfigurationManager\:setBindings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CConfigurationManager::setBindings (list< {\b CTypeFreeBinding} * > {\i newBindings}){\f2  [inline]}}
}\par
{\bkmkstart classCConfigurationManager_a8}
{\bkmkend classCConfigurationManager_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Replace all bindings.\par
\par
Definition at line 395 of file CConfigurationManager.h.\par
\par
References m_lBindings.}
{\xe \v WriteConfigFile\:CConfigurationManager}
{\xe \v CConfigurationManager\:WriteConfigFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CConfigurationManager::WriteConfigFile (int {\i fd})}
}\par
{\bkmkstart classCConfigurationManager_a22}
{\bkmkend classCConfigurationManager_a22}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Writes a configuration file which can be re-read to duplicate the current state of the configuration variables. The configuration file will contain a comment which will give the following information:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Identifying information to indicate that this is a configuration file written by the configuration subsystem. - When written\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Name of user executing this program.\par
}{{{\b Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i fd}}  - File descriptor of file open on the output configuration file.\par
}{{{\b Exceptions: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i {\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}})}}   - If there are problems writing to the file.\par
}{{{\b Note: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid It is the caller's responsibilility to close the file. \par
}\par
Definition at line 601 of file CConfigurationManager.cpp.\par
\par
References m_lBindings.}
{\xe \v WriteConfigFile\:CConfigurationManager}
{\xe \v CConfigurationManager\:WriteConfigFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CConfigurationManager::WriteConfigFile (const string & {\i rName})}
}\par
{\bkmkstart classCConfigurationManager_a21}
{\bkmkend classCConfigurationManager_a21}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Writes a configuration file which can be re-read to duplicate the current configuration. The file is specified by an STL string object. This file simply calls the prior overload of this function specifying  the .c_str() return value of the filename. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rName}}  - STL const string& name of the file to write to. \par
}\par
Definition at line 657 of file CConfigurationManager.cpp.\par
\par
References WriteConfigFile().}
{\xe \v WriteConfigFile\:CConfigurationManager}
{\xe \v CConfigurationManager\:WriteConfigFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CConfigurationManager::WriteConfigFile (const char * {\i pName})}
}\par
{\bkmkstart classCConfigurationManager_a20}
{\bkmkend classCConfigurationManager_a20}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Writes a configuraiton file which can be re-read to duplicate the current configuration. The file is specified by a null terminated array of characters (C-string). This function attempts to open the specified file for write and on success delegates the actual  write operation to the previous overload of this function. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i pName}}  - Pointer to the filename as a C-string. \par
}\par
Definition at line 641 of file CConfigurationManager.cpp.\par
\par
Referenced by WriteConfigFile().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_lBindings\:CConfigurationManager}
{\xe \v CConfigurationManager\:m_lBindings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
list<{\b CTypeFreeBinding}*> CConfigurationManager::m_lBindings{\f2  [private]}}
}\par
{\bkmkstart classCConfigurationManager_o0}
{\bkmkend classCConfigurationManager_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
List of configuration bindings.\par
\par
Definition at line 361 of file CConfigurationManager.h.\par
\par
Referenced by AddBinding(), CConfigurationManager(), getBindings(), operator=(), operator==(), ReadAllConfigFiles(), ReadConfigFile(), setBindings(), and WriteConfigFile().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CConfigurationManager.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CConfigurationManager.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CDAQTCLProcessor  Class Reference\par \pard\plain 
{\tc\tcl2 \v CDAQTCLProcessor}
{\xe \v CDAQTCLProcessor}
{\bkmkstart classCDAQTCLProcessor}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CDAQTCLProcessor.h>}\par
Inheritance diagram for CDAQTCLProcessor:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCDAQTCLProcessor.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CDAQTCLProcessor} (const string &rCommand, {\b CTCLInterpreter} *pInterp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CDAQTCLProcessor} (const char *pCommand, {\b CTCLInterpreter} *pInter)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CDAQTCLProcessor} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CDAQTCLProcessor &aCDAQTCLProcessor) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Operator== Equality Operator.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b Register} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CDAQTCLProcessor} (const CDAQTCLProcessor &aCDAQTCLProcessor)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Copy Constructor {\b illegal} and therefore unimplemented.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CDAQTCLProcessor & {\b operator=} (const CDAQTCLProcessor &aCDAQTCLProcessor)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Operator= Assignment Operator {\b illegal} and therefore unimplemented.}\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b EvalRelay} (ClientData pData, Tcl_Interp *pInterp, int Argc, char **Argv)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DeleteRelay} (ClientData pData)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
Provides a synchronized TCL command. Inheriting from this class allows you to produce a TCL command which is synchronized to the application through the application mutex. This member essentially just replaces the TCLProcessor's registration procedures and static callback relay. The static callback relay will now lock the application mutex prior to calling operator() and unlock on return (exception or normal). \par
\par
Definition at line 318 of file CDAQTCLProcessor.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CDAQTCLProcessor\:CDAQTCLProcessor}
{\xe \v CDAQTCLProcessor\:CDAQTCLProcessor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CDAQTCLProcessor::CDAQTCLProcessor (const string & {\i rCommand}, {\b CTCLInterpreter} * {\i pInterp})}
}\par
{\bkmkstart classCDAQTCLProcessor_a0}
{\bkmkend classCDAQTCLProcessor_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Constructor. Builds a new command which will execute synchronized with all other threads in the application. \par
\par
Definition at line 309 of file CDAQTCLProcessor.cpp.\par
}
{\xe \v CDAQTCLProcessor\:CDAQTCLProcessor}
{\xe \v CDAQTCLProcessor\:CDAQTCLProcessor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CDAQTCLProcessor::CDAQTCLProcessor (const char * {\i pCommand}, {\b CTCLInterpreter} * {\i pInterp})}
}\par
{\bkmkstart classCDAQTCLProcessor_a1}
{\bkmkend classCDAQTCLProcessor_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Constructor, Builds a new command which will execute synchronized with all the other threads in the application. \par
\par
Definition at line 319 of file CDAQTCLProcessor.cpp.\par
}
{\xe \v ~CDAQTCLProcessor\:CDAQTCLProcessor}
{\xe \v CDAQTCLProcessor\:~CDAQTCLProcessor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CDAQTCLProcessor::~CDAQTCLProcessor ()}
}\par
{\bkmkstart classCDAQTCLProcessor_a2}
{\bkmkend classCDAQTCLProcessor_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Destructor: The base class will take care of everything we need. The fact that register registered our DeleteRelay will take care of ensuring that OnDelete is executed with application synchronization. \par
\par
Definition at line 301 of file CDAQTCLProcessor.cpp.\par
}
{\xe \v CDAQTCLProcessor\:CDAQTCLProcessor}
{\xe \v CDAQTCLProcessor\:CDAQTCLProcessor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CDAQTCLProcessor::CDAQTCLProcessor (const CDAQTCLProcessor & {\i aCDAQTCLProcessor}){\f2  [private]}}
}\par
{\bkmkstart classCDAQTCLProcessor_c0}
{\bkmkend classCDAQTCLProcessor_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Copy Constructor {\b illegal} and therefore unimplemented.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v DeleteRelay\:CDAQTCLProcessor}
{\xe \v CDAQTCLProcessor\:DeleteRelay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CDAQTCLProcessor::DeleteRelay (ClientData {\i pData}){\f2  [static, private]}}
}\par
{\bkmkstart classCDAQTCLProcessor_f1}
{\bkmkend classCDAQTCLProcessor_f1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Locks the application mutex, call's the object's OnDelete member function (the object is pointed to by the client data parameter), and unlocks the mutex. \par
\par
Reimplemented from {\b CTCLProcessor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCLProcessor_d2 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 374 of file CDAQTCLProcessor.cpp.\par
\par
References CTCLProcessor::DeleteRelay(), CApplicationSerializer::getInstance(), CThreadRecursiveMutex::Lock(), and CThreadRecursiveMutex::UnLock().\par
Referenced by Register().}
{\xe \v EvalRelay\:CDAQTCLProcessor}
{\xe \v CDAQTCLProcessor\:EvalRelay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CDAQTCLProcessor::EvalRelay (ClientData {\i pData}, Tcl_Interp * {\i pInterp}, int {\i Argc}, char ** {\i Argv}){\f2  [static, private]}}
}\par
{\bkmkstart classCDAQTCLProcessor_f0}
{\bkmkend classCDAQTCLProcessor_f0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Locks the application mutex, calls operator() and the unlocks the resource. \par
\par
Definition at line 351 of file CDAQTCLProcessor.cpp.\par
\par
References CTCLProcessor::EvalRelay(), CApplicationSerializer::getInstance(), CThreadRecursiveMutex::Lock(), and CThreadRecursiveMutex::UnLock().\par
Referenced by Register().}
{\xe \v operator=\:CDAQTCLProcessor}
{\xe \v CDAQTCLProcessor\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CDAQTCLProcessor& CDAQTCLProcessor::operator= (const CDAQTCLProcessor & {\i aCDAQTCLProcessor}){\f2  [private]}}
}\par
{\bkmkstart classCDAQTCLProcessor_c1}
{\bkmkend classCDAQTCLProcessor_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operator= Assignment Operator {\b illegal} and therefore unimplemented.\par
}
{\xe \v operator==\:CDAQTCLProcessor}
{\xe \v CDAQTCLProcessor\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CDAQTCLProcessor::operator== (const CDAQTCLProcessor & {\i aCDAQTCLProcessor}) const{\f2  [inline]}}
}\par
{\bkmkstart classCDAQTCLProcessor_a3}
{\bkmkend classCDAQTCLProcessor_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operator== Equality Operator.\par
\par
Definition at line 335 of file CDAQTCLProcessor.h.\par
\par
References CTCLProcessor::operator==().}
{\xe \v Register\:CDAQTCLProcessor}
{\xe \v CDAQTCLProcessor\:Register}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CDAQTCLProcessor::Register (){\f2  [virtual]}}
}\par
{\bkmkstart classCDAQTCLProcessor_a4}
{\bkmkend classCDAQTCLProcessor_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Registers the processor on the current interpreter. This reimplements code from the base class because I need to specify my own Eval and Delete relay  functions (there's naturally no way for static functions to be virtual). \par
\par
Reimplemented from {\b CTCLProcessor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCLProcessor_a15 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 334 of file CDAQTCLProcessor.cpp.\par
\par
References CTCLInterpreter::AddCommand(), CTCLProcessor::AddRegisteredOnCurrent(), CTCLInterpreterObject::AssertIfNotBound(), DeleteRelay(), EvalRelay(), and CTCLProcessor::getCommandName().\par
Referenced by CInterpreterStartup::RegisterExtensions().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CDAQTCLProcessor.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CDAQTCLProcessor.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CDumpBinding  Class Reference\par \pard\plain 
{\tc\tcl2 \v CDumpBinding}
{\xe \v CDumpBinding}
{\bkmkstart classCDumpBinding}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CDumpBinding} (int fd)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b operator()} ({\b CTypeFreeBinding} *pBinding)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b m_fd}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CDumpBinding\:CDumpBinding}
{\xe \v CDumpBinding\:CDumpBinding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CDumpBinding::CDumpBinding (int {\i fd}){\f2  [inline]}}
}\par
{\bkmkstart classCDumpBinding_a0}
{\bkmkend classCDumpBinding_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 338 of file CConfigurationManager.cpp.\par
\par
References m_fd.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator()\:CDumpBinding}
{\xe \v CDumpBinding\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CDumpBinding::operator() ({\b CTypeFreeBinding} * {\i pBinding}){\f2  [inline]}}
}\par
{\bkmkstart classCDumpBinding_a1}
{\bkmkend classCDumpBinding_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 339 of file CConfigurationManager.cpp.\par
\par
References CTypeFreeBinding::Dump(), and m_fd.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_fd\:CDumpBinding}
{\xe \v CDumpBinding\:m_fd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CDumpBinding::m_fd{\f2  [private]}}
}\par
{\bkmkstart classCDumpBinding_o0}
{\bkmkend classCDumpBinding_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 336 of file CConfigurationManager.cpp.\par
\par
Referenced by CDumpBinding(), and operator()().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CConfigurationManager.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CDuplicateNameException  Class Reference\par \pard\plain 
{\tc\tcl2 \v CDuplicateNameException}
{\xe \v CDuplicateNameException}
{\bkmkstart classCDuplicateNameException}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CDuplicateNameException.h>}\par
Inheritance diagram for CDuplicateNameException:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCDuplicateNameException.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CDuplicateNameException} (const char *pDoing, const char *pName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CDuplicateNameException} (const char *pDoing, const string &rName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CDuplicateNameException} (const string &rDoing, const char *pName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CDuplicateNameException} (const string &rDoing, const string &rName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CDuplicateNameException} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CDuplicateNameException} (const CDuplicateNameException &aCDuplicateNameException)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CDuplicateNameException {\b operator=} (const CDuplicateNameException &aCDuplicateNameException)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CDuplicateNameException &aCDuplicateNameException)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b getName} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setName} (string am_sName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const char * {\b ReasonText} () const\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UpdateReasonText} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_sName}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_sReasonText}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CDuplicateNameException\:CDuplicateNameException}
{\xe \v CDuplicateNameException\:CDuplicateNameException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CDuplicateNameException::CDuplicateNameException (const char * {\i pDoing}, const char * {\i pName}){\f2  [inline]}}
}\par
{\bkmkstart classCDuplicateNameException_a0}
{\bkmkend classCDuplicateNameException_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 300 of file CDuplicateNameException.h.\par
\par
References m_sName, and UpdateReasonText().}
{\xe \v CDuplicateNameException\:CDuplicateNameException}
{\xe \v CDuplicateNameException\:CDuplicateNameException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CDuplicateNameException::CDuplicateNameException (const char * {\i pDoing}, const string & {\i rName}){\f2  [inline]}}
}\par
{\bkmkstart classCDuplicateNameException_a1}
{\bkmkend classCDuplicateNameException_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 305 of file CDuplicateNameException.h.\par
\par
References m_sName, and UpdateReasonText().}
{\xe \v CDuplicateNameException\:CDuplicateNameException}
{\xe \v CDuplicateNameException\:CDuplicateNameException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CDuplicateNameException::CDuplicateNameException (const string & {\i rDoing}, const char * {\i pName}){\f2  [inline]}}
}\par
{\bkmkstart classCDuplicateNameException_a2}
{\bkmkend classCDuplicateNameException_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 310 of file CDuplicateNameException.h.\par
\par
References m_sName, and UpdateReasonText().}
{\xe \v CDuplicateNameException\:CDuplicateNameException}
{\xe \v CDuplicateNameException\:CDuplicateNameException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CDuplicateNameException::CDuplicateNameException (const string & {\i rDoing}, const string & {\i rName}){\f2  [inline]}}
}\par
{\bkmkstart classCDuplicateNameException_a3}
{\bkmkend classCDuplicateNameException_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 315 of file CDuplicateNameException.h.\par
\par
References m_sName, and UpdateReasonText().}
{\xe \v ~CDuplicateNameException\:CDuplicateNameException}
{\xe \v CDuplicateNameException\:~CDuplicateNameException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual CDuplicateNameException::~CDuplicateNameException (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCDuplicateNameException_a4}
{\bkmkend classCDuplicateNameException_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 320 of file CDuplicateNameException.h.\par
}
{\xe \v CDuplicateNameException\:CDuplicateNameException}
{\xe \v CDuplicateNameException\:CDuplicateNameException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CDuplicateNameException::CDuplicateNameException (const CDuplicateNameException & {\i aCDuplicateNameException}){\f2  [inline]}}
}\par
{\bkmkstart classCDuplicateNameException_a5}
{\bkmkend classCDuplicateNameException_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 324 of file CDuplicateNameException.h.\par
\par
References m_sName, and UpdateReasonText().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getName\:CDuplicateNameException}
{\xe \v CDuplicateNameException\:getName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CDuplicateNameException::getName () const{\f2  [inline]}}
}\par
{\bkmkstart classCDuplicateNameException_a8}
{\bkmkend classCDuplicateNameException_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 354 of file CDuplicateNameException.h.\par
\par
References m_sName.}
{\xe \v operator=\:CDuplicateNameException}
{\xe \v CDuplicateNameException\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CDuplicateNameException CDuplicateNameException::operator= (const CDuplicateNameException & {\i aCDuplicateNameException}){\f2  [inline]}}
}\par
{\bkmkstart classCDuplicateNameException_a6}
{\bkmkend classCDuplicateNameException_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 334 of file CDuplicateNameException.h.\par
\par
References m_sName, CException::operator=(), and UpdateReasonText().}
{\xe \v operator==\:CDuplicateNameException}
{\xe \v CDuplicateNameException\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CDuplicateNameException::operator== (const CDuplicateNameException & {\i aCDuplicateNameException}){\f2  [inline]}}
}\par
{\bkmkstart classCDuplicateNameException_a7}
{\bkmkend classCDuplicateNameException_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 345 of file CDuplicateNameException.h.\par
\par
References m_sName, and CException::operator==().}
{\xe \v ReasonText\:CDuplicateNameException}
{\xe \v CDuplicateNameException\:ReasonText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * CDuplicateNameException::ReasonText () const{\f2  [virtual]}}
}\par
{\bkmkstart classCDuplicateNameException_a10}
{\bkmkend classCDuplicateNameException_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns a const pointer to text which describes the reason the exception was thrown. This is exception type specific. The default action returns a pointer to the constant string: "Unspecified Exception" \par
\par
Reimplemented from {\b CException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCException_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 284 of file CDuplicateNameException.cpp.\par
\par
References m_sReasonText.}
{\xe \v setName\:CDuplicateNameException}
{\xe \v CDuplicateNameException\:setName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CDuplicateNameException::setName (string {\i am_sName}){\f2  [inline]}}
}\par
{\bkmkstart classCDuplicateNameException_a9}
{\bkmkend classCDuplicateNameException_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 360 of file CDuplicateNameException.h.\par
\par
References m_sName.}
{\xe \v UpdateReasonText\:CDuplicateNameException}
{\xe \v CDuplicateNameException\:UpdateReasonText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CDuplicateNameException::UpdateReasonText (){\f2  [protected]}}
}\par
{\bkmkstart classCDuplicateNameException_b0}
{\bkmkend classCDuplicateNameException_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 290 of file CDuplicateNameException.cpp.\par
\par
References m_sName, and m_sReasonText.\par
Referenced by CDuplicateNameException(), and operator=().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_sName\:CDuplicateNameException}
{\xe \v CDuplicateNameException\:m_sName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CDuplicateNameException::m_sName{\f2  [private]}}
}\par
{\bkmkstart classCDuplicateNameException_o0}
{\bkmkend classCDuplicateNameException_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 295 of file CDuplicateNameException.h.\par
\par
Referenced by CDuplicateNameException(), getName(), operator=(), operator==(), setName(), and UpdateReasonText().}
{\xe \v m_sReasonText\:CDuplicateNameException}
{\xe \v CDuplicateNameException\:m_sReasonText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CDuplicateNameException::m_sReasonText{\f2  [private]}}
}\par
{\bkmkstart classCDuplicateNameException_o1}
{\bkmkend classCDuplicateNameException_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 296 of file CDuplicateNameException.h.\par
\par
Referenced by ReasonText(), and UpdateReasonText().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CDuplicateNameException.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CDuplicateNameException.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CDuplicateSingleton  Class Reference\par \pard\plain 
{\tc\tcl2 \v CDuplicateSingleton}
{\xe \v CDuplicateSingleton}
{\bkmkstart classCDuplicateSingleton}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CDuplicateSingleton.h>}\par
Inheritance diagram for CDuplicateSingleton:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCDuplicateSingleton.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CDuplicateSingleton} (const char *pDoing, const char *pName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CDuplicateSingleton} (const char *pDoing, const string &rName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CDuplicateSingleton} (const string &rDoing, const char *pName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CDuplicateSingleton} (const string &rDoing, const string &rName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CDuplicateSingleton} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CDuplicateSingleton} (const CDuplicateSingleton &aCDuplicateSingleton)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CDuplicateSingleton {\b operator=} (const CDuplicateSingleton &aCDuplicateSingleton)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CDuplicateSingleton &aCDuplicateSingleton)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b getName} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setName} (string am_sName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const char * {\b ReasonText} () const\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UpdateReasonText} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_sName}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_sReasonText}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CDuplicateSingleton\:CDuplicateSingleton}
{\xe \v CDuplicateSingleton\:CDuplicateSingleton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CDuplicateSingleton::CDuplicateSingleton (const char * {\i pDoing}, const char * {\i pName}){\f2  [inline]}}
}\par
{\bkmkstart classCDuplicateSingleton_a0}
{\bkmkend classCDuplicateSingleton_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 299 of file CDuplicateSingleton.h.\par
\par
References m_sName, and UpdateReasonText().}
{\xe \v CDuplicateSingleton\:CDuplicateSingleton}
{\xe \v CDuplicateSingleton\:CDuplicateSingleton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CDuplicateSingleton::CDuplicateSingleton (const char * {\i pDoing}, const string & {\i rName}){\f2  [inline]}}
}\par
{\bkmkstart classCDuplicateSingleton_a1}
{\bkmkend classCDuplicateSingleton_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 304 of file CDuplicateSingleton.h.\par
\par
References m_sName, and UpdateReasonText().}
{\xe \v CDuplicateSingleton\:CDuplicateSingleton}
{\xe \v CDuplicateSingleton\:CDuplicateSingleton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CDuplicateSingleton::CDuplicateSingleton (const string & {\i rDoing}, const char * {\i pName}){\f2  [inline]}}
}\par
{\bkmkstart classCDuplicateSingleton_a2}
{\bkmkend classCDuplicateSingleton_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 309 of file CDuplicateSingleton.h.\par
\par
References m_sName, and UpdateReasonText().}
{\xe \v CDuplicateSingleton\:CDuplicateSingleton}
{\xe \v CDuplicateSingleton\:CDuplicateSingleton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CDuplicateSingleton::CDuplicateSingleton (const string & {\i rDoing}, const string & {\i rName}){\f2  [inline]}}
}\par
{\bkmkstart classCDuplicateSingleton_a3}
{\bkmkend classCDuplicateSingleton_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 314 of file CDuplicateSingleton.h.\par
\par
References m_sName, and UpdateReasonText().}
{\xe \v ~CDuplicateSingleton\:CDuplicateSingleton}
{\xe \v CDuplicateSingleton\:~CDuplicateSingleton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual CDuplicateSingleton::~CDuplicateSingleton (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCDuplicateSingleton_a4}
{\bkmkend classCDuplicateSingleton_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 319 of file CDuplicateSingleton.h.\par
}
{\xe \v CDuplicateSingleton\:CDuplicateSingleton}
{\xe \v CDuplicateSingleton\:CDuplicateSingleton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CDuplicateSingleton::CDuplicateSingleton (const CDuplicateSingleton & {\i aCDuplicateSingleton}){\f2  [inline]}}
}\par
{\bkmkstart classCDuplicateSingleton_a5}
{\bkmkend classCDuplicateSingleton_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 323 of file CDuplicateSingleton.h.\par
\par
References m_sName, and UpdateReasonText().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getName\:CDuplicateSingleton}
{\xe \v CDuplicateSingleton\:getName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CDuplicateSingleton::getName () const{\f2  [inline]}}
}\par
{\bkmkstart classCDuplicateSingleton_a8}
{\bkmkend classCDuplicateSingleton_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 353 of file CDuplicateSingleton.h.\par
\par
References m_sName.}
{\xe \v operator=\:CDuplicateSingleton}
{\xe \v CDuplicateSingleton\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CDuplicateSingleton CDuplicateSingleton::operator= (const CDuplicateSingleton & {\i aCDuplicateSingleton}){\f2  [inline]}}
}\par
{\bkmkstart classCDuplicateSingleton_a6}
{\bkmkend classCDuplicateSingleton_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 333 of file CDuplicateSingleton.h.\par
\par
References m_sName, CException::operator=(), and UpdateReasonText().}
{\xe \v operator==\:CDuplicateSingleton}
{\xe \v CDuplicateSingleton\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CDuplicateSingleton::operator== (const CDuplicateSingleton & {\i aCDuplicateSingleton}){\f2  [inline]}}
}\par
{\bkmkstart classCDuplicateSingleton_a7}
{\bkmkend classCDuplicateSingleton_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 344 of file CDuplicateSingleton.h.\par
\par
References m_sName, and CException::operator==().}
{\xe \v ReasonText\:CDuplicateSingleton}
{\xe \v CDuplicateSingleton\:ReasonText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * CDuplicateSingleton::ReasonText () const{\f2  [virtual]}}
}\par
{\bkmkstart classCDuplicateSingleton_a10}
{\bkmkend classCDuplicateSingleton_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns a const pointer to text which describes the reason the exception was thrown. This is exception type specific. The default action returns a pointer to the constant string: "Unspecified Exception" \par
\par
Reimplemented from {\b CException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCException_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 283 of file CDuplicateSingleton.cpp.\par
\par
References m_sReasonText.}
{\xe \v setName\:CDuplicateSingleton}
{\xe \v CDuplicateSingleton\:setName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CDuplicateSingleton::setName (string {\i am_sName}){\f2  [inline]}}
}\par
{\bkmkstart classCDuplicateSingleton_a9}
{\bkmkend classCDuplicateSingleton_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 359 of file CDuplicateSingleton.h.\par
\par
References m_sName.}
{\xe \v UpdateReasonText\:CDuplicateSingleton}
{\xe \v CDuplicateSingleton\:UpdateReasonText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CDuplicateSingleton::UpdateReasonText (){\f2  [protected]}}
}\par
{\bkmkstart classCDuplicateSingleton_b0}
{\bkmkend classCDuplicateSingleton_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 289 of file CDuplicateSingleton.cpp.\par
\par
References m_sName, and m_sReasonText.\par
Referenced by CDuplicateSingleton(), and operator=().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_sName\:CDuplicateSingleton}
{\xe \v CDuplicateSingleton\:m_sName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CDuplicateSingleton::m_sName{\f2  [private]}}
}\par
{\bkmkstart classCDuplicateSingleton_o0}
{\bkmkend classCDuplicateSingleton_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 295 of file CDuplicateSingleton.h.\par
\par
Referenced by CDuplicateSingleton(), getName(), operator=(), operator==(), setName(), and UpdateReasonText().}
{\xe \v m_sReasonText\:CDuplicateSingleton}
{\xe \v CDuplicateSingleton\:m_sReasonText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CDuplicateSingleton::m_sReasonText{\f2  [private]}}
}\par
{\bkmkstart classCDuplicateSingleton_o1}
{\bkmkend classCDuplicateSingleton_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 296 of file CDuplicateSingleton.h.\par
\par
Referenced by ReasonText(), and UpdateReasonText().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CDuplicateSingleton.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CDuplicateSingleton.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CErrnoException  Class Reference\par \pard\plain 
{\tc\tcl2 \v CErrnoException}
{\xe \v CErrnoException}
{\bkmkstart classCErrnoException}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CErrnoException.h>}\par
Inheritance diagram for CErrnoException:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCErrnoException.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CErrnoException} (const char *pszAction)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CErrnoException} (const std::string &rsAction)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CErrnoException} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CErrnoException} (const CErrnoException &aCErrnoException)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CErrnoException & {\b operator=} (const CErrnoException &aCErrnoException)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CErrnoException &aCErrnoException)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Int_t} {\b getErrno} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const char * {\b ReasonText} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Int_t} {\b ReasonCode} () const\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setErrno} ({\b Int_t} am_nErrno)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Int_t} {\b m_nErrno}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CErrnoException\:CErrnoException}
{\xe \v CErrnoException\:CErrnoException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CErrnoException::CErrnoException (const char * {\i pszAction}){\f2  [inline]}}
}\par
{\bkmkstart classCErrnoException_a0}
{\bkmkend classCErrnoException_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 325 of file CErrnoException.h.\par
\par
References m_nErrno.}
{\xe \v CErrnoException\:CErrnoException}
{\xe \v CErrnoException\:CErrnoException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CErrnoException::CErrnoException (const std::string & {\i rsAction}){\f2  [inline]}}
}\par
{\bkmkstart classCErrnoException_a1}
{\bkmkend classCErrnoException_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 328 of file CErrnoException.h.\par
\par
References m_nErrno.}
{\xe \v ~CErrnoException\:CErrnoException}
{\xe \v CErrnoException\:~CErrnoException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CErrnoException::~CErrnoException (){\f2  [inline]}}
}\par
{\bkmkstart classCErrnoException_a2}
{\bkmkend classCErrnoException_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 331 of file CErrnoException.h.\par
}
{\xe \v CErrnoException\:CErrnoException}
{\xe \v CErrnoException\:CErrnoException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CErrnoException::CErrnoException (const CErrnoException & {\i aCErrnoException}){\f2  [inline]}}
}\par
{\bkmkstart classCErrnoException_a3}
{\bkmkend classCErrnoException_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 335 of file CErrnoException.h.\par
\par
References m_nErrno.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getErrno\:CErrnoException}
{\xe \v CErrnoException\:getErrno}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Int_t} CErrnoException::getErrno () const{\f2  [inline]}}
}\par
{\bkmkstart classCErrnoException_a6}
{\bkmkend classCErrnoException_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 361 of file CErrnoException.h.\par
\par
References Int_t, and m_nErrno.}
{\xe \v operator=\:CErrnoException}
{\xe \v CErrnoException\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CErrnoException& CErrnoException::operator= (const CErrnoException & {\i aCErrnoException}){\f2  [inline]}}
}\par
{\bkmkstart classCErrnoException_a4}
{\bkmkend classCErrnoException_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 342 of file CErrnoException.h.\par
\par
References m_nErrno, and CException::operator=().\par
Referenced by CTCPNoSuchService::operator=(), CTCPConnectionLost::operator=(), and CTCPConnectionFailed::operator=().}
{\xe \v operator==\:CErrnoException}
{\xe \v CErrnoException\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CErrnoException::operator== (const CErrnoException & {\i aCErrnoException}){\f2  [inline]}}
}\par
{\bkmkstart classCErrnoException_a5}
{\bkmkend classCErrnoException_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 352 of file CErrnoException.h.\par
\par
References m_nErrno, and CException::operator==().\par
Referenced by CTCPNoSuchService::operator==(), CTCPConnectionLost::operator==(), and CTCPConnectionFailed::operator==().}
{\xe \v ReasonCode\:CErrnoException}
{\xe \v CErrnoException\:ReasonCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Int_t} CErrnoException::ReasonCode () const{\f2  [virtual]}}
}\par
{\bkmkstart classCErrnoException_a8}
{\bkmkend classCErrnoException_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Return an integer valued code which indicates the reason for the exception. This value is exception type dependent. for CErrnoException, the value is the value of errno at the time the exception was instantiated. \par
\par
Reimplemented from {\b CException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCException_a9 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 342 of file CErrnoException.cpp.\par
\par
References m_nErrno.}
{\xe \v ReasonText\:CErrnoException}
{\xe \v CErrnoException\:ReasonText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * CErrnoException::ReasonText () const{\f2  [virtual]}}
}\par
{\bkmkstart classCErrnoException_a7}
{\bkmkend classCErrnoException_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Return the textual reason for the error. This is done by asking for the strerror of m_nErrno. Note therefore that the reason text returned relates to the value of errno at the time the exception was thrown, not the current time. \par
\par
Reimplemented from {\b CException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCException_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Reimplemented in {\b CTCPConnectionFailed} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPConnectionFailed_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CTCPConnectionLost} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPConnectionLost_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b CTCPNoSuchService} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPNoSuchService_a6 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 323 of file CErrnoException.cpp.\par
\par
References m_nErrno.\par
Referenced by CTCPNoSuchService::ReasonText(), CTCPConnectionLost::ReasonText(), and CTCPConnectionFailed::ReasonText().}
{\xe \v setErrno\:CErrnoException}
{\xe \v CErrnoException\:setErrno}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CErrnoException::setErrno ({\b Int_t} {\i am_nErrno}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCErrnoException_b0}
{\bkmkend classCErrnoException_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 367 of file CErrnoException.h.\par
\par
References Int_t, and m_nErrno.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_nErrno\:CErrnoException}
{\xe \v CErrnoException\:m_nErrno}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Int_t} CErrnoException::m_nErrno{\f2  [private]}}
}\par
{\bkmkstart classCErrnoException_o0}
{\bkmkend classCErrnoException_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 319 of file CErrnoException.h.\par
\par
Referenced by CErrnoException(), getErrno(), operator=(), operator==(), ReasonCode(), ReasonText(), and setErrno().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CErrnoException.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CErrnoException.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CEvent  Class Reference\par \pard\plain 
{\tc\tcl2 \v CEvent}
{\xe \v CEvent}
{\bkmkstart classCEvent}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CEvent.h>}\par
Inheritance diagram for CEvent:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCEvent.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CEvent} ({\b CEventMonitor} &rMonitor, {\b CReactor} &rReactor, bool InformTimeouts=false, int nTimeoutMs=500)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CEvent} (const char *pName, {\b CEventMonitor} &rMonitor, {\b CReactor} &rReactor, bool InformTimeouts=false, int nTimeoutMs=500)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CEvent} (const string &rName, {\b CEventMonitor} &rMonitor, {\b CReactor} &rReactor, bool InformTimeouts=false, int nTimeoutMs=500)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CEvent} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isEnabled} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Return TRUE if the thread is enabled if not thread halt is pending.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isActive} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Return TRUE if the thread is running (active) (small timing hole).}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getInformTimeout} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Return TRUE if Reactor also catches timeouts.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getMsReactivity} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Return the reactivity of the event to programmatic stimulus.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CEventMonitor} & {\b getMonitor} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Allow manipulation of the event monitor:.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CReactor} & {\b getReactor} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Allow manipulation of the event reactor:.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
DAQThreadId {\b getThreadId} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Allow external manipulation of the thread:.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Enable} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Disable} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setReactivity} (int nMs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setEnable} (bool fEnable)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ReactToTimeouts} (bool fReact=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual string {\b DescribeSelf} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setActive} (bool fActive)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set state of active flag.. implies thread is running.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTid} (const DAQThreadId Tid)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set Thread ID: implies you know a lot about the system.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnEvent} ({\b CEventMonitor::result} why)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Schedule} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b operator()} (int nargs, char **ppArgs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b ProcessQueues} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
DAQStatus {\b JoinThis} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CEvent} (const CEvent &aCEvent)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Copy Constructor - not allowed.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CEvent & {\b operator=} (const CEvent &aCEvent)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Operator= Assignment Operator - not allowed.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CEvent &aCEvent) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Operator== Equality Operator no point.}\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b m_fEnabled}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Event enabled flag.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b m_fActive}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i True if thread is active.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b m_InformTimeouts}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Pass timeouts on to reactor.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b m_nMsReactivity}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Reactivity to external events.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CEventMonitor} & {\b m_rMonitor}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Monitor which polls for event.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CReactor} & {\b m_rReactor}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Reactor to the event when it fires.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
DAQThreadId {\b m_Tid}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i spectrodaq thread identifier.}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
Encapsulates event handling. Events consist of an event monitor which is responsible for determining when an event fires and a reactor which provides application specific handling of the event.  When enabled, the event will schedule a thread m_EventThread to process the event. The event thread contains code to repeatedly calll the monitor's operator(), lock the global mutex and call the reactor's operator(). The reactors provided with  classes derived from this are generally standardized to invoke Subclass virtual function which are specific to the event being managed.. \par
\par
Definition at line 331 of file CEvent.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CEvent\:CEvent}
{\xe \v CEvent\:CEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CEvent::CEvent ({\b CEventMonitor} & {\i rMonitor}, {\b CReactor} & {\i rReactor}, bool {\i InformTimeouts} = false, int {\i nTimeoutMs} = 500)}
}\par
{\bkmkstart classCEvent_a0}
{\bkmkend classCEvent_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct an "anonymous" event object. Anonymous event objects have names like EventThread(unique_index). All Event objects will be registered in the "Event" registry of the application's global  object classified registry.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rMonitor}}  - The monitor which notices events. \par
{\b {\i rReactor}}  - The reactor which does stuff when an event fires. \par
{\b {\i InformTimeouts}}  [false] - Optional parameter which, if true, allows the Reactor to be called when the monitor times out. \par
{\b {\i Enabled}}  [true] - Optional parameter which when true indicates that the constructor should begin execution of the Event monitoring thread. If false, a call to the Enable member is required to start execution. \par
{\b {\i nTimeoutMs}}  - The timeout in ms for the Event monitor. Timeouts are an essential part of the event thread. The thread can only react to externally generated attempts to Disable it after the Monitor returns. The timeout in ms therefore is a measure of the  reactiveness of the event to programmatic stimulus from other threads. For 'permanent' events, use a timeout of -1 which will cause the monitor to be configured to run without a timeout. NOTE:{\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
The Event runs as a separate thread in the process. Destruction implies an attempt to kill the thread and join with it and may therefore be a time consuming process if the thread is active with a long or  nonexistent timeout.\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
All calls to the reactor are synchronized with the application  global mutex. \par
}}\par
Definition at line 358 of file CEvent.cpp.\par
\par
References CNamedObject::AppendClassInfo(), and RegistryName.}
{\xe \v CEvent\:CEvent}
{\xe \v CEvent\:CEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CEvent::CEvent (const char * {\i pName}, {\b CEventMonitor} & {\i rMonitor}, {\b CReactor} & {\i rReactor}, bool {\i InformTimeouts} = false, int {\i nTimeoutMs} = 500)}
}\par
{\bkmkstart classCEvent_a1}
{\bkmkend classCEvent_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct a named event object. See the previous overload of {\b CEvent::CEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent_a0 \\*MERGEFORMAT}{\fldrslt pagenum}}}) for most of the descriptive information. However:{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i pName}}  - the name of the event object.\par
}Throws:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CDuplicateNameException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDuplicateNameException \\*MERGEFORMAT}{\fldrslt pagenum}}}) if there is already an Event derived object with this name. \par
}\par
Definition at line 384 of file CEvent.cpp.\par
\par
References CNamedObject::AppendClassInfo(), and RegistryName.}
{\xe \v CEvent\:CEvent}
{\xe \v CEvent\:CEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CEvent::CEvent (const string & {\i rName}, {\b CEventMonitor} & {\i rMonitor}, {\b CReactor} & {\i rReactor}, bool {\i InformTimeouts} = false, int {\i nTimeoutMs} = 500)}
}\par
{\bkmkstart classCEvent_a2}
{\bkmkend classCEvent_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct a named event object. See the previous overloads of  {\b CEvent::CEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent_a0 \\*MERGEFORMAT}{\fldrslt pagenum}}}), however:{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rName}}  - STL String name of event.\par
}Throws:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CDuplicateNameException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDuplicateNameException \\*MERGEFORMAT}{\fldrslt pagenum}}}) if there is already an Event derived object with this name. \par
}\par
Definition at line 410 of file CEvent.cpp.\par
\par
References CNamedObject::AppendClassInfo(), and RegistryName.}
{\xe \v ~CEvent\:CEvent}
{\xe \v CEvent\:~CEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CEvent::~CEvent (){\f2  [virtual]}}
}\par
{\bkmkstart classCEvent_a3}
{\bkmkend classCEvent_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Destroys an instance of ourselves. This implies that our thread will exit. In general the destructor will not be called from this thread. \par
\par
Definition at line 431 of file CEvent.cpp.\par
\par
References Disable().}
{\xe \v CEvent\:CEvent}
{\xe \v CEvent\:CEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CEvent::CEvent (const CEvent & {\i aCEvent}){\f2  [private]}}
}\par
{\bkmkstart classCEvent_c0}
{\bkmkend classCEvent_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Copy Constructor - not allowed.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v DescribeSelf\:CEvent}
{\xe \v CEvent\:DescribeSelf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CEvent::DescribeSelf (){\f2  [virtual]}}
}\par
{\bkmkstart classCEvent_a16}
{\bkmkend classCEvent_a16}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Produce a string describing this : \par
\par
Reimplemented from {\b CNamedObject} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNamedObject_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Reimplemented in {\b CBufferEvent< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferEvent_a14 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CFileEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFileEvent_a19 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CLocationEvent< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCLocationEvent_a10 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CServerConnectionEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCServerConnectionEvent_a14 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CServerInstance} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCServerInstance_a11 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CTimerEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTimerEvent_a12 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b CBufferEvent< U >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferEvent_a14 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 534 of file CEvent.cpp.\par
\par
References CNamedObject::DescribeSelf(), m_fActive, m_fEnabled, m_nMsReactivity, m_rMonitor, and m_rReactor.\par
Referenced by CTimerEvent::DescribeSelf(), CServerInstance::DescribeSelf(), CServerConnectionEvent::DescribeSelf(), CLocationEvent< T >::DescribeSelf(), CFileEvent::DescribeSelf(), and CBufferEvent< T >::DescribeSelf().}
{\xe \v Disable\:CEvent}
{\xe \v CEvent\:Disable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CEvent::Disable ()}
}\par
{\bkmkstart classCEvent_a12}
{\bkmkend classCEvent_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Disable execution of the event. A join is done with the event to ensure that it actually exits. There are two cases:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
m_fActive == true - The thread is active m_fEnabled is set false, after some time, the thread will actually exit. We join with it to ensure that by the time Disable is exited, the thread has exited too.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
m_fActive == false - The thread is not active, we can just return.\par
}{{{\b Note: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid If the calling thread owns the global serialization mutex, it will be temporarily released. If this were not done, the Join could  deadlock the initiating thread and the thread being killed:{\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
The initiating thread will wait on the event thread to die, while holding the serialization mutex.\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
The Event thread will wait on the serialization mutex before it can notice that it has been asked to exit. \par
}}\par
Definition at line 479 of file CEvent.cpp.\par
\par
References CApplicationSerializer::getInstance(), CThreadRecursiveMutex::getLockLevel(), CThreadRecursiveMutex::getOwningThread(), CThreadRecursiveMutex::Lock(), m_fEnabled, m_Tid, and CThreadRecursiveMutex::UnLockCompletely().\par
Referenced by ~CEvent().}
{\xe \v Enable\:CEvent}
{\xe \v CEvent\:Enable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CEvent::Enable ()}
}\par
{\bkmkstart classCEvent_a11}
{\bkmkend classCEvent_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Enable execution of the event. This is intended to be called from outside the Event thread. This allows us to directly schedule the object as a thread, rather than going through the rigmarole required by {\b CEvent::Schedule} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent_b3 \\*MERGEFORMAT}{\fldrslt pagenum}}})\par
{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Enabling an active thread is a no-op.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The enable state is a flag, not a counter, so only a single disable is required to kill the thread regardless of the number of Enable calls. \par
}\par
Reimplemented in {\b CTimerEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTimerEvent_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 449 of file CEvent.cpp.\par
\par
References CApplicationSerializer::getInstance(), CThreadRecursiveMutex::Lock(), m_fEnabled, m_Tid, and CThreadRecursiveMutex::UnLock().\par
Referenced by CTimerEvent::Enable().}
{\xe \v getInformTimeout\:CEvent}
{\xe \v CEvent\:getInformTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CEvent::getInformTimeout () const{\f2  [inline]}}
}\par
{\bkmkstart classCEvent_a6}
{\bkmkend classCEvent_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Return TRUE if Reactor also catches timeouts.\par
\par
Definition at line 390 of file CEvent.h.\par
\par
References m_InformTimeouts.}
{\xe \v getMonitor\:CEvent}
{\xe \v CEvent\:getMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CEventMonitor}& CEvent::getMonitor (){\f2  [inline]}}
}\par
{\bkmkstart classCEvent_a8}
{\bkmkend classCEvent_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Allow manipulation of the event monitor:.\par
\par
Reimplemented in {\b CBufferEvent< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferEvent_a6 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CLocationEvent< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCLocationEvent_a4 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CTimerEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTimerEvent_a4 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b CBufferEvent< U >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferEvent_a6 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 398 of file CEvent.h.\par
\par
Referenced by CFileEvent::MonitorExceptions(), CFileEvent::MonitorReadable(), CFileEvent::MonitorWritable(), and CFileEvent::~CFileEvent().}
{\xe \v getMsReactivity\:CEvent}
{\xe \v CEvent\:getMsReactivity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CEvent::getMsReactivity () const{\f2  [inline]}}
}\par
{\bkmkstart classCEvent_a7}
{\bkmkend classCEvent_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Return the reactivity of the event to programmatic stimulus.\par
\par
Definition at line 394 of file CEvent.h.\par
\par
References m_nMsReactivity.}
{\xe \v getReactor\:CEvent}
{\xe \v CEvent\:getReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CReactor}& CEvent::getReactor (){\f2  [inline]}}
}\par
{\bkmkstart classCEvent_a9}
{\bkmkend classCEvent_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Allow manipulation of the event reactor:.\par
\par
Reimplemented in {\b CBufferEvent< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferEvent_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CLocationEvent< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCLocationEvent_a5 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CTimerEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTimerEvent_a5 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b CBufferEvent< U >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferEvent_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 402 of file CEvent.h.\par
\par
Referenced by CFileEvent::~CFileEvent().}
{\xe \v getThreadId\:CEvent}
{\xe \v CEvent\:getThreadId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DAQThreadId CEvent::getThreadId () const{\f2  [inline]}}
}\par
{\bkmkstart classCEvent_a10}
{\bkmkend classCEvent_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Allow external manipulation of the thread:.\par
\par
Definition at line 406 of file CEvent.h.\par
\par
References m_Tid.}
{\xe \v isActive\:CEvent}
{\xe \v CEvent\:isActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CEvent::isActive () const{\f2  [inline]}}
}\par
{\bkmkstart classCEvent_a5}
{\bkmkend classCEvent_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Return TRUE if the thread is running (active) (small timing hole).\par
\par
Definition at line 386 of file CEvent.h.\par
\par
References m_fActive.}
{\xe \v isEnabled\:CEvent}
{\xe \v CEvent\:isEnabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CEvent::isEnabled () const{\f2  [inline]}}
}\par
{\bkmkstart classCEvent_a4}
{\bkmkend classCEvent_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Return TRUE if the thread is enabled if not thread halt is pending.\par
\par
Definition at line 382 of file CEvent.h.\par
\par
References m_fEnabled.}
{\xe \v JoinThis\:CEvent}
{\xe \v CEvent\:JoinThis}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DAQStatus CEvent::JoinThis (){\f2  [protected]}}
}\par
{\bkmkstart classCEvent_b6}
{\bkmkend classCEvent_b6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Does a join on the current object. The assumption is that at some time this object exists as a thread and will exit to be joined before restarting. \par
\par
Definition at line 638 of file CEvent.cpp.\par
\par
References m_Tid.}
{\xe \v OnEvent\:CEvent}
{\xe \v CEvent\:OnEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CEvent::OnEvent ({\b CEventMonitor::result} {\i why}){\f2  [protected, virtual]}}
}\par
{\bkmkstart classCEvent_b2}
{\bkmkend classCEvent_b2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called when the event monitor indicates that an event has occured. The default action (overridable) is to: 1. Lock the global serialization mutex. 2. Call the Event reactor's operator() member function. 3. Unlock the global serialization mutex.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i why}}  - Indicates what condition the monitor signalled. \par
}\par
Definition at line 565 of file CEvent.cpp.\par
\par
References CApplicationSerializer::getInstance(), CThreadRecursiveMutex::Lock(), m_InformTimeouts, m_rMonitor, m_rReactor, ProcessQueues(), CEventMonitor::result, CEventMonitor::TimedOut, and CThreadRecursiveMutex::UnLock().\par
Referenced by operator()().}
{\xe \v operator()\:CEvent}
{\xe \v CEvent\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CEvent::operator() (int {\i nargs}, char ** {\i ppArgs}){\f2  [protected, virtual]}}
}\par
{\bkmkstart classCEvent_b4}
{\bkmkend classCEvent_b4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
This is the Event thread's entry point when scheduled. {\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Reap the scheduler thread.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Delete the scheduler object which started us.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Enter the main event loop of polling the monitor and dipatching to the  reactor.\par
}{{{\b Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i nargs}}  - Number of parameters. \par
{\b {\i ppargs}}  - Pointer to the arguments. In this case it's just a pointer to the dispatching thread's object. \par
}\par
Reimplemented in {\b CLocationEvent< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCLocationEvent_b0 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 616 of file CEvent.cpp.\par
\par
References m_fActive, m_nMsReactivity, m_rMonitor, m_Tid, OnEvent(), and CEventMonitor::setTimeout().\par
Referenced by CLocationEvent< T >::operator()().}
{\xe \v operator=\:CEvent}
{\xe \v CEvent\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CEvent& CEvent::operator= (const CEvent & {\i aCEvent}){\f2  [private]}}
}\par
{\bkmkstart classCEvent_c1}
{\bkmkend classCEvent_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operator= Assignment Operator - not allowed.\par
}
{\xe \v operator==\:CEvent}
{\xe \v CEvent\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CEvent::operator== (const CEvent & {\i aCEvent}) const{\f2  [private]}}
}\par
{\bkmkstart classCEvent_c2}
{\bkmkend classCEvent_c2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operator== Equality Operator no point.\par
}
{\xe \v ProcessQueues\:CEvent}
{\xe \v CEvent\:ProcessQueues}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CEvent::ProcessQueues (){\f2  [protected, virtual]}}
}\par
{\bkmkstart classCEvent_b5}
{\bkmkend classCEvent_b5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called periodically in event thread context to process any  inter thread communication primitives which may require action at event context. \par
\par
Reimplemented in {\b CBufferEvent< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferEvent_b0 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b CBufferEvent< U >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferEvent_b0 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 650 of file CEvent.cpp.\par
\par
Referenced by OnEvent().}
{\xe \v ReactToTimeouts\:CEvent}
{\xe \v CEvent\:ReactToTimeouts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CEvent::ReactToTimeouts (bool {\i fReact} = true)}
}\par
{\bkmkstart classCEvent_a15}
{\bkmkend classCEvent_a15}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Determines whether or not Monitor timeouts will cause a reactor to be fired. Timeouts are used regardless in order to sense the dropping of the m_fEnabled flag. However if a timeout occurs and  m_fInformTimeouts is false, the Reactor will not be called.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i fReact}}  [true] - true if reactivity is desired... \par
}\par
Definition at line 526 of file CEvent.cpp.\par
\par
References m_InformTimeouts.}
{\xe \v Schedule\:CEvent}
{\xe \v CEvent\:Schedule}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CEvent::Schedule (){\f2  [protected]}}
}\par
{\bkmkstart classCEvent_b3}
{\bkmkend classCEvent_b3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called to schedule this process. Eric feels that it is not safe to just start this process off directly, e.g. from the constructor, because execution may start while the constructor is still executing either at this or a  lower level of the class hierarchy if this is a class derived from CEvent. Therefore we do the following tricky startup:\par
{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Create a new thread (EventStartupThread).\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Schedule that thread this is a parameter.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The thread will wait for some period of ms. which hopefully will ensure that the constructors have all exited.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The thread will start this object as a thread, passing itself to our operator()\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Our operator() will do a Join on the thread which started us up to reap it.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Our operator() will enter the main event loop. \par
}\par
Definition at line 595 of file CEvent.cpp.\par
\par
References m_fEnabled.}
{\xe \v setActive\:CEvent}
{\xe \v CEvent\:setActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CEvent::setActive (bool {\i fActive}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCEvent_b0}
{\bkmkend classCEvent_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set state of active flag.. implies thread is running.\par
\par
Definition at line 414 of file CEvent.h.\par
\par
References m_fActive.}
{\xe \v setEnable\:CEvent}
{\xe \v CEvent\:setEnable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CEvent::setEnable (bool {\i fEnable}){\f2  [inline]}}
}\par
{\bkmkstart classCEvent_a14}
{\bkmkend classCEvent_a14}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 427 of file CEvent.h.\par
\par
References m_fEnabled.\par
Referenced by CTimerEvent::InternalOnTimer(), and CServerInstance::Shutdown().}
{\xe \v setReactivity\:CEvent}
{\xe \v CEvent\:setReactivity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CEvent::setReactivity (int {\i nMs})}
}\par
{\bkmkstart classCEvent_a13}
{\bkmkend classCEvent_a13}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Changes the Monitor timeout. This will take effect after the next exit from the monitor.. which may require as much as the current value of timeout. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i nMs}}  - Number of milliseconds in the new timeout. -1 disables timeouts which in turn makes the time required to kill the thread unbounded. \par
}\par
Definition at line 512 of file CEvent.cpp.\par
\par
References m_nMsReactivity.\par
Referenced by CTimerEvent::CTimerEvent(), CTimerEvent::Enable(), and CTimerEvent::SetTimeout().}
{\xe \v setTid\:CEvent}
{\xe \v CEvent\:setTid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CEvent::setTid (const DAQThreadId {\i Tid}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCEvent_b1}
{\bkmkend classCEvent_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set Thread ID: implies you know a lot about the system.\par
\par
Definition at line 418 of file CEvent.h.\par
\par
References m_Tid.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_fActive\:CEvent}
{\xe \v CEvent\:m_fActive}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CEvent::m_fActive{\f2  [private]}}
}\par
{\bkmkstart classCEvent_o1}
{\bkmkend classCEvent_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
True if thread is active.\par
\par
Definition at line 338 of file CEvent.h.\par
\par
Referenced by DescribeSelf(), isActive(), operator()(), and setActive().}
{\xe \v m_fEnabled\:CEvent}
{\xe \v CEvent\:m_fEnabled}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CEvent::m_fEnabled{\f2  [private]}}
}\par
{\bkmkstart classCEvent_o0}
{\bkmkend classCEvent_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Event enabled flag.\par
\par
Definition at line 337 of file CEvent.h.\par
\par
Referenced by DescribeSelf(), Disable(), Enable(), isEnabled(), Schedule(), and setEnable().}
{\xe \v m_InformTimeouts\:CEvent}
{\xe \v CEvent\:m_InformTimeouts}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CEvent::m_InformTimeouts{\f2  [private]}}
}\par
{\bkmkstart classCEvent_o2}
{\bkmkend classCEvent_o2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Pass timeouts on to reactor.\par
\par
Definition at line 339 of file CEvent.h.\par
\par
Referenced by getInformTimeout(), OnEvent(), and ReactToTimeouts().}
{\xe \v m_nMsReactivity\:CEvent}
{\xe \v CEvent\:m_nMsReactivity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CEvent::m_nMsReactivity{\f2  [private]}}
}\par
{\bkmkstart classCEvent_o3}
{\bkmkend classCEvent_o3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Reactivity to external events.\par
\par
Definition at line 340 of file CEvent.h.\par
\par
Referenced by DescribeSelf(), getMsReactivity(), operator()(), and setReactivity().}
{\xe \v m_rMonitor\:CEvent}
{\xe \v CEvent\:m_rMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CEventMonitor}& CEvent::m_rMonitor{\f2  [private]}}
}\par
{\bkmkstart classCEvent_o4}
{\bkmkend classCEvent_o4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Monitor which polls for event.\par
\par
Reimplemented in {\b CBufferEvent< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferEvent_o2 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CLocationEvent< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCLocationEvent_o1 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CTimerEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTimerEvent_o0 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b CBufferEvent< U >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferEvent_o2 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 341 of file CEvent.h.\par
\par
Referenced by DescribeSelf(), OnEvent(), and operator()().}
{\xe \v m_rReactor\:CEvent}
{\xe \v CEvent\:m_rReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CReactor}& CEvent::m_rReactor{\f2  [private]}}
}\par
{\bkmkstart classCEvent_o5}
{\bkmkend classCEvent_o5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Reactor to the event when it fires.\par
\par
Reimplemented in {\b CBufferEvent< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferEvent_o3 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CLocationEvent< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCLocationEvent_o2 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CTimerEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTimerEvent_o1 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b CBufferEvent< U >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferEvent_o3 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 342 of file CEvent.h.\par
\par
Referenced by DescribeSelf(), and OnEvent().}
{\xe \v m_Tid\:CEvent}
{\xe \v CEvent\:m_Tid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DAQThreadId CEvent::m_Tid{\f2  [private]}}
}\par
{\bkmkstart classCEvent_o6}
{\bkmkend classCEvent_o6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
spectrodaq thread identifier.\par
\par
Definition at line 343 of file CEvent.h.\par
\par
Referenced by Disable(), Enable(), getThreadId(), JoinThis(), operator()(), and setTid().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CEvent.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CEvent.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CEventLoop  Class Reference\par \pard\plain 
{\tc\tcl2 \v CEventLoop}
{\xe \v CEventLoop}
{\bkmkstart classCEventLoop}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CEventLoop.h>}\par
Inheritance diagram for CEventLoop:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCEventLoop.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CEventLoop} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CEventLoop} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CEventLoop * {\b getInstance} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b operator()} (int argc, char **argv)=0\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Singleton instance.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CEventLoop} (const CEventLoop &aCEventLoop)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CEventLoop & {\b operator=} (const CEventLoop &aCEventLoop)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Not Implemented.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CEventLoop &aCEventLoop) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Not Implemented.}\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CEventLoop * {\b m_pTheInstance} = (CEventLoop*)NULL\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
Encapsulates within a thread an application library which  runs it's own event loop. Examples are Xt and Tcl/Tk. These systems include their own mechanisms for detecting and dispatching events to application and framework specific code.\par
Attempting to instantiate more than one instance of an event  loop derived object results in a CDuplicateSingelton exception. Event loop derived processes implement operator() to  initiate an event loop how they are used depends on the iindividual framework. Each of these event loops is supposed to ensure that event dispatching to application level code is synchronized through the application's mutex. It is legal to synchronize all such events or an "appropriate subset". \par
\par
Definition at line 315 of file CEventLoop.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CEventLoop\:CEventLoop}
{\xe \v CEventLoop\:CEventLoop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CEventLoop::CEventLoop ()}
}\par
{\bkmkstart classCEventLoop_a0}
{\bkmkend classCEventLoop_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
The Constructs an event loop. Since event loops are singletons, this function throws a {\b CDuplicateSingleton} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDuplicateSingleton \\*MERGEFORMAT}{\fldrslt pagenum}}}) if the m_pTheInstance variable is not null. If the variable is null, it is filled in with this. \par
\par
Definition at line 323 of file CEventLoop.cpp.\par
\par
References m_pTheInstance.}
{\xe \v ~CEventLoop\:CEventLoop}
{\xe \v CEventLoop\:~CEventLoop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CEventLoop::~CEventLoop (){\f2  [virtual]}}
}\par
{\bkmkstart classCEventLoop_a1}
{\bkmkend classCEventLoop_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
The destructor sets the m_pTheInstance back to null. The assumption is that if derived classes catch the CDuplicateSingelton in their  constructors, they will re-throw it. Since such objects would be not fully constructed, they would not be destroyed and hence the instance pointer would not get spuriously deleted.\par
\par
{{{\b \par
{\b Bug: }}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid There is no good way to enforce that {\b CDuplicateSingleton} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDuplicateSingleton \\*MERGEFORMAT}{\fldrslt pagenum}}})'s don't result in spurious clears of the instance pointer.\par
} \par
\par
Definition at line 348 of file CEventLoop.cpp.\par
}
{\xe \v CEventLoop\:CEventLoop}
{\xe \v CEventLoop\:CEventLoop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CEventLoop::CEventLoop (const CEventLoop & {\i aCEventLoop}){\f2  [private]}}
}\par
{\bkmkstart classCEventLoop_c1}
{\bkmkend classCEventLoop_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Copy construction, assignment and comparison are not allowed. therefore they are declared as private and not implemented. \par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getInstance\:CEventLoop}
{\xe \v CEventLoop\:getInstance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CEventLoop * CEventLoop::getInstance (){\f2  [static]}}
}\par
{\bkmkstart classCEventLoop_d0}
{\bkmkend classCEventLoop_d0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Retrieves the instance pointer. If the instance variable is null, throws CNoSuchObject. \par
\par
Definition at line 365 of file CEventLoop.cpp.\par
\par
References m_pTheInstance.\par
Referenced by CTCLInterpreterStartup::Tcl_Init(), and CTKInterpreterStartup::Tk_Init().}
{\xe \v operator()\:CEventLoop}
{\xe \v CEventLoop\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual int CEventLoop::operator() (int {\i argc}, char ** {\i argv}){\f2  [private, pure virtual]}}
}\par
{\bkmkstart classCEventLoop_c0}
{\bkmkend classCEventLoop_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Singleton instance.\par
Implemented by subclasses to provide the actual event loop functionality. int argc, char** argv provide a mechanism for passing parameters to the event loop thread as if it was run from a main program. \par
\par
Implemented in {\b CInterpreterStartup} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCInterpreterStartup_c0 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CTCLInterpreterStartup} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCLInterpreterStartup_c0 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CTKInterpreterStartup} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTKInterpreterStartup_c3 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b CXtEventLoop} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCXtEventLoop_c0 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
}
{\xe \v operator=\:CEventLoop}
{\xe \v CEventLoop\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CEventLoop& CEventLoop::operator= (const CEventLoop & {\i aCEventLoop}){\f2  [private]}}
}\par
{\bkmkstart classCEventLoop_c2}
{\bkmkend classCEventLoop_c2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Not Implemented.\par
}
{\xe \v operator==\:CEventLoop}
{\xe \v CEventLoop\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CEventLoop::operator== (const CEventLoop & {\i aCEventLoop}) const{\f2  [private]}}
}\par
{\bkmkstart classCEventLoop_c3}
{\bkmkend classCEventLoop_c3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Not Implemented.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_pTheInstance\:CEventLoop}
{\xe \v CEventLoop\:m_pTheInstance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CEventLoop * CEventLoop::m_pTheInstance = (CEventLoop*)NULL{\f2  [static, private]}}
}\par
{\bkmkstart classCEventLoop_r0}
{\bkmkend classCEventLoop_r0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
CEventLoop* m_pTheInstance Contains a pointer to the single event loop instance allowed. If there are no instances of the singleton, this pointer is null. Note that GetInstance will not attempt to create a new instance since it does not know which element of the class hierarchy to create. \par
\par
Definition at line 315 of file CEventLoop.cpp.\par
\par
Referenced by CEventLoop(), and getInstance().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CEventLoop.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CEventLoop.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CEventMonitor  Class Reference\par \pard\plain 
{\tc\tcl2 \v CEventMonitor}
{\xe \v CEventMonitor}
{\bkmkstart classCEventMonitor}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CEventMonitor.h>}\par
Inheritance diagram for CEventMonitor:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCEventMonitor.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b result} \{ {\b Occurred} =  0, 
{\b TimedOut} =  1, 
{\b Error} =  2
 \}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CEventMonitor} (bool am_fTimedWait=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CEventMonitor} (const string &rName, bool am_fTimedWait=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CEventMonitor} (const char *pName, bool am_fTimedWait=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CEventMonitor &aCEventMonitor) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CEventMonitor} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
timeval {\b getTimeout} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getTimedWait} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b CEventMonitor::result} {\b operator()} ()=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b setTimeout} (int nTimeout={\b FOREVER})\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTimeout} (const timeval am_tvTimeout)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTimedWait} (const bool am_fTimedWait)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b GetAutoName} (const string &rBaseName)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Assign default name.}\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CEventMonitor} (const CEventMonitor &aCEventMonitor)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Copy construction is forbidden for now.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CEventMonitor {\b operator=} (const {\b CRegisteredObject} &aCEventMonitor)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Assignment is forbidden for now.}\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
timeval {\b m_tvTimeout}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b m_fTimedWait}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b m_nAutoIndex}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
\\class: CEventMonitor\par
This file defines the CEventMonitor class. CEventMonitor is the ABC for all Event Monitors. An event monitor  provides event specific logic for waiting for external program events. operator() is expected to wait for an event to occur and return to  indicate if the event in fact did occur. \par
\par
Definition at line 326 of file CEventMonitor.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v result\:CEventMonitor}
{\xe \v CEventMonitor\:result}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum CEventMonitor::result}
}\par
{\bkmkstart classCEventMonitor_s3}
{\bkmkend classCEventMonitor_s3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Used to name autonamed objects \par
{{{\b \par
Enumeration values:}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v Occurred\:CEventMonitor}
{\xe \v CEventMonitor\:Occurred}
{\b {\i {\i Occurred}{\bkmkstart classCEventMonitor_s3s0}
{\bkmkend classCEventMonitor_s3s0}
}}  \par
{\xe \v TimedOut\:CEventMonitor}
{\xe \v CEventMonitor\:TimedOut}
{\b {\i {\i TimedOut}{\bkmkstart classCEventMonitor_s3s1}
{\bkmkend classCEventMonitor_s3s1}
}}  \par
{\xe \v Error\:CEventMonitor}
{\xe \v CEventMonitor\:Error}
{\b {\i {\i Error}{\bkmkstart classCEventMonitor_s3s2}
{\bkmkend classCEventMonitor_s3s2}
}}  \par
}
\par
Definition at line 335 of file CEventMonitor.h.\par
\par
Referenced by CEvent::OnEvent(), and CReactor::operator()().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CEventMonitor\:CEventMonitor}
{\xe \v CEventMonitor\:CEventMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CEventMonitor::CEventMonitor (bool {\i am_fTimedWait} = true)}
}\par
{\bkmkstart classCEventMonitor_a0}
{\bkmkend classCEventMonitor_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Default constructor. An EventMonitor with name of the form Monitor_nnn is created. The monitor is entered in to the "Monitors" registry of the  classified object registry returned from getCClassifiedObjectRegistry(). The name used is gaurenteed unique and can be queried via: {\b getName}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNamedObject_a6 \\*MERGEFORMAT}{\fldrslt pagenum}}}). \par
\par
Definition at line 312 of file CEventMonitor.cpp.\par
\par
References CNamedObject::AppendClassInfo(), m_fTimedWait, m_tvTimeout, and RegistryName.}
{\xe \v CEventMonitor\:CEventMonitor}
{\xe \v CEventMonitor\:CEventMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CEventMonitor::CEventMonitor (const string & {\i rName}, bool {\i am_fTimedWait} = true)}
}\par
{\bkmkstart classCEventMonitor_a1}
{\bkmkend classCEventMonitor_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Constructs an EventMonitor given a name as an STL string, and a value of m_fTimedWait :{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rName}}  - The desired name of the event monitor. \par
{\b {\i am_fTimedWait}}  - indicates whether or not the monitor is timed\par
}Throws:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CDuplicateNameException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDuplicateNameException \\*MERGEFORMAT}{\fldrslt pagenum}}}) (indirectly) if a Reactor of this name already exists. \par
}\par
Definition at line 333 of file CEventMonitor.cpp.\par
\par
References CNamedObject::AppendClassInfo(), m_fTimedWait, m_tvTimeout, and RegistryName.}
{\xe \v CEventMonitor\:CEventMonitor}
{\xe \v CEventMonitor\:CEventMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CEventMonitor::CEventMonitor (const char * {\i pName}, bool {\i am_fTimedWait} = true)}
}\par
{\bkmkstart classCEventMonitor_a2}
{\bkmkend classCEventMonitor_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Constructs an event monitor given its name as an ASCII string and an (optional) value for m_fTimedWait :{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i pName}}  - char* pointer to the desired object name. \par
{\b {\i am_fTimedWait}}  - bool indicates whether the monitor is timed\par
}Throws: -{\b CDuplicateNameException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDuplicateNameException \\*MERGEFORMAT}{\fldrslt pagenum}}}) (indirectly) if an event monitor of this name already exists. \par
\par
Definition at line 354 of file CEventMonitor.cpp.\par
\par
References CNamedObject::AppendClassInfo(), m_fTimedWait, m_tvTimeout, and RegistryName.}
{\xe \v CEventMonitor\:CEventMonitor}
{\xe \v CEventMonitor\:CEventMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CEventMonitor::CEventMonitor (const CEventMonitor & {\i aCEventMonitor}){\f2  [private]}}
}\par
{\bkmkstart classCEventMonitor_c0}
{\bkmkend classCEventMonitor_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Copy construction is forbidden for now.\par
}
{\xe \v ~CEventMonitor\:CEventMonitor}
{\xe \v CEventMonitor\:~CEventMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CEventMonitor::~CEventMonitor (){\f2  [virtual]}}
}\par
{\bkmkstart classCEventMonitor_a4}
{\bkmkend classCEventMonitor_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Destructor: Just ensure that we are removed from the Reactors registry before being destroyed. \par
\par
Definition at line 368 of file CEventMonitor.cpp.\par
\par
References CRegisteredObject::getRegistry(), RegistryName, and CClassifiedObjectRegistry::Remove().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v GetAutoName\:CEventMonitor}
{\xe \v CEventMonitor\:GetAutoName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CEventMonitor::GetAutoName (const string & {\i rBaseName}){\f2  [static, protected]}}
}\par
{\bkmkstart classCEventMonitor_e0}
{\bkmkend classCEventMonitor_e0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Assign default name.\par
Allocate a name for an object given some generic base name.  The final name is of the form: BaseName(m_nAutoIndex). \par
\par
Reimplemented from {\b CNamedObject} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNamedObject_e0 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 397 of file CEventMonitor.cpp.\par
\par
References m_nAutoIndex.}
{\xe \v getTimedWait\:CEventMonitor}
{\xe \v CEventMonitor\:getTimedWait}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CEventMonitor::getTimedWait () const{\f2  [inline]}}
}\par
{\bkmkstart classCEventMonitor_a6}
{\bkmkend classCEventMonitor_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 375 of file CEventMonitor.h.\par
\par
References m_fTimedWait.\par
Referenced by CFdMonitor::DescribeSelf(), CFdMonitor::operator()(), and CBufferMonitor< T >::operator()().}
{\xe \v getTimeout\:CEventMonitor}
{\xe \v CEventMonitor\:getTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
timeval CEventMonitor::getTimeout () const{\f2  [inline]}}
}\par
{\bkmkstart classCEventMonitor_a5}
{\bkmkend classCEventMonitor_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 370 of file CEventMonitor.h.\par
\par
References m_tvTimeout.\par
Referenced by CFdMonitor::DescribeSelf(), CTimerMonitor::operator()(), CLocationMonitor< T >::operator()(), CFdMonitor::operator()(), and CBufferMonitor< T >::operator()().}
{\xe \v operator()\:CEventMonitor}
{\xe \v CEventMonitor\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual {\b CEventMonitor::result} CEventMonitor::operator() (){\f2  [pure virtual]}}
}\par
{\bkmkstart classCEventMonitor_a7}
{\bkmkend classCEventMonitor_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Implemented in {\b CBufferMonitor< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferMonitor_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CFdMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFdMonitor_a11 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CLocationMonitor< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCLocationMonitor_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CServerMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCServerMonitor_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CTimerMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTimerMonitor_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b CBufferMonitor< U >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferMonitor_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
}
{\xe \v operator=\:CEventMonitor}
{\xe \v CEventMonitor\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CEventMonitor CEventMonitor::operator= (const {\b CRegisteredObject} & {\i aCEventMonitor}){\f2  [private]}}
}\par
{\bkmkstart classCEventMonitor_c1}
{\bkmkend classCEventMonitor_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Assignment is forbidden for now.\par
\par
Reimplemented from {\b CRegisteredObject} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCRegisteredObject_c1 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Reimplemented in {\b CFdMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFdMonitor_c1 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
}
{\xe \v operator==\:CEventMonitor}
{\xe \v CEventMonitor\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CEventMonitor::operator== (const CEventMonitor & {\i aCEventMonitor}) const{\f2  [inline]}}
}\par
{\bkmkstart classCEventMonitor_a3}
{\bkmkend classCEventMonitor_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 348 of file CEventMonitor.h.\par
\par
References m_fTimedWait, m_tvTimeout, and CRegisteredObject::operator==().\par
Referenced by CTimerMonitor::operator==(), CLocationMonitor< T >::operator==(), and CFdMonitor::operator==().}
{\xe \v setTimedWait\:CEventMonitor}
{\xe \v CEventMonitor\:setTimedWait}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CEventMonitor::setTimedWait (const bool {\i am_fTimedWait}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCEventMonitor_b1}
{\bkmkend classCEventMonitor_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 388 of file CEventMonitor.h.\par
\par
References m_fTimedWait.}
{\xe \v setTimeout\:CEventMonitor}
{\xe \v CEventMonitor\:setTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CEventMonitor::setTimeout (int {\i nTimeout} = {\b FOREVER}){\f2  [virtual]}}
}\par
{\bkmkstart classCEventMonitor_a8}
{\bkmkend classCEventMonitor_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
void {\b CEventMonitor::setTimeout} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEventMonitor_b0 \\*MERGEFORMAT}{\fldrslt pagenum}}})(int nTimeout=FOREVER)  Operation Type: mutator\par
Purpose: Sets the timeout. The length of the timeout is determined by the parameter in ms..  Special values: 0 - Poll (return instantly). FOREVER - Block until event. \par
\par
Reimplemented in {\b CTimerMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTimerMonitor_a9 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 389 of file CEventMonitor.cpp.\par
\par
References m_fTimedWait, and m_tvTimeout.}
{\xe \v setTimeout\:CEventMonitor}
{\xe \v CEventMonitor\:setTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CEventMonitor::setTimeout (const timeval {\i am_tvTimeout}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCEventMonitor_b0}
{\bkmkend classCEventMonitor_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 383 of file CEventMonitor.h.\par
\par
References m_tvTimeout.\par
Referenced by main(), CEvent::operator()(), and CTimerMonitor::setTimeout().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_fTimedWait\:CEventMonitor}
{\xe \v CEventMonitor\:m_fTimedWait}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CEventMonitor::m_fTimedWait{\f2  [private]}}
}\par
{\bkmkstart classCEventMonitor_o1}
{\bkmkend classCEventMonitor_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Timeout length \par
\par
Definition at line 329 of file CEventMonitor.h.\par
\par
Referenced by CEventMonitor(), getTimedWait(), operator==(), setTimedWait(), and setTimeout().}
{\xe \v m_nAutoIndex\:CEventMonitor}
{\xe \v CEventMonitor\:m_nAutoIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int CEventMonitor::m_nAutoIndex{\f2  [static, private]}}
}\par
{\bkmkstart classCEventMonitor_r0}
{\bkmkend classCEventMonitor_r0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Timed wait? \par
\par
Reimplemented from {\b CNamedObject} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNamedObject_r0 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Referenced by GetAutoName().}
{\xe \v m_tvTimeout\:CEventMonitor}
{\xe \v CEventMonitor\:m_tvTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
timeval CEventMonitor::m_tvTimeout{\f2  [private]}}
}\par
{\bkmkstart classCEventMonitor_o0}
{\bkmkend classCEventMonitor_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 328 of file CEventMonitor.h.\par
\par
Referenced by CEventMonitor(), getTimeout(), operator==(), and setTimeout().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CEventMonitor.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CEventMonitor.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CException  Class Reference\par \pard\plain 
{\tc\tcl2 \v CException}
{\xe \v CException}
{\bkmkstart classCException}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CException.h>}\par
Inheritance diagram for CException:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCException.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CException} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CException} (const char *pszAction)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CException} (const std::string &rsAction)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CException} (const CException &aCException)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CException & {\b operator=} (const CException &aCException)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CException &aCException)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator!=} (const CException &rException)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b getAction} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const char * {\b ReasonText} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Int_t} {\b ReasonCode} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b WasDoing} () const\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAction} (const char *pszAction)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAction} (const std::string &rsAction)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b DoAssign} (const CException &rhs)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b m_szAction} [kACTIONSIZE]\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
Base class for exceptions thrown  by the histogrammign subsystem. (could be used for any other subsystem for that matter). \par
\par
Definition at line 308 of file CException.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v ~CException\:CException}
{\xe \v CException\:~CException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual CException::~CException (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCException_a0}
{\bkmkend classCException_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 318 of file CException.h.\par
}
{\xe \v CException\:CException}
{\xe \v CException\:CException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CException::CException (const char * {\i pszAction})}
}\par
{\bkmkstart classCException_a1}
{\bkmkend classCException_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 319 of file CException.cpp.\par
\par
References setAction().}
{\xe \v CException\:CException}
{\xe \v CException\:CException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CException::CException (const std::string & {\i rsAction})}
}\par
{\bkmkstart classCException_a2}
{\bkmkend classCException_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 323 of file CException.cpp.\par
\par
References setAction().}
{\xe \v CException\:CException}
{\xe \v CException\:CException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CException::CException (const CException & {\i aCException})}
}\par
{\bkmkstart classCException_a3}
{\bkmkend classCException_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 335 of file CException.cpp.\par
\par
References DoAssign().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v DoAssign\:CException}
{\xe \v CException\:DoAssign}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CException::DoAssign (const CException & {\i rException}){\f2  [protected, virtual]}}
}\par
{\bkmkstart classCException_b2}
{\bkmkend classCException_b2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
This is virtual to allow derived classes to override and chain calls to. \par
\par
Definition at line 465 of file CException.cpp.\par
\par
References m_szAction, and setAction().\par
Referenced by CException(), and operator=().}
{\xe \v getAction\:CException}
{\xe \v CException\:getAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* CException::getAction () const{\f2  [inline]}}
}\par
{\bkmkstart classCException_a7}
{\bkmkend classCException_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 343 of file CException.h.\par
\par
References m_szAction.\par
Referenced by WasDoing().}
{\xe \v operator!=\:CException}
{\xe \v CException\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CException::operator!= (const CException & {\i rException}){\f2  [inline]}}
}\par
{\bkmkstart classCException_a6}
{\bkmkend classCException_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 335 of file CException.h.\par
\par
References operator==().}
{\xe \v operator=\:CException}
{\xe \v CException\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CException & CException::operator= (const CException & {\i aCException})}
}\par
{\bkmkstart classCException_a4}
{\bkmkend classCException_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 347 of file CException.cpp.\par
\par
References DoAssign().\par
Referenced by CTCLException::operator=(), CTCPBadSocketState::operator=(), CRangeError::operator=(), CNoSuchObjectException::operator=(), CNoSuchLinkException::operator=(), CLinkFailedException::operator=(), CIncompatibleMonitor::operator=(), CErrnoException::operator=(), CDuplicateSingleton::operator=(), and CDuplicateNameException::operator=().}
{\xe \v operator==\:CException}
{\xe \v CException\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CException::operator== (const CException & {\i aCException})}
}\par
{\bkmkstart classCException_a5}
{\bkmkend classCException_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 363 of file CException.cpp.\par
\par
References m_szAction.\par
Referenced by operator!=(), CTCLException::operator==(), CTCPNoSuchHost::operator==(), CTCPBadSocketState::operator==(), CStreamIOError::operator==(), CRangeError::operator==(), CNoSuchObjectException::operator==(), CNoSuchLinkException::operator==(), CLinkFailedException::operator==(), CIncompatibleMonitor::operator==(), CErrnoException::operator==(), CDuplicateSingleton::operator==(), and CDuplicateNameException::operator==().}
{\xe \v ReasonCode\:CException}
{\xe \v CException\:ReasonCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Int_t} CException::ReasonCode () const{\f2  [virtual]}}
}\par
{\bkmkstart classCException_a9}
{\bkmkend classCException_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns a code which describes the reason for the exception . This is exception type specific and may be used to do detailed exception analysis and recovery. For example in the {\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) class, the errno at the time of instantiation of the object is returned. The default returns -1 \par
\par
Reimplemented in {\b CTCPNoSuchHost} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPNoSuchHost_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CRangeError} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCRangeError_a10 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CStreamIOError} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCStreamIOError_a9 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b CTCLException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCLException_a14 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 407 of file CException.cpp.\par
}
{\xe \v ReasonText\:CException}
{\xe \v CException\:ReasonText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * CException::ReasonText () const{\f2  [virtual]}}
}\par
{\bkmkstart classCException_a8}
{\bkmkend classCException_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns a const pointer to text which describes the reason the exception was thrown. This is exception type specific. The default action returns a pointer to the constant string: "Unspecified Exception" \par
\par
Reimplemented in {\b CDuplicateNameException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDuplicateNameException_a10 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CDuplicateSingleton} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDuplicateSingleton_a10 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CIncompatibleMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCIncompatibleMonitor_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CLinkFailedException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCLinkFailedException_a12 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CNoSuchLinkException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNoSuchLinkException_a12 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CNoSuchObjectException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNoSuchObjectException_a10 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CTCPBadSocketState} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPBadSocketState_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CTCPConnectionFailed} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPConnectionFailed_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CTCPConnectionLost} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPConnectionLost_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CTCPNoSuchHost} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPNoSuchHost_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CTCPNoSuchService} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPNoSuchService_a6 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CRangeError} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCRangeError_a9 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CStreamIOError} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCStreamIOError_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b CTCLException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCLException_a13 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 385 of file CException.cpp.\par
}
{\xe \v setAction\:CException}
{\xe \v CException\:setAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CException::setAction (const std::string & {\i rsAction}){\f2  [protected]}}
}\par
{\bkmkstart classCException_b1}
{\bkmkend classCException_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 448 of file CException.cpp.\par
\par
References setAction().}
{\xe \v setAction\:CException}
{\xe \v CException\:setAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CException::setAction (const char * {\i pszAction}){\f2  [protected]}}
}\par
{\bkmkstart classCException_b0}
{\bkmkend classCException_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 443 of file CException.cpp.\par
\par
References m_szAction.\par
Referenced by CException(), DoAssign(), and setAction().}
{\xe \v WasDoing\:CException}
{\xe \v CException\:WasDoing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * CException::WasDoing () const}
}\par
{\bkmkstart classCException_a10}
{\bkmkend classCException_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns a const pointer to m_szAction. This is intended to describe the action  which was occuring when the exception was thrown. \par
\par
Definition at line 427 of file CException.cpp.\par
\par
References getAction().\par
Referenced by CTCPNoSuchHost::ReasonText(), CTCPBadSocketState::ReasonText(), and CIncompatibleMonitor::ReasonText().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_szAction\:CException}
{\xe \v CException\:m_szAction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char CException::m_szAction[kACTIONSIZE]{\f2  [private]}}
}\par
{\bkmkstart classCException_o0}
{\bkmkend classCException_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 312 of file CException.h.\par
\par
Referenced by DoAssign(), getAction(), operator==(), and setAction().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CException.cpp}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CException.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CFdMonitor  Class Reference\par \pard\plain 
{\tc\tcl2 \v CFdMonitor}
{\xe \v CFdMonitor}
{\bkmkstart classCFdMonitor}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CFdMonitor.h>}\par
Inheritance diagram for CFdMonitor:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCFdMonitor.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b FdConditions} \{ {\b FD_READABLE} = 0, 
{\b FD_WRITABLE} = 1, 
{\b FD_EXCEPTION} = 2
 \}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CFdMonitor} (int am_nFd, bool am_fTimedWait=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CFdMonitor} (const string &rName, int am_nFd, bool am_fTimedWait=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CFdMonitor} (const char *pName, int am_nFd, bool am_fTimedWait=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CFdMonitor &aCFdMonitor) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CFdMonitor} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getFd} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getConditionMask} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getLastEventMask} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MonitorReadable} (bool fReadable=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MonitorWritable} (bool fWritable=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MonitorExceptions} (bool fException=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b CEventMonitor::result} {\b operator()} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual string {\b DescribeSelf} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setFd} (const int am_nFd)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setConditionMask} (const unsigned int am_nConditionMask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLastEventMask} (const int am_fLastEventMask)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CFdMonitor} (const {\b CRegisteredObject} &aCRegisteredObject)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CFdMonitor {\b operator=} (const {\b CRegisteredObject} &aCRegisteredObject)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Assignment is forbidden for now.}\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b m_nFd}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b m_nConditionMask}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b m_fLastEventMask}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
\\class: {\b CFdMonitor.h}\par
This file defines the CFdMonitor class. Monitors activity on a file descriptor. A file descriptior can be  monitored for the logical or of any of the following conditions: Readable Writable Exception\par
Monitoring is done via the select(2) system service. Note that this can yield some unexpected results. For example, in some operating systems, tape drives are never considered readable without blocking.\par
Author: Jason Venema NSCL Michigan State University East Lansing, MI 48824-1321 mailto:{\f2 venemaja@msu.edu} \par
\par
Definition at line 319 of file CFdMonitor.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v FdConditions\:CFdMonitor}
{\xe \v CFdMonitor\:FdConditions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum CFdMonitor::FdConditions}
}\par
{\bkmkstart classCFdMonitor_s3}
{\bkmkend classCFdMonitor_s3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Mask of the last set of bits to be detected \par
{{{\b \par
Enumeration values:}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v FD_READABLE\:CFdMonitor}
{\xe \v CFdMonitor\:FD_READABLE}
{\b {\i {\i FD_READABLE}{\bkmkstart classCFdMonitor_s3s0}
{\bkmkend classCFdMonitor_s3s0}
}}  \par
{\xe \v FD_WRITABLE\:CFdMonitor}
{\xe \v CFdMonitor\:FD_WRITABLE}
{\b {\i {\i FD_WRITABLE}{\bkmkstart classCFdMonitor_s3s1}
{\bkmkend classCFdMonitor_s3s1}
}}  \par
{\xe \v FD_EXCEPTION\:CFdMonitor}
{\xe \v CFdMonitor\:FD_EXCEPTION}
{\b {\i {\i FD_EXCEPTION}{\bkmkstart classCFdMonitor_s3s2}
{\bkmkend classCFdMonitor_s3s2}
}}  \par
}
\par
Definition at line 329 of file CFdMonitor.h.\par
\par
Referenced by CFdReactor::OnEvent().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CFdMonitor\:CFdMonitor}
{\xe \v CFdMonitor\:CFdMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CFdMonitor::CFdMonitor (int {\i am_nFd}, bool {\i am_fTimedWait} = true){\f2  [inline]}}
}\par
{\bkmkstart classCFdMonitor_a0}
{\bkmkend classCFdMonitor_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 338 of file CFdMonitor.h.\par
\par
References CNamedObject::AppendClassInfo(), m_fLastEventMask, m_nConditionMask, and m_nFd.}
{\xe \v CFdMonitor\:CFdMonitor}
{\xe \v CFdMonitor\:CFdMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CFdMonitor::CFdMonitor (const string & {\i rName}, int {\i am_nFd}, bool {\i am_fTimedWait} = true){\f2  [inline]}}
}\par
{\bkmkstart classCFdMonitor_a1}
{\bkmkend classCFdMonitor_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 345 of file CFdMonitor.h.\par
\par
References CNamedObject::AppendClassInfo(), m_fLastEventMask, m_nConditionMask, and m_nFd.}
{\xe \v CFdMonitor\:CFdMonitor}
{\xe \v CFdMonitor\:CFdMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CFdMonitor::CFdMonitor (const char * {\i pName}, int {\i am_nFd}, bool {\i am_fTimedWait} = true){\f2  [inline]}}
}\par
{\bkmkstart classCFdMonitor_a2}
{\bkmkend classCFdMonitor_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 352 of file CFdMonitor.h.\par
\par
References CNamedObject::AppendClassInfo(), m_fLastEventMask, m_nConditionMask, and m_nFd.}
{\xe \v ~CFdMonitor\:CFdMonitor}
{\xe \v CFdMonitor\:~CFdMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual CFdMonitor::~CFdMonitor (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCFdMonitor_a4}
{\bkmkend classCFdMonitor_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 369 of file CFdMonitor.h.\par
}
{\xe \v CFdMonitor\:CFdMonitor}
{\xe \v CFdMonitor\:CFdMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CFdMonitor::CFdMonitor (const {\b CRegisteredObject} & {\i aCRegisteredObject}){\f2  [private]}}
}\par
{\bkmkstart classCFdMonitor_c0}
{\bkmkend classCFdMonitor_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v DescribeSelf\:CFdMonitor}
{\xe \v CFdMonitor\:DescribeSelf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CFdMonitor::DescribeSelf (){\f2  [virtual]}}
}\par
{\bkmkstart classCFdMonitor_a12}
{\bkmkend classCFdMonitor_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Interface Implementation\par
Purpose: Uses the m_sClassPath member to describe its class path, and returns a string containing this and its data member values. \par
\par
Reimplemented from {\b CNamedObject} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNamedObject_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Reimplemented in {\b CServerMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCServerMonitor_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 420 of file CFdMonitor.cpp.\par
\par
References CNamedObject::DescribeSelf(), CEventMonitor::getTimedWait(), CEventMonitor::getTimeout(), and m_nFd.\par
Referenced by main().}
{\xe \v getConditionMask\:CFdMonitor}
{\xe \v CFdMonitor\:getConditionMask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int CFdMonitor::getConditionMask () const{\f2  [inline]}}
}\par
{\bkmkstart classCFdMonitor_a6}
{\bkmkend classCFdMonitor_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 386 of file CFdMonitor.h.\par
\par
References m_nConditionMask.\par
Referenced by main().}
{\xe \v getFd\:CFdMonitor}
{\xe \v CFdMonitor\:getFd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CFdMonitor::getFd () const{\f2  [inline]}}
}\par
{\bkmkstart classCFdMonitor_a5}
{\bkmkend classCFdMonitor_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 381 of file CFdMonitor.h.\par
\par
References m_nFd.\par
Referenced by CFdReactor::OnEvent().}
{\xe \v getLastEventMask\:CFdMonitor}
{\xe \v CFdMonitor\:getLastEventMask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CFdMonitor::getLastEventMask () const{\f2  [inline]}}
}\par
{\bkmkstart classCFdMonitor_a7}
{\bkmkend classCFdMonitor_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 391 of file CFdMonitor.h.\par
\par
References m_fLastEventMask.\par
Referenced by CFdReactor::OnEvent().}
{\xe \v MonitorExceptions\:CFdMonitor}
{\xe \v CFdMonitor\:MonitorExceptions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CFdMonitor::MonitorExceptions (bool {\i fException} = true)}
}\par
{\bkmkstart classCFdMonitor_a10}
{\bkmkend classCFdMonitor_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Mutator\par
Purpose: Sets or clears the FD_EXCEPTION bit in m_nConditionMask. \par
\par
Definition at line 344 of file CFdMonitor.cpp.\par
\par
References FD_EXCEPTION, and m_nConditionMask.\par
Referenced by main().}
{\xe \v MonitorReadable\:CFdMonitor}
{\xe \v CFdMonitor\:MonitorReadable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CFdMonitor::MonitorReadable (bool {\i fReadable} = true)}
}\par
{\bkmkstart classCFdMonitor_a8}
{\bkmkend classCFdMonitor_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Mutator\par
Purpose: Sets or clears the FD_READABLE bit in m_nConditionMask. \par
\par
Definition at line 314 of file CFdMonitor.cpp.\par
\par
References FD_READABLE, and m_nConditionMask.\par
Referenced by main().}
{\xe \v MonitorWritable\:CFdMonitor}
{\xe \v CFdMonitor\:MonitorWritable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CFdMonitor::MonitorWritable (bool {\i fWritable} = true)}
}\par
{\bkmkstart classCFdMonitor_a9}
{\bkmkend classCFdMonitor_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Mutator\par
Purpose:  Sets or clears the FD_WRITABLE bit in the m_nConditionMask attribute. \par
\par
Definition at line 329 of file CFdMonitor.cpp.\par
\par
References FD_WRITABLE, and m_nConditionMask.\par
Referenced by main().}
{\xe \v operator()\:CFdMonitor}
{\xe \v CFdMonitor\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CEventMonitor::result} CFdMonitor::operator() (){\f2  [virtual]}}
}\par
{\bkmkstart classCFdMonitor_a11}
{\bkmkend classCFdMonitor_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Interface Implementation\par
Purpose:\par
Implements a wait for a single file descriptor event as described in the mask. Returns one of: Occured - one of the masked conditions occured. TimedOut - Timeout was enabled and none of the conditions occured within the timeout. Error - An error condition ocurred. \par
\par
Implements {\b CEventMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEventMonitor_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Reimplemented in {\b CServerMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCServerMonitor_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 367 of file CFdMonitor.cpp.\par
\par
References CEventMonitor::Error, FD_EXCEPTION, FD_READABLE, FD_WRITABLE, CEventMonitor::getTimedWait(), CEventMonitor::getTimeout(), m_fLastEventMask, m_nConditionMask, m_nFd, CEventMonitor::Occurred, and CEventMonitor::TimedOut.}
{\xe \v operator=\:CFdMonitor}
{\xe \v CFdMonitor\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CFdMonitor CFdMonitor::operator= (const {\b CRegisteredObject} & {\i aCRegisteredObject}){\f2  [private]}}
}\par
{\bkmkstart classCFdMonitor_c1}
{\bkmkend classCFdMonitor_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Assignment is forbidden for now.\par
\par
Reimplemented from {\b CEventMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEventMonitor_c1 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Referenced by CServerMonitor::operator=().}
{\xe \v operator==\:CFdMonitor}
{\xe \v CFdMonitor\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CFdMonitor::operator== (const CFdMonitor & {\i aCFdMonitor}) const{\f2  [inline]}}
}\par
{\bkmkstart classCFdMonitor_a3}
{\bkmkend classCFdMonitor_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 360 of file CFdMonitor.h.\par
\par
References m_fLastEventMask, m_nConditionMask, m_nFd, and CEventMonitor::operator==().\par
Referenced by CServerMonitor::operator==().}
{\xe \v setConditionMask\:CFdMonitor}
{\xe \v CFdMonitor\:setConditionMask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CFdMonitor::setConditionMask (const unsigned int {\i am_nConditionMask}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCFdMonitor_b1}
{\bkmkend classCFdMonitor_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 404 of file CFdMonitor.h.\par
\par
References m_nConditionMask.}
{\xe \v setFd\:CFdMonitor}
{\xe \v CFdMonitor\:setFd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CFdMonitor::setFd (const int {\i am_nFd}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCFdMonitor_b0}
{\bkmkend classCFdMonitor_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 399 of file CFdMonitor.h.\par
\par
References m_nFd.}
{\xe \v setLastEventMask\:CFdMonitor}
{\xe \v CFdMonitor\:setLastEventMask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CFdMonitor::setLastEventMask (const int {\i am_fLastEventMask}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCFdMonitor_b2}
{\bkmkend classCFdMonitor_b2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 409 of file CFdMonitor.h.\par
\par
References m_fLastEventMask.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_fLastEventMask\:CFdMonitor}
{\xe \v CFdMonitor\:m_fLastEventMask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CFdMonitor::m_fLastEventMask{\f2  [private]}}
}\par
{\bkmkstart classCFdMonitor_o2}
{\bkmkend classCFdMonitor_o2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Conditions which will be monitored by  the monitor for the file descriptor. \par
\par
Definition at line 324 of file CFdMonitor.h.\par
\par
Referenced by CFdMonitor(), getLastEventMask(), operator()(), operator==(), and setLastEventMask().}
{\xe \v m_nConditionMask\:CFdMonitor}
{\xe \v CFdMonitor\:m_nConditionMask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int CFdMonitor::m_nConditionMask{\f2  [private]}}
}\par
{\bkmkstart classCFdMonitor_o1}
{\bkmkend classCFdMonitor_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
File descriptor which will be monitored by the monitor \par
\par
Definition at line 322 of file CFdMonitor.h.\par
\par
Referenced by CFdMonitor(), getConditionMask(), MonitorExceptions(), MonitorReadable(), MonitorWritable(), operator()(), operator==(), and setConditionMask().}
{\xe \v m_nFd\:CFdMonitor}
{\xe \v CFdMonitor\:m_nFd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CFdMonitor::m_nFd{\f2  [private]}}
}\par
{\bkmkstart classCFdMonitor_o0}
{\bkmkend classCFdMonitor_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 321 of file CFdMonitor.h.\par
\par
Referenced by CFdMonitor(), DescribeSelf(), getFd(), operator()(), operator==(), and setFd().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CFdMonitor.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CFdMonitor.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CFdReactor  Class Reference\par \pard\plain 
{\tc\tcl2 \v CFdReactor}
{\xe \v CFdReactor}
{\bkmkstart classCFdReactor}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CFdReactor.h>}\par
Inheritance diagram for CFdReactor:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCFdReactor.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CFdReactor} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CFdReactor} (const char *pName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CFdReactor} (const string &rName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CFdReactor} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CFdReactor &aCFdReactor) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Operator== Equality Operator.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnEvent} ({\b CEventMonitor} &rMonitor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnReadable} ({\b CFdMonitor} &rMonitor, int fd)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnWritable} ({\b CFdMonitor} &rMonitor, int fd)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnException} ({\b CFdMonitor} &rMonitor, int fd)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CFdReactor} (const CFdReactor &aCFdReactor)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Copy construction is prohibited.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CFdReactor & {\b operator=} (const CFdReactor &aCFdReactor)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Operator= Assignment Operator - Prohibited.}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
Base class for file descriptor reactors: Fd reactors react to events on a file descriptor. This abstract base class must be subclassed by the programmer to provide application specific behavior. \par
\par
Definition at line 317 of file CFdReactor.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CFdReactor\:CFdReactor}
{\xe \v CFdReactor\:CFdReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CFdReactor::CFdReactor ()}
}\par
{\bkmkstart classCFdReactor_a0}
{\bkmkend classCFdReactor_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Default constructor: Creates a file descriptor reactor which autonamed. Such fd reactors in general are not named in a memorable way. \par
\par
Definition at line 300 of file CFdReactor.cpp.\par
\par
References CNamedObject::AppendClassInfo().}
{\xe \v CFdReactor\:CFdReactor}
{\xe \v CFdReactor\:CFdReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CFdReactor::CFdReactor (const char * {\i pName})}
}\par
{\bkmkstart classCFdReactor_a1}
{\bkmkend classCFdReactor_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Constructor for a named reactor. Creates a file descriptor reactor which is given a memorable name by the object's client. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i pName}}  -Pointer to object name in ASCIZ form. \par
}\par
Definition at line 310 of file CFdReactor.cpp.\par
\par
References CNamedObject::AppendClassInfo().}
{\xe \v CFdReactor\:CFdReactor}
{\xe \v CFdReactor\:CFdReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CFdReactor::CFdReactor (const string & {\i rName})}
}\par
{\bkmkstart classCFdReactor_a2}
{\bkmkend classCFdReactor_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Constructor for a named reactor. Creates a file descriptor reactor which is given a memorable name by the object's client. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rName}}  - reference to an STL String which has the object's name. \par
}\par
Definition at line 321 of file CFdReactor.cpp.\par
\par
References CNamedObject::AppendClassInfo().}
{\xe \v CFdReactor\:CFdReactor}
{\xe \v CFdReactor\:CFdReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CFdReactor::CFdReactor (const CFdReactor & {\i aCFdReactor}){\f2  [private]}}
}\par
{\bkmkstart classCFdReactor_c0}
{\bkmkend classCFdReactor_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Copy construction is prohibited.\par
}
{\xe \v ~CFdReactor\:CFdReactor}
{\xe \v CFdReactor\:~CFdReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CFdReactor::~CFdReactor (){\f2  [virtual]}}
}\par
{\bkmkstart classCFdReactor_a3}
{\bkmkend classCFdReactor_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 327 of file CFdReactor.cpp.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v OnEvent\:CFdReactor}
{\xe \v CFdReactor\:OnEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CFdReactor::OnEvent ({\b CEventMonitor} & {\i rMonitor}){\f2  [virtual]}}
}\par
{\bkmkstart classCFdReactor_a5}
{\bkmkend classCFdReactor_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
EDispatches an incomming event from an FdMonitor to one or more of the following member functions:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
OnReadble - The file is readable.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
OnWritable - The file is writable.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
OnException - The file has an exceptional condition.\par
}NOTE: We can only dispatch to conditions the monitor is looking for.\par
Throws:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
CIncompatibleMonitorException - If the monitor cannot be cast to a {\b CFdMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFdMonitor \\*MERGEFORMAT}{\fldrslt pagenum}}}) object.\par
}{{{\b Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rMonitor}}  - Reference to the monitor which caused us to be invoked. This should be an object which lives in the {\b CFdMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFdMonitor \\*MERGEFORMAT}{\fldrslt pagenum}}}) branch of the CMonitor class hierarchy. \par
}\par
Reimplemented from {\b CReactor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCReactor_a6 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 357 of file CFdReactor.cpp.\par
\par
References CFdMonitor::FD_EXCEPTION, CFdMonitor::FD_READABLE, CFdMonitor::FD_WRITABLE, CFdMonitor::FdConditions, CFdMonitor::getFd(), CFdMonitor::getLastEventMask(), OnException(), OnReadable(), and OnWritable().}
{\xe \v OnException\:CFdReactor}
{\xe \v CFdReactor\:OnException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CFdReactor::OnException ({\b CFdMonitor} & {\i rMonitor}, int {\i fd}){\f2  [virtual]}}
}\par
{\bkmkstart classCFdReactor_a8}
{\bkmkend classCFdReactor_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called when the file associated with the event monitor has an "exceptional condition".. Actual use of this Reactor involves subclassing the monitor and overriding OnException if you care about processing exceptional conditions. \par
\par
Reimplemented in {\b CFileEventReactor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFileEvent_1_1CFileEventReactor_a4 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 409 of file CFdReactor.cpp.\par
\par
Referenced by OnEvent().}
{\xe \v OnReadable\:CFdReactor}
{\xe \v CFdReactor\:OnReadable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CFdReactor::OnReadable ({\b CFdMonitor} & {\i rMonitor}, int {\i fd}){\f2  [virtual]}}
}\par
{\bkmkstart classCFdReactor_a6}
{\bkmkend classCFdReactor_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called when the file associated with the event monitor becomes readable. Actual use of this Reactor involves subclassing the monitor and overriding OnReadable if you care about reading the file. \par
\par
Reimplemented in {\b CFileEventReactor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFileEvent_1_1CFileEventReactor_a2 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 389 of file CFdReactor.cpp.\par
\par
Referenced by OnEvent().}
{\xe \v OnWritable\:CFdReactor}
{\xe \v CFdReactor\:OnWritable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CFdReactor::OnWritable ({\b CFdMonitor} & {\i rMonitor}, int {\i fd}){\f2  [virtual]}}
}\par
{\bkmkstart classCFdReactor_a7}
{\bkmkend classCFdReactor_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called when the file associated with the event monitor becomes writable. Actual use of this Reactor involves subclassing the monitor and overriding OnWritable if you care about writing the file. \par
\par
Reimplemented in {\b CFileEventReactor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFileEvent_1_1CFileEventReactor_a3 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 399 of file CFdReactor.cpp.\par
\par
Referenced by OnEvent().}
{\xe \v operator=\:CFdReactor}
{\xe \v CFdReactor\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CFdReactor& CFdReactor::operator= (const CFdReactor & {\i aCFdReactor}){\f2  [private]}}
}\par
{\bkmkstart classCFdReactor_c1}
{\bkmkend classCFdReactor_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operator= Assignment Operator - Prohibited.\par
}
{\xe \v operator==\:CFdReactor}
{\xe \v CFdReactor\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CFdReactor::operator== (const CFdReactor & {\i aCFdReactor}) const}
}\par
{\bkmkstart classCFdReactor_a4}
{\bkmkend classCFdReactor_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operator== Equality Operator.\par
\par
Definition at line 332 of file CFdReactor.cpp.\par
\par
References CReactor::operator==().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CFdReactor.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CFdReactor.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CFileEvent  Class Reference\par \pard\plain 
{\tc\tcl2 \v CFileEvent}
{\xe \v CFileEvent}
{\bkmkstart classCFileEvent}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CFileEvent.h>}\par
Inheritance diagram for CFileEvent:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCFileEvent.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CFileEvent} (int fd, int access={\b readable})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CFileEvent} (const char *pName, int flags=O_RDONLY, int access={\b readable})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CFileEvent} (const string &rName, int flags=O_RDONLY, int access={\b readable})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CFileEvent} (int fd, const char *pObjName, int access={\b readable})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CFileEvent} (const char *pObjName, const char *pName, int flags=O_RDONLY, int access={\b readable})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CFileEvent} (const char *pObjName, const string &rName, int flags=O_RDONLY, int access={\b readable})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CFileEvent} (int fd, const string &rObjName, int access={\b readable})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CFileEvent} (const string &rObjName, const char *pname, int flags=O_RDONLY, int access={\b readable})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CFileEvent} (const string &rObjName, const string &rName, int flags=O_RDONLY, int access={\b readable})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CFileEvent} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getFd} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getCloseOnDestory} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MonitorReadable} (bool fReadable=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MonitorWritable} (bool fWritable=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MonitorExceptions} (bool fExcept=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnReadable} (istream &rStream)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnWritable} (ostream &rStream)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnException} (iostream &fd)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTimeout} (iostream &str)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual string {\b DescribeSelf} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b readable} = 1\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Bitmask for readable monitoring.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b writeable} = 2\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Bitmask for writable monitoring.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b exceptions} = 4\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Bitmask for exception monitoring.}\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Exit} (int status)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetupMonitor} (int AccessMask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CFdMonitor} * {\b CreateMonitor} (const char *pFilename, const char *pMonitor, int flags)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CFileEvent} (const CFileEvent &rEvent)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CFileEvent & {\b operator=} (const CFileEvent &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CFileEvent &rEvent)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b m_nFd}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i File descriptor.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b m_fCloseOnDestroy}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i true if we opened the file.}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
C lass providing functionality for  file descriptor events. Must be derived and  operator() implemented to provide application functionality. \par
\par
Definition at line 333 of file CFileEvent.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CFileEvent\:CFileEvent}
{\xe \v CFileEvent\:CFileEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CFileEvent::CFileEvent (int {\i fd}, int {\i access} = {\b readable})}
}\par
{\bkmkstart classCFileEvent_a0}
{\bkmkend classCFileEvent_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct an anonymous file event from a file descriptor,  The file monitor is a {\b CFdMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFdMonitor \\*MERGEFORMAT}{\fldrslt pagenum}}}) directly constructed from the fd via new. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i fd}}  - File descriptor to open on the file. \par
{\b {\i access}}  - Bitwise or of access required to file. \par
}\par
Definition at line 404 of file CFileEvent.cpp.\par
\par
References CNamedObject::AppendClassInfo(), CNamedObject::GetAutoName(), m_fCloseOnDestroy, m_nFd, and SetupMonitor().}
{\xe \v CFileEvent\:CFileEvent}
{\xe \v CFileEvent\:CFileEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CFileEvent::CFileEvent (const char * {\i pName}, int {\i flags} = O_RDONLY, int {\i access} = {\b readable})}
}\par
{\bkmkstart classCFileEvent_a1}
{\bkmkend classCFileEvent_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct an anonymous file event from a filename as a const char* A file is opened and created with CreateMonitor. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i pName}}  - Name of file to open/create. \par
{\b {\i flags}}  - open(2) flags. \par
{\b {\i access}}  - Bitwise access requirements for the file. \par
}\par
Definition at line 421 of file CFileEvent.cpp.\par
\par
References CNamedObject::AppendClassInfo(), and SetupMonitor().}
{\xe \v CFileEvent\:CFileEvent}
{\xe \v CFileEvent\:CFileEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CFileEvent::CFileEvent (const string & {\i rName}, int {\i flags} = O_RDONLY, int {\i access} = {\b readable})}
}\par
{\bkmkstart classCFileEvent_a2}
{\bkmkend classCFileEvent_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct an anonymous file event from a filename as a const string& A file is opened and created with {\b CreateMonitor}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFileEvent_b2 \\*MERGEFORMAT}{\fldrslt pagenum}}}) {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rName}}  - Nameof the file to open/create \par
{\b {\i flags}}  - open(2) flags.. \par
{\b {\i access}}  - Bitwise access requirements for the file. \par
}\par
Definition at line 436 of file CFileEvent.cpp.\par
\par
References CNamedObject::AppendClassInfo(), and SetupMonitor().}
{\xe \v CFileEvent\:CFileEvent}
{\xe \v CFileEvent\:CFileEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CFileEvent::CFileEvent (int {\i fd}, const char * {\i pObjName}, int {\i access} = {\b readable})}
}\par
{\bkmkstart classCFileEvent_a3}
{\bkmkend classCFileEvent_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct a named file event from a char* object name, and a file descriptor. The {\b CFdMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFdMonitor \\*MERGEFORMAT}{\fldrslt pagenum}}}) is directly new'd into existence in the operation. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i pObjName}}  - Pointer to object name. \par
{\b {\i fd}}  - File descriptor on already open file to monitor. \par
{\b {\i access}}  - Bitwise or of the desired access to the file.\par
}Throws:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CDuplicateNameException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDuplicateNameException \\*MERGEFORMAT}{\fldrslt pagenum}}}) - if this object or any subobject already have this name. \par
}\par
Definition at line 463 of file CFileEvent.cpp.\par
\par
References CNamedObject::AppendClassInfo(), and SetupMonitor().}
{\xe \v CFileEvent\:CFileEvent}
{\xe \v CFileEvent\:CFileEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CFileEvent::CFileEvent (const char * {\i pObjName}, const char * {\i pFilename}, int {\i flags} = O_RDONLY, int {\i access} = {\b readable})}
}\par
{\bkmkstart classCFileEvent_a4}
{\bkmkend classCFileEvent_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct a named file event from a char* object name and a char* filename. The {\b CFdMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFdMonitor \\*MERGEFORMAT}{\fldrslt pagenum}}}) is created by CreateMonitor. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i pObjName}}  - Name to give to all the objects. \par
{\b {\i pFilename}}  - Name of the file to access. \par
{\b {\i flags}}  - open(2) flags. \par
{\b {\i access}}  - Bitwise or of the access rights desired to the file.\par
}Throws:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CDuplicateNameException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDuplicateNameException \\*MERGEFORMAT}{\fldrslt pagenum}}}) - if this object or any subobject already have this name. \par
}\par
Definition at line 489 of file CFileEvent.cpp.\par
\par
References CNamedObject::AppendClassInfo(), and SetupMonitor().}
{\xe \v CFileEvent\:CFileEvent}
{\xe \v CFileEvent\:CFileEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CFileEvent::CFileEvent (const char * {\i pObjName}, const string & {\i rFilename}, int {\i flags} = O_RDONLY, int {\i access} = {\b readable})}
}\par
{\bkmkstart classCFileEvent_a5}
{\bkmkend classCFileEvent_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Constructs a named file event given a char* object name and a string& filename. The monitor is created via CreateMonitor. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i pObjName}}  - Pointer to the name of the object  \par
{\b {\i rFilename}}  - Reference to the name of the file \par
{\b {\i flags}}  - open(2) flags.. \par
{\b {\i access}}  - Bitmask specifying access desired.\par
}Throws:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CDuplicateNameException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDuplicateNameException \\*MERGEFORMAT}{\fldrslt pagenum}}}) - if this object or any subobject already have this name. \par
}\par
Definition at line 513 of file CFileEvent.cpp.\par
\par
References CNamedObject::AppendClassInfo(), and SetupMonitor().}
{\xe \v CFileEvent\:CFileEvent}
{\xe \v CFileEvent\:CFileEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CFileEvent::CFileEvent (int {\i fd}, const string & {\i rObjName}, int {\i access} = {\b readable})}
}\par
{\bkmkstart classCFileEvent_a6}
{\bkmkend classCFileEvent_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct a file event from a string& object name and an fd. The Monitor can be created directly via new {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rObjName}}  - Reference to the name of the object. \par
{\b {\i fd}}  - File descriptor to monitor. \par
{\b {\i access}}  - Desired access to the file.\par
}Throws:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CDuplicateNameException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDuplicateNameException \\*MERGEFORMAT}{\fldrslt pagenum}}}) - if this object or any subobject already have this name. \par
}\par
Definition at line 539 of file CFileEvent.cpp.\par
\par
References CNamedObject::AppendClassInfo(), and SetupMonitor().}
{\xe \v CFileEvent\:CFileEvent}
{\xe \v CFileEvent\:CFileEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CFileEvent::CFileEvent (const string & {\i rObjName}, const char * {\i pFilename}, int {\i flags} = O_RDONLY, int {\i access} = {\b readable})}
}\par
{\bkmkstart classCFileEvent_a7}
{\bkmkend classCFileEvent_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct a file event from a string& object name and a char* filename. The monitor is created via CreateMonitor. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rObjName}}  - Reference to the name of the object. \par
{\b {\i pFilename}}  - Pointer to the filename. \par
{\b {\i flags}}  - open(2) flags. \par
{\b {\i access}}  - Bitmask specifying the desired file access.\par
}Throws:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CDuplicateNameException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDuplicateNameException \\*MERGEFORMAT}{\fldrslt pagenum}}}) - if this object or any subobject already have this name. \par
}\par
Definition at line 562 of file CFileEvent.cpp.\par
\par
References CNamedObject::AppendClassInfo(), and SetupMonitor().}
{\xe \v CFileEvent\:CFileEvent}
{\xe \v CFileEvent\:CFileEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CFileEvent::CFileEvent (const string & {\i rObjName}, const string & {\i rFilename}, int {\i flags} = O_RDONLY, int {\i access} = {\b readable})}
}\par
{\bkmkstart classCFileEvent_a8}
{\bkmkend classCFileEvent_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct a file event from a string& object name, and a string& filename. The monitor is created via CreateMonitor: {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rObjName}}  - The name of the object being created. \par
{\b {\i rFilename}}  - The name of the file being accessed. \par
{\b {\i flags}}  - open(2) flags. \par
{\b {\i access}}  - bitmask of requested access.\par
}Throws:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CDuplicateNameException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDuplicateNameException \\*MERGEFORMAT}{\fldrslt pagenum}}}) - if this object or any subobject already have this name. \par
}\par
Definition at line 584 of file CFileEvent.cpp.\par
\par
References CNamedObject::AppendClassInfo(), and SetupMonitor().}
{\xe \v ~CFileEvent\:CFileEvent}
{\xe \v CFileEvent\:~CFileEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CFileEvent::~CFileEvent ()}
}\par
{\bkmkstart classCFileEvent_a9}
{\bkmkend classCFileEvent_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Destructor: In all of the construction methods, the monitor and reactor are dynamically instantiated via new (that's what CreateMonitor will do). We need to get the Monitor and the Reactor and delete them. \par
\par
Definition at line 600 of file CFileEvent.cpp.\par
\par
References CEvent::getMonitor(), CEvent::getReactor(), and m_nFd.}
{\xe \v CFileEvent\:CFileEvent}
{\xe \v CFileEvent\:CFileEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CFileEvent::CFileEvent (const CFileEvent & {\i rEvent}){\f2  [private]}}
}\par
{\bkmkstart classCFileEvent_c0}
{\bkmkend classCFileEvent_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v CreateMonitor\:CFileEvent}
{\xe \v CFileEvent\:CreateMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CFdMonitor} * CFileEvent::CreateMonitor (const char * {\i pFilename}, const char * {\i pMonitor}, int {\i flags}){\f2  [protected]}}
}\par
{\bkmkstart classCFileEvent_b2}
{\bkmkend classCFileEvent_b2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Creates a new monitor given a filename. The file is created/opened for  read/write and the fd resulting is used to create a new {\b CFdMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFdMonitor \\*MERGEFORMAT}{\fldrslt pagenum}}}) (via new).{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i pFilename}}  - Name of the file to create/open. \par
{\b {\i pMonitor}}  - Name to give to the monitor. \par
{\b {\i flags}}  - open(2) flags.\par
}Exceptions:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) - If the file cannot be created/opened.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CDuplicateNameException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDuplicateNameException \\*MERGEFORMAT}{\fldrslt pagenum}}}) - If the a monitor with that name already exists. \par
}\par
Definition at line 728 of file CFileEvent.cpp.\par
\par
References m_nFd.}
{\xe \v DescribeSelf\:CFileEvent}
{\xe \v CFileEvent\:DescribeSelf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CFileEvent::DescribeSelf (){\f2  [virtual]}}
}\par
{\bkmkstart classCFileEvent_a19}
{\bkmkend classCFileEvent_a19}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called to get a description of the object. Tells the world we're a file handling event, dumps the {\b CEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent \\*MERGEFORMAT}{\fldrslt pagenum}}}) Description,  and gives the values of m_nFd, m_fCloseOnDestroy: \par
\par
Reimplemented from {\b CEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent_a16 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Reimplemented in {\b CServerConnectionEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCServerConnectionEvent_a14 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b CServerInstance} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCServerInstance_a11 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 785 of file CFileEvent.cpp.\par
\par
References CEvent::DescribeSelf(), m_fCloseOnDestroy, and m_nFd.}
{\xe \v Exit\:CFileEvent}
{\xe \v CFileEvent\:Exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CFileEvent::Exit (int {\i status}){\f2  [protected]}}
}\par
{\bkmkstart classCFileEvent_b0}
{\bkmkend classCFileEvent_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Exits the thread now (the object must still be destroyed at some point). The global mutex is released unconditionally, a DAQStatus object is created with the given status value and DAQThread::Exit is called.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i status}}  - An integer status value (often chosen from errno.h). \par
}\par
Definition at line 706 of file CFileEvent.cpp.\par
\par
References CApplicationSerializer::getInstance(), and CThreadRecursiveMutex::UnLockCompletely().}
{\xe \v getCloseOnDestory\:CFileEvent}
{\xe \v CFileEvent\:getCloseOnDestory}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CFileEvent::getCloseOnDestory () const{\f2  [inline]}}
}\par
{\bkmkstart classCFileEvent_a11}
{\bkmkend classCFileEvent_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 405 of file CFileEvent.h.\par
\par
References m_fCloseOnDestroy.}
{\xe \v getFd\:CFileEvent}
{\xe \v CFileEvent\:getFd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CFileEvent::getFd () const{\f2  [inline]}}
}\par
{\bkmkstart classCFileEvent_a10}
{\bkmkend classCFileEvent_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 404 of file CFileEvent.h.\par
\par
References m_nFd.\par
Referenced by CFileEventReactor::OnTimeout().}
{\xe \v MonitorExceptions\:CFileEvent}
{\xe \v CFileEvent\:MonitorExceptions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CFileEvent::MonitorExceptions (bool {\i fExcept} = true)}
}\par
{\bkmkstart classCFileEvent_a14}
{\bkmkend classCFileEvent_a14}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Select if the monitor should watch exceptions on the fd. This is delegated to the monitor's MonitorExceptions member function. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i fExcept}}  - true to watch for exceptions, false to disable. \par
}\par
Definition at line 636 of file CFileEvent.cpp.\par
\par
References CEvent::getMonitor().\par
Referenced by SetupMonitor().}
{\xe \v MonitorReadable\:CFileEvent}
{\xe \v CFileEvent\:MonitorReadable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CFileEvent::MonitorReadable (bool {\i fReadable} = true)}
}\par
{\bkmkstart classCFileEvent_a12}
{\bkmkend classCFileEvent_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Select if the monitor should watch readability. This is delegated to the monitor's MonitorReadable member function. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i fReadable}}  - true to watch readability false to disable that. \par
}\par
Definition at line 616 of file CFileEvent.cpp.\par
\par
References CEvent::getMonitor().\par
Referenced by SetupMonitor(), and CServerInstance::Shutdown().}
{\xe \v MonitorWritable\:CFileEvent}
{\xe \v CFileEvent\:MonitorWritable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CFileEvent::MonitorWritable (bool {\i fWritable} = true)}
}\par
{\bkmkstart classCFileEvent_a13}
{\bkmkend classCFileEvent_a13}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Select if the monitor should watch writability. This is delegated to the Monitor's MonitorWritable member function. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i fWritable}}  - true to watch writability false to disable \par
}\par
Definition at line 626 of file CFileEvent.cpp.\par
\par
References CEvent::getMonitor().\par
Referenced by SetupMonitor().}
{\xe \v OnException\:CFileEvent}
{\xe \v CFileEvent\:OnException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CFileEvent::OnException (iostream & {\i rStream}){\f2  [virtual]}}
}\par
{\bkmkstart classCFileEvent_a17}
{\bkmkend classCFileEvent_a17}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called when the file descriptor has some exception condition.  Normally, if an application is interested in this, the programmer will create a  subclass of a CFileEvent which implements this member function in a non null way. Default action is an implemented no-op. This requires the programmer to only provide implementations for the members s/he needs. The alternative (pure virtual member), requires a programmer to implement (even if only as a no-op), all members. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rStream}}  - Stream open on the file. \par
}\par
Definition at line 683 of file CFileEvent.cpp.\par
\par
Referenced by CFileEventReactor::OnException().}
{\xe \v OnReadable\:CFileEvent}
{\xe \v CFileEvent\:OnReadable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CFileEvent::OnReadable (istream & {\i str}){\f2  [virtual]}}
}\par
{\bkmkstart classCFileEvent_a15}
{\bkmkend classCFileEvent_a15}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called when a file descriptor becomes readable. Normally, if an  application is interested in this, the programmer will create a subclass of CFileEvent which implements this member function in a non-null way. Default action is an implemented No-op. By implementing (rather than making this a pure virtual member), the programmer needs only to provide the members s/he's interested in.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rStream}}  - Stream open on the file. \par
}\par
Reimplemented in {\b CServerConnectionEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCServerConnectionEvent_a13 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b CServerInstance} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCServerInstance_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 654 of file CFileEvent.cpp.\par
\par
Referenced by CFileEventReactor::OnReadable().}
{\xe \v OnTimeout\:CFileEvent}
{\xe \v CFileEvent\:OnTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CFileEvent::OnTimeout (iostream & {\i rStream}){\f2  [virtual]}}
}\par
{\bkmkstart classCFileEvent_a18}
{\bkmkend classCFileEvent_a18}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Calle dwhen a wait times out, and the caller has idicated that they want to pay attention to timeouts. {{{\b \par
ams str - reference to stream open on file.}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid \par
}\par
Definition at line 692 of file CFileEvent.cpp.\par
\par
Referenced by CFileEventReactor::OnTimeout().}
{\xe \v OnWritable\:CFileEvent}
{\xe \v CFileEvent\:OnWritable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CFileEvent::OnWritable (ostream & {\i rStream}){\f2  [virtual]}}
}\par
{\bkmkstart classCFileEvent_a16}
{\bkmkend classCFileEvent_a16}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called when the file descriptor becomes writable. Normally, if an application is interested in this, the programmer will create a  subclass of a CFileEvent which implements this member function in a non null way. Default action is an implemented no-op. This requires the programmer to only provide implementations for the members s/he needs. The alternative (pure virtual member), requires a programmer to implement (even if only as a no-op), all members. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rStream}}  - Stream open on the file. \par
}\par
Definition at line 668 of file CFileEvent.cpp.\par
\par
Referenced by CFileEventReactor::OnWritable().}
{\xe \v operator=\:CFileEvent}
{\xe \v CFileEvent\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CFileEvent& CFileEvent::operator= (const CFileEvent & {\i rhs}){\f2  [private]}}
}\par
{\bkmkstart classCFileEvent_c1}
{\bkmkend classCFileEvent_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:CFileEvent}
{\xe \v CFileEvent\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CFileEvent::operator== (const CFileEvent & {\i rEvent}){\f2  [private]}}
}\par
{\bkmkstart classCFileEvent_c2}
{\bkmkend classCFileEvent_c2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v SetupMonitor\:CFileEvent}
{\xe \v CFileEvent\:SetupMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CFileEvent::SetupMonitor (int {\i AccessMask}){\f2  [protected]}}
}\par
{\bkmkstart classCFileEvent_b1}
{\bkmkend classCFileEvent_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set up the acessibility of the monitor. This means that the access mask is translated into an initial set of calls to  MonitorReadable, MonitorWritable.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i AccessMask}}  - Bitwise or of the access requested.\par
}Legitimate bits in AccessMask are:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CFileEvent::readable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFileEvent_p0 \\*MERGEFORMAT}{\fldrslt pagenum}}}) - Monitor readability.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
CFileEvent::writable - Monitor writability.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CFileEvent::exceptions} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFileEvent_p2 \\*MERGEFORMAT}{\fldrslt pagenum}}}) - Monitor for exceptions. \par
}\par
Definition at line 762 of file CFileEvent.cpp.\par
\par
References exceptions, MonitorExceptions(), MonitorReadable(), MonitorWritable(), readable, and writeable.\par
Referenced by CFileEvent().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v exceptions\:CFileEvent}
{\xe \v CFileEvent\:exceptions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CFileEvent::exceptions = 4{\f2  [static]}}
}\par
{\bkmkstart classCFileEvent_p2}
{\bkmkend classCFileEvent_p2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Bitmask for exception monitoring.\par
\par
Definition at line 304 of file CFileEvent.cpp.\par
\par
Referenced by SetupMonitor().}
{\xe \v m_fCloseOnDestroy\:CFileEvent}
{\xe \v CFileEvent\:m_fCloseOnDestroy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CFileEvent::m_fCloseOnDestroy{\f2  [private]}}
}\par
{\bkmkstart classCFileEvent_o1}
{\bkmkend classCFileEvent_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
true if we opened the file.\par
\par
Definition at line 358 of file CFileEvent.h.\par
\par
Referenced by CFileEvent(), DescribeSelf(), and getCloseOnDestory().}
{\xe \v m_nFd\:CFileEvent}
{\xe \v CFileEvent\:m_nFd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CFileEvent::m_nFd{\f2  [private]}}
}\par
{\bkmkstart classCFileEvent_o0}
{\bkmkend classCFileEvent_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
File descriptor.\par
\par
Definition at line 357 of file CFileEvent.h.\par
\par
Referenced by CFileEvent(), CreateMonitor(), DescribeSelf(), getFd(), and ~CFileEvent().}
{\xe \v readable\:CFileEvent}
{\xe \v CFileEvent\:readable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CFileEvent::readable = 1{\f2  [static]}}
}\par
{\bkmkstart classCFileEvent_p0}
{\bkmkend classCFileEvent_p0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Bitmask for readable monitoring.\par
\par
Definition at line 302 of file CFileEvent.cpp.\par
\par
Referenced by SetupMonitor().}
{\xe \v writeable\:CFileEvent}
{\xe \v CFileEvent\:writeable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CFileEvent::writeable = 2{\f2  [static]}}
}\par
{\bkmkstart classCFileEvent_p1}
{\bkmkend classCFileEvent_p1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Bitmask for writable monitoring.\par
\par
Definition at line 303 of file CFileEvent.cpp.\par
\par
Referenced by SetupMonitor().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CFileEvent.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CFileEvent.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CFileEventReactor  Class Reference\par \pard\plain 
{\tc\tcl2 \v CFileEvent::CFileEventReactor}
{\xe \v CFileEvent::CFileEventReactor}
{\bkmkstart classCFileEvent_1_1CFileEventReactor}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Inheritance diagram for CFileEventReactor:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCFileEvent_1_1CFileEventReactor.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CFileEventReactor} (const string &rName, {\b CFileEvent} &rOwner)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CFileEventReactor} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnReadable} ({\b CFdMonitor} &rMonitor, int fd)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnWritable} ({\b CFdMonitor} &rMonitor, int fd)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnException} ({\b CFdMonitor} &rMonitor, int fd)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTimeout} ({\b CEventMonitor} &rMonitor)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CFileEvent} & {\b m_rOwner}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Owner of us.}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
This is an internal class which is automatically used as the  Reactor for File events. About the only thing it does is call back to the file event. \par
\par
Definition at line 342 of file CFileEvent.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CFileEventReactor\:CFileEvent::CFileEventReactor}
{\xe \v CFileEvent::CFileEventReactor\:CFileEventReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CFileEventReactor::CFileEventReactor (const string & {\i rName}, {\b CFileEvent} & {\i rOwner})}
}\par
{\bkmkstart classCFileEvent_1_1CFileEventReactor_a0}
{\bkmkend classCFileEvent_1_1CFileEventReactor_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Constructor for {\b CFileEventReactor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFileEvent_1_1CFileEventReactor \\*MERGEFORMAT}{\fldrslt pagenum}}}): Constructs the reactor by {\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Calling the base class constructor ({\b CReactor}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCReactor_a0 \\*MERGEFORMAT}{\fldrslt pagenum}}})).\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Initializing m_rOwner to the event which is instantiating us.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Calling {\b AppendClassInfo}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNamedObject_b2 \\*MERGEFORMAT}{\fldrslt pagenum}}}) so that our place in the class hierarchy is well defined.\par
}{{{\b Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rName}}  - Reference to the name given to this reactor. \par
{\b {\i rOwner}}  - Reference to the owning event. \par
}\par
Definition at line 324 of file CFileEvent.cpp.\par
\par
References CNamedObject::AppendClassInfo().}
{\xe \v ~CFileEventReactor\:CFileEvent::CFileEventReactor}
{\xe \v CFileEvent::CFileEventReactor\:~CFileEventReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CFileEventReactor::~CFileEventReactor (){\f2  [inline]}}
}\par
{\bkmkstart classCFileEvent_1_1CFileEventReactor_a1}
{\bkmkend classCFileEvent_1_1CFileEventReactor_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 347 of file CFileEvent.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v OnException\:CFileEvent::CFileEventReactor}
{\xe \v CFileEvent::CFileEventReactor\:OnException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CFileEventReactor::OnException ({\b CFdMonitor} & {\i rMonitor}, int {\i fd}){\f2  [virtual]}}
}\par
{\bkmkstart classCFileEvent_1_1CFileEventReactor_a4}
{\bkmkend classCFileEvent_1_1CFileEventReactor_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called when an exceptional condition is encountered on a file. We create an iostream and bounce the call back to m_rOwner's OnException. This  creates the look and feel of a monolithic Event class. \par
\par
Reimplemented from {\b CFdReactor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFdReactor_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 371 of file CFileEvent.cpp.\par
\par
References CFileEventReactor::m_rOwner, and CFileEvent::OnException().}
{\xe \v OnReadable\:CFileEvent::CFileEventReactor}
{\xe \v CFileEvent::CFileEventReactor\:OnReadable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CFileEventReactor::OnReadable ({\b CFdMonitor} & {\i rMonitor}, int {\i fd}){\f2  [virtual]}}
}\par
{\bkmkstart classCFileEvent_1_1CFileEventReactor_a2}
{\bkmkend classCFileEvent_1_1CFileEventReactor_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called whenever the file becomes readable. We create an istream for the file, and call back to m_rOwner's OnReadable member. This all makes the Event seem like a monolithic unit to the user.... They just subclass it, open a file in an appropriate way and poof.{{{\b \par
arm rMonitor - Refers to the monitor on the file (unused).}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid  \par
}{{{\b Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i fd}}  - File descriptor open on the file. \par
}\par
Reimplemented from {\b CFdReactor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFdReactor_a6 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 342 of file CFileEvent.cpp.\par
\par
References CFileEventReactor::m_rOwner, and CFileEvent::OnReadable().}
{\xe \v OnTimeout\:CFileEvent::CFileEventReactor}
{\xe \v CFileEvent::CFileEventReactor\:OnTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CFileEventReactor::OnTimeout ({\b CEventMonitor} & {\i rMonitor}){\f2  [virtual]}}
}\par
{\bkmkstart classCFileEvent_1_1CFileEventReactor_a5}
{\bkmkend classCFileEvent_1_1CFileEventReactor_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called when a wait on the file event times out. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rMonitor}}  -referens to the event monitor. \par
}\par
Reimplemented from {\b CReactor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCReactor_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 383 of file CFileEvent.cpp.\par
\par
References CFileEvent::getFd(), CFileEventReactor::m_rOwner, and CFileEvent::OnTimeout().}
{\xe \v OnWritable\:CFileEvent::CFileEventReactor}
{\xe \v CFileEvent::CFileEventReactor\:OnWritable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CFileEventReactor::OnWritable ({\b CFdMonitor} & {\i rMonitor}, int {\i fd}){\f2  [virtual]}}
}\par
{\bkmkstart classCFileEvent_1_1CFileEventReactor_a3}
{\bkmkend classCFileEvent_1_1CFileEventReactor_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called when a file descriptor becomes writable. We just create a stream and bounce the call back to the {\b CFileEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFileEvent \\*MERGEFORMAT}{\fldrslt pagenum}}})'s OnWritable member. This presents a monolithic look and feel to the end user of this library.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rMonitor}}  - The file monitor which declared the event.(unused) \par
{\b {\i fd}}  - The file id which is now writable  (constructs the ostream) \par
}\par
Reimplemented from {\b CFdReactor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFdReactor_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 360 of file CFileEvent.cpp.\par
\par
References CFileEventReactor::m_rOwner, and CFileEvent::OnWritable().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_rOwner\:CFileEvent::CFileEventReactor}
{\xe \v CFileEvent::CFileEventReactor\:m_rOwner}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CFileEvent}& CFileEventReactor::m_rOwner{\f2  [private]}}
}\par
{\bkmkstart classCFileEvent_1_1CFileEventReactor_o0}
{\bkmkend classCFileEvent_1_1CFileEventReactor_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Owner of us.\par
\par
Definition at line 344 of file CFileEvent.h.\par
\par
Referenced by CFileEventReactor::OnException(), CFileEventReactor::OnReadable(), CFileEventReactor::OnTimeout(), and CFileEventReactor::OnWritable().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CFileEvent.cpp}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CFileEvent.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Generic_List< T >  Class Template Reference\par \pard\plain 
{\tc\tcl2 \v Generic_List}
{\xe \v Generic_List}
{\bkmkstart classGeneric__List}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMWlist.h>}\par
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Generic_List} (int size=LIST_DEFAULT_SIZE)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Generic_List} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Add} (T *item)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InitIteration} (int loc=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Exists} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T * {\b Next} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Index} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Remove} (int idx)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b index}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b num_entries}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b max_entries}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T ** {\b entries}\par
}

{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class T> class Generic_List< T >\par
}

{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Generic_List\:Generic_List}
{\xe \v Generic_List\:Generic_List}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> Generic_List< T >::Generic_List (int {\i size} = LIST_DEFAULT_SIZE){\f2  [inline]}}
}\par
{\bkmkstart classGeneric__List_a0}
{\bkmkend classGeneric__List_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 320 of file XMWlist.h.\par
}
{\xe \v ~Generic_List\:Generic_List}
{\xe \v Generic_List\:~Generic_List}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> Generic_List< T >::~Generic_List (){\f2  [inline]}}
}\par
{\bkmkstart classGeneric__List_a1}
{\bkmkend classGeneric__List_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 330 of file XMWlist.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Add\:Generic_List}
{\xe \v Generic_List\:Add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int Generic_List< T >::Add (T * {\i item}){\f2  [inline]}}
}\par
{\bkmkstart classGeneric__List_a2}
{\bkmkend classGeneric__List_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 336 of file XMWlist.h.\par
}
{\xe \v Exists\:Generic_List}
{\xe \v Generic_List\:Exists}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int Generic_List< T >::Exists (){\f2  [inline]}}
}\par
{\bkmkstart classGeneric__List_a4}
{\bkmkend classGeneric__List_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 349 of file XMWlist.h.\par
}
{\xe \v Index\:Generic_List}
{\xe \v Generic_List\:Index}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int Generic_List< T >::Index (){\f2  [inline]}}
}\par
{\bkmkstart classGeneric__List_a6}
{\bkmkend classGeneric__List_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 361 of file XMWlist.h.\par
}
{\xe \v InitIteration\:Generic_List}
{\xe \v Generic_List\:InitIteration}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void Generic_List< T >::InitIteration (int {\i loc} = 0){\f2  [inline]}}
}\par
{\bkmkstart classGeneric__List_a3}
{\bkmkend classGeneric__List_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 346 of file XMWlist.h.\par
}
{\xe \v Next\:Generic_List}
{\xe \v Generic_List\:Next}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> T* Generic_List< T >::Next (){\f2  [inline]}}
}\par
{\bkmkstart classGeneric__List_a5}
{\bkmkend classGeneric__List_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 352 of file XMWlist.h.\par
}
{\xe \v Remove\:Generic_List}
{\xe \v Generic_List\:Remove}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void Generic_List< T >::Remove (int {\i idx}){\f2  [inline]}}
}\par
{\bkmkstart classGeneric__List_a7}
{\bkmkend classGeneric__List_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 364 of file XMWlist.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v entries\:Generic_List}
{\xe \v Generic_List\:entries}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> T** Generic_List< T >::entries{\f2  [protected]}}
}\par
{\bkmkstart classGeneric__List_n3}
{\bkmkend classGeneric__List_n3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 314 of file XMWlist.h.\par
\par
Referenced by Generic_List< XMWidget >::Add(), Generic_List< XMWidget >::Generic_List(), Generic_List< XMWidget >::Next(), Generic_List< XMWidget >::Remove(), and Generic_List< XMWidget >::~Generic_List().}
{\xe \v index\:Generic_List}
{\xe \v Generic_List\:index}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int Generic_List< T >::index{\f2  [protected]}}
}\par
{\bkmkstart classGeneric__List_n0}
{\bkmkend classGeneric__List_n0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 311 of file XMWlist.h.\par
\par
Referenced by Generic_List< XMWidget >::Exists(), Generic_List< XMWidget >::Generic_List(), Generic_List< XMWidget >::Index(), Generic_List< XMWidget >::InitIteration(), and Generic_List< XMWidget >::Next().}
{\xe \v max_entries\:Generic_List}
{\xe \v Generic_List\:max_entries}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int Generic_List< T >::max_entries{\f2  [protected]}}
}\par
{\bkmkstart classGeneric__List_n2}
{\bkmkend classGeneric__List_n2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 313 of file XMWlist.h.\par
\par
Referenced by Generic_List< XMWidget >::Add(), and Generic_List< XMWidget >::Generic_List().}
{\xe \v num_entries\:Generic_List}
{\xe \v Generic_List\:num_entries}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int Generic_List< T >::num_entries{\f2  [protected]}}
}\par
{\bkmkstart classGeneric__List_n1}
{\bkmkend classGeneric__List_n1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 312 of file XMWlist.h.\par
\par
Referenced by Generic_List< XMWidget >::Add(), Generic_List< XMWidget >::Exists(), Generic_List< XMWidget >::Generic_List(), Generic_List< XMWidget >::Next(), and Generic_List< XMWidget >::Remove().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMWlist.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CIncompatibleMonitor  Class Reference\par \pard\plain 
{\tc\tcl2 \v CIncompatibleMonitor}
{\xe \v CIncompatibleMonitor}
{\bkmkstart classCIncompatibleMonitor}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CIncompatibleMonitor.h>}\par
Inheritance diagram for CIncompatibleMonitor:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCIncompatibleMonitor.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CIncompatibleMonitor} ({\b CEventMonitor} &rMonitor, const char *pDoing)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CIncompatibleMonitor} (const CIncompatibleMonitor &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CIncompatibleMonitor} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CIncompatibleMonitor & {\b operator=} (const CIncompatibleMonitor &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CIncompatibleMonitor &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b getMonitorDescription} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMonitorDescription} (const string &rnew)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const char * {\b ReasonText} () const\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_MonitorDescription}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_Reason}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
Encapsulates exceptions thrown when a reactor sense that it has been attached to an incompatible event monitor. The exception is capable of returning textual string information about the type of the monitor received and what the reactor was doing when it threw the exception. \par
\par
Definition at line 307 of file CIncompatibleMonitor.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CIncompatibleMonitor\:CIncompatibleMonitor}
{\xe \v CIncompatibleMonitor\:CIncompatibleMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CIncompatibleMonitor::CIncompatibleMonitor ({\b CEventMonitor} & {\i rMonitor}, const char * {\i pDoing})}
}\par
{\bkmkstart classCIncompatibleMonitor_a0}
{\bkmkend classCIncompatibleMonitor_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
"Normal" Constructor. Constructs an incompatible exception object just prior to throwing it. Information from the monitor is stored as is information about what was happening in the system at the time the exception was constructed:{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rMonitor}}  - The monitor which was not compatible with the Reactor that detected the problem. \par
{\b {\i pDoing}}  - Text string describing what the program was attempting to do when the incompatibility was detected. \par
}\par
Definition at line 306 of file CIncompatibleMonitor.cpp.\par
}
{\xe \v CIncompatibleMonitor\:CIncompatibleMonitor}
{\xe \v CIncompatibleMonitor\:CIncompatibleMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CIncompatibleMonitor::CIncompatibleMonitor (const CIncompatibleMonitor & {\i rhs})}
}\par
{\bkmkstart classCIncompatibleMonitor_a1}
{\bkmkend classCIncompatibleMonitor_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Copy constructor. Used by the compiler construct temporary objects or  alternatively, and more usually for this class to build a 'scope safe' copy of the exception which can be saved and passed to catch handlers. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rhs}}  - the reference object being copy constructed. \par
}\par
Definition at line 320 of file CIncompatibleMonitor.cpp.\par
}
{\xe \v ~CIncompatibleMonitor\:CIncompatibleMonitor}
{\xe \v CIncompatibleMonitor\:~CIncompatibleMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual CIncompatibleMonitor::~CIncompatibleMonitor (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCIncompatibleMonitor_a2}
{\bkmkend classCIncompatibleMonitor_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 318 of file CIncompatibleMonitor.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getMonitorDescription\:CIncompatibleMonitor}
{\xe \v CIncompatibleMonitor\:getMonitorDescription}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CIncompatibleMonitor::getMonitorDescription () const{\f2  [inline]}}
}\par
{\bkmkstart classCIncompatibleMonitor_a5}
{\bkmkend classCIncompatibleMonitor_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 325 of file CIncompatibleMonitor.h.\par
\par
References m_MonitorDescription.}
{\xe \v operator=\:CIncompatibleMonitor}
{\xe \v CIncompatibleMonitor\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CIncompatibleMonitor & CIncompatibleMonitor::operator= (const CIncompatibleMonitor & {\i rhs})}
}\par
{\bkmkstart classCIncompatibleMonitor_a3}
{\bkmkend classCIncompatibleMonitor_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Assignment operator. .much like copy construction except:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
We gaurd against self assignment problems.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
We are already a fully constructed object in our own right.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
We return a refereince to *this.\par
}{{{\b Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rhs}}  - the object being assigned to us. \par
}\par
Definition at line 335 of file CIncompatibleMonitor.cpp.\par
\par
References m_MonitorDescription, and CException::operator=().}
{\xe \v operator==\:CIncompatibleMonitor}
{\xe \v CIncompatibleMonitor\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CIncompatibleMonitor::operator== (const CIncompatibleMonitor & {\i rhs})}
}\par
{\bkmkstart classCIncompatibleMonitor_a4}
{\bkmkend classCIncompatibleMonitor_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Equality comparison. We do base class comparison and compare the monitor description. The m_Reason string is not relevant.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rhs}}  - Reference to object we compare ourselves to. \par
}\par
Definition at line 351 of file CIncompatibleMonitor.cpp.\par
\par
References m_MonitorDescription, and CException::operator==().}
{\xe \v ReasonText\:CIncompatibleMonitor}
{\xe \v CIncompatibleMonitor\:ReasonText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * CIncompatibleMonitor::ReasonText () const{\f2  [virtual]}}
}\par
{\bkmkstart classCIncompatibleMonitor_a7}
{\bkmkend classCIncompatibleMonitor_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns a description of why the exception is being thrown. This is of the form: Incompatible Event monitor found: "monitor description", while: Doing" \par
\par
Reimplemented from {\b CException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCException_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 363 of file CIncompatibleMonitor.cpp.\par
\par
References m_MonitorDescription, m_Reason, and CException::WasDoing().}
{\xe \v setMonitorDescription\:CIncompatibleMonitor}
{\xe \v CIncompatibleMonitor\:setMonitorDescription}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CIncompatibleMonitor::setMonitorDescription (const string & {\i rnew}){\f2  [inline]}}
}\par
{\bkmkstart classCIncompatibleMonitor_a6}
{\bkmkend classCIncompatibleMonitor_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 331 of file CIncompatibleMonitor.h.\par
\par
References m_MonitorDescription.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_MonitorDescription\:CIncompatibleMonitor}
{\xe \v CIncompatibleMonitor\:m_MonitorDescription}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CIncompatibleMonitor::m_MonitorDescription{\f2  [private]}}
}\par
{\bkmkstart classCIncompatibleMonitor_o0}
{\bkmkend classCIncompatibleMonitor_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 311 of file CIncompatibleMonitor.h.\par
\par
Referenced by getMonitorDescription(), operator=(), operator==(), ReasonText(), and setMonitorDescription().}
{\xe \v m_Reason\:CIncompatibleMonitor}
{\xe \v CIncompatibleMonitor\:m_Reason}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CIncompatibleMonitor::m_Reason{\f2  [private]}}
}\par
{\bkmkstart classCIncompatibleMonitor_o1}
{\bkmkend classCIncompatibleMonitor_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 312 of file CIncompatibleMonitor.h.\par
\par
Referenced by ReasonText().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CIncompatibleMonitor.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CIncompatibleMonitor.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CInitBinding  Class Reference\par \pard\plain 
{\tc\tcl2 \v CInitBinding}
{\xe \v CInitBinding}
{\bkmkstart classCInitBinding}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CInitBinding} ({\b CTCLInterpreter} &rInterp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b operator()} ({\b CTypeFreeBinding} *pBinding)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLInterpreter} & {\b m_rInterp}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CInitBinding\:CInitBinding}
{\xe \v CInitBinding\:CInitBinding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CInitBinding::CInitBinding ({\b CTCLInterpreter} & {\i rInterp}){\f2  [inline]}}
}\par
{\bkmkstart classCInitBinding_a0}
{\bkmkend classCInitBinding_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 311 of file CConfigurationManager.cpp.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator()\:CInitBinding}
{\xe \v CInitBinding\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CInitBinding::operator() ({\b CTypeFreeBinding} * {\i pBinding}){\f2  [inline]}}
}\par
{\bkmkstart classCInitBinding_a1}
{\bkmkend classCInitBinding_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 312 of file CConfigurationManager.cpp.\par
\par
References CTypeFreeBinding::InitBindings().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_rInterp\:CInitBinding}
{\xe \v CInitBinding\:m_rInterp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CTCLInterpreter}& CInitBinding::m_rInterp{\f2  [private]}}
}\par
{\bkmkstart classCInitBinding_o0}
{\bkmkend classCInitBinding_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 309 of file CConfigurationManager.cpp.\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CConfigurationManager.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CInterpreterStartup  Class Reference\par \pard\plain 
{\tc\tcl2 \v CInterpreterStartup}
{\xe \v CInterpreterStartup}
{\bkmkstart classCInterpreterStartup}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CInterpreterStartup.h>}\par
Inheritance diagram for CInterpreterStartup:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCInterpreterStartup.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CInterpreterStartup} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Nulls out the interpreter and sync command pointers.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CInterpreterStartup} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLInterpreter} * {\b getInterpreter} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Return a pointer to the interpreter object.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLInterpreter} & {\b Interp} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnInitialize} (int argc, char **Argv)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b RegisterExtensions} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setInterpreter} ({\b CTCLInterpreter} *pInterp)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set the interpreter object:.}\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator()} (int argc, char **argv)=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CInterpreterStartup} (const CInterpreterStartup &aCInterpreterStartup)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Copy Constructor is forbidden, private, unimplemented.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CInterpreterStartup & {\b operator=} (const CInterpreterStartup &aCInterpreterStartup)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Assignment is forbidden, private, unimplemented.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CInterpreterStartup &aCInterpreterStartup) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Operator== Equality Operator forbidden, private, unimplemented.}\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLInterpreter} * {\b m_pInterp}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLSynchronizeCommand} * {\b m_pSyncCommand}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
Encapsulates interfaces for starting up  TCL based interpreter event loops. The TCL interpreter executes within a thread. Adding a command to the interpreter should be done by subclassing {\b CDAQTCLProcessor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDAQTCLProcessor \\*MERGEFORMAT}{\fldrslt pagenum}}}), instantiating an object for that class, and registring it on the current interpreter. It is important that DAQTCLProcessor objects be used rather than TCLProcessor objects since DAQTCLProcessor is thread-aware and will therefore synchronize its action through the application's global mutex. \par
\par
Definition at line 315 of file CInterpreterStartup.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CInterpreterStartup\:CInterpreterStartup}
{\xe \v CInterpreterStartup\:CInterpreterStartup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CInterpreterStartup::CInterpreterStartup ()}
}\par
{\bkmkstart classCInterpreterStartup_a0}
{\bkmkend classCInterpreterStartup_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Nulls out the interpreter and sync command pointers.\par
Encapsulates interfaces for starting up  TCL based interpreter event loops. The TCL interpreter executes within a thread. Adding a command to the interpreter should be done by subclassing {\b CDAQTCLProcessor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDAQTCLProcessor \\*MERGEFORMAT}{\fldrslt pagenum}}}), instantiating an object for that class, and registring it on the current interpreter. It is important that DAQTCLProcessor objects be used rather than TCLProcessor objects since DAQTCLProcessor is thread-aware and will therefore synchronize its action  through the application's global mutex. \par
\par
Definition at line 300 of file CInterpreterStartup.cpp.\par
}
{\xe \v ~CInterpreterStartup\:CInterpreterStartup}
{\xe \v CInterpreterStartup\:~CInterpreterStartup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CInterpreterStartup::~CInterpreterStartup (){\f2  [virtual]}}
}\par
{\bkmkstart classCInterpreterStartup_a1}
{\bkmkend classCInterpreterStartup_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
The destructor only destroys the sync command. The subclass is responsible for destroying the interpreter which in turn will unregister the sync command \par
\par
Definition at line 311 of file CInterpreterStartup.cpp.\par
\par
References m_pSyncCommand.}
{\xe \v CInterpreterStartup\:CInterpreterStartup}
{\xe \v CInterpreterStartup\:CInterpreterStartup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CInterpreterStartup::CInterpreterStartup (const CInterpreterStartup & {\i aCInterpreterStartup}){\f2  [private]}}
}\par
{\bkmkstart classCInterpreterStartup_c1}
{\bkmkend classCInterpreterStartup_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Copy Constructor is forbidden, private, unimplemented.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getInterpreter\:CInterpreterStartup}
{\xe \v CInterpreterStartup\:getInterpreter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CTCLInterpreter}* CInterpreterStartup::getInterpreter (){\f2  [inline]}}
}\par
{\bkmkstart classCInterpreterStartup_a2}
{\bkmkend classCInterpreterStartup_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Return a pointer to the interpreter object.\par
\par
Definition at line 353 of file CInterpreterStartup.h.\par
}
{\xe \v Interp\:CInterpreterStartup}
{\xe \v CInterpreterStartup\:Interp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CTCLInterpreter}& CInterpreterStartup::Interp (){\f2  [inline]}}
}\par
{\bkmkstart classCInterpreterStartup_a3}
{\bkmkend classCInterpreterStartup_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get a reference to the interpreter object: Note that this can fail if there is not yet an interpreter (m_pInterp is NULL in that case). \par
\par
Definition at line 360 of file CInterpreterStartup.h.\par
}
{\xe \v OnInitialize\:CInterpreterStartup}
{\xe \v CInterpreterStartup\:OnInitialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CInterpreterStartup::OnInitialize (int {\i argc}, char ** {\i Argv}){\f2  [protected, virtual]}}
}\par
{\bkmkstart classCInterpreterStartup_b0}
{\bkmkend classCInterpreterStartup_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
On initialize is called very early in  the execution of the operator() member. It is intended that subclassed interpreters perform early initialization here. At this point an interpreter has not yet been  instantiated. Therefore, you may not perform Tcl/Tk library calls at this  stage.\par
Default implementation is a no-op. \par
\par
Definition at line 332 of file CInterpreterStartup.cpp.\par
\par
Referenced by CTKInterpreterStartup::operator()(), and CTCLInterpreterStartup::operator()().}
{\xe \v operator()\:CInterpreterStartup}
{\xe \v CInterpreterStartup\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CInterpreterStartup::operator() (int {\i argc}, char ** {\i argv}){\f2  [private, pure virtual]}}
}\par
{\bkmkstart classCInterpreterStartup_c0}
{\bkmkend classCInterpreterStartup_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
This pure virtual member function is expected to start the interpreter and call the other member functions; it is the entry point of the thread. \par
\par
Implements {\b CEventLoop} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEventLoop_c0 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Implemented in {\b CTCLInterpreterStartup} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCLInterpreterStartup_c0 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b CTKInterpreterStartup} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTKInterpreterStartup_c3 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
}
{\xe \v operator=\:CInterpreterStartup}
{\xe \v CInterpreterStartup\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CInterpreterStartup& CInterpreterStartup::operator= (const CInterpreterStartup & {\i aCInterpreterStartup}){\f2  [private]}}
}\par
{\bkmkstart classCInterpreterStartup_c2}
{\bkmkend classCInterpreterStartup_c2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Assignment is forbidden, private, unimplemented.\par
}
{\xe \v operator==\:CInterpreterStartup}
{\xe \v CInterpreterStartup\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CInterpreterStartup::operator== (const CInterpreterStartup & {\i aCInterpreterStartup}) const{\f2  [private]}}
}\par
{\bkmkstart classCInterpreterStartup_c3}
{\bkmkend classCInterpreterStartup_c3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operator== Equality Operator forbidden, private, unimplemented.\par
}
{\xe \v RegisterExtensions\:CInterpreterStartup}
{\xe \v CInterpreterStartup\:RegisterExtensions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CInterpreterStartup::RegisterExtensions (){\f2  [protected, virtual]}}
}\par
{\bkmkstart classCInterpreterStartup_b1}
{\bkmkend classCInterpreterStartup_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Concrete subclasses of this class must implement this function. It is expected that all tcl interpreters run in this envrionment will have extensions At this point, an interpreter has been created.\par
If this is a Tk derived  interpreter, it's not certain that the tk Main window has been created yet however.\par
Default behavior which should be chained to by subclasses is to register the synch command. This makes available scripts which are synchronized to the application's global mutex. \par
\par
Definition at line 355 of file CInterpreterStartup.cpp.\par
\par
References m_pInterp, m_pSyncCommand, and CDAQTCLProcessor::Register().\par
Referenced by CTCLInterpreterStartup::Tcl_Init(), and CTKInterpreterStartup::Tk_Init().}
{\xe \v setInterpreter\:CInterpreterStartup}
{\xe \v CInterpreterStartup\:setInterpreter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CInterpreterStartup::setInterpreter ({\b CTCLInterpreter} * {\i pInterp}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCInterpreterStartup_b2}
{\bkmkend classCInterpreterStartup_b2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set the interpreter object:.\par
\par
Definition at line 368 of file CInterpreterStartup.h.\par
\par
Referenced by CTCLInterpreterStartup::Tcl_Init(), and CTKInterpreterStartup::Tk_Init().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_pInterp\:CInterpreterStartup}
{\xe \v CInterpreterStartup\:m_pInterp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CTCLInterpreter}* CInterpreterStartup::m_pInterp{\f2  [private]}}
}\par
{\bkmkstart classCInterpreterStartup_o0}
{\bkmkend classCInterpreterStartup_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 318 of file CInterpreterStartup.h.\par
\par
Referenced by RegisterExtensions().}
{\xe \v m_pSyncCommand\:CInterpreterStartup}
{\xe \v CInterpreterStartup\:m_pSyncCommand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CTCLSynchronizeCommand}* CInterpreterStartup::m_pSyncCommand{\f2  [private]}}
}\par
{\bkmkstart classCInterpreterStartup_o1}
{\bkmkend classCInterpreterStartup_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 319 of file CInterpreterStartup.h.\par
\par
Referenced by RegisterExtensions(), and ~CInterpreterStartup().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CInterpreterStartup.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CInterpreterStartup.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CLinkFailedException  Class Reference\par \pard\plain 
{\tc\tcl2 \v CLinkFailedException}
{\xe \v CLinkFailedException}
{\bkmkstart classCLinkFailedException}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CLinkFailedException.h>}\par
Inheritance diagram for CLinkFailedException:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCLinkFailedException.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLinkFailedException} (const char *pDoing, const char *pName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLinkFailedException} (const char *pDoing, const string &rName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLinkFailedException} (const string &rDoing, const char *pName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLinkFailedException} (const string &rDoing, const string &rName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLinkFailedException} (const string &rDoing, int nId)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLinkFailedException} (const char *pDoing, int nId)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CLinkFailedException} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLinkFailedException} (const CLinkFailedException &aCLinkFailedException)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CLinkFailedException {\b operator=} (const CLinkFailedException &aCLinkFailedException)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CLinkFailedException &aCLinkFailedException)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b getName} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setName} (string am_sName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const char * {\b ReasonText} () const\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UpdateReasonText} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_sName}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b m_nId}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b m_fName}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_sReasonText}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CLinkFailedException\:CLinkFailedException}
{\xe \v CLinkFailedException\:CLinkFailedException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CLinkFailedException::CLinkFailedException (const char * {\i pDoing}, const char * {\i pName}){\f2  [inline]}}
}\par
{\bkmkstart classCLinkFailedException_a0}
{\bkmkend classCLinkFailedException_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 301 of file CLinkFailedException.h.\par
\par
References m_fName, m_sName, and UpdateReasonText().}
{\xe \v CLinkFailedException\:CLinkFailedException}
{\xe \v CLinkFailedException\:CLinkFailedException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CLinkFailedException::CLinkFailedException (const char * {\i pDoing}, const string & {\i rName}){\f2  [inline]}}
}\par
{\bkmkstart classCLinkFailedException_a1}
{\bkmkend classCLinkFailedException_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 307 of file CLinkFailedException.h.\par
\par
References m_fName, m_sName, and UpdateReasonText().}
{\xe \v CLinkFailedException\:CLinkFailedException}
{\xe \v CLinkFailedException\:CLinkFailedException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CLinkFailedException::CLinkFailedException (const string & {\i rDoing}, const char * {\i pName}){\f2  [inline]}}
}\par
{\bkmkstart classCLinkFailedException_a2}
{\bkmkend classCLinkFailedException_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 313 of file CLinkFailedException.h.\par
\par
References m_fName, m_sName, and UpdateReasonText().}
{\xe \v CLinkFailedException\:CLinkFailedException}
{\xe \v CLinkFailedException\:CLinkFailedException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CLinkFailedException::CLinkFailedException (const string & {\i rDoing}, const string & {\i rName}){\f2  [inline]}}
}\par
{\bkmkstart classCLinkFailedException_a3}
{\bkmkend classCLinkFailedException_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 319 of file CLinkFailedException.h.\par
\par
References m_fName, m_sName, and UpdateReasonText().}
{\xe \v CLinkFailedException\:CLinkFailedException}
{\xe \v CLinkFailedException\:CLinkFailedException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CLinkFailedException::CLinkFailedException (const string & {\i rDoing}, int {\i nId}){\f2  [inline]}}
}\par
{\bkmkstart classCLinkFailedException_a4}
{\bkmkend classCLinkFailedException_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 325 of file CLinkFailedException.h.\par
\par
References m_fName, m_nId, and UpdateReasonText().}
{\xe \v CLinkFailedException\:CLinkFailedException}
{\xe \v CLinkFailedException\:CLinkFailedException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CLinkFailedException::CLinkFailedException (const char * {\i pDoing}, int {\i nId}){\f2  [inline]}}
}\par
{\bkmkstart classCLinkFailedException_a5}
{\bkmkend classCLinkFailedException_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 331 of file CLinkFailedException.h.\par
\par
References m_fName, m_nId, and UpdateReasonText().}
{\xe \v ~CLinkFailedException\:CLinkFailedException}
{\xe \v CLinkFailedException\:~CLinkFailedException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual CLinkFailedException::~CLinkFailedException (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCLinkFailedException_a6}
{\bkmkend classCLinkFailedException_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 337 of file CLinkFailedException.h.\par
}
{\xe \v CLinkFailedException\:CLinkFailedException}
{\xe \v CLinkFailedException\:CLinkFailedException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CLinkFailedException::CLinkFailedException (const CLinkFailedException & {\i aCLinkFailedException}){\f2  [inline]}}
}\par
{\bkmkstart classCLinkFailedException_a7}
{\bkmkend classCLinkFailedException_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 341 of file CLinkFailedException.h.\par
\par
References m_sName, and UpdateReasonText().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getName\:CLinkFailedException}
{\xe \v CLinkFailedException\:getName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CLinkFailedException::getName () const{\f2  [inline]}}
}\par
{\bkmkstart classCLinkFailedException_a10}
{\bkmkend classCLinkFailedException_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 371 of file CLinkFailedException.h.\par
\par
References m_sName.}
{\xe \v operator=\:CLinkFailedException}
{\xe \v CLinkFailedException\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CLinkFailedException CLinkFailedException::operator= (const CLinkFailedException & {\i aCLinkFailedException}){\f2  [inline]}}
}\par
{\bkmkstart classCLinkFailedException_a8}
{\bkmkend classCLinkFailedException_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 351 of file CLinkFailedException.h.\par
\par
References m_sName, CException::operator=(), and UpdateReasonText().}
{\xe \v operator==\:CLinkFailedException}
{\xe \v CLinkFailedException\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CLinkFailedException::operator== (const CLinkFailedException & {\i aCLinkFailedException}){\f2  [inline]}}
}\par
{\bkmkstart classCLinkFailedException_a9}
{\bkmkend classCLinkFailedException_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 362 of file CLinkFailedException.h.\par
\par
References m_sName, and CException::operator==().}
{\xe \v ReasonText\:CLinkFailedException}
{\xe \v CLinkFailedException\:ReasonText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * CLinkFailedException::ReasonText () const{\f2  [virtual]}}
}\par
{\bkmkstart classCLinkFailedException_a12}
{\bkmkend classCLinkFailedException_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns a const pointer to text which describes the reason the exception was thrown. This is exception type specific. The default action returns a pointer to the constant string: "Unspecified Exception" \par
\par
Reimplemented from {\b CException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCException_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 285 of file CLinkFailedException.cpp.\par
\par
References m_sReasonText.}
{\xe \v setName\:CLinkFailedException}
{\xe \v CLinkFailedException\:setName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CLinkFailedException::setName (string {\i am_sName}){\f2  [inline]}}
}\par
{\bkmkstart classCLinkFailedException_a11}
{\bkmkend classCLinkFailedException_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 377 of file CLinkFailedException.h.\par
\par
References m_sName.}
{\xe \v UpdateReasonText\:CLinkFailedException}
{\xe \v CLinkFailedException\:UpdateReasonText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CLinkFailedException::UpdateReasonText (){\f2  [protected]}}
}\par
{\bkmkstart classCLinkFailedException_b0}
{\bkmkend classCLinkFailedException_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 291 of file CLinkFailedException.cpp.\par
\par
References m_nId, m_sName, and m_sReasonText.\par
Referenced by CLinkFailedException(), and operator=().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_fName\:CLinkFailedException}
{\xe \v CLinkFailedException\:m_fName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CLinkFailedException::m_fName{\f2  [private]}}
}\par
{\bkmkstart classCLinkFailedException_o2}
{\bkmkend classCLinkFailedException_o2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 297 of file CLinkFailedException.h.\par
\par
Referenced by CLinkFailedException().}
{\xe \v m_nId\:CLinkFailedException}
{\xe \v CLinkFailedException\:m_nId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CLinkFailedException::m_nId{\f2  [private]}}
}\par
{\bkmkstart classCLinkFailedException_o1}
{\bkmkend classCLinkFailedException_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 296 of file CLinkFailedException.h.\par
\par
Referenced by CLinkFailedException(), and UpdateReasonText().}
{\xe \v m_sName\:CLinkFailedException}
{\xe \v CLinkFailedException\:m_sName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CLinkFailedException::m_sName{\f2  [private]}}
}\par
{\bkmkstart classCLinkFailedException_o0}
{\bkmkend classCLinkFailedException_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 295 of file CLinkFailedException.h.\par
\par
Referenced by CLinkFailedException(), getName(), operator=(), operator==(), setName(), and UpdateReasonText().}
{\xe \v m_sReasonText\:CLinkFailedException}
{\xe \v CLinkFailedException\:m_sReasonText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CLinkFailedException::m_sReasonText{\f2  [private]}}
}\par
{\bkmkstart classCLinkFailedException_o3}
{\bkmkend classCLinkFailedException_o3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 298 of file CLinkFailedException.h.\par
\par
Referenced by ReasonText(), and UpdateReasonText().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CLinkFailedException.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CLinkFailedException.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
LinkInfo  Struct Reference\par \pard\plain 
{\tc\tcl2 \v LinkInfo}
{\xe \v LinkInfo}
{\bkmkstart structLinkInfo}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CBufferMonitor.h>}\par
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const LinkInfo &l) const\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Tag}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Mask}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b URL}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b linkid}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator==\:LinkInfo}
{\xe \v LinkInfo\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int LinkInfo::operator== (const LinkInfo & {\i l}) const{\f2  [inline]}}
}\par
{\bkmkstart structLinkInfo_a0}
{\bkmkend structLinkInfo_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 331 of file CBufferMonitor.h.\par
\par
References linkid, Mask, Tag, and URL.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v linkid\:LinkInfo}
{\xe \v LinkInfo\:linkid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int LinkInfo::linkid}
}\par
{\bkmkstart structLinkInfo_m3}
{\bkmkend structLinkInfo_m3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 330 of file CBufferMonitor.h.\par
\par
Referenced by CBufferMonitor< T >::AddLink(), and operator==().}
{\xe \v Mask\:LinkInfo}
{\xe \v LinkInfo\:Mask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int LinkInfo::Mask}
}\par
{\bkmkstart structLinkInfo_m1}
{\bkmkend structLinkInfo_m1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 328 of file CBufferMonitor.h.\par
\par
Referenced by CBufferMonitor< T >::AddLink(), MatchAll::operator()(), and operator==().}
{\xe \v Tag\:LinkInfo}
{\xe \v LinkInfo\:Tag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int LinkInfo::Tag}
}\par
{\bkmkstart structLinkInfo_m0}
{\bkmkend structLinkInfo_m0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 327 of file CBufferMonitor.h.\par
\par
Referenced by CBufferMonitor< T >::AddLink(), MatchAll::operator()(), and operator==().}
{\xe \v URL\:LinkInfo}
{\xe \v LinkInfo\:URL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string LinkInfo::URL}
}\par
{\bkmkstart structLinkInfo_m2}
{\bkmkend structLinkInfo_m2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 329 of file CBufferMonitor.h.\par
\par
Referenced by CBufferMonitor< T >::AddLink(), MatchAll::operator()(), MatchURL::operator()(), and operator==().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CBufferMonitor.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CLocationEvent< T >  Class Template Reference\par \pard\plain 
{\tc\tcl2 \v CLocationEvent}
{\xe \v CLocationEvent}
{\bkmkstart classCLocationEvent}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CLocationEvent.h>}\par
Inheritance diagram for CLocationEvent< T >:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCLocationEvent.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLocationEvent} (volatile T *Location, {\b CPointerPredicate}< T > &pred)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLocationEvent} (const char *pName, volatile T *Location, {\b CPointerPredicate}< T > &pred)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLocationEvent} (const string &rName, volatile T *Location, {\b CPointerPredicate}< T > &pred)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CLocationEvent} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLocationMonitor}< T > & {\b getMonitor} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Allow manipulation of the event monitor:.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLocationReactor}< T > & {\b getReactor} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Allow manipulation of the event reactor:.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPointerPredicate}< T > & {\b getPredicate} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile T * {\b getPointer} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnLocationChanged} (T newValue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTimeout} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual string {\b DescribeSelf} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b operator()} (int nargs, char **ppargs)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class U> {\b CLocationEvent} (const CLocationEvent< U > &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class U> CLocationEvent & {\b operator=} (const CLocationEvent< U > &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class U> int {\b operator==} (const CLocationEvent< U > &rhs)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPointerPredicate}< T > & {\b m_rPredicate}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLocationMonitor}< T > & {\b m_rMonitor}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Monitor which polls for event.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLocationReactor}< T > & {\b m_rReactor}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Reactor to the event when it fires.}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class T> class CLocationEvent< T >\par
}

\par
Encapsulates application level location monitor event processing. The CLocation event contains a special  {\b CLocationReactor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCLocationReactor \\*MERGEFORMAT}{\fldrslt pagenum}}}) which understands that it lives inside a CLocation event. It gathers typicallly needed information from the event monitor and passes it back to the location event's operator() member.\par
This class must be subclassed with operator() filled in. Note that information sufficent to start a location monitor is passed in at construction time.. this is an abstract,templated class. \par
\par
Definition at line 332 of file CLocationEvent.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CLocationEvent\:CLocationEvent}
{\xe \v CLocationEvent\:CLocationEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CLocationEvent< T >::CLocationEvent (volatile T * {\i Location}, {\b CPointerPredicate}< T > & {\i pred})}
}\par
{\bkmkstart classCLocationEvent_a0}
{\bkmkend classCLocationEvent_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Constructor: Construct an anonymous location monitor event. To construct a location event requires:{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i Location}}  - pointer to the monitored location \par
{\b {\i pred}}  - Reference to the prediate which defines an eventworthy change in *Location. \par
}\par
Definition at line 359 of file CLocationEvent.cpp.\par
\par
References CLocationEvent< T >::getMonitor(), CLocationEvent< T >::getReactor(), CLocationEvent< T >::m_rMonitor, CLocationEvent< T >::m_rPredicate, and CLocationEvent< T >::m_rReactor.}
{\xe \v CLocationEvent\:CLocationEvent}
{\xe \v CLocationEvent\:CLocationEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CLocationEvent< T >::CLocationEvent< T > (const char * {\i pName}, volatile T * {\i Location}, {\b CPointerPredicate}< T > & {\i pred})}
}\par
{\bkmkstart classCLocationEvent_a1}
{\bkmkend classCLocationEvent_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Constructs a named location monitor event using a char* as the location monitor's name.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i pName}}  - Pointer to name of location monitor. \par
{\b {\i Location}}  - Pointer to the name string. \par
{\b {\i pred}}  - Reference to the predicate which defines an eventworthy change in *Location. \par
}}
{\xe \v CLocationEvent\:CLocationEvent}
{\xe \v CLocationEvent\:CLocationEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CLocationEvent< T >::CLocationEvent< T > (const string & {\i rName}, volatile T * {\i Location}, {\b CPointerPredicate}< T > & {\i pred})}
}\par
{\bkmkstart classCLocationEvent_a2}
{\bkmkend classCLocationEvent_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Constructs a CLocationEvent whose name is given by an STL String: {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i pName}}  - Pointer to name of location monitor. \par
{\b {\i Location}}  - Pointer to the name string. \par
{\b {\i pred}}  - Reference to the predicate which defines an eventworthy change in *Location. \par
}}
{\xe \v ~CLocationEvent\:CLocationEvent}
{\xe \v CLocationEvent\:~CLocationEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CLocationEvent< T >::~CLocationEvent< T > ()}
}\par
{\bkmkstart classCLocationEvent_a3}
{\bkmkend classCLocationEvent_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Destructor: \par
}
{\xe \v CLocationEvent\:CLocationEvent}
{\xe \v CLocationEvent\:CLocationEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> template<class U> CLocationEvent< T >::CLocationEvent (const CLocationEvent< U > & {\i rhs}){\f2  [private]}}
}\par
{\bkmkstart classCLocationEvent_c0}
{\bkmkend classCLocationEvent_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v DescribeSelf\:CLocationEvent}
{\xe \v CLocationEvent\:DescribeSelf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> string CLocationEvent< T >::DescribeSelf (){\f2  [virtual]}}
}\par
{\bkmkstart classCLocationEvent_a10}
{\bkmkend classCLocationEvent_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called to get a string description of self. \par
\par
Reimplemented from {\b CEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent_a16 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 451 of file CLocationEvent.cpp.\par
\par
References CEvent::DescribeSelf().}
{\xe \v getMonitor\:CLocationEvent}
{\xe \v CLocationEvent\:getMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> {\b CLocationMonitor}<T>& CLocationEvent< T >::getMonitor (){\f2  [inline]}}
}\par
{\bkmkstart classCLocationEvent_a4}
{\bkmkend classCLocationEvent_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Allow manipulation of the event monitor:.\par
\par
Reimplemented from {\b CEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 384 of file CLocationEvent.h.\par
\par
Referenced by CLocationEvent< T >::CLocationEvent().}
{\xe \v getPointer\:CLocationEvent}
{\xe \v CLocationEvent\:getPointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> volatile T* CLocationEvent< T >::getPointer (){\f2  [inline]}}
}\par
{\bkmkstart classCLocationEvent_a7}
{\bkmkend classCLocationEvent_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 393 of file CLocationEvent.h.\par
\par
References CLocationMonitor< T >::getLocation().}
{\xe \v getPredicate\:CLocationEvent}
{\xe \v CLocationEvent\:getPredicate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> {\b CPointerPredicate}<T>& CLocationEvent< T >::getPredicate (){\f2  [inline]}}
}\par
{\bkmkstart classCLocationEvent_a6}
{\bkmkend classCLocationEvent_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 390 of file CLocationEvent.h.\par
}
{\xe \v getReactor\:CLocationEvent}
{\xe \v CLocationEvent\:getReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> {\b CLocationReactor}<T>& CLocationEvent< T >::getReactor (){\f2  [inline]}}
}\par
{\bkmkstart classCLocationEvent_a5}
{\bkmkend classCLocationEvent_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Allow manipulation of the event reactor:.\par
\par
Reimplemented from {\b CEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent_a9 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 387 of file CLocationEvent.h.\par
\par
Referenced by CLocationEvent< T >::CLocationEvent().}
{\xe \v OnLocationChanged\:CLocationEvent}
{\xe \v CLocationEvent\:OnLocationChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CLocationEvent< T >::OnLocationChanged (T {\i newValue}){\f2  [virtual]}}
}\par
{\bkmkstart classCLocationEvent_a8}
{\bkmkend classCLocationEvent_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called whenever the predicate indicates that the location has changed in an event-worthy way. Default operation is a no-op. Normally, this class is subclassed and this member overridden.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i newValue}}  - New value of the monitored location. \par
}\par
Definition at line 421 of file CLocationEvent.cpp.\par
}
{\xe \v OnTimeout\:CLocationEvent}
{\xe \v CLocationEvent\:OnTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CLocationEvent< T >::OnTimeout (){\f2  [virtual]}}
}\par
{\bkmkstart classCLocationEvent_a9}
{\bkmkend classCLocationEvent_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called whenever the monitor declared a timeout. The default implementation is a no-op. Normally this class is subclassed and if timeouts need to be responded to, this member is over-ridden. \par
\par
Definition at line 430 of file CLocationEvent.cpp.\par
}
{\xe \v operator()\:CLocationEvent}
{\xe \v CLocationEvent\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int CLocationEvent< T >::operator() (int {\i nargs}, char ** {\i ppargs}){\f2  [protected, virtual]}}
}\par
{\bkmkstart classCLocationEvent_b0}
{\bkmkend classCLocationEvent_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set nice value to allow others to execute and then call CEvent::operator() \par
\par
Reimplemented from {\b CEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent_b4 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 440 of file CLocationEvent.cpp.\par
\par
References CEvent::operator()().}
{\xe \v operator=\:CLocationEvent}
{\xe \v CLocationEvent\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> template<class U> CLocationEvent& CLocationEvent< T >::operator= (const CLocationEvent< U > & {\i rhs}){\f2  [private]}}
}\par
{\bkmkstart classCLocationEvent_c1}
{\bkmkend classCLocationEvent_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:CLocationEvent}
{\xe \v CLocationEvent\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> template<class U> int CLocationEvent< T >::operator== (const CLocationEvent< U > & {\i rhs}){\f2  [private]}}
}\par
{\bkmkstart classCLocationEvent_c2}
{\bkmkend classCLocationEvent_c2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_rMonitor\:CLocationEvent}
{\xe \v CLocationEvent\:m_rMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> {\b CLocationMonitor}<T>& CLocationEvent< T >::m_rMonitor{\f2  [private]}}
}\par
{\bkmkstart classCLocationEvent_o1}
{\bkmkend classCLocationEvent_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Monitor which polls for event.\par
\par
Reimplemented from {\b CEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent_o4 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 336 of file CLocationEvent.h.\par
\par
Referenced by CLocationEvent< T >::CLocationEvent().}
{\xe \v m_rPredicate\:CLocationEvent}
{\xe \v CLocationEvent\:m_rPredicate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> {\b CPointerPredicate}<T>& CLocationEvent< T >::m_rPredicate{\f2  [private]}}
}\par
{\bkmkstart classCLocationEvent_o0}
{\bkmkend classCLocationEvent_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 335 of file CLocationEvent.h.\par
\par
Referenced by CLocationEvent< T >::CLocationEvent().}
{\xe \v m_rReactor\:CLocationEvent}
{\xe \v CLocationEvent\:m_rReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> {\b CLocationReactor}<T>& CLocationEvent< T >::m_rReactor{\f2  [private]}}
}\par
{\bkmkstart classCLocationEvent_o2}
{\bkmkend classCLocationEvent_o2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Reactor to the event when it fires.\par
\par
Reimplemented from {\b CEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent_o5 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 337 of file CLocationEvent.h.\par
\par
Referenced by CLocationEvent< T >::CLocationEvent().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CLocationEvent.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CLocationEvent.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CLocationEvent< T >::CGenericLocationReactor< U >  Class Template Reference\par \pard\plain 
{\tc\tcl2 \v CLocationEvent::CGenericLocationReactor}
{\xe \v CLocationEvent::CGenericLocationReactor}
{\bkmkstart classCLocationEvent_1_1CGenericLocationReactor}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Inheritance diagram for CLocationEvent< T >::CGenericLocationReactor< U >:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCLocationEvent_1_1CGenericLocationReactor.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CGenericLocationReactor} ({\b CLocationEvent}< T > &rOwner)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnLocationChanged} ({\b CLocationMonitor}< T > &rEvent, T NewValue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTimeout} ({\b CEventMonitor} &rEvent)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLocationEvent}< T > & {\b m_rOwner}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class T>template<class U> class CLocationEvent< T >::CGenericLocationReactor< U >\par
}

\par
Nested class CLocationEvent::CLocationReactor This class is used to give events a monolithic appearance. They relay calls to the Reactor action member functions to corresponding event members. This allows the user of this class to create response by simply subclassing this class rather than forcing them to be aware of the relationship between monitors and reactors. \par
\par
Definition at line 348 of file CLocationEvent.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CGenericLocationReactor\:CLocationEvent::CGenericLocationReactor}
{\xe \v CLocationEvent::CGenericLocationReactor\:CGenericLocationReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> template<class U> {\b CLocationEvent}< T >::CGenericLocationReactor< U >::CGenericLocationReactor ({\b CLocationEvent}< T > & {\i rOwner})}
}\par
{\bkmkstart classCLocationEvent_1_1CGenericLocationReactor_a0}
{\bkmkend classCLocationEvent_1_1CGenericLocationReactor_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Constructor. Builds a location reactor for {\b CLocationEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCLocationEvent \\*MERGEFORMAT}{\fldrslt pagenum}}}) objects. We just keep track of our 'owner' so we know how to callback.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rOwner}}  - Reference to our owner object. \par
}\par
Definition at line 308 of file CLocationEvent.cpp.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v OnLocationChanged\:CLocationEvent::CGenericLocationReactor}
{\xe \v CLocationEvent::CGenericLocationReactor\:OnLocationChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> template<class U> void {\b CLocationEvent}< T >::CGenericLocationReactor< U >::OnLocationChanged ({\b CLocationMonitor}< T > & {\i rEvent}, T {\i NewValue}){\f2  [virtual]}}
}\par
{\bkmkstart classCLocationEvent_1_1CGenericLocationReactor_a1}
{\bkmkend classCLocationEvent_1_1CGenericLocationReactor_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called when the location has changed in a manner which is significant to the predicate attached to the event. We delegate the action to the Event object which owns us presenting a monolithic appearance of events to the experimenter.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rEvent}}  - Event which fired the operation. \par
{\b {\i NewValue}}  - New value in the location. \par
}\par
Definition at line 326 of file CLocationEvent.cpp.\par
\par
References CLocationEvent< T >::CGenericLocationReactor< U >::m_rOwner.}
{\xe \v OnTimeout\:CLocationEvent::CGenericLocationReactor}
{\xe \v CLocationEvent::CGenericLocationReactor\:OnTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> template<class U> void {\b CLocationEvent}< T >::CGenericLocationReactor< U >::OnTimeout ({\b CEventMonitor} & {\i rEvent}){\f2  [virtual]}}
}\par
{\bkmkstart classCLocationEvent_1_1CGenericLocationReactor_a2}
{\bkmkend classCLocationEvent_1_1CGenericLocationReactor_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called when timeout receipt is enabled, and a wait times out.  This function delegates action tot he event object which owns us, presenting a monolithic appearance of events to the experimentalist.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rEvent}}  - Reference to the monitor which timed out. (unused). \par
}\par
Reimplemented from {\b CReactor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCReactor_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 342 of file CLocationEvent.cpp.\par
\par
References CLocationEvent< T >::CGenericLocationReactor< U >::m_rOwner.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_rOwner\:CLocationEvent::CGenericLocationReactor}
{\xe \v CLocationEvent::CGenericLocationReactor\:m_rOwner}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> template<class U> {\b CLocationEvent}<T>& {\b CLocationEvent}< T >::CGenericLocationReactor< U >::m_rOwner{\f2  [private]}}
}\par
{\bkmkstart classCLocationEvent_1_1CGenericLocationReactor_o0}
{\bkmkend classCLocationEvent_1_1CGenericLocationReactor_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 351 of file CLocationEvent.h.\par
\par
Referenced by CLocationEvent< T >::CGenericLocationReactor< U >::OnLocationChanged(), and CLocationEvent< T >::CGenericLocationReactor< U >::OnTimeout().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CLocationEvent.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CLocationEvent.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CLocationMonitor< T >  Class Template Reference\par \pard\plain 
{\tc\tcl2 \v CLocationMonitor}
{\xe \v CLocationMonitor}
{\bkmkstart classCLocationMonitor}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CLocationMonitor.h>}\par
Inheritance diagram for CLocationMonitor< T >:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCLocationMonitor.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLocationMonitor} (volatile T *am_pTLocation, {\b CPointerPredicate}< T > *am_Predicate, bool am_fTimedWait=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLocationMonitor} (const string &rName, volatile T *am_pTLocation, {\b CPointerPredicate}< T > *am_Predicate, bool am_fTimedWait=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLocationMonitor} (const char *pName, volatile T *am_pTLocation, {\b CPointerPredicate}< T > *am_Predicate, bool am_fTimedWait=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CLocationMonitor} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CLocationMonitor< T > &aCLocationMonitor) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile T * {\b getLocation} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPointerPredicate}< T > {\b getPredicate} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b CEventMonitor::result} {\b operator()} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ChangeLocation} (T *pNewLocation)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ChangePredicate} ({\b CPointerPredicate}< T > *newloc)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b getContents} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual string {\b DescribeSelf} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLocation} (volatile T *am_pTLocation)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPredicate} ({\b CPointerPredicate}< T > &am_Predicate)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLocationMonitor} (const CLocationMonitor< T > &aCLocationMonitor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CLocationMonitor< T > {\b operator=} (const CLocationMonitor< T > &aCLocationMonitor)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
volatile T * {\b m_pTLocation}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPointerPredicate}< T > * {\b m_Predicate}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T> class CLocationMonitor< T >\par
}

\par
Encapsulates a location monitor.  The location monitor watches a volatile memory location  to satisfy some predicate function object. Predicates are objects from classes which implement: bool operator()(T value) T is a templated variable of the class. Such objects are function objects. The  Event is fired when the predicate returns TRUE. \par
\par
Definition at line 335 of file CLocationMonitor.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CLocationMonitor\:CLocationMonitor}
{\xe \v CLocationMonitor\:CLocationMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> CLocationMonitor< T >::CLocationMonitor (volatile T * {\i am_pTLocation}, {\b CPointerPredicate}< T > * {\i am_Predicate}, bool {\i am_fTimedWait} = true){\f2  [inline]}}
}\par
{\bkmkstart classCLocationMonitor_a0}
{\bkmkend classCLocationMonitor_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
associated predicate \par
}
{\xe \v CLocationMonitor\:CLocationMonitor}
{\xe \v CLocationMonitor\:CLocationMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> CLocationMonitor< T >::CLocationMonitor (const string & {\i rName}, volatile T * {\i am_pTLocation}, {\b CPointerPredicate}< T > * {\i am_Predicate}, bool {\i am_fTimedWait} = true){\f2  [inline]}}
}\par
{\bkmkstart classCLocationMonitor_a1}
{\bkmkend classCLocationMonitor_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CLocationMonitor\:CLocationMonitor}
{\xe \v CLocationMonitor\:CLocationMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> CLocationMonitor< T >::CLocationMonitor (const char * {\i pName}, volatile T * {\i am_pTLocation}, {\b CPointerPredicate}< T > * {\i am_Predicate}, bool {\i am_fTimedWait} = true){\f2  [inline]}}
}\par
{\bkmkstart classCLocationMonitor_a2}
{\bkmkend classCLocationMonitor_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~CLocationMonitor\:CLocationMonitor}
{\xe \v CLocationMonitor\:~CLocationMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> CLocationMonitor< T >::~CLocationMonitor (){\f2  [inline]}}
}\par
{\bkmkstart classCLocationMonitor_a3}
{\bkmkend classCLocationMonitor_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CLocationMonitor\:CLocationMonitor}
{\xe \v CLocationMonitor\:CLocationMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> CLocationMonitor< T >::CLocationMonitor (const CLocationMonitor< T > & {\i aCLocationMonitor}){\f2  [private]}}
}\par
{\bkmkstart classCLocationMonitor_c0}
{\bkmkend classCLocationMonitor_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v ChangeLocation\:CLocationMonitor}
{\xe \v CLocationMonitor\:ChangeLocation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> void CLocationMonitor< T >::ChangeLocation (T * {\i pNewLocation})}
}\par
{\bkmkstart classCLocationMonitor_a8}
{\bkmkend classCLocationMonitor_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Mutator\par
Purpose: Changes the location monitored. \par
\par
Definition at line 354 of file CLocationMonitor.cpp.\par
\par
References CLocationMonitor< T >::m_pTLocation.}
{\xe \v ChangePredicate\:CLocationMonitor}
{\xe \v CLocationMonitor\:ChangePredicate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> void CLocationMonitor< T >::ChangePredicate ({\b CPointerPredicate}< T > * {\i newLoc})}
}\par
{\bkmkstart classCLocationMonitor_a9}
{\bkmkend classCLocationMonitor_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Mutator\par
Purpose: Associates a new predicate with the  location monitor. \par
\par
Definition at line 371 of file CLocationMonitor.cpp.\par
\par
References CLocationMonitor< T >::m_Predicate.}
{\xe \v DescribeSelf\:CLocationMonitor}
{\xe \v CLocationMonitor\:DescribeSelf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> string CLocationMonitor< T >::DescribeSelf (){\f2  [virtual]}}
}\par
{\bkmkstart classCLocationMonitor_a11}
{\bkmkend classCLocationMonitor_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Selector\par
Purpose: Returns a string which describes the monitor. Inlcudes: 1. {\b CEventMonitor::DescribeSelf} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNamedObject_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}) 2. Dumps of the pointer value, 3. m_Predicate->{\b DescribeSelf}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCLocationMonitor_a11 \\*MERGEFORMAT}{\fldrslt pagenum}}}) \par
\par
Reimplemented from {\b CNamedObject} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNamedObject_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 390 of file CLocationMonitor.cpp.\par
\par
References CNamedObject::DescribeSelf(), CLocationMonitor< T >::m_Predicate, and CLocationMonitor< T >::m_pTLocation.}
{\xe \v getContents\:CLocationMonitor}
{\xe \v CLocationMonitor\:getContents}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> T CLocationMonitor< T >::getContents () const{\f2  [inline]}}
}\par
{\bkmkstart classCLocationMonitor_a10}
{\bkmkend classCLocationMonitor_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 419 of file CLocationMonitor.h.\par
}
{\xe \v getLocation\:CLocationMonitor}
{\xe \v CLocationMonitor\:getLocation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> volatile T* CLocationMonitor< T >::getLocation () const{\f2  [inline]}}
}\par
{\bkmkstart classCLocationMonitor_a5}
{\bkmkend classCLocationMonitor_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 390 of file CLocationMonitor.h.\par
\par
References CLocationMonitor< T >::m_pTLocation.\par
Referenced by CLocationEvent< T >::getPointer(), and CLocationReactor< T >::OnEvent().}
{\xe \v getPredicate\:CLocationMonitor}
{\xe \v CLocationMonitor\:getPredicate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> {\b CPointerPredicate}<T> CLocationMonitor< T >::getPredicate () const{\f2  [inline]}}
}\par
{\bkmkstart classCLocationMonitor_a6}
{\bkmkend classCLocationMonitor_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 395 of file CLocationMonitor.h.\par
}
{\xe \v operator()\:CLocationMonitor}
{\xe \v CLocationMonitor\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> {\b CEventMonitor::result} CLocationMonitor< T >::operator() (){\f2  [virtual]}}
}\par
{\bkmkstart classCLocationMonitor_a7}
{\bkmkend classCLocationMonitor_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Override behavior\par
Purpose: Reads the current value of the location and passes it to the predicate. Returns: 1. Occured - if the predicate returned TRUE 2. TimedOut - if the wait time for this event timedout. 3. Error - If the predicate threw an exception. \par
\par
Implements {\b CEventMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEventMonitor_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 315 of file CLocationMonitor.cpp.\par
\par
References CEventMonitor::Error, CEventMonitor::getTimeout(), INCREMENTS, CLocationMonitor< T >::m_Predicate, CEventMonitor::Occurred, and CEventMonitor::TimedOut.}
{\xe \v operator=\:CLocationMonitor}
{\xe \v CLocationMonitor\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> CLocationMonitor<T> CLocationMonitor< T >::operator= (const CLocationMonitor< T > & {\i aCLocationMonitor}){\f2  [private]}}
}\par
{\bkmkstart classCLocationMonitor_c1}
{\bkmkend classCLocationMonitor_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:CLocationMonitor}
{\xe \v CLocationMonitor\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> int CLocationMonitor< T >::operator== (const CLocationMonitor< T > & {\i aCLocationMonitor}) const{\f2  [inline]}}
}\par
{\bkmkstart classCLocationMonitor_a4}
{\bkmkend classCLocationMonitor_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 371 of file CLocationMonitor.h.\par
\par
References CLocationMonitor< T >::m_Predicate, CLocationMonitor< T >::m_pTLocation, and CEventMonitor::operator==().}
{\xe \v setLocation\:CLocationMonitor}
{\xe \v CLocationMonitor\:setLocation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> void CLocationMonitor< T >::setLocation (volatile T * {\i am_pTLocation}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCLocationMonitor_b0}
{\bkmkend classCLocationMonitor_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 403 of file CLocationMonitor.h.\par
\par
References CLocationMonitor< T >::m_pTLocation.}
{\xe \v setPredicate\:CLocationMonitor}
{\xe \v CLocationMonitor\:setPredicate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> void CLocationMonitor< T >::setPredicate ({\b CPointerPredicate}< T > & {\i am_Predicate}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCLocationMonitor_b1}
{\bkmkend classCLocationMonitor_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 408 of file CLocationMonitor.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_Predicate\:CLocationMonitor}
{\xe \v CLocationMonitor\:m_Predicate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> {\b CPointerPredicate}<T>* CLocationMonitor< T >::m_Predicate{\f2  [private]}}
}\par
{\bkmkstart classCLocationMonitor_o1}
{\bkmkend classCLocationMonitor_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Location monitored \par
\par
Definition at line 338 of file CLocationMonitor.h.\par
\par
Referenced by CLocationMonitor< T >::ChangePredicate(), CLocationMonitor< T >::DescribeSelf(), CLocationMonitor< T >::operator()(), and CLocationMonitor< T >::operator==().}
{\xe \v m_pTLocation\:CLocationMonitor}
{\xe \v CLocationMonitor\:m_pTLocation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> volatile T* CLocationMonitor< T >::m_pTLocation{\f2  [private]}}
}\par
{\bkmkstart classCLocationMonitor_o0}
{\bkmkend classCLocationMonitor_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 337 of file CLocationMonitor.h.\par
\par
Referenced by CLocationMonitor< T >::ChangeLocation(), CLocationMonitor< T >::DescribeSelf(), CLocationMonitor< T >::getLocation(), CLocationMonitor< T >::operator==(), and CLocationMonitor< T >::setLocation().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CLocationMonitor.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CLocationMonitor.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CLocationReactor< T >  Class Template Reference\par \pard\plain 
{\tc\tcl2 \v CLocationReactor}
{\xe \v CLocationReactor}
{\bkmkstart classCLocationReactor}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CLocationReactor.h>}\par
Inheritance diagram for CLocationReactor< T >:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCLocationReactor.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLocationReactor} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLocationReactor} (const string &rName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLocationReactor} (const char *pName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CLocationReactor} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Destructor:.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class U> int {\b operator==} (const CLocationReactor< U > &aCLocationReactor) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Operator== Equality Operator is allowed, but doesn't mean much.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnEvent} ({\b CEventMonitor} &rEvent)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnLocationChanged} ({\b CLocationMonitor}< T > &rEvent, T newValue)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLocationReactor} (const CLocationReactor &aCLocationReactor)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Copy Constructor is not allowed.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CLocationReactor & {\b operator=} (const CLocationReactor &aCLocationReactor)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Operator= Assignment Operator is not allowed.}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class T> class CLocationReactor< T >\par
}

\par
Reacts to location monitor events. A location monitor monitors a Specific volatile object for various abstract conditions checked by a predicate. This is an abstract base class which must be derived for a particular applciation. The purpose of this class is to provide a branch in the Reactor class hierarchy from which Location Monitors can determine comptibility of the reactor. This class should be templated by the type used to template the monitor. \par
\par
Definition at line 318 of file CLocationReactor.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CLocationReactor\:CLocationReactor}
{\xe \v CLocationReactor\:CLocationReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CLocationReactor< T >::CLocationReactor ()}
}\par
{\bkmkstart classCLocationReactor_a0}
{\bkmkend classCLocationReactor_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Default Constructor: Creates a reactor with an autoassigned name. There's currently no way to know by looking at the name that this is a Location Reactor \par
\par
Definition at line 315 of file CLocationReactor.cpp.\par
\par
References CNamedObject::AppendClassInfo().}
{\xe \v CLocationReactor\:CLocationReactor}
{\xe \v CLocationReactor\:CLocationReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CLocationReactor< T >::CLocationReactor (const string & {\i rName})}
}\par
{\bkmkstart classCLocationReactor_a1}
{\bkmkend classCLocationReactor_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Constructor given a name in STL String form. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rName}}  - name of the object. \par
}\par
Definition at line 326 of file CLocationReactor.cpp.\par
\par
References CNamedObject::AppendClassInfo().}
{\xe \v CLocationReactor\:CLocationReactor}
{\xe \v CLocationReactor\:CLocationReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CLocationReactor< T >::CLocationReactor (const char * {\i pName})}
}\par
{\bkmkstart classCLocationReactor_a2}
{\bkmkend classCLocationReactor_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Constructor given a name in ASCIZ format. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i pName}}  - pointer to the ASCIZ name of the object to create. \par
}\par
Definition at line 336 of file CLocationReactor.cpp.\par
\par
References CNamedObject::AppendClassInfo().}
{\xe \v ~CLocationReactor\:CLocationReactor}
{\xe \v CLocationReactor\:~CLocationReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CLocationReactor< T >::~CLocationReactor ()}
}\par
{\bkmkstart classCLocationReactor_a3}
{\bkmkend classCLocationReactor_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Destructor:.\par
\par
Definition at line 343 of file CLocationReactor.cpp.\par
}
{\xe \v CLocationReactor\:CLocationReactor}
{\xe \v CLocationReactor\:CLocationReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CLocationReactor< T >::CLocationReactor (const CLocationReactor< T > & {\i aCLocationReactor}){\f2  [private]}}
}\par
{\bkmkstart classCLocationReactor_c0}
{\bkmkend classCLocationReactor_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Copy Constructor is not allowed.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v OnEvent\:CLocationReactor}
{\xe \v CLocationReactor\:OnEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CLocationReactor< T >::OnEvent ({\b CEventMonitor} & {\i rEvent}){\f2  [virtual]}}
}\par
{\bkmkstart classCLocationReactor_a5}
{\bkmkend classCLocationReactor_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called when an event occurs.  The base class is overriddent to dynamically cast the  rEvent parameter to a {\b CLocationMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCLocationMonitor \\*MERGEFORMAT}{\fldrslt pagenum}}})<T> reference, and then get the value pointed to by the pointer. Once this is done, OnLocationChanged is called. THus users of this class typically will only need to derive and override OnLocationChanged.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rEvent}}  - Reference to the {\b CEventMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEventMonitor \\*MERGEFORMAT}{\fldrslt pagenum}}}) which was monitoring us. \par
}\par
Reimplemented from {\b CReactor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCReactor_a6 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 371 of file CLocationReactor.cpp.\par
\par
References CLocationMonitor< T >::getLocation(), and CLocationReactor< T >::OnLocationChanged().}
{\xe \v OnLocationChanged\:CLocationReactor}
{\xe \v CLocationReactor\:OnLocationChanged}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CLocationReactor< T >::OnLocationChanged ({\b CLocationMonitor}< T > & {\i rEvent}, T {\i newValue}){\f2  [virtual]}}
}\par
{\bkmkstart classCLocationReactor_a6}
{\bkmkend classCLocationReactor_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called when a location monitor detects a location change which satisfies its predicate. I expect that this Reactor will be used minimally by subclassing this class and overriding this function with application specific code.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rEvent}}  - Reference to the location monitor which fired us. \par
{\b {\i newValue}}  - New value at the location being monitored. \par
}\par
Definition at line 402 of file CLocationReactor.cpp.\par
\par
Referenced by CLocationReactor< T >::OnEvent().}
{\xe \v operator=\:CLocationReactor}
{\xe \v CLocationReactor\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CLocationReactor& CLocationReactor< T >::operator= (const CLocationReactor< T > & {\i aCLocationReactor}){\f2  [private]}}
}\par
{\bkmkstart classCLocationReactor_c1}
{\bkmkend classCLocationReactor_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operator= Assignment Operator is not allowed.\par
}
{\xe \v operator==\:CLocationReactor}
{\xe \v CLocationReactor\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> template<class U> int CLocationReactor< T >::operator== (const CLocationReactor< U > & {\i aCLocationReactor}) const}
}\par
{\bkmkstart classCLocationReactor_a4}
{\bkmkend classCLocationReactor_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operator== Equality Operator is allowed, but doesn't mean much.\par
\par
Definition at line 351 of file CLocationReactor.cpp.\par
\par
References CReactor::operator==().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CLocationReactor.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CLocationReactor.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CLogger  Class Reference\par \pard\plain 
{\tc\tcl2 \v CLogger}
{\xe \v CLogger}
{\bkmkstart classCLogger}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CLogger.h>}\par
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b Severity} \{ {\b SUCCESS}, 
{\b WARNING}, 
{\b ERROR}
 \}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i The facility name which is logging the event.}\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLogger} (string facility)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CLogger} (const CLogger &aCLogger)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CLogger} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b Log} ({\b Severity} sev, string message)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HostListIterator} {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b HostListIterator} {\b end} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b size} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddHost} (const string &newHost)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b RemoveHost} (const string &oldHost)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b RemoveHost} ({\b HostListIterator} It)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CLogger {\b operator=} (const CLogger &aCLogger)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CLogger &aCLogger)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
list< string > {\b getHostList} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const string {\b getFacility} () const\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
list< string > {\b m_HostList}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const string {\b m_sFacility}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i The list of hosts running EventLog.tcl.}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
Encapsulates a logger class for events which occur in the data acquisition framework.  The Logger maintains a list of hostnames on which the actual EventLog.tcl script is running, as well as the port number and name of the facility which contains it. An event is logged via a call to the {\b CLogger::Log}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCLogger_a3 \\*MERGEFORMAT}{\fldrslt pagenum}}}) function member which creates  client sockets that connect to each of the hosts in the host list and logs the events. Each socket is shut down immediately  after the log entry is written. CLogger also contains an enumeration {\b CLogger::Severity} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCLogger_s3 \\*MERGEFORMAT}{\fldrslt pagenum}}}). This is used for function {\b CLogger::Log}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCLogger_a3 \\*MERGEFORMAT}{\fldrslt pagenum}}}), as there are only three possible values for severity that the logger will accept:\par
{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
SUCCESS: The operation being logged completed successfully.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
WARNING: The operation being logged completed, but there was a warning issued by the application.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
ERROR: The operation being logged did not complete, and an exceptional condition was encountered. \par
}\par
Definition at line 347 of file CLogger.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v Severity\:CLogger}
{\xe \v CLogger\:Severity}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum CLogger::Severity}
}\par
{\bkmkstart classCLogger_s3}
{\bkmkend classCLogger_s3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
The facility name which is logging the event.\par
{{{\b \par
Enumeration values:}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v SUCCESS\:CLogger}
{\xe \v CLogger\:SUCCESS}
{\b {\i {\i SUCCESS}{\bkmkstart classCLogger_s3s0}
{\bkmkend classCLogger_s3s0}
}}  \par
{\xe \v WARNING\:CLogger}
{\xe \v CLogger\:WARNING}
{\b {\i {\i WARNING}{\bkmkstart classCLogger_s3s1}
{\bkmkend classCLogger_s3s1}
}}  \par
{\xe \v ERROR\:CLogger}
{\xe \v CLogger\:ERROR}
{\b {\i {\i ERROR}{\bkmkstart classCLogger_s3s2}
{\bkmkend classCLogger_s3s2}
}}  \par
}
\par
Definition at line 353 of file CLogger.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CLogger\:CLogger}
{\xe \v CLogger\:CLogger}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CLogger::CLogger (string {\i facility})}
}\par
{\bkmkstart classCLogger_a0}
{\bkmkend classCLogger_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
"Default Constructor" This is the default constructor which constructs a CLogger given a list of hosts to which it will form socket connections when logging events, and a facility name which will be the name of the facility doing the logging.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i facility}}  - the name of the facility doing the logging \par
}\par
Definition at line 310 of file CLogger.cpp.\par
}
{\xe \v CLogger\:CLogger}
{\xe \v CLogger\:CLogger}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CLogger::CLogger (const CLogger & {\i aCLogger})}
}\par
{\bkmkstart classCLogger_a1}
{\bkmkend classCLogger_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
"Copy Constructor" This is the copy constructor. It creates a new object by copying the information of the reference object which is its parameter.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i aCLogger}}  - the reference object whose attributes will be copied. \par
}\par
Definition at line 320 of file CLogger.cpp.\par
}
{\xe \v ~CLogger\:CLogger}
{\xe \v CLogger\:~CLogger}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CLogger::~CLogger ()}
}\par
{\bkmkstart classCLogger_a2}
{\bkmkend classCLogger_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
"Destructor" Called when an object goes out of scope, or when execution of the program is terminated. Destroys the object, and frees up space. \par
\par
Definition at line 329 of file CLogger.cpp.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddHost\:CLogger}
{\xe \v CLogger\:AddHost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CLogger::AddHost (const string & {\i newHost})}
}\par
{\bkmkstart classCLogger_a7}
{\bkmkend classCLogger_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Mutator\par
Purpose: Adds a host to the list of hosts that we will attempt to form a connection with and log a message to.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i const}}  string& newHost The name of the new host to be  added to m_HostList\par
}{{{\b Exceptions: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i {\b CDuplicateNameException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDuplicateNameException \\*MERGEFORMAT}{\fldrslt pagenum}}})}}   Thrown if the host already  exists in the host list \par
}\par
Definition at line 517 of file CLogger.cpp.\par
\par
References HostListIterator, and m_HostList.}
{\xe \v begin\:CLogger}
{\xe \v CLogger\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HostListIterator} CLogger::begin ()}
}\par
{\bkmkstart classCLogger_a4}
{\bkmkend classCLogger_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Selector\par
Purpose: Returns an iterator to the first host in m_HostList. \par
\par
Definition at line 468 of file CLogger.cpp.\par
\par
References m_HostList.}
{\xe \v end\:CLogger}
{\xe \v CLogger\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b HostListIterator} CLogger::end ()}
}\par
{\bkmkstart classCLogger_a5}
{\bkmkend classCLogger_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operator Type: Selector\par
Purpose: Returns an iterator which points to just past the last host in m_HostList. \par
\par
Definition at line 482 of file CLogger.cpp.\par
\par
References m_HostList.}
{\xe \v getFacility\:CLogger}
{\xe \v CLogger\:getFacility}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const string CLogger::getFacility () const{\f2  [inline, private]}}
}\par
{\bkmkstart classCLogger_c3}
{\bkmkend classCLogger_c3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 377 of file CLogger.h.\par
\par
References m_sFacility.}
{\xe \v getHostList\:CLogger}
{\xe \v CLogger\:getHostList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
list<string> CLogger::getHostList () const{\f2  [inline, private]}}
}\par
{\bkmkstart classCLogger_c2}
{\bkmkend classCLogger_c2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 376 of file CLogger.h.\par
\par
References m_HostList.}
{\xe \v Log\:CLogger}
{\xe \v CLogger\:Log}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CLogger::Log ({\b Severity} {\i sev}, string {\i message})}
}\par
{\bkmkstart classCLogger_a3}
{\bkmkend classCLogger_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Log to file and screen\par
Attempts to log a message (facility, severity, message, date) to  EventLog.tcl by opening a socket connection to each of the hosts in m_HostList. The first connection logs the message which consists of the facility, severity, and message to the log file via a call to the tcl procedure Logger::Log. This only needs to be written once, since the same log file will be used by each displayer. The Logger::Log tcl procedure obtains the exact time of the event via a call to date(1). It then returns the date string through the socket (which we read) and that string is what is displayed on the GUI via a call to Logger::Display_Event. In this way, the date on each display will be exactly the same. NOTE: If {\b Log}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCLogger_a3 \\*MERGEFORMAT}{\fldrslt pagenum}}}) fails for the first host in the list, then the event will not be written to the log file and will not be displayed anywhere.  If connection to the first host succeeds, but fails on a subsequent host, the event will be logged to file but will not be displayed on whichever host connection failed. It will, however, be displayed on all hosts (including subsequent hosts) to which connection does not fail.{{{\b \par
Exceptions: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i {\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}})}}   - Errno exception occurred \par
{\b {\i {\b CTCPBadSocketState} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPBadSocketState \\*MERGEFORMAT}{\fldrslt pagenum}}})}}   - {\b CSocket::m_State} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCSocket_o1 \\*MERGEFORMAT}{\fldrslt pagenum}}}) was not disconnected \par
{\b {\i {\b CTCPNoSuchHost} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPNoSuchHost \\*MERGEFORMAT}{\fldrslt pagenum}}})}}   - Host not in DNS or nonexistent \par
{\b {\i {\b CTCPNoSuchService} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPNoSuchService \\*MERGEFORMAT}{\fldrslt pagenum}}})}}   - Named service does not translate. \par
{\b {\i {\b CTCPConnectionFailed} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPConnectionFailed \\*MERGEFORMAT}{\fldrslt pagenum}}})}}   - Connection refused by remote host \par
{\b {\i {\b CTCPConnectionLost} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPConnectionLost \\*MERGEFORMAT}{\fldrslt pagenum}}})}}   - Connection terminated by remote host\par
}{{{\b Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i sev}}  - This is an enumerated value which represent the severity of the event. \par
{\b {\i message}}  - This is the message which the caller wants to log. \par
}\par
Definition at line 365 of file CLogger.cpp.\par
\par
References CSocket::Connect(), ERROR, m_HostList, m_sFacility, PORT, CSocket::Read(), CSocket::Shutdown(), SUCCESS, WARNING, and CSocket::Write().}
{\xe \v operator=\:CLogger}
{\xe \v CLogger\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CLogger CLogger::operator= (const CLogger & {\i aCLogger}){\f2  [private]}}
}\par
{\bkmkstart classCLogger_c0}
{\bkmkend classCLogger_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:CLogger}
{\xe \v CLogger\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CLogger::operator== (const CLogger & {\i aCLogger}){\f2  [private]}}
}\par
{\bkmkstart classCLogger_c1}
{\bkmkend classCLogger_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v RemoveHost\:CLogger}
{\xe \v CLogger\:RemoveHost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CLogger::RemoveHost ({\b HostListIterator} {\i It})}
}\par
{\bkmkstart classCLogger_a9}
{\bkmkend classCLogger_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Mutator\par
Purpose: Removes a host from the list of hosts that we will attempt to form a connection with and log a message to.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i HostListIterator}}  It An iterator which points to the host in m_HostList that is to be removed. \par
}{{{\b Exceptions: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i {\b CNoSuchObjectException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNoSuchObjectException \\*MERGEFORMAT}{\fldrslt pagenum}}})}}   Thrown if the name supplied in the paramter is not in m_HostList. \par
}\par
Definition at line 574 of file CLogger.cpp.\par
\par
References HostListIterator, and m_HostList.}
{\xe \v RemoveHost\:CLogger}
{\xe \v CLogger\:RemoveHost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CLogger::RemoveHost (const string & {\i oldHost})}
}\par
{\bkmkstart classCLogger_a8}
{\bkmkend classCLogger_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Mutator\par
Purpose: Removes a host from the list of hosts that we will attempt to form a connection with and log a message to.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i const}}  string& oldHost The name of the old host to be  removed from m_HostList \par
}{{{\b Exceptions: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i {\b CNoSuchObjectException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNoSuchObjectException \\*MERGEFORMAT}{\fldrslt pagenum}}})}}   Thrown if the name supplied in the parameter is not in m_HostList. \par
}\par
Definition at line 544 of file CLogger.cpp.\par
\par
References HostListIterator, and m_HostList.}
{\xe \v size\:CLogger}
{\xe \v CLogger\:size}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CLogger::size ()}
}\par
{\bkmkstart classCLogger_a6}
{\bkmkend classCLogger_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Selector\par
Purpose: Returns the number of hosts that are currently being logged to.\par
{{{\b \par
Returns: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid The number of hosts in m_HostList \par
}\par
Definition at line 497 of file CLogger.cpp.\par
\par
References m_HostList.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_HostList\:CLogger}
{\xe \v CLogger\:m_HostList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
list<string> CLogger::m_HostList{\f2  [private]}}
}\par
{\bkmkstart classCLogger_o0}
{\bkmkend classCLogger_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 349 of file CLogger.h.\par
\par
Referenced by AddHost(), begin(), end(), getHostList(), Log(), RemoveHost(), and size().}
{\xe \v m_sFacility\:CLogger}
{\xe \v CLogger\:m_sFacility}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const string CLogger::m_sFacility{\f2  [private]}}
}\par
{\bkmkstart classCLogger_o1}
{\bkmkend classCLogger_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
The list of hosts running EventLog.tcl.\par
\par
Definition at line 350 of file CLogger.h.\par
\par
Referenced by getFacility(), and Log().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CLogger.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CLogger.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CMaskedValuePredicate< T >  Class Template Reference\par \pard\plain 
{\tc\tcl2 \v CMaskedValuePredicate}
{\xe \v CMaskedValuePredicate}
{\bkmkstart classCMaskedValuePredicate}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CMaskedValuePredicate.h>}\par
Inheritance diagram for CMaskedValuePredicate< T >:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCMaskedValuePredicate.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CMaskedValuePredicate} (T am_TValue, T am_TMask={\b COS_ALLBITS})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CMaskedValuePredicate} (const string &rName, T am_TValue, T am_TMask={\b COS_ALLBITS})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CMaskedValuePredicate} (const char *pName, T am_TValue, T am_TMask={\b COS_ALLBITS})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CMaskedValuePredicate} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CMaskedValuePredicate< T > &aCMaskedValuePredicate) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b getMask} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b getValue} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b operator()} (T nValue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual string {\b DescribeSelf} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMask} (const T am_TMask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setValue} (const T am_TValue)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CMaskedValuePredicate} (const CMaskedValuePredicate< T > &aCMaskedValuePredicate)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CMaskedValuePredicate< T > {\b operator=} (const CMaskedValuePredicate< T > &aCMaskedValuePredicate)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b m_TValue}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b m_TMask}\par
}

{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T> class CMaskedValuePredicate< T >\par
}

{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CMaskedValuePredicate\:CMaskedValuePredicate}
{\xe \v CMaskedValuePredicate\:CMaskedValuePredicate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> CMaskedValuePredicate< T >::CMaskedValuePredicate (T {\i am_TValue}, T {\i am_TMask} = {\b COS_ALLBITS}){\f2  [inline]}}
}\par
{\bkmkstart classCMaskedValuePredicate_a0}
{\bkmkend classCMaskedValuePredicate_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
The predicate mask \par
}
{\xe \v CMaskedValuePredicate\:CMaskedValuePredicate}
{\xe \v CMaskedValuePredicate\:CMaskedValuePredicate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> CMaskedValuePredicate< T >::CMaskedValuePredicate (const string & {\i rName}, T {\i am_TValue}, T {\i am_TMask} = {\b COS_ALLBITS}){\f2  [inline]}}
}\par
{\bkmkstart classCMaskedValuePredicate_a1}
{\bkmkend classCMaskedValuePredicate_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CMaskedValuePredicate\:CMaskedValuePredicate}
{\xe \v CMaskedValuePredicate\:CMaskedValuePredicate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> CMaskedValuePredicate< T >::CMaskedValuePredicate (const char * {\i pName}, T {\i am_TValue}, T {\i am_TMask} = {\b COS_ALLBITS}){\f2  [inline]}}
}\par
{\bkmkstart classCMaskedValuePredicate_a2}
{\bkmkend classCMaskedValuePredicate_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~CMaskedValuePredicate\:CMaskedValuePredicate}
{\xe \v CMaskedValuePredicate\:~CMaskedValuePredicate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> CMaskedValuePredicate< T >::~CMaskedValuePredicate (){\f2  [inline]}}
}\par
{\bkmkstart classCMaskedValuePredicate_a3}
{\bkmkend classCMaskedValuePredicate_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CMaskedValuePredicate\:CMaskedValuePredicate}
{\xe \v CMaskedValuePredicate\:CMaskedValuePredicate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> CMaskedValuePredicate< T >::CMaskedValuePredicate (const CMaskedValuePredicate< T > & {\i aCMaskedValuePredicate}){\f2  [private]}}
}\par
{\bkmkstart classCMaskedValuePredicate_c0}
{\bkmkend classCMaskedValuePredicate_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v DescribeSelf\:CMaskedValuePredicate}
{\xe \v CMaskedValuePredicate\:DescribeSelf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> string CMaskedValuePredicate< T >::DescribeSelf (){\f2  [virtual]}}
}\par
{\bkmkstart classCMaskedValuePredicate_a8}
{\bkmkend classCMaskedValuePredicate_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Selector\par
Purpose: Returns a string with the following information: 1 - m_TMask 2 - m_TValue \par
\par
Implements {\b CPointerPredicate< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCPointerPredicate_a6 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 315 of file CMaskedValuePredicate.cpp.\par
\par
References CMaskedValuePredicate< T >::m_TMask, and CMaskedValuePredicate< T >::m_TValue.}
{\xe \v getMask\:CMaskedValuePredicate}
{\xe \v CMaskedValuePredicate\:getMask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> T CMaskedValuePredicate< T >::getMask () const{\f2  [inline]}}
}\par
{\bkmkstart classCMaskedValuePredicate_a5}
{\bkmkend classCMaskedValuePredicate_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 352 of file CMaskedValuePredicate.h.\par
}
{\xe \v getValue\:CMaskedValuePredicate}
{\xe \v CMaskedValuePredicate\:getValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> T CMaskedValuePredicate< T >::getValue () const{\f2  [inline]}}
}\par
{\bkmkstart classCMaskedValuePredicate_a6}
{\bkmkend classCMaskedValuePredicate_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 357 of file CMaskedValuePredicate.h.\par
}
{\xe \v operator()\:CMaskedValuePredicate}
{\xe \v CMaskedValuePredicate\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> bool CMaskedValuePredicate< T >::operator() (T {\i nValue}){\f2  [virtual]}}
}\par
{\bkmkstart classCMaskedValuePredicate_a7}
{\bkmkend classCMaskedValuePredicate_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Override behavior\par
Purpose: Returns true if (nValue & m_TMask) == m_TValue \par
\par
Implements {\b CPointerPredicate< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCPointerPredicate_a5 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 296 of file CMaskedValuePredicate.cpp.\par
\par
References CMaskedValuePredicate< T >::m_TMask, and CMaskedValuePredicate< T >::m_TValue.}
{\xe \v operator=\:CMaskedValuePredicate}
{\xe \v CMaskedValuePredicate\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> CMaskedValuePredicate<T> CMaskedValuePredicate< T >::operator= (const CMaskedValuePredicate< T > & {\i aCMaskedValuePredicate}){\f2  [private]}}
}\par
{\bkmkstart classCMaskedValuePredicate_c1}
{\bkmkend classCMaskedValuePredicate_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:CMaskedValuePredicate}
{\xe \v CMaskedValuePredicate\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> int CMaskedValuePredicate< T >::operator== (const CMaskedValuePredicate< T > & {\i aCMaskedValuePredicate}) const{\f2  [inline]}}
}\par
{\bkmkstart classCMaskedValuePredicate_a4}
{\bkmkend classCMaskedValuePredicate_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 333 of file CMaskedValuePredicate.h.\par
\par
References CMaskedValuePredicate< T >::m_TMask, CMaskedValuePredicate< T >::m_TValue, and CPointerPredicate< T >::operator==().}
{\xe \v setMask\:CMaskedValuePredicate}
{\xe \v CMaskedValuePredicate\:setMask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> void CMaskedValuePredicate< T >::setMask (const T {\i am_TMask}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCMaskedValuePredicate_b0}
{\bkmkend classCMaskedValuePredicate_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 365 of file CMaskedValuePredicate.h.\par
}
{\xe \v setValue\:CMaskedValuePredicate}
{\xe \v CMaskedValuePredicate\:setValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> void CMaskedValuePredicate< T >::setValue (const T {\i am_TValue}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCMaskedValuePredicate_b1}
{\bkmkend classCMaskedValuePredicate_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 370 of file CMaskedValuePredicate.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_TMask\:CMaskedValuePredicate}
{\xe \v CMaskedValuePredicate\:m_TMask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> T CMaskedValuePredicate< T >::m_TMask{\f2  [private]}}
}\par
{\bkmkstart classCMaskedValuePredicate_o1}
{\bkmkend classCMaskedValuePredicate_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
The predicate value \par
\par
Definition at line 304 of file CMaskedValuePredicate.h.\par
\par
Referenced by CMaskedValuePredicate< T >::DescribeSelf(), CMaskedValuePredicate< T >::operator()(), and CMaskedValuePredicate< T >::operator==().}
{\xe \v m_TValue\:CMaskedValuePredicate}
{\xe \v CMaskedValuePredicate\:m_TValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> T CMaskedValuePredicate< T >::m_TValue{\f2  [private]}}
}\par
{\bkmkstart classCMaskedValuePredicate_o0}
{\bkmkend classCMaskedValuePredicate_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 303 of file CMaskedValuePredicate.h.\par
\par
Referenced by CMaskedValuePredicate< T >::DescribeSelf(), CMaskedValuePredicate< T >::operator()(), and CMaskedValuePredicate< T >::operator==().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CMaskedValuePredicate.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CMaskedValuePredicate.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MatchAll  Class Reference\par \pard\plain 
{\tc\tcl2 \v MatchAll}
{\xe \v MatchAll}
{\bkmkstart classMatchAll}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CBufferMonitor.h>}\par
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchAll} (string &rURL, int nTag, int nMask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b operator()} (struct {\b LinkInfo} l)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_sURL}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b m_nTag}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b m_nMask}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v MatchAll\:MatchAll}
{\xe \v MatchAll\:MatchAll}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MatchAll::MatchAll (string & {\i rURL}, int {\i nTag}, int {\i nMask}){\f2  [inline]}}
}\par
{\bkmkstart classMatchAll_a0}
{\bkmkend classMatchAll_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 360 of file CBufferMonitor.h.\par
\par
References m_nMask, m_nTag, and m_sURL.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator()\:MatchAll}
{\xe \v MatchAll\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual bool MatchAll::operator() (struct {\b LinkInfo} {\i l}){\f2  [inline, virtual]}}
}\par
{\bkmkstart classMatchAll_a1}
{\bkmkend classMatchAll_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 364 of file CBufferMonitor.h.\par
\par
References m_nMask, m_nTag, m_sURL, LinkInfo::Mask, LinkInfo::Tag, and LinkInfo::URL.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_nMask\:MatchAll}
{\xe \v MatchAll\:m_nMask}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MatchAll::m_nMask{\f2  [private]}}
}\par
{\bkmkstart classMatchAll_o2}
{\bkmkend classMatchAll_o2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 358 of file CBufferMonitor.h.\par
\par
Referenced by MatchAll(), and operator()().}
{\xe \v m_nTag\:MatchAll}
{\xe \v MatchAll\:m_nTag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int MatchAll::m_nTag{\f2  [private]}}
}\par
{\bkmkstart classMatchAll_o1}
{\bkmkend classMatchAll_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 357 of file CBufferMonitor.h.\par
\par
Referenced by MatchAll(), and operator()().}
{\xe \v m_sURL\:MatchAll}
{\xe \v MatchAll\:m_sURL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string MatchAll::m_sURL{\f2  [private]}}
}\par
{\bkmkstart classMatchAll_o0}
{\bkmkend classMatchAll_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 356 of file CBufferMonitor.h.\par
\par
Referenced by MatchAll(), and operator()().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CBufferMonitor.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
MatchURL  Class Reference\par \pard\plain 
{\tc\tcl2 \v MatchURL}
{\xe \v MatchURL}
{\bkmkstart classMatchURL}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CBufferMonitor.h>}\par
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b MatchURL} (string &rURL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b operator()} (struct {\b LinkInfo} l)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_sURL}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v MatchURL\:MatchURL}
{\xe \v MatchURL\:MatchURL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
MatchURL::MatchURL (string & {\i rURL}){\f2  [inline]}}
}\par
{\bkmkstart classMatchURL_a0}
{\bkmkend classMatchURL_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 348 of file CBufferMonitor.h.\par
\par
References m_sURL.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator()\:MatchURL}
{\xe \v MatchURL\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool MatchURL::operator() (struct {\b LinkInfo} {\i l}){\f2  [inline]}}
}\par
{\bkmkstart classMatchURL_a1}
{\bkmkend classMatchURL_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 350 of file CBufferMonitor.h.\par
\par
References m_sURL, and LinkInfo::URL.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_sURL\:MatchURL}
{\xe \v MatchURL\:m_sURL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string MatchURL::m_sURL{\f2  [private]}}
}\par
{\bkmkstart classMatchURL_o0}
{\bkmkend classMatchURL_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 346 of file CBufferMonitor.h.\par
\par
Referenced by MatchURL(), and operator()().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CBufferMonitor.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CNamedObject  Class Reference\par \pard\plain 
{\tc\tcl2 \v CNamedObject}
{\xe \v CNamedObject}
{\bkmkstart classCNamedObject}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CNamedObject.h>}\par
Inheritance diagram for CNamedObject:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCNamedObject.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CNamedObject} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CNamedObject} (string am_sName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CNamedObject} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CNamedObject & {\b operator=} (const CNamedObject &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CNamedObject &rhs) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b getClassPath} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const string {\b getName} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getAutoIndex} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i < Return value of auto naming index.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual string {\b DescribeSelf} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setClassPath} (const string am_sClassPath)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAutoIndex} (unsigned nNew)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b AppendClassInfo} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b GetAutoName} (const string &rBase)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Assign default name.}\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_sName}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_sClassPath}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b m_nAutoIndex}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Used to name autonamed objects.}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
Definition of a named object. Named objects are objects with a name and class path. The class path describes what type the object derived from CNamedObject actually is. That type is determined by AppendClass() which uses RTTI and is called each time CNamedObject (or anything derived from it) is instantiated. \par
\par
Definition at line 314 of file CNamedObject.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CNamedObject\:CNamedObject}
{\xe \v CNamedObject\:CNamedObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CNamedObject::CNamedObject (){\f2  [inline]}}
}\par
{\bkmkstart classCNamedObject_a0}
{\bkmkend classCNamedObject_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 323 of file CNamedObject.h.\par
\par
References AppendClassInfo(), GetAutoName(), and m_sName.}
{\xe \v CNamedObject\:CNamedObject}
{\xe \v CNamedObject\:CNamedObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CNamedObject::CNamedObject (string {\i am_sName}){\f2  [inline]}}
}\par
{\bkmkstart classCNamedObject_a1}
{\bkmkend classCNamedObject_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 328 of file CNamedObject.h.\par
\par
References AppendClassInfo(), and m_sName.}
{\xe \v ~CNamedObject\:CNamedObject}
{\xe \v CNamedObject\:~CNamedObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual CNamedObject::~CNamedObject (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCNamedObject_a2}
{\bkmkend classCNamedObject_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 333 of file CNamedObject.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AppendClassInfo\:CNamedObject}
{\xe \v CNamedObject\:AppendClassInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CNamedObject::AppendClassInfo (){\f2  [protected, virtual]}}
}\par
{\bkmkstart classCNamedObject_b2}
{\bkmkend classCNamedObject_b2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Appends class information to m_sClassPath. The information consists of the class hierarchy of the object being created. \par
\par
Definition at line 304 of file CNamedObject.cpp.\par
\par
References m_sClassPath.\par
Referenced by CBufferReactor< T >::CBufferReactor(), CClassifiedObjectRegistry::CClassifiedObjectRegistry(), CEvent::CEvent(), CEventMonitor::CEventMonitor(), CFdMonitor::CFdMonitor(), CFdReactor::CFdReactor(), CFileEvent::CFileEvent(), CFileEventReactor::CFileEventReactor(), CLocationReactor< T >::CLocationReactor(), CNamedObject(), CObjectRegistry::CObjectRegistry(), CReactor::CReactor(), CRegisteredObject::CRegisteredObject(), and CTimerMonitor::CTimerMonitor().}
{\xe \v DescribeSelf\:CNamedObject}
{\xe \v CNamedObject\:DescribeSelf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CNamedObject::DescribeSelf (){\f2  [virtual]}}
}\par
{\bkmkstart classCNamedObject_a8}
{\bkmkend classCNamedObject_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Describes the named object. The information given is the object type given by m_sClassPath, and the object name. \par
\par
Reimplemented in {\b CBufferEvent< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferEvent_a14 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CBufferMonitor< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferMonitor_a17 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CChangedPredicate< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCChangedPredicate_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CClassifiedObjectRegistry} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCClassifiedObjectRegistry_a11 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent_a16 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CFdMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFdMonitor_a12 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CFileEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFileEvent_a19 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CLocationEvent< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCLocationEvent_a10 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CLocationMonitor< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCLocationMonitor_a11 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CMaskedValuePredicate< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCMaskedValuePredicate_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CObjectRegistry} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCObjectRegistry_a9 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CPointerPredicate< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCPointerPredicate_a6 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CServerConnectionEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCServerConnectionEvent_a14 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CServerInstance} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCServerInstance_a11 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CServerMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCServerMonitor_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CTimerEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTimerEvent_a12 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CTimerMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTimerMonitor_a10 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CBufferEvent< U >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferEvent_a14 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b CBufferMonitor< U >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferMonitor_a17 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 316 of file CNamedObject.cpp.\par
\par
References m_sClassPath, and m_sName.\par
Referenced by CTimerMonitor::DescribeSelf(), CObjectRegistry::DescribeSelf(), CLocationMonitor< T >::DescribeSelf(), CFdMonitor::DescribeSelf(), CEvent::DescribeSelf(), CClassifiedObjectRegistry::DescribeSelf(), and CBufferMonitor< T >::DescribeSelf().}
{\xe \v getAutoIndex\:CNamedObject}
{\xe \v CNamedObject\:getAutoIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int CNamedObject::getAutoIndex () const{\f2  [inline]}}
}\par
{\bkmkstart classCNamedObject_a7}
{\bkmkend classCNamedObject_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
< Return value of auto naming index.\par
\par
Definition at line 364 of file CNamedObject.h.\par
\par
References m_nAutoIndex.}
{\xe \v GetAutoName\:CNamedObject}
{\xe \v CNamedObject\:GetAutoName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CNamedObject::GetAutoName (const string & {\i rBase}){\f2  [static, protected]}}
}\par
{\bkmkstart classCNamedObject_e0}
{\bkmkend classCNamedObject_e0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Assign default name.\par
Allocate a name for an object given some generic base name.  The final name is of the form: BaseName(m_nAutoIndex). \par
\par
Reimplemented in {\b CEventMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEventMonitor_e0 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b CPointerPredicate< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCPointerPredicate_e0 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 330 of file CNamedObject.cpp.\par
\par
References m_nAutoIndex.\par
Referenced by CFileEvent::CFileEvent(), and CNamedObject().}
{\xe \v getClassPath\:CNamedObject}
{\xe \v CNamedObject\:getClassPath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CNamedObject::getClassPath () const{\f2  [inline]}}
}\par
{\bkmkstart classCNamedObject_a5}
{\bkmkend classCNamedObject_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 354 of file CNamedObject.h.\par
\par
References m_sClassPath.}
{\xe \v getName\:CNamedObject}
{\xe \v CNamedObject\:getName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const string CNamedObject::getName () const{\f2  [inline]}}
}\par
{\bkmkstart classCNamedObject_a6}
{\bkmkend classCNamedObject_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 360 of file CNamedObject.h.\par
\par
References m_sName.\par
Referenced by CObjectRegistry::Add(), CObjectRegistry::Remove(), and CClassifiedObjectRegistry::Remove().}
{\xe \v operator=\:CNamedObject}
{\xe \v CNamedObject\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CNamedObject& CNamedObject::operator= (const CNamedObject & {\i rhs}){\f2  [inline]}}
}\par
{\bkmkstart classCNamedObject_a3}
{\bkmkend classCNamedObject_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 337 of file CNamedObject.h.\par
\par
References m_sClassPath, and m_sName.}
{\xe \v operator==\:CNamedObject}
{\xe \v CNamedObject\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CNamedObject::operator== (const CNamedObject & {\i rhs}) const{\f2  [inline]}}
}\par
{\bkmkstart classCNamedObject_a4}
{\bkmkend classCNamedObject_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 345 of file CNamedObject.h.\par
\par
References m_sClassPath, and m_sName.\par
Referenced by CRegisteredObject::operator==().}
{\xe \v setAutoIndex\:CNamedObject}
{\xe \v CNamedObject\:setAutoIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CNamedObject::setAutoIndex (unsigned {\i nNew}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCNamedObject_b1}
{\bkmkend classCNamedObject_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 378 of file CNamedObject.h.\par
\par
References m_nAutoIndex.}
{\xe \v setClassPath\:CNamedObject}
{\xe \v CNamedObject\:setClassPath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CNamedObject::setClassPath (const string {\i am_sClassPath}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCNamedObject_b0}
{\bkmkend classCNamedObject_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 374 of file CNamedObject.h.\par
\par
References m_sClassPath.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_nAutoIndex\:CNamedObject}
{\xe \v CNamedObject\:m_nAutoIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int CNamedObject::m_nAutoIndex{\f2  [static, private]}}
}\par
{\bkmkstart classCNamedObject_r0}
{\bkmkend classCNamedObject_r0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Used to name autonamed objects.\par
NamedObject.cpp Base class for all objects in the event management system.\par
Author: Jason Venema NSCL Michigan State University East Lansing, MI 48824-1321 mailto:{\f2 venemaja@msu.edu} \par
\par
Reimplemented in {\b CEventMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEventMonitor_r0 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b CPointerPredicate< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCPointerPredicate_r0 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Referenced by getAutoIndex(), GetAutoName(), and setAutoIndex().}
{\xe \v m_sClassPath\:CNamedObject}
{\xe \v CNamedObject\:m_sClassPath}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CNamedObject::m_sClassPath{\f2  [private]}}
}\par
{\bkmkstart classCNamedObject_o1}
{\bkmkend classCNamedObject_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
The class path of the object \par
\par
Definition at line 317 of file CNamedObject.h.\par
\par
Referenced by AppendClassInfo(), DescribeSelf(), getClassPath(), operator=(), operator==(), and setClassPath().}
{\xe \v m_sName\:CNamedObject}
{\xe \v CNamedObject\:m_sName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CNamedObject::m_sName{\f2  [private]}}
}\par
{\bkmkstart classCNamedObject_o0}
{\bkmkend classCNamedObject_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
The name of the object \par
\par
Definition at line 316 of file CNamedObject.h.\par
\par
Referenced by CNamedObject(), DescribeSelf(), getName(), operator=(), and operator==().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CNamedObject.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CNamedObject.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CNoSuchLinkException  Class Reference\par \pard\plain 
{\tc\tcl2 \v CNoSuchLinkException}
{\xe \v CNoSuchLinkException}
{\bkmkstart classCNoSuchLinkException}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CNoSuchLinkException.h>}\par
Inheritance diagram for CNoSuchLinkException:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCNoSuchLinkException.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CNoSuchLinkException} (const char *pDoing, const char *pName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CNoSuchLinkException} (const char *pDoing, const string &rName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CNoSuchLinkException} (const string &rDoing, const char *pName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CNoSuchLinkException} (const string &rDoing, const string &rName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CNoSuchLinkException} (const string &rDoing, int nId)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CNoSuchLinkException} (const char *pDoing, int nId)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CNoSuchLinkException} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CNoSuchLinkException} (const CNoSuchLinkException &aCNoSuchLinkException)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CNoSuchLinkException {\b operator=} (const CNoSuchLinkException &aCNoSuchLinkException)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CNoSuchLinkException &aCNoSuchLinkException)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b getName} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setName} (string am_sName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const char * {\b ReasonText} () const\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UpdateReasonText} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_sName}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b m_nId}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b m_fName}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_sReasonText}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CNoSuchLinkException\:CNoSuchLinkException}
{\xe \v CNoSuchLinkException\:CNoSuchLinkException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CNoSuchLinkException::CNoSuchLinkException (const char * {\i pDoing}, const char * {\i pName}){\f2  [inline]}}
}\par
{\bkmkstart classCNoSuchLinkException_a0}
{\bkmkend classCNoSuchLinkException_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 301 of file CNoSuchLinkException.h.\par
\par
References m_sName, and UpdateReasonText().}
{\xe \v CNoSuchLinkException\:CNoSuchLinkException}
{\xe \v CNoSuchLinkException\:CNoSuchLinkException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CNoSuchLinkException::CNoSuchLinkException (const char * {\i pDoing}, const string & {\i rName}){\f2  [inline]}}
}\par
{\bkmkstart classCNoSuchLinkException_a1}
{\bkmkend classCNoSuchLinkException_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 306 of file CNoSuchLinkException.h.\par
\par
References m_sName, and UpdateReasonText().}
{\xe \v CNoSuchLinkException\:CNoSuchLinkException}
{\xe \v CNoSuchLinkException\:CNoSuchLinkException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CNoSuchLinkException::CNoSuchLinkException (const string & {\i rDoing}, const char * {\i pName}){\f2  [inline]}}
}\par
{\bkmkstart classCNoSuchLinkException_a2}
{\bkmkend classCNoSuchLinkException_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 311 of file CNoSuchLinkException.h.\par
\par
References m_sName, and UpdateReasonText().}
{\xe \v CNoSuchLinkException\:CNoSuchLinkException}
{\xe \v CNoSuchLinkException\:CNoSuchLinkException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CNoSuchLinkException::CNoSuchLinkException (const string & {\i rDoing}, const string & {\i rName}){\f2  [inline]}}
}\par
{\bkmkstart classCNoSuchLinkException_a3}
{\bkmkend classCNoSuchLinkException_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 316 of file CNoSuchLinkException.h.\par
\par
References m_sName, and UpdateReasonText().}
{\xe \v CNoSuchLinkException\:CNoSuchLinkException}
{\xe \v CNoSuchLinkException\:CNoSuchLinkException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CNoSuchLinkException::CNoSuchLinkException (const string & {\i rDoing}, int {\i nId}){\f2  [inline]}}
}\par
{\bkmkstart classCNoSuchLinkException_a4}
{\bkmkend classCNoSuchLinkException_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 321 of file CNoSuchLinkException.h.\par
\par
References m_fName, m_nId, and UpdateReasonText().}
{\xe \v CNoSuchLinkException\:CNoSuchLinkException}
{\xe \v CNoSuchLinkException\:CNoSuchLinkException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CNoSuchLinkException::CNoSuchLinkException (const char * {\i pDoing}, int {\i nId}){\f2  [inline]}}
}\par
{\bkmkstart classCNoSuchLinkException_a5}
{\bkmkend classCNoSuchLinkException_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 327 of file CNoSuchLinkException.h.\par
\par
References m_fName, m_nId, and UpdateReasonText().}
{\xe \v ~CNoSuchLinkException\:CNoSuchLinkException}
{\xe \v CNoSuchLinkException\:~CNoSuchLinkException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual CNoSuchLinkException::~CNoSuchLinkException (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCNoSuchLinkException_a6}
{\bkmkend classCNoSuchLinkException_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 333 of file CNoSuchLinkException.h.\par
}
{\xe \v CNoSuchLinkException\:CNoSuchLinkException}
{\xe \v CNoSuchLinkException\:CNoSuchLinkException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CNoSuchLinkException::CNoSuchLinkException (const CNoSuchLinkException & {\i aCNoSuchLinkException}){\f2  [inline]}}
}\par
{\bkmkstart classCNoSuchLinkException_a7}
{\bkmkend classCNoSuchLinkException_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 337 of file CNoSuchLinkException.h.\par
\par
References m_sName, and UpdateReasonText().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getName\:CNoSuchLinkException}
{\xe \v CNoSuchLinkException\:getName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CNoSuchLinkException::getName () const{\f2  [inline]}}
}\par
{\bkmkstart classCNoSuchLinkException_a10}
{\bkmkend classCNoSuchLinkException_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 367 of file CNoSuchLinkException.h.\par
\par
References m_sName.}
{\xe \v operator=\:CNoSuchLinkException}
{\xe \v CNoSuchLinkException\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CNoSuchLinkException CNoSuchLinkException::operator= (const CNoSuchLinkException & {\i aCNoSuchLinkException}){\f2  [inline]}}
}\par
{\bkmkstart classCNoSuchLinkException_a8}
{\bkmkend classCNoSuchLinkException_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 347 of file CNoSuchLinkException.h.\par
\par
References m_sName, CException::operator=(), and UpdateReasonText().}
{\xe \v operator==\:CNoSuchLinkException}
{\xe \v CNoSuchLinkException\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CNoSuchLinkException::operator== (const CNoSuchLinkException & {\i aCNoSuchLinkException}){\f2  [inline]}}
}\par
{\bkmkstart classCNoSuchLinkException_a9}
{\bkmkend classCNoSuchLinkException_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 358 of file CNoSuchLinkException.h.\par
\par
References m_sName, and CException::operator==().}
{\xe \v ReasonText\:CNoSuchLinkException}
{\xe \v CNoSuchLinkException\:ReasonText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * CNoSuchLinkException::ReasonText () const{\f2  [virtual]}}
}\par
{\bkmkstart classCNoSuchLinkException_a12}
{\bkmkend classCNoSuchLinkException_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns a const pointer to text which describes the reason the exception was thrown. This is exception type specific. The default action returns a pointer to the constant string: "Unspecified Exception" \par
\par
Reimplemented from {\b CException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCException_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 285 of file CNoSuchLinkException.cpp.\par
\par
References m_sReasonText.}
{\xe \v setName\:CNoSuchLinkException}
{\xe \v CNoSuchLinkException\:setName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CNoSuchLinkException::setName (string {\i am_sName}){\f2  [inline]}}
}\par
{\bkmkstart classCNoSuchLinkException_a11}
{\bkmkend classCNoSuchLinkException_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 373 of file CNoSuchLinkException.h.\par
\par
References m_sName.}
{\xe \v UpdateReasonText\:CNoSuchLinkException}
{\xe \v CNoSuchLinkException\:UpdateReasonText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CNoSuchLinkException::UpdateReasonText (){\f2  [protected]}}
}\par
{\bkmkstart classCNoSuchLinkException_b0}
{\bkmkend classCNoSuchLinkException_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 291 of file CNoSuchLinkException.cpp.\par
\par
References m_nId, m_sName, and m_sReasonText.\par
Referenced by CNoSuchLinkException(), and operator=().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_fName\:CNoSuchLinkException}
{\xe \v CNoSuchLinkException\:m_fName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CNoSuchLinkException::m_fName{\f2  [private]}}
}\par
{\bkmkstart classCNoSuchLinkException_o2}
{\bkmkend classCNoSuchLinkException_o2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 297 of file CNoSuchLinkException.h.\par
\par
Referenced by CNoSuchLinkException().}
{\xe \v m_nId\:CNoSuchLinkException}
{\xe \v CNoSuchLinkException\:m_nId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CNoSuchLinkException::m_nId{\f2  [private]}}
}\par
{\bkmkstart classCNoSuchLinkException_o1}
{\bkmkend classCNoSuchLinkException_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 296 of file CNoSuchLinkException.h.\par
\par
Referenced by CNoSuchLinkException(), and UpdateReasonText().}
{\xe \v m_sName\:CNoSuchLinkException}
{\xe \v CNoSuchLinkException\:m_sName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CNoSuchLinkException::m_sName{\f2  [private]}}
}\par
{\bkmkstart classCNoSuchLinkException_o0}
{\bkmkend classCNoSuchLinkException_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 295 of file CNoSuchLinkException.h.\par
\par
Referenced by CNoSuchLinkException(), getName(), operator=(), operator==(), setName(), and UpdateReasonText().}
{\xe \v m_sReasonText\:CNoSuchLinkException}
{\xe \v CNoSuchLinkException\:m_sReasonText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CNoSuchLinkException::m_sReasonText{\f2  [private]}}
}\par
{\bkmkstart classCNoSuchLinkException_o3}
{\bkmkend classCNoSuchLinkException_o3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 298 of file CNoSuchLinkException.h.\par
\par
Referenced by ReasonText(), and UpdateReasonText().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CNoSuchLinkException.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CNoSuchLinkException.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CNoSuchObjectException  Class Reference\par \pard\plain 
{\tc\tcl2 \v CNoSuchObjectException}
{\xe \v CNoSuchObjectException}
{\bkmkstart classCNoSuchObjectException}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CNoSuchObjectException.h>}\par
Inheritance diagram for CNoSuchObjectException:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCNoSuchObjectException.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CNoSuchObjectException} (const char *pDoing, const char *pName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CNoSuchObjectException} (const char *pDoing, const string &rName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CNoSuchObjectException} (const string &rDoing, const char *pName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CNoSuchObjectException} (const string &rDoing, const string &rName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CNoSuchObjectException} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CNoSuchObjectException} (const CNoSuchObjectException &aCNoSuchObjectException)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CNoSuchObjectException {\b operator=} (const CNoSuchObjectException &aCNoSuchObjectException)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CNoSuchObjectException &aCNoSuchObjectException)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b getName} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setName} (string am_sName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const char * {\b ReasonText} () const\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UpdateReasonText} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_sName}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_sReasonText}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CNoSuchObjectException\:CNoSuchObjectException}
{\xe \v CNoSuchObjectException\:CNoSuchObjectException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CNoSuchObjectException::CNoSuchObjectException (const char * {\i pDoing}, const char * {\i pName}){\f2  [inline]}}
}\par
{\bkmkstart classCNoSuchObjectException_a0}
{\bkmkend classCNoSuchObjectException_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 299 of file CNoSuchObjectException.h.\par
\par
References m_sName, and UpdateReasonText().}
{\xe \v CNoSuchObjectException\:CNoSuchObjectException}
{\xe \v CNoSuchObjectException\:CNoSuchObjectException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CNoSuchObjectException::CNoSuchObjectException (const char * {\i pDoing}, const string & {\i rName}){\f2  [inline]}}
}\par
{\bkmkstart classCNoSuchObjectException_a1}
{\bkmkend classCNoSuchObjectException_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 304 of file CNoSuchObjectException.h.\par
\par
References m_sName, and UpdateReasonText().}
{\xe \v CNoSuchObjectException\:CNoSuchObjectException}
{\xe \v CNoSuchObjectException\:CNoSuchObjectException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CNoSuchObjectException::CNoSuchObjectException (const string & {\i rDoing}, const char * {\i pName}){\f2  [inline]}}
}\par
{\bkmkstart classCNoSuchObjectException_a2}
{\bkmkend classCNoSuchObjectException_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 309 of file CNoSuchObjectException.h.\par
\par
References m_sName, and UpdateReasonText().}
{\xe \v CNoSuchObjectException\:CNoSuchObjectException}
{\xe \v CNoSuchObjectException\:CNoSuchObjectException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CNoSuchObjectException::CNoSuchObjectException (const string & {\i rDoing}, const string & {\i rName}){\f2  [inline]}}
}\par
{\bkmkstart classCNoSuchObjectException_a3}
{\bkmkend classCNoSuchObjectException_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 314 of file CNoSuchObjectException.h.\par
\par
References m_sName, and UpdateReasonText().}
{\xe \v ~CNoSuchObjectException\:CNoSuchObjectException}
{\xe \v CNoSuchObjectException\:~CNoSuchObjectException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual CNoSuchObjectException::~CNoSuchObjectException (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCNoSuchObjectException_a4}
{\bkmkend classCNoSuchObjectException_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 319 of file CNoSuchObjectException.h.\par
}
{\xe \v CNoSuchObjectException\:CNoSuchObjectException}
{\xe \v CNoSuchObjectException\:CNoSuchObjectException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CNoSuchObjectException::CNoSuchObjectException (const CNoSuchObjectException & {\i aCNoSuchObjectException}){\f2  [inline]}}
}\par
{\bkmkstart classCNoSuchObjectException_a5}
{\bkmkend classCNoSuchObjectException_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 323 of file CNoSuchObjectException.h.\par
\par
References m_sName, and UpdateReasonText().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getName\:CNoSuchObjectException}
{\xe \v CNoSuchObjectException\:getName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CNoSuchObjectException::getName () const{\f2  [inline]}}
}\par
{\bkmkstart classCNoSuchObjectException_a8}
{\bkmkend classCNoSuchObjectException_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 353 of file CNoSuchObjectException.h.\par
\par
References m_sName.}
{\xe \v operator=\:CNoSuchObjectException}
{\xe \v CNoSuchObjectException\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CNoSuchObjectException CNoSuchObjectException::operator= (const CNoSuchObjectException & {\i aCNoSuchObjectException}){\f2  [inline]}}
}\par
{\bkmkstart classCNoSuchObjectException_a6}
{\bkmkend classCNoSuchObjectException_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 333 of file CNoSuchObjectException.h.\par
\par
References m_sName, CException::operator=(), and UpdateReasonText().}
{\xe \v operator==\:CNoSuchObjectException}
{\xe \v CNoSuchObjectException\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CNoSuchObjectException::operator== (const CNoSuchObjectException & {\i aCNoSuchObjectException}){\f2  [inline]}}
}\par
{\bkmkstart classCNoSuchObjectException_a7}
{\bkmkend classCNoSuchObjectException_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 344 of file CNoSuchObjectException.h.\par
\par
References m_sName, and CException::operator==().}
{\xe \v ReasonText\:CNoSuchObjectException}
{\xe \v CNoSuchObjectException\:ReasonText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * CNoSuchObjectException::ReasonText () const{\f2  [virtual]}}
}\par
{\bkmkstart classCNoSuchObjectException_a10}
{\bkmkend classCNoSuchObjectException_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns a const pointer to text which describes the reason the exception was thrown. This is exception type specific. The default action returns a pointer to the constant string: "Unspecified Exception" \par
\par
Reimplemented from {\b CException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCException_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 284 of file CNoSuchObjectException.cpp.\par
\par
References m_sReasonText.}
{\xe \v setName\:CNoSuchObjectException}
{\xe \v CNoSuchObjectException\:setName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CNoSuchObjectException::setName (string {\i am_sName}){\f2  [inline]}}
}\par
{\bkmkstart classCNoSuchObjectException_a9}
{\bkmkend classCNoSuchObjectException_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 359 of file CNoSuchObjectException.h.\par
\par
References m_sName.}
{\xe \v UpdateReasonText\:CNoSuchObjectException}
{\xe \v CNoSuchObjectException\:UpdateReasonText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CNoSuchObjectException::UpdateReasonText (){\f2  [protected]}}
}\par
{\bkmkstart classCNoSuchObjectException_b0}
{\bkmkend classCNoSuchObjectException_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 290 of file CNoSuchObjectException.cpp.\par
\par
References m_sName, and m_sReasonText.\par
Referenced by CNoSuchObjectException(), and operator=().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_sName\:CNoSuchObjectException}
{\xe \v CNoSuchObjectException\:m_sName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CNoSuchObjectException::m_sName{\f2  [private]}}
}\par
{\bkmkstart classCNoSuchObjectException_o0}
{\bkmkend classCNoSuchObjectException_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 295 of file CNoSuchObjectException.h.\par
\par
Referenced by CNoSuchObjectException(), getName(), operator=(), operator==(), setName(), and UpdateReasonText().}
{\xe \v m_sReasonText\:CNoSuchObjectException}
{\xe \v CNoSuchObjectException\:m_sReasonText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CNoSuchObjectException::m_sReasonText{\f2  [private]}}
}\par
{\bkmkstart classCNoSuchObjectException_o1}
{\bkmkend classCNoSuchObjectException_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 296 of file CNoSuchObjectException.h.\par
\par
Referenced by ReasonText(), and UpdateReasonText().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CNoSuchObjectException.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CNoSuchObjectException.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CObjectRegistry  Class Reference\par \pard\plain 
{\tc\tcl2 \v CObjectRegistry}
{\xe \v CObjectRegistry}
{\bkmkstart classCObjectRegistry}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CObjectRegistry.h>}\par
Inheritance diagram for CObjectRegistry:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCObjectRegistry.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CObjectRegistry} (string am_sName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CObjectRegistry} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
map< string, {\b CNamedObject} * > {\b getObjects} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Add} ({\b CNamedObject} &rObject)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Remove} (const string &rName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Remove} (const {\b CNamedObject} &rObject)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b ObjectIterator} {\b Find} (const string &rObjectName) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ObjectIterator} {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ObjectIterator} {\b end} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual string {\b DescribeSelf} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setObjects} (map< string, {\b CNamedObject} * > am_Objects)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
map< string, {\b CNamedObject} * > {\b m_Objects}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
Implements a registry of named objects.  Registries allow you to determine which instances of particular types of objects exist. Typically a programmer wanting to  allow this level of introspection will subclass a class hierarchy from {\b CRegisteredObject} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCRegisteredObject \\*MERGEFORMAT}{\fldrslt pagenum}}}) such that the constructor of each class will register that class. One can then programmatically search for named instances of a class as well as iterate through the registry to determine which instances exist. \par
\par
Definition at line 321 of file CObjectRegistry.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CObjectRegistry\:CObjectRegistry}
{\xe \v CObjectRegistry\:CObjectRegistry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CObjectRegistry::CObjectRegistry (string {\i am_sName}){\f2  [inline]}}
}\par
{\bkmkstart classCObjectRegistry_a0}
{\bkmkend classCObjectRegistry_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Map containing the name key and a pointer to the object. \par
\par
Definition at line 329 of file CObjectRegistry.h.\par
\par
References CNamedObject::AppendClassInfo().}
{\xe \v ~CObjectRegistry\:CObjectRegistry}
{\xe \v CObjectRegistry\:~CObjectRegistry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual CObjectRegistry::~CObjectRegistry (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCObjectRegistry_a1}
{\bkmkend classCObjectRegistry_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 334 of file CObjectRegistry.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Add\:CObjectRegistry}
{\xe \v CObjectRegistry\:Add}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CObjectRegistry::Add ({\b CNamedObject} & {\i rObject})}
}\par
{\bkmkstart classCObjectRegistry_a3}
{\bkmkend classCObjectRegistry_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Adds an object to the object registry.  The name of the object is gotten from the object itself.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rObject}}  The object to add to the registry. \par
}\par
Definition at line 310 of file CObjectRegistry.cpp.\par
\par
References CNamedObject::getName(), and m_Objects.}
{\xe \v begin\:CObjectRegistry}
{\xe \v CObjectRegistry\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ObjectIterator} CObjectRegistry::begin ()}
}\par
{\bkmkstart classCObjectRegistry_a7}
{\bkmkend classCObjectRegistry_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns an iterator which 'points' to the beginning of the  registry of objects. Traversing the registry through this  iterator will visit all objects in name alphabetical order. \par
\par
Definition at line 386 of file CObjectRegistry.cpp.\par
\par
References m_Objects.}
{\xe \v DescribeSelf\:CObjectRegistry}
{\xe \v CObjectRegistry\:DescribeSelf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CObjectRegistry::DescribeSelf (){\f2  [virtual]}}
}\par
{\bkmkstart classCObjectRegistry_a9}
{\bkmkend classCObjectRegistry_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns a string which describes the registry The description includes the name and class path of the registry, and the name and class path of all objects contained in the registry. \par
\par
Reimplemented from {\b CNamedObject} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNamedObject_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 409 of file CObjectRegistry.cpp.\par
\par
References CNamedObject::DescribeSelf(), m_Objects, and ObjectIterator.}
{\xe \v end\:CObjectRegistry}
{\xe \v CObjectRegistry\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b ObjectIterator} CObjectRegistry::end ()}
}\par
{\bkmkstart classCObjectRegistry_a8}
{\bkmkend classCObjectRegistry_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns an iterator which 'points' off the end of the registry of objects. Provided to allow clients to know when to terminate iteration through the registry. \par
\par
Definition at line 397 of file CObjectRegistry.cpp.\par
\par
References m_Objects.}
{\xe \v Find\:CObjectRegistry}
{\xe \v CObjectRegistry\:Find}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b ObjectIterator} CObjectRegistry::Find (const string & {\i rObjectName}) const}
}\par
{\bkmkstart classCObjectRegistry_a6}
{\bkmkend classCObjectRegistry_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Searches the registry for an object name. If the object exists in the registry, an ObjectIterator pointing to the object is returned. If it does not exist, a {\b CNoSuchObjectException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNoSuchObjectException \\*MERGEFORMAT}{\fldrslt pagenum}}}) is thrown.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rObjectName}}  The name of the object to find. \par
}\par
Definition at line 368 of file CObjectRegistry.cpp.\par
\par
References m_Objects, and ObjectIterator.}
{\xe \v getObjects\:CObjectRegistry}
{\xe \v CObjectRegistry\:getObjects}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
map<string, {\b CNamedObject}*> CObjectRegistry::getObjects () const{\f2  [inline]}}
}\par
{\bkmkstart classCObjectRegistry_a2}
{\bkmkend classCObjectRegistry_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 339 of file CObjectRegistry.h.\par
\par
References m_Objects.}
{\xe \v Remove\:CObjectRegistry}
{\xe \v CObjectRegistry\:Remove}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CObjectRegistry::Remove (const {\b CNamedObject} & {\i rObject})}
}\par
{\bkmkstart classCObjectRegistry_a5}
{\bkmkend classCObjectRegistry_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Removes an object from the object registry. The name of the object is obtained from the object itself. If the name does not exist in the registry, a  {\b CNoSuchObjectException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNoSuchObjectException \\*MERGEFORMAT}{\fldrslt pagenum}}}) is thrown.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rObject}}  The object to be removed from the registry. \par
}\par
Definition at line 350 of file CObjectRegistry.cpp.\par
\par
References CNamedObject::getName(), and m_Objects.}
{\xe \v Remove\:CObjectRegistry}
{\xe \v CObjectRegistry\:Remove}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CObjectRegistry::Remove (const string & {\i rName})}
}\par
{\bkmkstart classCObjectRegistry_a4}
{\bkmkend classCObjectRegistry_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Removes an object from the object registry. The name of the object is inserted into the registry. If the name does not exists, a {\b CNoSuchObjectException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNoSuchObjectException \\*MERGEFORMAT}{\fldrslt pagenum}}}) is  thrown.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rName}}  The name of the object to remove from the registry. \par
}\par
Definition at line 332 of file CObjectRegistry.cpp.\par
\par
References m_Objects.}
{\xe \v setObjects\:CObjectRegistry}
{\xe \v CObjectRegistry\:setObjects}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CObjectRegistry::setObjects (map< string, {\b CNamedObject} * > {\i am_Objects}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCObjectRegistry_b0}
{\bkmkend classCObjectRegistry_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 347 of file CObjectRegistry.h.\par
\par
References m_Objects.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_Objects\:CObjectRegistry}
{\xe \v CObjectRegistry\:m_Objects}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
map<string, {\b CNamedObject}*> CObjectRegistry::m_Objects{\f2  [private]}}
}\par
{\bkmkstart classCObjectRegistry_o0}
{\bkmkend classCObjectRegistry_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 323 of file CObjectRegistry.h.\par
\par
Referenced by Add(), begin(), DescribeSelf(), end(), Find(), getObjects(), Remove(), and setObjects().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CObjectRegistry.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CObjectRegistry.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CPointerPredicate< T >  Class Template Reference\par \pard\plain 
{\tc\tcl2 \v CPointerPredicate}
{\xe \v CPointerPredicate}
{\bkmkstart classCPointerPredicate}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CPointerPredicate.h>}\par
Inheritance diagram for CPointerPredicate< T >:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCPointerPredicate.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPointerPredicate} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPointerPredicate} (const string &rName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPointerPredicate} (const char *pName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CPointerPredicate} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CPointerPredicate< T > &aCPointerPredicate) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual bool {\b operator()} (T nValue)=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual string {\b DescribeSelf} ()=0\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b GetAutoName} (const string &rBaseName)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CPointerPredicate} (const CPointerPredicate< T > &aCPointerPredicate)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CPointerPredicate< T > {\b operator=} (const CPointerPredicate< T > &aCPointerPredicate)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b m_nAutoIndex} = 0\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Used to name autonamed objects.}\par
\par}
}

{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<typename T> class CPointerPredicate< T >\par
}

{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CPointerPredicate\:CPointerPredicate}
{\xe \v CPointerPredicate\:CPointerPredicate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> CPointerPredicate< T >::CPointerPredicate (){\f2  [inline]}}
}\par
{\bkmkstart classCPointerPredicate_a0}
{\bkmkend classCPointerPredicate_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Used to name predicate objects \par
}
{\xe \v CPointerPredicate\:CPointerPredicate}
{\xe \v CPointerPredicate\:CPointerPredicate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> CPointerPredicate< T >::CPointerPredicate (const string & {\i rName}){\f2  [inline]}}
}\par
{\bkmkstart classCPointerPredicate_a1}
{\bkmkend classCPointerPredicate_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CPointerPredicate\:CPointerPredicate}
{\xe \v CPointerPredicate\:CPointerPredicate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> CPointerPredicate< T >::CPointerPredicate (const char * {\i pName}){\f2  [inline]}}
}\par
{\bkmkstart classCPointerPredicate_a2}
{\bkmkend classCPointerPredicate_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v ~CPointerPredicate\:CPointerPredicate}
{\xe \v CPointerPredicate\:~CPointerPredicate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> CPointerPredicate< T >::~CPointerPredicate (){\f2  [inline]}}
}\par
{\bkmkstart classCPointerPredicate_a3}
{\bkmkend classCPointerPredicate_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CPointerPredicate\:CPointerPredicate}
{\xe \v CPointerPredicate\:CPointerPredicate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> CPointerPredicate< T >::CPointerPredicate (const CPointerPredicate< T > & {\i aCPointerPredicate}){\f2  [private]}}
}\par
{\bkmkstart classCPointerPredicate_c0}
{\bkmkend classCPointerPredicate_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v DescribeSelf\:CPointerPredicate}
{\xe \v CPointerPredicate\:DescribeSelf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> virtual string CPointerPredicate< T >::DescribeSelf (){\f2  [pure virtual]}}
}\par
{\bkmkstart classCPointerPredicate_a6}
{\bkmkend classCPointerPredicate_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Describes the named object. The information given is the object type given by m_sClassPath, and the object name. \par
\par
Reimplemented from {\b CNamedObject} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNamedObject_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Implemented in {\b CChangedPredicate< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCChangedPredicate_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b CMaskedValuePredicate< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCMaskedValuePredicate_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
}
{\xe \v GetAutoName\:CPointerPredicate}
{\xe \v CPointerPredicate\:GetAutoName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> string CPointerPredicate< T >::GetAutoName (const string & {\i rBaseName}){\f2  [static, protected]}}
}\par
{\bkmkstart classCPointerPredicate_e0}
{\bkmkend classCPointerPredicate_e0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\\function string {\b CPointerPredicate::GetAutoName}(const string& rBaseName) ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCPointerPredicate_e0 \\*MERGEFORMAT}{\fldrslt pagenum}}}) Automatically names an object given its base class(es){{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i const}}  string& rBaseName The base name of the object being named \par
}\par
Reimplemented from {\b CNamedObject} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNamedObject_e0 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 296 of file CPointerPredicate.cpp.\par
\par
References CPointerPredicate< T >::m_nAutoIndex.}
{\xe \v operator()\:CPointerPredicate}
{\xe \v CPointerPredicate\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> virtual bool CPointerPredicate< T >::operator() (T {\i nValue}){\f2  [pure virtual]}}
}\par
{\bkmkstart classCPointerPredicate_a5}
{\bkmkend classCPointerPredicate_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Implemented in {\b CChangedPredicate< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCChangedPredicate_a6 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b CMaskedValuePredicate< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCMaskedValuePredicate_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
}
{\xe \v operator=\:CPointerPredicate}
{\xe \v CPointerPredicate\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> CPointerPredicate<T> CPointerPredicate< T >::operator= (const CPointerPredicate< T > & {\i aCPointerPredicate}){\f2  [private]}}
}\par
{\bkmkstart classCPointerPredicate_c1}
{\bkmkend classCPointerPredicate_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:CPointerPredicate}
{\xe \v CPointerPredicate\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> int CPointerPredicate< T >::operator== (const CPointerPredicate< T > & {\i aCPointerPredicate}) const{\f2  [inline]}}
}\par
{\bkmkstart classCPointerPredicate_a4}
{\bkmkend classCPointerPredicate_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 335 of file CPointerPredicate.h.\par
\par
References CRegisteredObject::operator==().\par
Referenced by CMaskedValuePredicate< T >::operator==(), and CChangedPredicate< T >::operator==().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_nAutoIndex\:CPointerPredicate}
{\xe \v CPointerPredicate\:m_nAutoIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<typename T> unsigned int CPointerPredicate< T >::m_nAutoIndex = 0{\f2  [static, private]}}
}\par
{\bkmkstart classCPointerPredicate_r0}
{\bkmkend classCPointerPredicate_r0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Used to name autonamed objects.\par
NamedObject.cpp Base class for all objects in the event management system.\par
Author: Jason Venema NSCL Michigan State University East Lansing, MI 48824-1321 mailto:{\f2 venemaja@msu.edu} \par
\par
Reimplemented from {\b CNamedObject} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNamedObject_r0 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 283 of file CPointerPredicate.cpp.\par
\par
Referenced by CPointerPredicate< T >::GetAutoName().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CPointerPredicate.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CPointerPredicate.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CRangeError  Class Reference\par \pard\plain 
{\tc\tcl2 \v CRangeError}
{\xe \v CRangeError}
{\bkmkstart classCRangeError}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CRangeError.h>}\par
Inheritance diagram for CRangeError:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCRangeError.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum \{ {\b knTooLow}, 
{\b knTooHigh}
 \}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CRangeError} ({\b Int_t} nLow, {\b Int_t} nHigh, {\b Int_t} nRequested, const char *pDoing)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CRangeError} ({\b Int_t} nLow, {\b Int_t} nHigh, {\b Int_t} nRequested, const string &rDoing)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CRangeError} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CRangeError} (const CRangeError &aCRangeError)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CRangeError {\b operator=} (const CRangeError &aCRangeError)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CRangeError &aCRangeError)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Int_t} {\b getLow} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Int_t} {\b getHigh} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Int_t} {\b getRequested} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const char * {\b ReasonText} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Int_t} {\b ReasonCode} () const\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLow} ({\b Int_t} am_nLow)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setHigh} ({\b Int_t} am_nHigh)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRequested} ({\b Int_t} am_nRequested)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UpdateReason} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Int_t} {\b m_nLow}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Int_t} {\b m_nHigh}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Int_t} {\b m_nRequested}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_ReasonText}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
anonymous enum}
}\par
{\bkmkstart classCRangeError_s2}
{\bkmkend classCRangeError_s2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{{{\b \par
Enumeration values:}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v knTooLow\:CRangeError}
{\xe \v CRangeError\:knTooLow}
{\b {\i {\i knTooLow}{\bkmkstart classCRangeError_s2s0}
{\bkmkend classCRangeError_s2s0}
}}  \par
{\xe \v knTooHigh\:CRangeError}
{\xe \v CRangeError\:knTooHigh}
{\b {\i {\i knTooHigh}{\bkmkstart classCRangeError_s2s1}
{\bkmkend classCRangeError_s2s1}
}}  \par
}
\par
Definition at line 315 of file CRangeError.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CRangeError\:CRangeError}
{\xe \v CRangeError\:CRangeError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CRangeError::CRangeError ({\b Int_t} {\i nLow}, {\b Int_t} {\i nHigh}, {\b Int_t} {\i nRequested}, const char * {\i pDoing}){\f2  [inline]}}
}\par
{\bkmkstart classCRangeError_a0}
{\bkmkend classCRangeError_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 321 of file CRangeError.h.\par
\par
References Int_t, m_nHigh, m_nLow, m_nRequested, and UpdateReason().}
{\xe \v CRangeError\:CRangeError}
{\xe \v CRangeError\:CRangeError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CRangeError::CRangeError ({\b Int_t} {\i nLow}, {\b Int_t} {\i nHigh}, {\b Int_t} {\i nRequested}, const string & {\i rDoing}){\f2  [inline]}}
}\par
{\bkmkstart classCRangeError_a1}
{\bkmkend classCRangeError_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 328 of file CRangeError.h.\par
\par
References Int_t, m_nHigh, m_nLow, m_nRequested, and UpdateReason().}
{\xe \v ~CRangeError\:CRangeError}
{\xe \v CRangeError\:~CRangeError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual CRangeError::~CRangeError (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCRangeError_a2}
{\bkmkend classCRangeError_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 335 of file CRangeError.h.\par
}
{\xe \v CRangeError\:CRangeError}
{\xe \v CRangeError\:CRangeError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CRangeError::CRangeError (const CRangeError & {\i aCRangeError}){\f2  [inline]}}
}\par
{\bkmkstart classCRangeError_a3}
{\bkmkend classCRangeError_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 339 of file CRangeError.h.\par
\par
References m_nHigh, m_nLow, m_nRequested, and UpdateReason().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getHigh\:CRangeError}
{\xe \v CRangeError\:getHigh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Int_t} CRangeError::getHigh () const{\f2  [inline]}}
}\par
{\bkmkstart classCRangeError_a7}
{\bkmkend classCRangeError_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 384 of file CRangeError.h.\par
\par
References Int_t, and m_nHigh.}
{\xe \v getLow\:CRangeError}
{\xe \v CRangeError\:getLow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Int_t} CRangeError::getLow () const{\f2  [inline]}}
}\par
{\bkmkstart classCRangeError_a6}
{\bkmkend classCRangeError_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 380 of file CRangeError.h.\par
\par
References Int_t, and m_nLow.}
{\xe \v getRequested\:CRangeError}
{\xe \v CRangeError\:getRequested}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Int_t} CRangeError::getRequested () const{\f2  [inline]}}
}\par
{\bkmkstart classCRangeError_a8}
{\bkmkend classCRangeError_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 388 of file CRangeError.h.\par
\par
References Int_t, and m_nRequested.}
{\xe \v operator=\:CRangeError}
{\xe \v CRangeError\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CRangeError CRangeError::operator= (const CRangeError & {\i aCRangeError}){\f2  [inline]}}
}\par
{\bkmkstart classCRangeError_a4}
{\bkmkend classCRangeError_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 350 of file CRangeError.h.\par
\par
References m_nHigh, m_nLow, m_nRequested, CException::operator=(), and UpdateReason().}
{\xe \v operator==\:CRangeError}
{\xe \v CRangeError\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CRangeError::operator== (const CRangeError & {\i aCRangeError}){\f2  [inline]}}
}\par
{\bkmkstart classCRangeError_a5}
{\bkmkend classCRangeError_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 365 of file CRangeError.h.\par
\par
References m_nHigh, m_nLow, m_nRequested, and CException::operator==().}
{\xe \v ReasonCode\:CRangeError}
{\xe \v CRangeError\:ReasonCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Int_t} CRangeError::ReasonCode () const{\f2  [virtual]}}
}\par
{\bkmkstart classCRangeError_a10}
{\bkmkend classCRangeError_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns a code which describes the reason for the exception . This is exception type specific and may be used to do detailed exception analysis and recovery. For example in the {\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) class, the errno at the time of instantiation of the object is returned. The default returns -1 \par
\par
Reimplemented from {\b CException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCException_a9 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 334 of file CRangeError.cpp.\par
\par
References knTooHigh, knTooLow, m_nHigh, m_nLow, and m_nRequested.}
{\xe \v ReasonText\:CRangeError}
{\xe \v CRangeError\:ReasonText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * CRangeError::ReasonText () const{\f2  [virtual]}}
}\par
{\bkmkstart classCRangeError_a9}
{\bkmkend classCRangeError_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns a const pointer to text which describes the reason the exception was thrown. This is exception type specific. The default action returns a pointer to the constant string: "Unspecified Exception" \par
\par
Reimplemented from {\b CException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCException_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 316 of file CRangeError.cpp.\par
\par
References m_ReasonText.}
{\xe \v setHigh\:CRangeError}
{\xe \v CRangeError\:setHigh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CRangeError::setHigh ({\b Int_t} {\i am_nHigh}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCRangeError_b1}
{\bkmkend classCRangeError_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 400 of file CRangeError.h.\par
\par
References Int_t, m_nHigh, and UpdateReason().}
{\xe \v setLow\:CRangeError}
{\xe \v CRangeError\:setLow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CRangeError::setLow ({\b Int_t} {\i am_nLow}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCRangeError_b0}
{\bkmkend classCRangeError_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 395 of file CRangeError.h.\par
\par
References Int_t, m_nLow, and UpdateReason().}
{\xe \v setRequested\:CRangeError}
{\xe \v CRangeError\:setRequested}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CRangeError::setRequested ({\b Int_t} {\i am_nRequested}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCRangeError_b2}
{\bkmkend classCRangeError_b2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 405 of file CRangeError.h.\par
\par
References Int_t, m_nRequested, and UpdateReason().}
{\xe \v UpdateReason\:CRangeError}
{\xe \v CRangeError\:UpdateReason}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CRangeError::UpdateReason (){\f2  [protected]}}
}\par
{\bkmkstart classCRangeError_b3}
{\bkmkend classCRangeError_b3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 363 of file CRangeError.cpp.\par
\par
References m_nHigh, m_nLow, m_nRequested, and m_ReasonText.\par
Referenced by CRangeError(), operator=(), setHigh(), setLow(), and setRequested().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_nHigh\:CRangeError}
{\xe \v CRangeError\:m_nHigh}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Int_t} CRangeError::m_nHigh{\f2  [private]}}
}\par
{\bkmkstart classCRangeError_o1}
{\bkmkend classCRangeError_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 307 of file CRangeError.h.\par
\par
Referenced by CRangeError(), getHigh(), operator=(), operator==(), ReasonCode(), setHigh(), and UpdateReason().}
{\xe \v m_nLow\:CRangeError}
{\xe \v CRangeError\:m_nLow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Int_t} CRangeError::m_nLow{\f2  [private]}}
}\par
{\bkmkstart classCRangeError_o0}
{\bkmkend classCRangeError_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 306 of file CRangeError.h.\par
\par
Referenced by CRangeError(), getLow(), operator=(), operator==(), ReasonCode(), setLow(), and UpdateReason().}
{\xe \v m_nRequested\:CRangeError}
{\xe \v CRangeError\:m_nRequested}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Int_t} CRangeError::m_nRequested{\f2  [private]}}
}\par
{\bkmkstart classCRangeError_o2}
{\bkmkend classCRangeError_o2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 308 of file CRangeError.h.\par
\par
Referenced by CRangeError(), getRequested(), operator=(), operator==(), ReasonCode(), setRequested(), and UpdateReason().}
{\xe \v m_ReasonText\:CRangeError}
{\xe \v CRangeError\:m_ReasonText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CRangeError::m_ReasonText{\f2  [private]}}
}\par
{\bkmkstart classCRangeError_o3}
{\bkmkend classCRangeError_o3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 310 of file CRangeError.h.\par
\par
Referenced by ReasonText(), and UpdateReason().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CRangeError.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CRangeError.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CReactor  Class Reference\par \pard\plain 
{\tc\tcl2 \v CReactor}
{\xe \v CReactor}
{\bkmkstart classCReactor}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CReactor.h>}\par
Inheritance diagram for CReactor:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCReactor.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CReactor} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CReactor} (const string &rName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CReactor} (const char *pName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CReactor} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CReactor &aCReactor) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b operator()} ({\b CEventMonitor} &rMonitor, {\b CEventMonitor::result} Reason)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnEvent} ({\b CEventMonitor} &rMonitor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnError} ({\b CEventMonitor} &rMonitor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTimeout} ({\b CEventMonitor} &rMonitor)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CReactor} (const CReactor &aCReactor)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i For now copy construction is not allowed.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CReactor & {\b operator=} (const CReactor &aCReactor)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i For now assignment is illegal.}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
Encapsulates the base class for reactors. A reactor is an object which responds to an  event. This class hierarchy is of necessity slightly parallel to the Monitor hierarchy. In additional to the Named Object standard functions, all monitors must implement:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
operator() - called when the monitor fires.\par
}{\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b OnEvent}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCReactor_a6 \\*MERGEFORMAT}{\fldrslt pagenum}}}) - Called from operator() if an event fired.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b OnError}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCReactor_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}) - Called from operator() if a monitor detected and error.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b OnTimeout}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCReactor_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}})- Called from operator() if a monitor deteted a timeout.\par
}As a named object, CReactor's require a name on construction. The name is entered into the "Reactor" registry. As a convenience, a default  constructor is supplied, however. If used the default constructor generates a name of the form Reactor_nnn where nnn is a unique number... from m_AutoIndex.\par
This base class provides: GetAutoName member function for derived classes which desire to implement this functionality as well. \par
\par
Definition at line 331 of file CReactor.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CReactor\:CReactor}
{\xe \v CReactor\:CReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CReactor::CReactor ()}
}\par
{\bkmkstart classCReactor_a0}
{\bkmkend classCReactor_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Default constructor. A Reactor with name of the form Reactor_nnn is created. The reactor is entered in to the "Reactor" registry of the  classified object registry returned from getCClassifiedObjectRegistry(). The name used is gaurenteed unique and can be queried via: {\b getName}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNamedObject_a6 \\*MERGEFORMAT}{\fldrslt pagenum}}}). \par
\par
Definition at line 321 of file CReactor.cpp.\par
\par
References CNamedObject::AppendClassInfo(), and RegistryName.}
{\xe \v CReactor\:CReactor}
{\xe \v CReactor\:CReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CReactor::CReactor (const string & {\i rName})}
}\par
{\bkmkstart classCReactor_a1}
{\bkmkend classCReactor_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Constructs a Reactor given a name as an STL string:{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rName}}  - The desired name of the reactor.\par
}Throws:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CDuplicateNameException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDuplicateNameException \\*MERGEFORMAT}{\fldrslt pagenum}}}) (indirectly) if a Reactor of this name already exists. \par
}\par
Definition at line 337 of file CReactor.cpp.\par
\par
References CNamedObject::AppendClassInfo(), and RegistryName.}
{\xe \v CReactor\:CReactor}
{\xe \v CReactor\:CReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CReactor::CReactor (const char * {\i pName})}
}\par
{\bkmkstart classCReactor_a2}
{\bkmkend classCReactor_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Constructs a reactor given its name as an ASCIZ string:{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i pName}}  - char* pointer to the desired object name.\par
}Throws: -{\b CDuplicateNameException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDuplicateNameException \\*MERGEFORMAT}{\fldrslt pagenum}}}) (indirectly) if a Reactor of this name already exists. \par
\par
Definition at line 354 of file CReactor.cpp.\par
\par
References CNamedObject::AppendClassInfo(), and RegistryName.}
{\xe \v CReactor\:CReactor}
{\xe \v CReactor\:CReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CReactor::CReactor (const CReactor & {\i aCReactor}){\f2  [private]}}
}\par
{\bkmkstart classCReactor_c0}
{\bkmkend classCReactor_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
For now copy construction is not allowed.\par
}
{\xe \v ~CReactor\:CReactor}
{\xe \v CReactor\:~CReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CReactor::~CReactor (){\f2  [virtual]}}
}\par
{\bkmkstart classCReactor_a3}
{\bkmkend classCReactor_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Destructor: Just ensure that we are removed from the Reactors registry before being destroyed. \par
\par
Definition at line 366 of file CReactor.cpp.\par
\par
References CApplicationRegistry::getInstance(), RegistryName, and CClassifiedObjectRegistry::Remove().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v OnError\:CReactor}
{\xe \v CReactor\:OnError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CReactor::OnError ({\b CEventMonitor} & {\i rEvent}){\f2  [virtual]}}
}\par
{\bkmkstart classCReactor_a7}
{\bkmkend classCReactor_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called when the event monitor detects an error while waiting for an event. In general, this class is subclassed, and the actual code for OnError is supplied by the subclass. In order to support classes which may not care about event monitor errors themselves,  we provide an empty implementation of this function, preventing us from being an ABC.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rMonitor}}  - The monitor which detected the event. \par
}\par
Definition at line 447 of file CReactor.cpp.\par
\par
Referenced by operator()().}
{\xe \v OnEvent\:CReactor}
{\xe \v CReactor\:OnEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CReactor::OnEvent ({\b CEventMonitor} & {\i rEvent}){\f2  [virtual]}}
}\par
{\bkmkstart classCReactor_a6}
{\bkmkend classCReactor_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called when the event occurs. This is called from operator(). In general, this class is subclassed, and the actual code for OnEvent is supplied by the subclass. In order to support classes which may not care about the event themselves, we provide an empty implementation of this function, preventing us from being an ABC.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rMonitor}}  - The monitor which detected the event. \par
}\par
Reimplemented in {\b CBufferReactor< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferReactor_a5 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CFdReactor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFdReactor_a5 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CLocationReactor< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCLocationReactor_a5 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CTimerEvent::CTimerGenericReactor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTimerEvent_1_1CTimerGenericReactor_a2 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CBufferReactor< U >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferReactor_a5 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b CLocationReactor< U >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCLocationReactor_a5 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 433 of file CReactor.cpp.\par
\par
Referenced by operator()().}
{\xe \v OnTimeout\:CReactor}
{\xe \v CReactor\:OnTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CReactor::OnTimeout ({\b CEventMonitor} & {\i rEvent}){\f2  [virtual]}}
}\par
{\bkmkstart classCReactor_a8}
{\bkmkend classCReactor_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called when an event monitor detects a timeout while waiting for the event. In general, this class is subclassed, and the actual code for OnTimeout is supplied by the subclass. In order to support classes which may not care about event monitor timeouts themselves,  we provide an empty implementation of this function, preventing us from being an ABC.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rMonitor}}  - The monitor which detected the event. \par
}\par
Reimplemented in {\b CBufferEvent< T >::CGenericBufferReactor< U >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferEvent_1_1CGenericBufferReactor_a2 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CFileEventReactor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFileEvent_1_1CFileEventReactor_a5 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CLocationEvent< T >::CGenericLocationReactor< U >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCLocationEvent_1_1CGenericLocationReactor_a2 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b CBufferEvent< T >::CGenericBufferReactor< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferEvent_1_1CGenericBufferReactor_a2 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 461 of file CReactor.cpp.\par
\par
Referenced by operator()().}
{\xe \v operator()\:CReactor}
{\xe \v CReactor\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CReactor::operator() ({\b CEventMonitor} & {\i rMonitor}, {\b CEventMonitor::result} {\i Reason}){\f2  [virtual]}}
}\par
{\bkmkstart classCReactor_a5}
{\bkmkend classCReactor_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Interface Definition\par
Purpose:\par
This method is called in response ot an event from an event monitor on which this reactor has been established. The Reactor provides  application specific procesing of the event.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rMonitor}}  - The event monitor which fired off our reaction. \par
{\b {\i Reason}}  - Why we were fired. Can be any of:{\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
Ocurred - the event happened.\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
TimedOut - The event did not happen within the timeout.\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
Error - Some error occured on the event.\par
}}Throws:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CRangeError} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCRangeError \\*MERGEFORMAT}{\fldrslt pagenum}}}) if an invalid Reason was passed in. \par
}\par
Definition at line 404 of file CReactor.cpp.\par
\par
References CEventMonitor::Error, CEventMonitor::Occurred, OnError(), OnEvent(), OnTimeout(), CEventMonitor::result, and CEventMonitor::TimedOut.}
{\xe \v operator=\:CReactor}
{\xe \v CReactor\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CReactor& CReactor::operator= (const CReactor & {\i aCReactor}){\f2  [private]}}
}\par
{\bkmkstart classCReactor_c1}
{\bkmkend classCReactor_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
For now assignment is illegal.\par
}
{\xe \v operator==\:CReactor}
{\xe \v CReactor\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CReactor::operator== (const CReactor & {\i aCReactor}) const}
}\par
{\bkmkstart classCReactor_a4}
{\bkmkend classCReactor_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 374 of file CReactor.cpp.\par
\par
References CRegisteredObject::operator==().\par
Referenced by CLocationReactor< T >::operator==(), CFdReactor::operator==(), and CBufferReactor< T >::operator==().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CReactor.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CReactor.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CRefcountedPtr< T >  Class Template Reference\par \pard\plain 
{\tc\tcl2 \v CRefcountedPtr}
{\xe \v CRefcountedPtr}
{\bkmkstart classCRefcountedPtr}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CRefptr.h>}\par
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CRefcountedPtr} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CRefcountedPtr} (T *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CRefcountedPtr} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class U> {\b CRefcountedPtr} (const CRefcountedPtr< U > &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CRefcountedPtr & {\b operator=} (const CRefcountedPtr &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b refcount} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class U> int {\b operator==} (const CRefcountedPtr< U > &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T & {\b operator *} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T * {\b operator->} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CReferenceCounted}< T > * {\b m_Object}\par
}

{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class T> class CRefcountedPtr< T >\par
}

{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CRefcountedPtr\:CRefcountedPtr}
{\xe \v CRefcountedPtr\:CRefcountedPtr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CRefcountedPtr< T >::CRefcountedPtr (){\f2  [inline]}}
}\par
{\bkmkstart classCRefcountedPtr_a0}
{\bkmkend classCRefcountedPtr_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 326 of file CRefptr.h.\par
}
{\xe \v CRefcountedPtr\:CRefcountedPtr}
{\xe \v CRefcountedPtr\:CRefcountedPtr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CRefcountedPtr< T >::CRefcountedPtr (T * {\i p}){\f2  [inline]}}
}\par
{\bkmkstart classCRefcountedPtr_a1}
{\bkmkend classCRefcountedPtr_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 327 of file CRefptr.h.\par
}
{\xe \v ~CRefcountedPtr\:CRefcountedPtr}
{\xe \v CRefcountedPtr\:~CRefcountedPtr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CRefcountedPtr< T >::~CRefcountedPtr (){\f2  [inline]}}
}\par
{\bkmkstart classCRefcountedPtr_a2}
{\bkmkend classCRefcountedPtr_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 329 of file CRefptr.h.\par
\par
References CReferenceCounted< T >::dereference(), and CReferenceCounted< T >::norefs().}
{\xe \v CRefcountedPtr\:CRefcountedPtr}
{\xe \v CRefcountedPtr\:CRefcountedPtr}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> template<class U> CRefcountedPtr< T >::CRefcountedPtr (const CRefcountedPtr< U > & {\i rhs}){\f2  [inline]}}
}\par
{\bkmkstart classCRefcountedPtr_a3}
{\bkmkend classCRefcountedPtr_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 336 of file CRefptr.h.\par
\par
References CRefcountedPtr< T >::m_Object, and CReferenceCounted< T >::reference().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator *\:CRefcountedPtr}
{\xe \v CRefcountedPtr\:operator *}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> T& CRefcountedPtr< T >::operator * (){\f2  [inline]}}
}\par
{\bkmkstart classCRefcountedPtr_a7}
{\bkmkend classCRefcountedPtr_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 372 of file CRefptr.h.\par
}
{\xe \v operator->\:CRefcountedPtr}
{\xe \v CRefcountedPtr\:operator->}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> T* CRefcountedPtr< T >::operator-> (){\f2  [inline]}}
}\par
{\bkmkstart classCRefcountedPtr_a8}
{\bkmkend classCRefcountedPtr_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 373 of file CRefptr.h.\par
\par
References CReferenceCounted< T >::get().}
{\xe \v operator=\:CRefcountedPtr}
{\xe \v CRefcountedPtr\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CRefcountedPtr& CRefcountedPtr< T >::operator= (const CRefcountedPtr< T > & {\i rhs}){\f2  [inline]}}
}\par
{\bkmkstart classCRefcountedPtr_a4}
{\bkmkend classCRefcountedPtr_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 343 of file CRefptr.h.\par
\par
References CReferenceCounted< T >::dereference(), CRefcountedPtr< T >::m_Object, CReferenceCounted< T >::norefs(), and CReferenceCounted< T >::reference().}
{\xe \v operator==\:CRefcountedPtr}
{\xe \v CRefcountedPtr\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> template<class U> int CRefcountedPtr< T >::operator== (const CRefcountedPtr< U > & {\i rhs}){\f2  [inline]}}
}\par
{\bkmkstart classCRefcountedPtr_a6}
{\bkmkend classCRefcountedPtr_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 369 of file CRefptr.h.\par
\par
References CRefcountedPtr< T >::m_Object.}
{\xe \v refcount\:CRefcountedPtr}
{\xe \v CRefcountedPtr\:refcount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int CRefcountedPtr< T >::refcount () const{\f2  [inline]}}
}\par
{\bkmkstart classCRefcountedPtr_a5}
{\bkmkend classCRefcountedPtr_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 358 of file CRefptr.h.\par
\par
References CReferenceCounted< T >::refcount().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_Object\:CRefcountedPtr}
{\xe \v CRefcountedPtr\:m_Object}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> {\b CReferenceCounted}<T>* CRefcountedPtr< T >::m_Object{\f2  [private]}}
}\par
{\bkmkstart classCRefcountedPtr_o0}
{\bkmkend classCRefcountedPtr_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 324 of file CRefptr.h.\par
\par
Referenced by CRefcountedPtr< T >::CRefcountedPtr(), CRefcountedPtr< T >::operator=(), and CRefcountedPtr< T >::operator==().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CRefptr.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CReferenceCounted< T >  Class Template Reference\par \pard\plain 
{\tc\tcl2 \v CReferenceCounted}
{\xe \v CReferenceCounted}
{\bkmkstart classCReferenceCounted}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CRefptr.h>}\par
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CReferenceCounted} (T *p)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CReferenceCounted} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T & {\b operator *} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T * {\b get} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b reference} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dereference} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b norefs} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b refcount} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class U> CReferenceCounted< T > & {\b operator=} (const CReferenceCounted< U > &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
template<class U> {\b CReferenceCounted} (const CReferenceCounted< U > &rhs)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned {\b m_ReferenceCount}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T * {\b m_Pointer}\par
}

{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class T> class CReferenceCounted< T >\par
}

{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CReferenceCounted\:CReferenceCounted}
{\xe \v CReferenceCounted\:CReferenceCounted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> template<class U> CReferenceCounted< T >::CReferenceCounted (const CReferenceCounted< U > & {\i rhs}){\f2  [private]}}
}\par
{\bkmkstart classCReferenceCounted_c1}
{\bkmkend classCReferenceCounted_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v CReferenceCounted\:CReferenceCounted}
{\xe \v CReferenceCounted\:CReferenceCounted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CReferenceCounted< T >::CReferenceCounted (T * {\i p}){\f2  [inline]}}
}\par
{\bkmkstart classCReferenceCounted_a0}
{\bkmkend classCReferenceCounted_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 307 of file CRefptr.h.\par
\par
References CReferenceCounted< T >::m_Pointer, and CReferenceCounted< T >::m_ReferenceCount.}
{\xe \v ~CReferenceCounted\:CReferenceCounted}
{\xe \v CReferenceCounted\:~CReferenceCounted}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CReferenceCounted< T >::~CReferenceCounted (){\f2  [inline]}}
}\par
{\bkmkstart classCReferenceCounted_a1}
{\bkmkend classCReferenceCounted_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 310 of file CRefptr.h.\par
\par
References CReferenceCounted< T >::m_Pointer.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v dereference\:CReferenceCounted}
{\xe \v CReferenceCounted\:dereference}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CReferenceCounted< T >::dereference (){\f2  [inline]}}
}\par
{\bkmkstart classCReferenceCounted_a5}
{\bkmkend classCReferenceCounted_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 314 of file CRefptr.h.\par
\par
References CReferenceCounted< T >::m_ReferenceCount.\par
Referenced by CRefcountedPtr< T >::operator=(), and CRefcountedPtr< T >::~CRefcountedPtr().}
{\xe \v get\:CReferenceCounted}
{\xe \v CReferenceCounted\:get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> T* CReferenceCounted< T >::get (){\f2  [inline]}}
}\par
{\bkmkstart classCReferenceCounted_a3}
{\bkmkend classCReferenceCounted_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 312 of file CRefptr.h.\par
\par
References CReferenceCounted< T >::m_Pointer.\par
Referenced by CRefcountedPtr< T >::operator->().}
{\xe \v norefs\:CReferenceCounted}
{\xe \v CReferenceCounted\:norefs}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int CReferenceCounted< T >::norefs (){\f2  [inline]}}
}\par
{\bkmkstart classCReferenceCounted_a6}
{\bkmkend classCReferenceCounted_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 315 of file CRefptr.h.\par
\par
References CReferenceCounted< T >::m_ReferenceCount.\par
Referenced by CRefcountedPtr< T >::operator=(), and CRefcountedPtr< T >::~CRefcountedPtr().}
{\xe \v operator *\:CReferenceCounted}
{\xe \v CReferenceCounted\:operator *}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> T& CReferenceCounted< T >::operator * (){\f2  [inline]}}
}\par
{\bkmkstart classCReferenceCounted_a2}
{\bkmkend classCReferenceCounted_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 311 of file CRefptr.h.\par
\par
References CReferenceCounted< T >::m_Pointer.}
{\xe \v operator=\:CReferenceCounted}
{\xe \v CReferenceCounted\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> template<class U> CReferenceCounted<T>& CReferenceCounted< T >::operator= (const CReferenceCounted< U > & {\i rhs}){\f2  [private]}}
}\par
{\bkmkstart classCReferenceCounted_c0}
{\bkmkend classCReferenceCounted_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v refcount\:CReferenceCounted}
{\xe \v CReferenceCounted\:refcount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int CReferenceCounted< T >::refcount (){\f2  [inline]}}
}\par
{\bkmkstart classCReferenceCounted_a7}
{\bkmkend classCReferenceCounted_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 316 of file CRefptr.h.\par
\par
References CReferenceCounted< T >::m_ReferenceCount.\par
Referenced by CRefcountedPtr< T >::refcount().}
{\xe \v reference\:CReferenceCounted}
{\xe \v CReferenceCounted\:reference}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CReferenceCounted< T >::reference (){\f2  [inline]}}
}\par
{\bkmkstart classCReferenceCounted_a4}
{\bkmkend classCReferenceCounted_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 313 of file CRefptr.h.\par
\par
References CReferenceCounted< T >::m_ReferenceCount.\par
Referenced by CRefcountedPtr< T >::CRefcountedPtr(), and CRefcountedPtr< T >::operator=().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_Pointer\:CReferenceCounted}
{\xe \v CReferenceCounted\:m_Pointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> T* CReferenceCounted< T >::m_Pointer{\f2  [private]}}
}\par
{\bkmkstart classCReferenceCounted_o1}
{\bkmkend classCReferenceCounted_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 298 of file CRefptr.h.\par
\par
Referenced by CReferenceCounted< T >::CReferenceCounted(), CReferenceCounted< T >::get(), CReferenceCounted< T >::operator *(), and CReferenceCounted< T >::~CReferenceCounted().}
{\xe \v m_ReferenceCount\:CReferenceCounted}
{\xe \v CReferenceCounted\:m_ReferenceCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> unsigned CReferenceCounted< T >::m_ReferenceCount{\f2  [private]}}
}\par
{\bkmkstart classCReferenceCounted_o0}
{\bkmkend classCReferenceCounted_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 297 of file CRefptr.h.\par
\par
Referenced by CReferenceCounted< T >::CReferenceCounted(), CReferenceCounted< T >::dereference(), CReferenceCounted< T >::norefs(), CReferenceCounted< T >::refcount(), and CReferenceCounted< T >::reference().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CRefptr.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CRegisteredObject  Class Reference\par \pard\plain 
{\tc\tcl2 \v CRegisteredObject}
{\xe \v CRegisteredObject}
{\bkmkstart classCRegisteredObject}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CRegisteredObject.h>}\par
Inheritance diagram for CRegisteredObject:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCRegisteredObject.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CRegisteredObject} (string am_sName, {\b CClassifiedObjectRegistry} *am_Registry, const string &{\b RegistryName})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CRegisteredObject &aCRegisteredObject) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CRegisteredObject} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CClassifiedObjectRegistry} * {\b getRegistry} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b RegisterSelf} (const string &{\b RegistryName})\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRegistry} ({\b CClassifiedObjectRegistry} *const am_Registry)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CRegisteredObject} (const CRegisteredObject &aCRegisteredObject)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Copy construction is forbidden for now.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CRegisteredObject {\b operator=} (const CRegisteredObject &aCRegisteredObject)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Assignment is forbidden for now.}\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CClassifiedObjectRegistry} * {\b m_Registry}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
RegisteredObject.h:\par
This file defines the CRegisteredObject class.\par
Author: Jason Venema NSCL Michigan State University East Lansing, MI 48824-1321 mailto:{\f2 venemaja@msu.edu} \par
\par
Definition at line 307 of file CRegisteredObject.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CRegisteredObject\:CRegisteredObject}
{\xe \v CRegisteredObject\:CRegisteredObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CRegisteredObject::CRegisteredObject (string {\i am_sName}, {\b CClassifiedObjectRegistry} * {\i am_Registry}, const string & {\i RegistryName}){\f2  [inline]}}
}\par
{\bkmkstart classCRegisteredObject_a0}
{\bkmkend classCRegisteredObject_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
The classified object  registry into which this  object will be registered \par
\par
Definition at line 315 of file CRegisteredObject.h.\par
\par
References CNamedObject::AppendClassInfo(), and RegisterSelf().}
{\xe \v CRegisteredObject\:CRegisteredObject}
{\xe \v CRegisteredObject\:CRegisteredObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CRegisteredObject::CRegisteredObject (const CRegisteredObject & {\i aCRegisteredObject}){\f2  [private]}}
}\par
{\bkmkstart classCRegisteredObject_c0}
{\bkmkend classCRegisteredObject_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Copy construction is forbidden for now.\par
}
{\xe \v ~CRegisteredObject\:CRegisteredObject}
{\xe \v CRegisteredObject\:~CRegisteredObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual CRegisteredObject::~CRegisteredObject (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCRegisteredObject_a2}
{\bkmkend classCRegisteredObject_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 339 of file CRegisteredObject.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getRegistry\:CRegisteredObject}
{\xe \v CRegisteredObject\:getRegistry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b CClassifiedObjectRegistry}* CRegisteredObject::getRegistry () const{\f2  [inline]}}
}\par
{\bkmkstart classCRegisteredObject_a3}
{\bkmkend classCRegisteredObject_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 344 of file CRegisteredObject.h.\par
\par
Referenced by CEventMonitor::~CEventMonitor().}
{\xe \v operator=\:CRegisteredObject}
{\xe \v CRegisteredObject\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CRegisteredObject CRegisteredObject::operator= (const CRegisteredObject & {\i aCRegisteredObject}){\f2  [private]}}
}\par
{\bkmkstart classCRegisteredObject_c1}
{\bkmkend classCRegisteredObject_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Assignment is forbidden for now.\par
\par
Reimplemented in {\b CEventMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEventMonitor_c1 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b CFdMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFdMonitor_c1 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
}
{\xe \v operator==\:CRegisteredObject}
{\xe \v CRegisteredObject\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CRegisteredObject::operator== (const CRegisteredObject & {\i aCRegisteredObject}) const{\f2  [inline]}}
}\par
{\bkmkstart classCRegisteredObject_a1}
{\bkmkend classCRegisteredObject_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 332 of file CRegisteredObject.h.\par
\par
References m_Registry, and CNamedObject::operator==().\par
Referenced by CReactor::operator==(), CPointerPredicate< T >::operator==(), and CEventMonitor::operator==().}
{\xe \v RegisterSelf\:CRegisteredObject}
{\xe \v CRegisteredObject\:RegisterSelf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CRegisteredObject::RegisterSelf (const string & {\i RegistryName})}
}\par
{\bkmkstart classCRegisteredObject_a4}
{\bkmkend classCRegisteredObject_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Registers this object in the appropriate object registry. Note: the object registry will throw a DuplicateNameException if there is already an object in our registry with that name. If necessary, the registry is created. Implicit parameters: m_Registry - a static member which is the collection of object registries into which the object will be registered. m_sName - the name under which the object will be registered.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i RegistryName}}  The name of the registry in which to register the object \par
}\par
Definition at line 307 of file CRegisteredObject.cpp.\par
\par
References CClassifiedObjectRegistry::Add(), CClassifiedObjectRegistry::CreateRegistry(), and m_Registry.\par
Referenced by CRegisteredObject().}
{\xe \v setRegistry\:CRegisteredObject}
{\xe \v CRegisteredObject\:setRegistry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CRegisteredObject::setRegistry ({\b CClassifiedObjectRegistry} *const {\i am_Registry}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCRegisteredObject_b0}
{\bkmkend classCRegisteredObject_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 352 of file CRegisteredObject.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_Registry\:CRegisteredObject}
{\xe \v CRegisteredObject\:m_Registry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CClassifiedObjectRegistry}* CRegisteredObject::m_Registry{\f2  [private]}}
}\par
{\bkmkstart classCRegisteredObject_o0}
{\bkmkend classCRegisteredObject_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 309 of file CRegisteredObject.h.\par
\par
Referenced by operator==(), and RegisterSelf().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CRegisteredObject.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CRegisteredObject.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CServerConnectionEvent  Class Reference\par \pard\plain 
{\tc\tcl2 \v CServerConnectionEvent}
{\xe \v CServerConnectionEvent}
{\bkmkstart classCServerConnectionEvent}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \\class: CServerConnectionEvent \\file: {\b CServerConnectionEvent.h}. 
\par
{\f2 #include <CServerConnectionEvent.h>}\par
Inheritance diagram for CServerConnectionEvent:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCServerConnectionEvent.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CServerConnectionEvent} ({\b CSocket} &sock)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CServerConnectionEvent} (const char *pName, {\b CSocket} &sock)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CServerConnectionEvent} (const string &rName, {\b CSocket} &sock)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CServerConnectionEvent} (const string &rServiceName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CServerConnectionEvent} (const char *pName, const string &rServiceName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CServerConnectionEvent} (const string &rName, const string &rServiceName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CServerConnectionEvent} (int nFd)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CServerConnectionEvent} (const char *pName, int nFd)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CServerConnectionEvent} (const string &rName, int nFd)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CServerConnectionEvent} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CSocket} * {\b getSocket} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isDynamicSocket} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnConnection} ({\b CSocket} *pPeer)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnReadable} (istream &rStream)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual string {\b DescribeSelf} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSocket} ({\b CSocket} *pSocket)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setDynamic} (bool fDyn)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ConfigureSocket} (const string &rSvcName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ConfigureSocket} (int nPort)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Protocol} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CServerConnectionEvent} (const CServerConnectionEvent &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CServerConnectionEvent & {\b operator=} (const CServerConnectionEvent &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CServerConnectionEvent &rhs)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CSocket} * {\b m_pService}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Server listener socket.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b m_fDeleteSocket}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i true if destructor delete socket.}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \\class: CServerConnectionEvent \\file: {\b CServerConnectionEvent.h}.\par
\par
This class encapsulates the process of listening for and accepting client connections to a Tcp/Ip service. The event is policy free in the sense that all it does is set up an encapsulated {\b CSocket} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCSocket \\*MERGEFORMAT}{\fldrslt pagenum}}}) to listen on a specified port and listen for connections on the socket within a thread. When a connection request is received... it is accepted and the resulting socket is passed to {\b OnConnection}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCServerConnectionEvent_a12 \\*MERGEFORMAT}{\fldrslt pagenum}}})\par
The user of this class in general will subclass the server and override the default (no-op) implementation of {\b OnConnection}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCServerConnectionEvent_a12 \\*MERGEFORMAT}{\fldrslt pagenum}}}) \par
\par
Definition at line 322 of file CServerConnectionEvent.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CServerConnectionEvent\:CServerConnectionEvent}
{\xe \v CServerConnectionEvent\:CServerConnectionEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CServerConnectionEvent::CServerConnectionEvent ({\b CSocket} & {\i rSocket})}
}\par
{\bkmkstart classCServerConnectionEvent_a0}
{\bkmkend classCServerConnectionEvent_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct an anonymous connection listener from an existing socket object. In this case, it will not be necessary for the destructor to eliminate the socket.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i sock}}  - An existing socket, bound, listening and ready to accept when the fd becomes readable. \par
}\par
Definition at line 305 of file CServerConnectionEvent.cpp.\par
}
{\xe \v CServerConnectionEvent\:CServerConnectionEvent}
{\xe \v CServerConnectionEvent\:CServerConnectionEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CServerConnectionEvent::CServerConnectionEvent (const char * {\i pname}, {\b CSocket} & {\i rSocket})}
}\par
{\bkmkstart classCServerConnectionEvent_a1}
{\bkmkend classCServerConnectionEvent_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct a named connection listener from and existing socket object.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i pName}}  - char* pointer to the name of the event. \par
{\b {\i rSocket}}  - Reference to existing socket. \par
}\par
Definition at line 317 of file CServerConnectionEvent.cpp.\par
}
{\xe \v CServerConnectionEvent\:CServerConnectionEvent}
{\xe \v CServerConnectionEvent\:CServerConnectionEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CServerConnectionEvent::CServerConnectionEvent (const string & {\i rName}, {\b CSocket} & {\i rSocket})}
}\par
{\bkmkstart classCServerConnectionEvent_a2}
{\bkmkend classCServerConnectionEvent_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct a named connnection listener from an existing socket object.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rName}}  - Reference to the object name desired. \par
{\b {\i rSocket-}}  Socket to create the listener around. The socket must be in the listening state, by the time the event is enabled/scheduled. \par
}\par
Definition at line 331 of file CServerConnectionEvent.cpp.\par
}
{\xe \v CServerConnectionEvent\:CServerConnectionEvent}
{\xe \v CServerConnectionEvent\:CServerConnectionEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CServerConnectionEvent::CServerConnectionEvent (const string & {\i rServiceName})}
}\par
{\bkmkstart classCServerConnectionEvent_a3}
{\bkmkend classCServerConnectionEvent_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct an anonymous connection listener from a service name. Since we need to construct the file event with an fd, that will be done by an explicit socket(2) call. The m_pService will be dynamically allocated and configured from the fd, and the service information in the constructor body.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rServiceName}}  - Name of the service to connect to. The {\b CSocket} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCSocket \\*MERGEFORMAT}{\fldrslt pagenum}}}) type accepts either a name which translates via getservbyname, or a stringified service number. \par
}\par
Definition at line 349 of file CServerConnectionEvent.cpp.\par
\par
References ConfigureSocket().}
{\xe \v CServerConnectionEvent\:CServerConnectionEvent}
{\xe \v CServerConnectionEvent\:CServerConnectionEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CServerConnectionEvent::CServerConnectionEvent (const char * {\i pName}, const string & {\i rServiceName})}
}\par
{\bkmkstart classCServerConnectionEvent_a4}
{\bkmkend classCServerConnectionEvent_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct a named connection listener from a service name. See above for more information. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i pName}}  - char* name to be given to the connection listener. \par
{\b {\i rServiceName}}  - Name of the service to connect to. The {\b CSocket} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCSocket \\*MERGEFORMAT}{\fldrslt pagenum}}}) type accepts either a name which translates via getservbyname, or a stringified service number. \par
}\par
Definition at line 365 of file CServerConnectionEvent.cpp.\par
\par
References ConfigureSocket().}
{\xe \v CServerConnectionEvent\:CServerConnectionEvent}
{\xe \v CServerConnectionEvent\:CServerConnectionEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CServerConnectionEvent::CServerConnectionEvent (const string & {\i rName}, const string & {\i rServiceName})}
}\par
{\bkmkstart classCServerConnectionEvent_a5}
{\bkmkend classCServerConnectionEvent_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 373 of file CServerConnectionEvent.cpp.\par
\par
References ConfigureSocket().}
{\xe \v CServerConnectionEvent\:CServerConnectionEvent}
{\xe \v CServerConnectionEvent\:CServerConnectionEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CServerConnectionEvent::CServerConnectionEvent (int {\i nFd})}
}\par
{\bkmkstart classCServerConnectionEvent_a6}
{\bkmkend classCServerConnectionEvent_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct an anonymous Connection listener given a file id which represents a bound and listening socket.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i nFd}}  - A file descriptor which is a bound and listening socket. \par
}\par
Definition at line 388 of file CServerConnectionEvent.cpp.\par
}
{\xe \v CServerConnectionEvent\:CServerConnectionEvent}
{\xe \v CServerConnectionEvent\:CServerConnectionEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CServerConnectionEvent::CServerConnectionEvent (const char * {\i pName}, int {\i nFd})}
}\par
{\bkmkstart classCServerConnectionEvent_a7}
{\bkmkend classCServerConnectionEvent_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct a named connection listener given a file id which represents a  bound and listening socket.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i pName}}  - char* name to be given to the socket. \par
{\b {\i nFd}}  - File descriptor representing a bound and listening sock. \par
}\par
Definition at line 401 of file CServerConnectionEvent.cpp.\par
}
{\xe \v CServerConnectionEvent\:CServerConnectionEvent}
{\xe \v CServerConnectionEvent\:CServerConnectionEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CServerConnectionEvent::CServerConnectionEvent (const string & {\i rName}, int {\i nFd})}
}\par
{\bkmkstart classCServerConnectionEvent_a8}
{\bkmkend classCServerConnectionEvent_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct a named connection listener given a file id which represents a bound and listening socket.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rName}}  - string& name to be given to the socket. \par
{\b {\i nFd}}  - File descriptor representing a bound and listening socket. \par
}\par
Definition at line 414 of file CServerConnectionEvent.cpp.\par
}
{\xe \v ~CServerConnectionEvent\:CServerConnectionEvent}
{\xe \v CServerConnectionEvent\:~CServerConnectionEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CServerConnectionEvent::~CServerConnectionEvent ()}
}\par
{\bkmkstart classCServerConnectionEvent_a9}
{\bkmkend classCServerConnectionEvent_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Destructor... if m_fDelete socket is true, then the socket is deleted. otherwise just closed. \par
\par
Definition at line 425 of file CServerConnectionEvent.cpp.\par
\par
References m_pService, and CSocket::Shutdown().}
{\xe \v CServerConnectionEvent\:CServerConnectionEvent}
{\xe \v CServerConnectionEvent\:CServerConnectionEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CServerConnectionEvent::CServerConnectionEvent (const CServerConnectionEvent & {\i rhs}){\f2  [private]}}
}\par
{\bkmkstart classCServerConnectionEvent_c0}
{\bkmkend classCServerConnectionEvent_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v ConfigureSocket\:CServerConnectionEvent}
{\xe \v CServerConnectionEvent\:ConfigureSocket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CServerConnectionEvent::ConfigureSocket (int {\i nPort}){\f2  [protected]}}
}\par
{\bkmkstart classCServerConnectionEvent_b3}
{\bkmkend classCServerConnectionEvent_b3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Utility function to configure a socket. The port id is  used to bind the socket and set it into listen mode.\par
{{{\b \par
Note: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid It's possible that a socket can come into this function in the wrong mode if there are program errors. In that case, the {\b CSocket} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCSocket \\*MERGEFORMAT}{\fldrslt pagenum}}}) calls made may throw an exception. We catch all exceptions, if necessary delete the socket object and rethrow to the caller.\par
}{{{\b Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i nPort}}  - The number of the port to bind the socket to.\par
}{{{\b Note: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid On non exceptional exit from this function, m_pService is bound to the selected service and the socket is in the listen state. \par
}\par
Definition at line 513 of file CServerConnectionEvent.cpp.\par
\par
References ConfigureSocket().}
{\xe \v ConfigureSocket\:CServerConnectionEvent}
{\xe \v CServerConnectionEvent\:ConfigureSocket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CServerConnectionEvent::ConfigureSocket (const string & {\i rSvcName}){\f2  [protected]}}
}\par
{\bkmkstart classCServerConnectionEvent_b2}
{\bkmkend classCServerConnectionEvent_b2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Utility function to configure a socket. The service name is  used to bind the socket and set it into listen mode.\par
{{{\b \par
Note: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid It's possible that a socket can come into this function in the wrong mode if there are program errors. In that case, the {\b CSocket} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCSocket \\*MERGEFORMAT}{\fldrslt pagenum}}}) calls made may throw an exception. We catch all exceptions, if necessary delete the socket object and rethrow to the caller.\par
}{{{\b Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rSvcName}}  - A service name which can either be an entry in the local system's service data base, or alternatively a numerically encoded port id.\par
}{{{\b Note: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid On non exceptional exit from this function, m_pService is bound to the selected service and the socket is in the listen state. \par
}\par
Definition at line 485 of file CServerConnectionEvent.cpp.\par
\par
References CSocket::Bind(), CSocket::Listen(), m_fDeleteSocket, and m_pService.\par
Referenced by ConfigureSocket(), and CServerConnectionEvent().}
{\xe \v DescribeSelf\:CServerConnectionEvent}
{\xe \v CServerConnectionEvent\:DescribeSelf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CServerConnectionEvent::DescribeSelf (){\f2  [virtual]}}
}\par
{\bkmkstart classCServerConnectionEvent_a14}
{\bkmkend classCServerConnectionEvent_a14}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns a string which describes this object. \par
\par
Reimplemented from {\b CFileEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFileEvent_a19 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 552 of file CServerConnectionEvent.cpp.\par
\par
References CEvent::DescribeSelf(), CSocket::getSocketFd(), CSocket::getState(), m_fDeleteSocket, m_pService, and CSocket::StateName().}
{\xe \v getSocket\:CServerConnectionEvent}
{\xe \v CServerConnectionEvent\:getSocket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CSocket}* CServerConnectionEvent::getSocket (){\f2  [inline]}}
}\par
{\bkmkstart classCServerConnectionEvent_a10}
{\bkmkend classCServerConnectionEvent_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 363 of file CServerConnectionEvent.h.\par
}
{\xe \v isDynamicSocket\:CServerConnectionEvent}
{\xe \v CServerConnectionEvent\:isDynamicSocket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CServerConnectionEvent::isDynamicSocket () const{\f2  [inline]}}
}\par
{\bkmkstart classCServerConnectionEvent_a11}
{\bkmkend classCServerConnectionEvent_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 367 of file CServerConnectionEvent.h.\par
\par
References m_fDeleteSocket.}
{\xe \v OnConnection\:CServerConnectionEvent}
{\xe \v CServerConnectionEvent\:OnConnection}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CServerConnectionEvent::OnConnection ({\b CSocket} * {\i pPeer}){\f2  [virtual]}}
}\par
{\bkmkstart classCServerConnectionEvent_a12}
{\bkmkend classCServerConnectionEvent_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
This member function is called whenever a connection is available. The default implementation rejects the connection and destroys the connection object. It's assumed that the user of this class will subclass it and override this member with code to generate an object to manage the connection. How this is done depends on the needs of the application. One typical way to do this would be to create a {\b CServerInstance} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCServerInstance \\*MERGEFORMAT}{\fldrslt pagenum}}}) derived object and enable it. This would start up a server instance in a separate thread, to handle requests in a application synchronized manner.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i pPeer}}  - pointer to dynamically created socket representing the connection peer. \par
}\par
Definition at line 445 of file CServerConnectionEvent.cpp.\par
\par
References CSocket::Shutdown().\par
Referenced by OnReadable().}
{\xe \v OnReadable\:CServerConnectionEvent}
{\xe \v CServerConnectionEvent\:OnReadable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CServerConnectionEvent::OnReadable (istream & {\i rStream}){\f2  [virtual]}}
}\par
{\bkmkstart classCServerConnectionEvent_a13}
{\bkmkend classCServerConnectionEvent_a13}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called when the service socket becomes readable. This indicates that a connection request is available. The request is serviced by an accept on the service socket and OnConnection is called to handle the actual service.  {{{\b \par
Note: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid OnReadable is called while holding the application serialization mutex. OnReadable in general need not be overridden in subclasses.\par
}{{{\b Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rStream}}  - istream on the socket... ignored. \par
}\par
Reimplemented from {\b CFileEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFileEvent_a15 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 462 of file CServerConnectionEvent.cpp.\par
\par
References CSocket::Accept(), m_pService, and OnConnection().}
{\xe \v operator=\:CServerConnectionEvent}
{\xe \v CServerConnectionEvent\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CServerConnectionEvent& CServerConnectionEvent::operator= (const CServerConnectionEvent & {\i rhs}){\f2  [private]}}
}\par
{\bkmkstart classCServerConnectionEvent_c1}
{\bkmkend classCServerConnectionEvent_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:CServerConnectionEvent}
{\xe \v CServerConnectionEvent\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CServerConnectionEvent::operator== (const CServerConnectionEvent & {\i rhs}){\f2  [private]}}
}\par
{\bkmkstart classCServerConnectionEvent_c2}
{\bkmkend classCServerConnectionEvent_c2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Protocol\:CServerConnectionEvent}
{\xe \v CServerConnectionEvent\:Protocol}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CServerConnectionEvent::Protocol (){\f2  [protected]}}
}\par
{\bkmkstart classCServerConnectionEvent_b4}
{\bkmkend classCServerConnectionEvent_b4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Determine the correct protocol id for a socket(2) call. We only support tcp as the protocol. This function encapsulates the call to getprotobyname(3), and the decode of the arguments. getprotobyname(3) is assumed to be non-reentrant/non-recursive and therefore the call to it is serialized to the application.\par
Failures are not considered possible, so are asserted against, since the only acceptable protocol is "TCP".{{{\b \par
Return values: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i int}}  - a protocol id suitable for the last parameter of the socket(2) call. \par
}\par
Definition at line 535 of file CServerConnectionEvent.cpp.\par
\par
References CApplicationSerializer::getInstance(), CThreadRecursiveMutex::Lock(), and CThreadRecursiveMutex::UnLock().}
{\xe \v setDynamic\:CServerConnectionEvent}
{\xe \v CServerConnectionEvent\:setDynamic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CServerConnectionEvent::setDynamic (bool {\i fDyn}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCServerConnectionEvent_b1}
{\bkmkend classCServerConnectionEvent_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 376 of file CServerConnectionEvent.h.\par
\par
References m_fDeleteSocket.}
{\xe \v setSocket\:CServerConnectionEvent}
{\xe \v CServerConnectionEvent\:setSocket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CServerConnectionEvent::setSocket ({\b CSocket} * {\i pSocket}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCServerConnectionEvent_b0}
{\bkmkend classCServerConnectionEvent_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 373 of file CServerConnectionEvent.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_fDeleteSocket\:CServerConnectionEvent}
{\xe \v CServerConnectionEvent\:m_fDeleteSocket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CServerConnectionEvent::m_fDeleteSocket{\f2  [private]}}
}\par
{\bkmkstart classCServerConnectionEvent_o1}
{\bkmkend classCServerConnectionEvent_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
true if destructor delete socket.\par
\par
Definition at line 327 of file CServerConnectionEvent.h.\par
\par
Referenced by ConfigureSocket(), DescribeSelf(), isDynamicSocket(), and setDynamic().}
{\xe \v m_pService\:CServerConnectionEvent}
{\xe \v CServerConnectionEvent\:m_pService}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CSocket}* CServerConnectionEvent::m_pService{\f2  [private]}}
}\par
{\bkmkstart classCServerConnectionEvent_o0}
{\bkmkend classCServerConnectionEvent_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Server listener socket.\par
\par
Definition at line 326 of file CServerConnectionEvent.h.\par
\par
Referenced by ConfigureSocket(), DescribeSelf(), OnReadable(), and ~CServerConnectionEvent().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CServerConnectionEvent.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CServerConnectionEvent.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CServerInstance  Class Reference\par \pard\plain 
{\tc\tcl2 \v CServerInstance}
{\xe \v CServerInstance}
{\bkmkstart classCServerInstance}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CServerInstance.h>}\par
Inheritance diagram for CServerInstance:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCServerInstance.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CServerInstance} ({\b CSocket} *pSocket, bool fDeleteSocket=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CServerInstance} (const char *pName, {\b CSocket} *pSocket, bool fDeleteSocket=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CServerInstance} (const string &rName, {\b CSocket} *pSocket, bool fDeleteSocket=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CServerInstance} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CSocket} * {\b getSocket} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getDeleteFlag} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b getPeername} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b getPeerPort} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnReadable} (istream &rStream)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnRequest} ({\b CSocket} *pConnection)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Shutdown} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual string {\b DescribeSelf} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSocket} ({\b CSocket} *sock)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setDelFlag} (bool flag)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CServerInstance} (const CServerInstance &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CServerInstance & {\b operator=} (const CServerInstance &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CServerInstance &rhs)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CSocket} * {\b m_pPeer}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Pointer to peer socket.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b m_fDeleteSocket}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i True if destructor deletes socket.}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
Encapsulates the funtionality of a `simple' Tcp/Ip server instance. Simpler tcp/ip server instances are connections with a client over a socket which operate in the simple::{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Accept a request from the client.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Respond to those requests mode.\par
}This class is a subclass of the {\b CFileEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFileEvent \\*MERGEFORMAT}{\fldrslt pagenum}}}) class... OnReadable is overridden by this class, the user, should in turn override this class and override {\b OnRequest}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCServerInstance_a9 \\*MERGEFORMAT}{\fldrslt pagenum}}}). {\b OnRequest}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCServerInstance_a9 \\*MERGEFORMAT}{\fldrslt pagenum}}}) entered with the application serialization mutex held, and therefore can perform any function which requires global syncrhonization. \par
\par
Definition at line 321 of file CServerInstance.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CServerInstance\:CServerInstance}
{\xe \v CServerInstance\:CServerInstance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CServerInstance::CServerInstance ({\b CSocket} * {\i pSocket}, bool {\i fDeleteSocket} = true)}
}\par
{\bkmkstart classCServerInstance_a0}
{\bkmkend classCServerInstance_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct an anonymous server instance:{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i pSocket}}  - Pointer to the socket open to the client. \par
{\b {\i fDeleteSocket}}  - true if the destructor should delete the socket. \par
}\par
Definition at line 300 of file CServerInstance.cpp.\par
}
{\xe \v CServerInstance\:CServerInstance}
{\xe \v CServerInstance\:CServerInstance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CServerInstance::CServerInstance (const char * {\i pName}, {\b CSocket} * {\i pSocket}, bool {\i fDeleteSocket} = true)}
}\par
{\bkmkstart classCServerInstance_a1}
{\bkmkend classCServerInstance_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct a server instance whose name comes from a char* string.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i pName}}  - Name to give to the instance (const char*) [in] \par
{\b {\i pSocket}}  - Socket open on peer. ({\b CSocket} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCSocket \\*MERGEFORMAT}{\fldrslt pagenum}}})* ) [in] \par
{\b {\i fDeleteSocket}}  - true to delete sock on destruct (bool) [in = true] \par
}\par
Definition at line 314 of file CServerInstance.cpp.\par
}
{\xe \v CServerInstance\:CServerInstance}
{\xe \v CServerInstance\:CServerInstance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CServerInstance::CServerInstance (const string & {\i rName}, {\b CSocket} * {\i pSocket}, bool {\i fDeleteSocket} = true)}
}\par
{\bkmkstart classCServerInstance_a2}
{\bkmkend classCServerInstance_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct a server instance whose name comes from a string& string.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rName}}  - Name to give to the instance (const string& [in]). \par
{\b {\i pSocket-}}  Socket already open on peer ({\b CSocket} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCSocket \\*MERGEFORMAT}{\fldrslt pagenum}}})* [in]). \par
{\b {\i fDeleteSocket}}  - true to delete sock on destruction. (bool [in] = true). \par
}\par
Definition at line 328 of file CServerInstance.cpp.\par
}
{\xe \v ~CServerInstance\:CServerInstance}
{\xe \v CServerInstance\:~CServerInstance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CServerInstance::~CServerInstance ()}
}\par
{\bkmkstart classCServerInstance_a3}
{\bkmkend classCServerInstance_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
The destructor just deletes m_pPeer if m_fDeleteSocket is true. \par
\par
Definition at line 338 of file CServerInstance.cpp.\par
\par
References CSocket::Connected, CSocket::getState(), m_pPeer, and CSocket::Shutdown().}
{\xe \v CServerInstance\:CServerInstance}
{\xe \v CServerInstance\:CServerInstance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CServerInstance::CServerInstance (const CServerInstance & {\i rhs}){\f2  [private]}}
}\par
{\bkmkstart classCServerInstance_c0}
{\bkmkend classCServerInstance_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v DescribeSelf\:CServerInstance}
{\xe \v CServerInstance\:DescribeSelf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CServerInstance::DescribeSelf (){\f2  [virtual]}}
}\par
{\bkmkstart classCServerInstance_a11}
{\bkmkend classCServerInstance_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Describe this textually. \par
\par
Reimplemented from {\b CFileEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFileEvent_a19 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 447 of file CServerInstance.cpp.\par
\par
References CEvent::DescribeSelf(), CSocket::getSocketFd(), CSocket::getState(), m_fDeleteSocket, m_pPeer, and CSocket::StateName().}
{\xe \v getDeleteFlag\:CServerInstance}
{\xe \v CServerInstance\:getDeleteFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CServerInstance::getDeleteFlag () const{\f2  [inline]}}
}\par
{\bkmkstart classCServerInstance_a5}
{\bkmkend classCServerInstance_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 349 of file CServerInstance.h.\par
\par
References m_fDeleteSocket.}
{\xe \v getPeername\:CServerInstance}
{\xe \v CServerInstance\:getPeername}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CServerInstance::getPeername () const}
}\par
{\bkmkstart classCServerInstance_a6}
{\bkmkend classCServerInstance_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Determines the node to which this socket is connected.{{{\b \par
Return values: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i string&}}  The name of the peer to which this socket is connected. if the peer has a dns entry the name of the peer is returned, otherwise the IP address is converted to dotted string form and returned. See {\b CSocket::getPeer}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCSocket_a13 \\*MERGEFORMAT}{\fldrslt pagenum}}})\par
}{{{\b Note: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Can throw any exception thrown by {\b CSocket::getPeer}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCSocket_a13 \\*MERGEFORMAT}{\fldrslt pagenum}}}) \par
}\par
Definition at line 361 of file CServerInstance.cpp.\par
\par
References CSocket::getPeer(), and m_pPeer.}
{\xe \v getPeerPort\:CServerInstance}
{\xe \v CServerInstance\:getPeerPort}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short CServerInstance::getPeerPort () const}
}\par
{\bkmkstart classCServerInstance_a7}
{\bkmkend classCServerInstance_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Determines the port to which the socket is connected on the peer.{{{\b \par
Return values: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i int}}  The port number assigned to this socket.\par
}{{{\b Note: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid Can throw any exception thrown by {\b CSocket::getPeer}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCSocket_a13 \\*MERGEFORMAT}{\fldrslt pagenum}}}) \par
}\par
Definition at line 380 of file CServerInstance.cpp.\par
\par
References CSocket::getPeer(), and m_pPeer.}
{\xe \v getSocket\:CServerInstance}
{\xe \v CServerInstance\:getSocket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CSocket}* CServerInstance::getSocket (){\f2  [inline]}}
}\par
{\bkmkstart classCServerInstance_a4}
{\bkmkend classCServerInstance_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 346 of file CServerInstance.h.\par
}
{\xe \v OnReadable\:CServerInstance}
{\xe \v CServerInstance\:OnReadable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CServerInstance::OnReadable (istream & {\i rInput}){\f2  [virtual]}}
}\par
{\bkmkstart classCServerInstance_a8}
{\bkmkend classCServerInstance_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called when the socket becomes readable. We get the socket and pass that to OnRequest which is what the user is supposed to override and embed application functionality in.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rInput}}  - Stream open on the socket (istream& [in-out])\par
}{{{\b Note: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid DO NOT OVERRIDE THIS \par
}\par
Reimplemented from {\b CFileEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFileEvent_a15 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 402 of file CServerInstance.cpp.\par
\par
References m_pPeer, OnRequest(), and Shutdown().}
{\xe \v OnRequest\:CServerInstance}
{\xe \v CServerInstance\:OnRequest}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CServerInstance::OnRequest ({\b CSocket} * {\i pConnection}){\f2  [virtual]}}
}\par
{\bkmkstart classCServerInstance_a9}
{\bkmkend classCServerInstance_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called when the client has a request of the server. The application has overridden this member in its derived class.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i pConnection}}  - Socket open to the peer ({\b CSocket} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCSocket \\*MERGEFORMAT}{\fldrslt pagenum}}})* [in-out]). \par
}\par
Definition at line 418 of file CServerInstance.cpp.\par
\par
Referenced by OnReadable().}
{\xe \v operator=\:CServerInstance}
{\xe \v CServerInstance\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CServerInstance& CServerInstance::operator= (const CServerInstance & {\i rhs}){\f2  [private]}}
}\par
{\bkmkstart classCServerInstance_c1}
{\bkmkend classCServerInstance_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:CServerInstance}
{\xe \v CServerInstance\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CServerInstance::operator== (const CServerInstance & {\i rhs}){\f2  [private]}}
}\par
{\bkmkstart classCServerInstance_c2}
{\bkmkend classCServerInstance_c2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v setDelFlag\:CServerInstance}
{\xe \v CServerInstance\:setDelFlag}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CServerInstance::setDelFlag (bool {\i flag}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCServerInstance_b1}
{\bkmkend classCServerInstance_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 361 of file CServerInstance.h.\par
\par
References m_fDeleteSocket.}
{\xe \v setSocket\:CServerInstance}
{\xe \v CServerInstance\:setSocket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CServerInstance::setSocket ({\b CSocket} * {\i sock}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCServerInstance_b0}
{\bkmkend classCServerInstance_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 358 of file CServerInstance.h.\par
}
{\xe \v Shutdown\:CServerInstance}
{\xe \v CServerInstance\:Shutdown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CServerInstance::Shutdown ()}
}\par
{\bkmkstart classCServerInstance_a10}
{\bkmkend classCServerInstance_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called when we want to shutdown the server we must:{
\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
1.\tab Remove all fd monitoring.\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
2.\tab Clear the enable flag.\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
3.\tab Shutdown the socket.\par
}It's someone else's responsibility to reap these threads and delete the objects. \par
\par
Definition at line 434 of file CServerInstance.cpp.\par
\par
References CSocket::Connected, CSocket::getState(), m_pPeer, CFileEvent::MonitorReadable(), CEvent::setEnable(), and CSocket::Shutdown().\par
Referenced by OnReadable().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_fDeleteSocket\:CServerInstance}
{\xe \v CServerInstance\:m_fDeleteSocket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CServerInstance::m_fDeleteSocket{\f2  [private]}}
}\par
{\bkmkstart classCServerInstance_o1}
{\bkmkend classCServerInstance_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
True if destructor deletes socket.\par
\par
Definition at line 325 of file CServerInstance.h.\par
\par
Referenced by DescribeSelf(), getDeleteFlag(), and setDelFlag().}
{\xe \v m_pPeer\:CServerInstance}
{\xe \v CServerInstance\:m_pPeer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CSocket}* CServerInstance::m_pPeer{\f2  [private]}}
}\par
{\bkmkstart classCServerInstance_o0}
{\bkmkend classCServerInstance_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Pointer to peer socket.\par
\par
Definition at line 324 of file CServerInstance.h.\par
\par
Referenced by DescribeSelf(), getPeername(), getPeerPort(), OnReadable(), Shutdown(), and ~CServerInstance().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CServerInstance.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CServerInstance.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CServerMonitor  Class Reference\par \pard\plain 
{\tc\tcl2 \v CServerMonitor}
{\xe \v CServerMonitor}
{\bkmkstart classCServerMonitor}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \\class: CServerMonitor \\file: {\b CServerMonitor.h}. 
\par
{\f2 #include <CServerMonitor.h>}\par
Inheritance diagram for CServerMonitor:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCServerMonitor.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CServerMonitor} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Associated Socket.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CServerMonitor} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CServerMonitor} ({\b CSocket} &am_Socket)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CServerMonitor} (const CServerMonitor &aCServerMonitor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CServerMonitor & {\b operator=} (const CServerMonitor &aCServerMonitor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CServerMonitor &aCServerMonitor) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CSocket} & {\b getm_Socket} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b operator()} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual string {\b DescribeSelf} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setm_Socket} (const {\b CSocket} &am_Socket)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CSocket} & {\b m_Socket}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \\class: CServerMonitor \\file: {\b CServerMonitor.h}.\par
\par
Monitors a TCP/IP socket for connection requests. When a connection request is available, returns. Note that it is up to the reactor to actually accept the connection request. ServerMonitors can have monitors which are descended from CFdMoniitors \par
\par
Definition at line 312 of file CServerMonitor.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CServerMonitor\:CServerMonitor}
{\xe \v CServerMonitor\:CServerMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CServerMonitor::CServerMonitor ()}
}\par
{\bkmkstart classCServerMonitor_a0}
{\bkmkend classCServerMonitor_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Associated Socket.\par
\par
Definition at line 301 of file CServerMonitor.cpp.\par
}
{\xe \v ~CServerMonitor\:CServerMonitor}
{\xe \v CServerMonitor\:~CServerMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CServerMonitor::~CServerMonitor ()}
}\par
{\bkmkstart classCServerMonitor_a1}
{\bkmkend classCServerMonitor_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 312 of file CServerMonitor.cpp.\par
}
{\xe \v CServerMonitor\:CServerMonitor}
{\xe \v CServerMonitor\:CServerMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CServerMonitor::CServerMonitor ({\b CSocket} & {\i am_Socket})}
}\par
{\bkmkstart classCServerMonitor_a2}
{\bkmkend classCServerMonitor_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 319 of file CServerMonitor.cpp.\par
\par
References m_Socket.}
{\xe \v CServerMonitor\:CServerMonitor}
{\xe \v CServerMonitor\:CServerMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CServerMonitor::CServerMonitor (const CServerMonitor & {\i aCServerMonitor})}
}\par
{\bkmkstart classCServerMonitor_a3}
{\bkmkend classCServerMonitor_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 329 of file CServerMonitor.cpp.\par
\par
References m_Socket.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v DescribeSelf\:CServerMonitor}
{\xe \v CServerMonitor\:DescribeSelf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CServerMonitor::DescribeSelf (){\f2  [virtual]}}
}\par
{\bkmkstart classCServerMonitor_a8}
{\bkmkend classCServerMonitor_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: selector\par
Purpose:\par
Describes self as a file descriptor which has a socket that has a state. \par
\par
Reimplemented from {\b CFdMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFdMonitor_a12 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 393 of file CServerMonitor.cpp.\par
}
{\xe \v getm_Socket\:CServerMonitor}
{\xe \v CServerMonitor\:getm_Socket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CSocket}& CServerMonitor::getm_Socket () const{\f2  [inline]}}
}\par
{\bkmkstart classCServerMonitor_a6}
{\bkmkend classCServerMonitor_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 360 of file CServerMonitor.h.\par
}
{\xe \v operator()\:CServerMonitor}
{\xe \v CServerMonitor\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CServerMonitor::operator() (){\f2  [virtual]}}
}\par
{\bkmkstart classCServerMonitor_a7}
{\bkmkend classCServerMonitor_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type:\par
Purpose: \par
\par
Reimplemented from {\b CFdMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFdMonitor_a11 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 376 of file CServerMonitor.cpp.\par
}
{\xe \v operator=\:CServerMonitor}
{\xe \v CServerMonitor\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CServerMonitor & CServerMonitor::operator= (const CServerMonitor & {\i aCServerMonitor})}
}\par
{\bkmkstart classCServerMonitor_a4}
{\bkmkend classCServerMonitor_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 339 of file CServerMonitor.cpp.\par
\par
References m_Socket, and CFdMonitor::operator=().}
{\xe \v operator==\:CServerMonitor}
{\xe \v CServerMonitor\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CServerMonitor::operator== (const CServerMonitor & {\i aCServerMonitor}) const}
}\par
{\bkmkstart classCServerMonitor_a5}
{\bkmkend classCServerMonitor_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 349 of file CServerMonitor.cpp.\par
\par
References m_Socket, and CFdMonitor::operator==().}
{\xe \v setm_Socket\:CServerMonitor}
{\xe \v CServerMonitor\:setm_Socket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CServerMonitor::setm_Socket (const {\b CSocket} & {\i am_Socket}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCServerMonitor_b0}
{\bkmkend classCServerMonitor_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 369 of file CServerMonitor.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_Socket\:CServerMonitor}
{\xe \v CServerMonitor\:m_Socket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CSocket}& CServerMonitor::m_Socket{\f2  [private]}}
}\par
{\bkmkstart classCServerMonitor_o0}
{\bkmkend classCServerMonitor_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 317 of file CServerMonitor.h.\par
\par
Referenced by CServerMonitor(), operator=(), and operator==().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CServerMonitor.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CServerMonitor.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Shell  Class Reference\par \pard\plain 
{\tc\tcl2 \v Shell}
{\xe \v Shell}
{\bkmkstart classShell}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMShell.h>}\par
Inheritance diagram for Shell:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classShell.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Shell} (String shellname, WidgetClass shelltype, {\b XMWidget} *parent, ArgList args=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~Shell} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AllowResize} (Boolean allow)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Boolean {\b IsResizeAllowed} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetGeometry} (String newg)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b GetGeometry} (String geom)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetSaveUnder} (Boolean newstate)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Boolean {\b GetSaveUnder} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Realize} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Manage} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnManage} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMCallback}< Shell > {\b Popdown}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMCallback}< Shell > {\b Popup}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b PopupCb} ({\b XMWidget} *shell, XtPointer user_d, XtPointer call_d)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b PopdnCb} ({\b XMWidget} *shell, XtPointer user_d, XtPointer call_d)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v Shell\:Shell}
{\xe \v Shell\:Shell}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Shell::Shell (String {\i shellname}, WidgetClass {\i shelltype}, {\b XMWidget} * {\i parent}, ArgList {\i args} = NULL, Cardinal {\i num_args} = 0)}
}\par
{\bkmkstart classShell_a0}
{\bkmkend classShell_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 323 of file XMShell.cpp.\par
\par
References XMWidget::getid(), XMWidget::id, PopdnCb(), Popdown, Popup, PopupCb(), and XMCallback< Shell >::Register().}
{\xe \v ~Shell\:Shell}
{\xe \v Shell\:~Shell}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Shell::~Shell ()}
}\par
{\bkmkstart classShell_a1}
{\bkmkend classShell_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 385 of file XMShell.cpp.\par
\par
References Popdown, Popup, UnManage(), and XMCallback< Shell >::UnRegister().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AllowResize\:Shell}
{\xe \v Shell\:AllowResize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Shell::AllowResize (Boolean {\i allow}){\f2  [inline]}}
}\par
{\bkmkstart classShell_a2}
{\bkmkend classShell_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 311 of file XMShell.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v GetGeometry\:Shell}
{\xe \v Shell\:GetGeometry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Shell::GetGeometry (String {\i geom}){\f2  [inline]}}
}\par
{\bkmkstart classShell_a5}
{\bkmkend classShell_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 322 of file XMShell.h.\par
\par
References XMWidget::GetAttribute().}
{\xe \v GetSaveUnder\:Shell}
{\xe \v Shell\:GetSaveUnder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Boolean Shell::GetSaveUnder (){\f2  [inline]}}
}\par
{\bkmkstart classShell_a7}
{\bkmkend classShell_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 327 of file XMShell.h.\par
\par
References XMWidget::GetAttribute().}
{\xe \v IsResizeAllowed\:Shell}
{\xe \v Shell\:IsResizeAllowed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Boolean Shell::IsResizeAllowed (){\f2  [inline]}}
}\par
{\bkmkstart classShell_a3}
{\bkmkend classShell_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 313 of file XMShell.h.\par
\par
References XMWidget::GetAttribute().}
{\xe \v Manage\:Shell}
{\xe \v Shell\:Manage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Shell::Manage (){\f2  [inline]}}
}\par
{\bkmkstart classShell_a9}
{\bkmkend classShell_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Reimplemented from {\b XMWidget} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classXMWidget_a16 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 339 of file XMShell.h.\par
\par
References XMWidget::id.\par
Referenced by Realize().}
{\xe \v PopdnCb\:Shell}
{\xe \v Shell\:PopdnCb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Shell::PopdnCb ({\b XMWidget} * {\i shell}, XtPointer {\i user_d}, XtPointer {\i call_d}){\f2  [private, virtual]}}
}\par
{\bkmkstart classShell_c1}
{\bkmkend classShell_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 402 of file XMShell.cpp.\par
\par
Referenced by Shell().}
{\xe \v PopupCb\:Shell}
{\xe \v Shell\:PopupCb}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Shell::PopupCb ({\b XMWidget} * {\i shell}, XtPointer {\i user_d}, XtPointer {\i call_d}){\f2  [private, virtual]}}
}\par
{\bkmkstart classShell_c0}
{\bkmkend classShell_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 399 of file XMShell.cpp.\par
\par
Referenced by Shell().}
{\xe \v Realize\:Shell}
{\xe \v Shell\:Realize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Shell::Realize (){\f2  [inline]}}
}\par
{\bkmkstart classShell_a8}
{\bkmkend classShell_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Reimplemented from {\b XMWidget} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classXMWidget_a18 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 334 of file XMShell.h.\par
\par
References XMWidget::id, and Manage().}
{\xe \v SetGeometry\:Shell}
{\xe \v Shell\:SetGeometry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Shell::SetGeometry (String {\i newg}){\f2  [inline]}}
}\par
{\bkmkstart classShell_a4}
{\bkmkend classShell_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 320 of file XMShell.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v SetSaveUnder\:Shell}
{\xe \v Shell\:SetSaveUnder}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Shell::SetSaveUnder (Boolean {\i newstate}){\f2  [inline]}}
}\par
{\bkmkstart classShell_a6}
{\bkmkend classShell_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 325 of file XMShell.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v UnManage\:Shell}
{\xe \v Shell\:UnManage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void Shell::UnManage (){\f2  [inline]}}
}\par
{\bkmkstart classShell_a10}
{\bkmkend classShell_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Reimplemented from {\b XMWidget} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classXMWidget_a17 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 340 of file XMShell.h.\par
\par
References XMWidget::id.\par
Referenced by ~Shell().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v Popdown\:Shell}
{\xe \v Shell\:Popdown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMCallback}<Shell> Shell::Popdown{\f2  [protected]}}
}\par
{\bkmkstart classShell_n0}
{\bkmkend classShell_n0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 342 of file XMShell.h.\par
\par
Referenced by Shell(), and ~Shell().}
{\xe \v Popup\:Shell}
{\xe \v Shell\:Popup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMCallback}<Shell> Shell::Popup{\f2  [protected]}}
}\par
{\bkmkstart classShell_n1}
{\bkmkend classShell_n1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 343 of file XMShell.h.\par
\par
Referenced by Shell(), and ~Shell().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMShell.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMShell.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CShutdownBinding  Class Reference\par \pard\plain 
{\tc\tcl2 \v CShutdownBinding}
{\xe \v CShutdownBinding}
{\bkmkstart classCShutdownBinding}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CShutdownBinding} ({\b CTCLInterpreter} &rInterp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b operator()} ({\b CTypeFreeBinding} *pBinding)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLInterpreter} & {\b m_rInterp}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CShutdownBinding\:CShutdownBinding}
{\xe \v CShutdownBinding\:CShutdownBinding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CShutdownBinding::CShutdownBinding ({\b CTCLInterpreter} & {\i rInterp}){\f2  [inline]}}
}\par
{\bkmkstart classCShutdownBinding_a0}
{\bkmkend classCShutdownBinding_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 329 of file CConfigurationManager.cpp.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator()\:CShutdownBinding}
{\xe \v CShutdownBinding\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CShutdownBinding::operator() ({\b CTypeFreeBinding} * {\i pBinding}){\f2  [inline]}}
}\par
{\bkmkstart classCShutdownBinding_a1}
{\bkmkend classCShutdownBinding_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 330 of file CConfigurationManager.cpp.\par
\par
References CTypeFreeBinding::ShutdownBindings().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_rInterp\:CShutdownBinding}
{\xe \v CShutdownBinding\:m_rInterp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CTCLInterpreter}& CShutdownBinding::m_rInterp{\f2  [private]}}
}\par
{\bkmkstart classCShutdownBinding_o0}
{\bkmkend classCShutdownBinding_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 327 of file CConfigurationManager.cpp.\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CConfigurationManager.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CSocket  Class Reference\par \pard\plain 
{\tc\tcl2 \v CSocket}
{\xe \v CSocket}
{\bkmkstart classCSocket}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CSocket.h>}\par
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b State} \{ {\b Disconnected}, 
{\b Bound}, 
{\b Listening}, 
{\b Connected}
 \}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Captures the state of the socket. See general remarks for more info.}\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CSocket} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CSocket} (int am_Fd, {\b CSocket::State} am_State)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CSocket} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getSocketFd} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get accessor function socket file descriptor.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CSocket::State} {\b getState} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Get accessor function for socket state.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Connect} (const string &host, const string &service)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Connect} (unsigned long int IpAddress, unsigned short service)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Bind} (const string &service)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Listen} (unsigned int nBacklog=5)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CSocket * {\b Accept} (string &client)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Shutdown} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Read} (void *pBuffer, size_t nBytes)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Write} (void *pBuffer, size_t nBytes)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getPeer} (unsigned short &port, string &peer)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b OOBInline} (bool {\b State}=TRUE)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isOOBInline} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRcvLowWaterMark} (size_t nBytes)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b getRcvLowWaterMark} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSndLowWaterMark} (size_t nBytes)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b getSndLowWaterMark} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRcvTimeout} (unsigned int nMs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getRcvTimeout} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSndTimeout} (unsigned int nMs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getSndTimeout} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Debug} (bool fState=TRUE)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isDebug} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetNotRoutable} (bool fRoutable=TRUE)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b isNotRoutable} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSndBufSize} (size_t nBufferSize)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b getSndBufSize} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRcvBufSize} (size_t nBytes)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
size_t {\b getRcvBufSize} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLinger} (bool lOn, int nLingerSeconds)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b getLinger} (bool &isLingering, int &nLingerSeconds)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b StateName} ({\b CSocket::State} state)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSocketFd} (const int am_Fd)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set accessor function for Socket file descriptor.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setState} (const {\b CSocket::State} am_State)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set accessor function for current socket state.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned short {\b Service} (const string &rService)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b AddressToHostString} (in_addr peer)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b OpenSocket} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b StockStateMap} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CSocket} (const CSocket &aCSocket)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Copy Constructor forbidden.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CSocket & {\b operator=} (const CSocket &aCSocket)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Assignment Operator Forbidden.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CSocket &aCSocket) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Equality Operator Forbidden.}\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b m_Fd}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Socket.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CSocket::State} {\b m_State}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i State of socket.}\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
map< {\b CSocket::State}, string > {\b m_StateNames}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i State name lookup tbl.}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
Encapsulates a generalized TCP/IP SOCK_STREAM socket.  Note that TCP/IP Sockets can come in two flavors: Clients and Servers. Clients must perform a connect, while servers perform a bind, listen and then serveral accepts to create 'server instances'. The state of a socket is maintained in the m_State variable and is from the enumerator: {\b CSocket::State} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCSocket_s4 \\*MERGEFORMAT}{\fldrslt pagenum}}})\par
{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Disconnected: The socket is not connected to anything.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Bound: The socket is a server socket which is not connected, but has been bound to a service port.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Listening: The socket is a server port which is listening and can therefore accept connections\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Connected The socket is either a client or a  server instance and is connected to it's counterpart. \par
}\par
Definition at line 338 of file CSocket.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v State\:CSocket}
{\xe \v CSocket\:State}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum CSocket::State}
}\par
{\bkmkstart classCSocket_s4}
{\bkmkend classCSocket_s4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Captures the state of the socket. See general remarks for more info.\par
{{{\b \par
Enumeration values:}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v Disconnected\:CSocket}
{\xe \v CSocket\:Disconnected}
{\b {\i {\i Disconnected}{\bkmkstart classCSocket_s4s0}
{\bkmkend classCSocket_s4s0}
}}  \par
{\xe \v Bound\:CSocket}
{\xe \v CSocket\:Bound}
{\b {\i {\i Bound}{\bkmkstart classCSocket_s4s1}
{\bkmkend classCSocket_s4s1}
}}  \par
{\xe \v Listening\:CSocket}
{\xe \v CSocket\:Listening}
{\b {\i {\i Listening}{\bkmkstart classCSocket_s4s2}
{\bkmkend classCSocket_s4s2}
}}  \par
{\xe \v Connected\:CSocket}
{\xe \v CSocket\:Connected}
{\b {\i {\i Connected}{\bkmkstart classCSocket_s4s3}
{\bkmkend classCSocket_s4s3}
}}  \par
}
\par
Definition at line 343 of file CSocket.h.\par
\par
Referenced by CSocket(), CTCPBadSocketState::CTCPBadSocketState(), CTCPBadSocketState::getBadState(), getState(), OOBInline(), CTCPBadSocketState::setBadState(), setState(), and StateName().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CSocket\:CSocket}
{\xe \v CSocket\:CSocket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CSocket::CSocket ()}
}\par
{\bkmkstart classCSocket_a0}
{\bkmkend classCSocket_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
The default constructor initializes the fd to an illegal value and sets the state to Disconnected.  The body of the constructor attempts to set the m_Fd member via a call to  socket(2) to create an INET domain SOCK_STREAM, protocl tcp.\par
It is up to the user to call Connect or alternatively set up the socket as a server by binding and listening.\par
Exceptions:\par
{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) if getprotoent for tcp fails or if the socket call itself fails. \par
}\par
Definition at line 365 of file CSocket.cpp.\par
\par
References OpenSocket().\par
Referenced by Accept().}
{\xe \v CSocket\:CSocket}
{\xe \v CSocket\:CSocket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CSocket::CSocket (int {\i am_Fd}, {\b CSocket::State} {\i am_State})}
}\par
{\bkmkstart classCSocket_a1}
{\bkmkend classCSocket_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
This parameterized constructor is intended to allow a program which already has created a socket in some arbitrary state to wrap it inside a CSocket object. It must be used with care.. in the sense that the am_State parameter must match the actual socket state.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i am_Fd}}  The file descriptor already open on a socket. \par
{\b {\i am_State}}  The current state of the socket am_Fd \par
}\par
Definition at line 398 of file CSocket.cpp.\par
\par
References State, and StockStateMap().}
{\xe \v ~CSocket\:CSocket}
{\xe \v CSocket\:~CSocket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CSocket::~CSocket (){\f2  [virtual]}}
}\par
{\bkmkstart classCSocket_a2}
{\bkmkend classCSocket_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Destructor action depends on the state: sockets which are Connected are shutdown and then closed. Sockets which are in other states are just closed if the fd > 0. \par
\par
Definition at line 378 of file CSocket.cpp.\par
}
{\xe \v CSocket\:CSocket}
{\xe \v CSocket\:CSocket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CSocket::CSocket (const CSocket & {\i aCSocket}){\f2  [private]}}
}\par
{\bkmkstart classCSocket_c0}
{\bkmkend classCSocket_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Copy Constructor forbidden.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Accept\:CSocket}
{\xe \v CSocket\:Accept}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CSocket * CSocket::Accept (string & {\i client})}
}\par
{\bkmkstart classCSocket_a9}
{\bkmkend classCSocket_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
This member function can be called on  a server socket. The calling thread is blocked until a connection request is received. At that time, the connection is accepted (granted), and a new CSocket is created in the Connected state. The new CSocket represents a Server Instance socket, communication along that socket can take place immediately and will represent communication with the client.\par
Exceptions which can be thrown:\par
{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CTCPBadSocketState} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPBadSocketState \\*MERGEFORMAT}{\fldrslt pagenum}}}) m_State != Listening\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) accept(2) call failed.\par
}Side effects:\par
The client parameter is  written with a string representing the hostname of the client or the IP address if the hostname can not be determined.\par
The socket created is created via new, therefore  it is the responsibility of the caller to delete it.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i client}}  Recieves the IP information of the connecting host. Where possible, this is the hostname. Where not, a dotted IP address. \par
}\par
Definition at line 659 of file CSocket.cpp.\par
\par
References AddressToHostString(), Connected, CSocket(), Listening, m_Fd, and m_State.\par
Referenced by CServerConnectionEvent::OnReadable().}
{\xe \v AddressToHostString\:CSocket}
{\xe \v CSocket\:AddressToHostString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CSocket::AddressToHostString (in_addr {\i peer}){\f2  [protected]}}
}\par
{\bkmkstart classCSocket_b3}
{\bkmkend classCSocket_b3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Purpose: Given an IP address in in_addr format, returns a string describing the address. First gethostbyaddr(3) is used to attempt to get the primary DNS name of the address. If this fails, then inet_ntoa(3) is called to get a dotted string. Note that this entire function must run syncrhonized to the global application mutex since the (3) network database calls are assumed to be nonthreadsafe.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i peer}}  - The network address of a host in in_addr, network byte order form. \par
}\par
Definition at line 1503 of file CSocket.cpp.\par
\par
References CApplicationSerializer::getInstance(), CThreadRecursiveMutex::Lock(), and CThreadRecursiveMutex::UnLock().\par
Referenced by Accept(), and getPeer().}
{\xe \v Bind\:CSocket}
{\xe \v CSocket\:Bind}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CSocket::Bind (const string & {\i service})}
}\par
{\bkmkstart classCSocket_a7}
{\bkmkend classCSocket_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Indicates that the socket will be used as a server listener socket, and binds it to a service port. The service can be provided either as a numerical string or as a string translated via getservbyname().\par
The following exceptions can be thrown:\par
{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CTCPBadSocketState} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPBadSocketState \\*MERGEFORMAT}{\fldrslt pagenum}}}) m_State != Disconnected\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CTCPNoSuchService} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPNoSuchService \\*MERGEFORMAT}{\fldrslt pagenum}}}) Service could not be determined.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) bind(2) failed.\par
}On success, m_State = Bound \par
\par
Definition at line 562 of file CSocket.cpp.\par
\par
References Bound, Disconnected, m_Fd, m_State, and Service().\par
Referenced by CServerConnectionEvent::ConfigureSocket().}
{\xe \v Connect\:CSocket}
{\xe \v CSocket\:Connect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CSocket::Connect (unsigned long int {\i IpAddress}, unsigned short {\i service})}
}\par
{\bkmkstart classCSocket_a6}
{\bkmkend classCSocket_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Connects a socket as a client given numerical host, and port numbers in  host byte order. For the host that means that an ip address of form:\par
aa.bb.cc.dd is stored Hi->Low as aabbccdd in a longword.\par
See {\b Connect}(const string&host, const string& service) ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCSocket_a5 \\*MERGEFORMAT}{\fldrslt pagenum}}}) for more information.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i IpAddress}}  The numerical ip address of the server in host byte order. \par
{\b {\i service}}  The port number of the service. \par
}\par
Definition at line 495 of file CSocket.cpp.\par
\par
References Connected, Disconnected, CApplicationSerializer::getInstance(), CThreadRecursiveMutex::Lock(), m_Fd, m_State, and CThreadRecursiveMutex::UnLock().}
{\xe \v Connect\:CSocket}
{\xe \v CSocket\:Connect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CSocket::Connect (const string & {\i host}, const string & {\i service})}
}\par
{\bkmkstart classCSocket_a5}
{\bkmkend classCSocket_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Connection Control\par
Indicates that the socket will be used as a client socket and attempts to connect it to a server.  The address of the server can be passed in either in IP address or IP name textual format. Similarly, the port can be passed in as a textual port name (in /etc/services) or a port number.\par
The action of this function is to convert (if possible) the Host and service  into numeric equivalents and call the overloaded Connect(int IpAddress, int service)\par
Exceptions which can be thrown:\par
{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CTCPBadSocketState} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPBadSocketState \\*MERGEFORMAT}{\fldrslt pagenum}}}) -- m_State was not Disconnected\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CTCPNoSuchHost} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPNoSuchHost \\*MERGEFORMAT}{\fldrslt pagenum}}}) - Host not in DNS or nonexistent.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CTCPNoSuchService} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPNoSuchService \\*MERGEFORMAT}{\fldrslt pagenum}}}) - Named service does not translate.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CTCPConnectionFailed} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPConnectionFailed \\*MERGEFORMAT}{\fldrslt pagenum}}})- Connection refused by remote host (from Connect(int IpAddress, int service).\par
}{{{\b Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i host}}  Specifies the system to connect to. This can be either a DNS textual name or a string in dotted IP address format. \par
{\b {\i service}}  Specifies a service offered by the host. This can be either a service name or the textual equivalent of a service number.\par
}On Success the socket state is set to Connected. \par
\par
Definition at line 443 of file CSocket.cpp.\par
\par
References Disconnected, CApplicationSerializer::getInstance(), CThreadRecursiveMutex::Lock(), m_State, Service(), and CThreadRecursiveMutex::UnLock().\par
Referenced by CLogger::Log(), and CAlarmLogger::Log().}
{\xe \v Debug\:CSocket}
{\xe \v CSocket\:Debug}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CSocket::Debug (bool {\i fState} = TRUE)}
}\par
{\bkmkstart classCSocket_a24}
{\bkmkend classCSocket_a24}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Purpose:\par
Attempts to turn on Socket debugging. To support this. The user must have effective UID = 0. .\par
Throws:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) if an error was returned from setsockopt(2) At present we don't know of systems which don't implement this so all errors will throw.\par
}{{{\b Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i fState}}  [TRUE] Desired state of debugging. TRUE will cause debugging to be turned on. FALSE turned off. \par
}\par
Definition at line 1193 of file CSocket.cpp.\par
\par
References m_Fd, and TRUE.}
{\xe \v getLinger\:CSocket}
{\xe \v CSocket\:getLinger}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CSocket::getLinger (bool & {\i isLingering}, int & {\i nLingerSeconds})}
}\par
{\bkmkstart classCSocket_a33}
{\bkmkend classCSocket_a33}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Purpose:\par
Retrieve the linger parameters.\par
Throws:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) if the setsockopt(2) call failed.\par
}{{{\b Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i isLingering}}  [out] Receives the value of the linger state:{\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
TRUE linger is enabled.\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
FALSE linger is not enabled. \par
}}{{{\b Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i nLingerSeconds}}  [out] Receives the value of the linger timeout. This only has meaning in the event that isLingering == TRUE. \par
}\par
Definition at line 1441 of file CSocket.cpp.\par
\par
References m_Fd.}
{\xe \v getPeer\:CSocket}
{\xe \v CSocket\:getPeer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CSocket::getPeer (unsigned short & {\i port}, string & {\i peer})}
}\par
{\bkmkstart classCSocket_a13}
{\bkmkend classCSocket_a13}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Purpose:\par
Returns information about who a socket is connected to. If the socket is not connected, {\b CTCPBadSocketState} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPBadSocketState \\*MERGEFORMAT}{\fldrslt pagenum}}}) is thrown. If possible, the peername parameter is returned as a string containing the DNS name of the peer. If the DNS lookup fails, the IP address is converted into dotted form.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i port}}  The number of the port to which the socket is connected. \par
{\b {\i peer}}  The peer as either a DNS hostname or a dotted IP address.\par
}Throws:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CTCPBadSocketState} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPBadSocketState \\*MERGEFORMAT}{\fldrslt pagenum}}}) if m_State != Connected\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) if getpeeername(2) failed. \par
}\par
Definition at line 870 of file CSocket.cpp.\par
\par
References AddressToHostString(), Connected, m_Fd, and m_State.\par
Referenced by CServerInstance::getPeername(), and CServerInstance::getPeerPort().}
{\xe \v getRcvBufSize\:CSocket}
{\xe \v CSocket\:getRcvBufSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t CSocket::getRcvBufSize ()}
}\par
{\bkmkstart classCSocket_a31}
{\bkmkend classCSocket_a31}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Purpose:\par
Returns the maximum number of bytes which can be  recieved in a single read(2) call.\par
Throws:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) if getsockopt(2) fails. \par
}\par
Definition at line 1375 of file CSocket.cpp.\par
\par
References m_Fd.}
{\xe \v getRcvLowWaterMark\:CSocket}
{\xe \v CSocket\:getRcvLowWaterMark}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t CSocket::getRcvLowWaterMark ()}
}\par
{\bkmkstart classCSocket_a17}
{\bkmkend classCSocket_a17}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns the size of the current receive low water mark. See setRcvLowWaterMark for information about what this parameter does. Note that the value returned is inquired from the socket rather than stored in internal state.\par
Throws:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) if an error from getsockopt is detected. \par
}\par
Definition at line 997 of file CSocket.cpp.\par
\par
References m_Fd.}
{\xe \v getRcvTimeout\:CSocket}
{\xe \v CSocket\:getRcvTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int CSocket::getRcvTimeout ()}
}\par
{\bkmkstart classCSocket_a21}
{\bkmkend classCSocket_a21}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Purpose:\par
Retrieve the protocol receive timeout. The time out is returned as an integer number of milliseconds.\par
Throws:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) if getsockopt(3) returns an error. \par
}\par
Definition at line 1098 of file CSocket.cpp.\par
\par
References m_Fd.}
{\xe \v getSndBufSize\:CSocket}
{\xe \v CSocket\:getSndBufSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t CSocket::getSndBufSize ()}
}\par
{\bkmkstart classCSocket_a29}
{\bkmkend classCSocket_a29}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Purpose:\par
Returns the number of bytes that can be written in a single write(2) call.\par
Throws:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) if getsockopt(2) fails. \par
}\par
Definition at line 1326 of file CSocket.cpp.\par
\par
References m_Fd.}
{\xe \v getSndLowWaterMark\:CSocket}
{\xe \v CSocket\:getSndLowWaterMark}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
size_t CSocket::getSndLowWaterMark ()}
}\par
{\bkmkstart classCSocket_a19}
{\bkmkend classCSocket_a19}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Return the value of the current Send Low Water Mark Set setSndLowWaterMarrk for more information.\par
Throws:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) if an error from getsockopt is detected. \par
}\par
Definition at line 1044 of file CSocket.cpp.\par
\par
References m_Fd.}
{\xe \v getSndTimeout\:CSocket}
{\xe \v CSocket\:getSndTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int CSocket::getSndTimeout ()}
}\par
{\bkmkstart classCSocket_a23}
{\bkmkend classCSocket_a23}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Purpose:\par
Returns the current send timeout in ms.\par
Throws:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) if there was an error in getsockopt(2). \par
}\par
Definition at line 1159 of file CSocket.cpp.\par
\par
References m_Fd.}
{\xe \v getSocketFd\:CSocket}
{\xe \v CSocket\:getSocketFd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CSocket::getSocketFd () const{\f2  [inline]}}
}\par
{\bkmkstart classCSocket_a3}
{\bkmkend classCSocket_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get accessor function socket file descriptor.\par
\par
Definition at line 383 of file CSocket.h.\par
\par
References m_Fd.\par
Referenced by CServerInstance::DescribeSelf(), CServerConnectionEvent::DescribeSelf(), CTCPConnectionLost::Host(), and CTCPConnectionLost::Port().}
{\xe \v getState\:CSocket}
{\xe \v CSocket\:getState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CSocket::State} CSocket::getState () const{\f2  [inline]}}
}\par
{\bkmkstart classCSocket_a4}
{\bkmkend classCSocket_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Get accessor function for socket state.\par
\par
Definition at line 388 of file CSocket.h.\par
\par
References m_State, and State.\par
Referenced by CServerInstance::DescribeSelf(), CServerConnectionEvent::DescribeSelf(), CServerInstance::Shutdown(), and CServerInstance::~CServerInstance().}
{\xe \v isDebug\:CSocket}
{\xe \v CSocket\:isDebug}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CSocket::isDebug ()}
}\par
{\bkmkstart classCSocket_a25}
{\bkmkend classCSocket_a25}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Purpose:\par
Returns TRUE if socket debugging is turned on and False otherwise.\par
Exceptions:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) if an error is returned from the getsockopt(2) call. \par
}\par
Definition at line 1214 of file CSocket.cpp.\par
\par
References FALSE, m_Fd, and TRUE.}
{\xe \v isNotRoutable\:CSocket}
{\xe \v CSocket\:isNotRoutable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CSocket::isNotRoutable ()}
}\par
{\bkmkstart classCSocket_a27}
{\bkmkend classCSocket_a27}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Purpose:\par
Returns the state of the routability flag.\par
Throws:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) If getsockopt(2) failed.\par
}Return values:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
TRUE Routing is turned off.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
FALSE Routing is tured on. \par
}\par
Definition at line 1272 of file CSocket.cpp.\par
\par
References FALSE, m_Fd, and TRUE.}
{\xe \v isOOBInline\:CSocket}
{\xe \v CSocket\:isOOBInline}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CSocket::isOOBInline ()}
}\par
{\bkmkstart classCSocket_a15}
{\bkmkend classCSocket_a15}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Purpose:\par
Returns TRUE if OOBinline is set FALSE otherwise. Note that the underlying socket state is inquired, not some saved internal state.\par
This function is valid in any socket state.\par
Throws:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) if getsockopt(2) fails\par
} \par
\par
Definition at line 941 of file CSocket.cpp.\par
\par
References FALSE, m_Fd, and TRUE.}
{\xe \v Listen\:CSocket}
{\xe \v CSocket\:Listen}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CSocket::Listen (unsigned int {\i nBacklog} = 5)}
}\par
{\bkmkstart classCSocket_a8}
{\bkmkend classCSocket_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Indicates that the specified server  listener socket is ready to listen for connections.\par
The Following exceptions can be  thrown:\par
{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CTCPBadSocketState} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPBadSocketState \\*MERGEFORMAT}{\fldrslt pagenum}}}) - m_State != Bound\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) - listen(2) failed.\par
}On success, m_State = Listening{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i nBacklog}}  The limit on the queue size for incomming connections.  This value of this parameter defaults to 5. If a a connection is requested when the listen queue is full, it is refused or allowed to retry depending on the protocol (according to linux man connect(2)). On some systems this parameter may be ignored or have other meaning. \par
}\par
Definition at line 610 of file CSocket.cpp.\par
\par
References Bound, Listening, m_Fd, and m_State.\par
Referenced by CServerConnectionEvent::ConfigureSocket().}
{\xe \v OOBInline\:CSocket}
{\xe \v CSocket\:OOBInline}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CSocket::OOBInline (bool {\i State} = TRUE)}
}\par
{\bkmkstart classCSocket_a14}
{\bkmkend classCSocket_a14}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Purpose:\par
Allows Out Of Band (OOB) data to be inserted in line with buffered data. OOB data is data with a higher delivery priority than 'normal data'. If this flag is not set, then by default OOB data must be read through normal socket interface functions by specifying it in the recv flags parameter. If this flag is set, oob data is queue at the front of the data to be read with the Read member.\par
This is allowed in any socket state. Exceptions:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) if the setsockopt(2) function failed.\par
}{{{\b Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i State}}  This can be (Defaults to TRUE):{\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
TRUE Enables out of band inline data.\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
FALSE disables out of band inline data. \par
}}\par
Definition at line 916 of file CSocket.cpp.\par
\par
References m_Fd, and State.}
{\xe \v OpenSocket\:CSocket}
{\xe \v CSocket\:OpenSocket}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CSocket::OpenSocket (){\f2  [protected]}}
}\par
{\bkmkstart classCSocket_b4}
{\bkmkend classCSocket_b4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Opens the socket on a TCP/IP endpoint. \par
\par
Definition at line 1557 of file CSocket.cpp.\par
\par
References CApplicationSerializer::getInstance(), CThreadRecursiveMutex::Lock(), m_Fd, StockStateMap(), and CThreadRecursiveMutex::UnLock().\par
Referenced by CSocket(), and Shutdown().}
{\xe \v operator=\:CSocket}
{\xe \v CSocket\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CSocket& CSocket::operator= (const CSocket & {\i aCSocket}){\f2  [private]}}
}\par
{\bkmkstart classCSocket_c1}
{\bkmkend classCSocket_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Assignment Operator Forbidden.\par
}
{\xe \v operator==\:CSocket}
{\xe \v CSocket\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CSocket::operator== (const CSocket & {\i aCSocket}) const{\f2  [private]}}
}\par
{\bkmkstart classCSocket_c2}
{\bkmkend classCSocket_c2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Equality Operator Forbidden.\par
}
{\xe \v Read\:CSocket}
{\xe \v CSocket\:Read}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CSocket::Read (void * {\i pBuffer}, size_t {\i nBytes})}
}\par
{\bkmkstart classCSocket_a11}
{\bkmkend classCSocket_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Purpose:\par
Performs a read on the socket. The read will transfer all of the bytes currently waiting in the socket buffers or block until data is avaialble. The return valiue will be the number of bytes transferred. If the connection is lost, {\b CTCPConnectionLost} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPConnectionLost \\*MERGEFORMAT}{\fldrslt pagenum}}}) will be thrown. Multiple reads will not be performed so that any known messaging structure can be maintained.\par
Throws:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) - the read(2) system service returned an error.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CTCPConnectionLost} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPConnectionLost \\*MERGEFORMAT}{\fldrslt pagenum}}}) - the read(2) system service returned 0 indicating an end of file condition.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CTCPBadSocketState} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPBadSocketState \\*MERGEFORMAT}{\fldrslt pagenum}}}) - m_State != Connected. \par
}\par
Definition at line 749 of file CSocket.cpp.\par
\par
References Connected, Disconnected, m_Fd, and m_State.\par
Referenced by CLogger::Log().}
{\xe \v Service\:CSocket}
{\xe \v CSocket\:Service}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned short CSocket::Service (const string & {\i rService}){\f2  [protected]}}
}\par
{\bkmkstart classCSocket_b2}
{\bkmkend classCSocket_b2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Purpose: Determines the service which corresponds to a service string. Service strings can either be a numerical equivalent of a service port number or a service name which can be looked up in the service database.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rService}}  The service name.\par
}Returns: The port number or throws: -{\b CTCPNoSuchService} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPNoSuchService \\*MERGEFORMAT}{\fldrslt pagenum}}}) The service cannot be translated. \par
\par
Definition at line 1466 of file CSocket.cpp.\par
\par
References CApplicationSerializer::getInstance(), CThreadRecursiveMutex::Lock(), and CThreadRecursiveMutex::UnLock().\par
Referenced by Bind(), and Connect().}
{\xe \v setLinger\:CSocket}
{\xe \v CSocket\:setLinger}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CSocket::setLinger (bool {\i lOn}, int {\i nLingerSeconds})}
}\par
{\bkmkstart classCSocket_a32}
{\bkmkend classCSocket_a32}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Purpose:\par
Sets the socket linger parameters. Linger properties govern the way a shutdown, operates. Note that object destruction which requires a shutdown implicitly turns off linger.  If linger is enabled, then the close will block until all pending data has been successfully sent or until the linger timeout is exceeded.\par
Throws:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) if the setsockopt(2) call failed.\par
}{{{\b Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i lOn}}  Determines if linger is on or off:{\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
TRUE Linger is on.\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
FALSE Linger is off. \par
}}{{{\b Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i nLingerSeconds}}  (only used if lOn is TRUE). Indicates how many seconds to linger on the close until a timeout is declared and the close unblocks. \par
}\par
Definition at line 1407 of file CSocket.cpp.\par
\par
References m_Fd.}
{\xe \v SetNotRoutable\:CSocket}
{\xe \v CSocket\:SetNotRoutable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CSocket::SetNotRoutable (bool {\i fRoutable} = TRUE)}
}\par
{\bkmkstart classCSocket_a26}
{\bkmkend classCSocket_a26}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Purpose:\par
Allows the caller to control the routability of messages sent on the socket. If set, messages will not be sent through a gateway. Note: The socket need not be connected. Presumably, if this flag is set prior to Connect on a client socket the client will be unable to connect outside the local subnet, and if set prior to Bind for a server, the server will be unable to accept connections from outside the subnet.\par
Exceptions: -{\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) if the setsockopt(2) call failed.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i fRoutable}}  [TRUE] :{\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
TRUE to turn OFF Routing\par
\pard\plain \s83\fi-360\li1440\widctlpar\jclisttab\tx1440{\*\pn \pnlvlbody\ilvl0\ls4\pnrnot0\pndec }\ls4\adjustright \fs20\cgrid 
FALSE to turn ON Routing. \par
}}\par
Definition at line 1247 of file CSocket.cpp.\par
\par
References m_Fd.}
{\xe \v setRcvBufSize\:CSocket}
{\xe \v CSocket\:setRcvBufSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CSocket::setRcvBufSize (size_t {\i nBytes})}
}\par
{\bkmkstart classCSocket_a30}
{\bkmkend classCSocket_a30}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Purpose:\par
Sets the maximum number of bytes which can be received in a single read(2) operation. Note that CTCPSocket::Read does >NOT<  automatically segment or else you may block when you'd like to believe that a message has been received.\par
Throws:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) if setsockopt(2) fails.\par
}{{{\b Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i nBufferSize}}  Number of bytes which can be sent in one write(2) call \par
}\par
Definition at line 1353 of file CSocket.cpp.\par
\par
References m_Fd.}
{\xe \v setRcvLowWaterMark\:CSocket}
{\xe \v CSocket\:setRcvLowWaterMark}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CSocket::setRcvLowWaterMark (size_t {\i nBytes})}
}\par
{\bkmkstart classCSocket_a16}
{\bkmkend classCSocket_a16}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Purpose:\par
Sets the Receive low water mark for the socket. This is the number of bytes received by the protocol before any is made available to the user. Note that some systems do not allow  this to be changed. It is not an error at this level to attempt to do so, however you will need to  call getRcvlowWaterMark to be sure the change was actually made.\par
Throws:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) if an error from setsockopt is detected other than that the system doesn't support resetting the low water mark. \par
}\par
Definition at line 973 of file CSocket.cpp.\par
\par
References m_Fd.}
{\xe \v setRcvTimeout\:CSocket}
{\xe \v CSocket\:setRcvTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CSocket::setRcvTimeout (unsigned int {\i nMs})}
}\par
{\bkmkstart classCSocket_a20}
{\bkmkend classCSocket_a20}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set the protocol receive timeouts. Note that in some systems, these are not settable. However it is not an error to attempt to do so.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i nMs}}  number of milliseconds of timeout to set.\par
}Throws:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) if a setsockopt(3) returns an error other than that this is unsupported. \par
}\par
Definition at line 1067 of file CSocket.cpp.\par
\par
References m_Fd.}
{\xe \v setSndBufSize\:CSocket}
{\xe \v CSocket\:setSndBufSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CSocket::setSndBufSize (size_t {\i nBufferSize})}
}\par
{\bkmkstart classCSocket_a28}
{\bkmkend classCSocket_a28}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Configuration\par
Purpose:\par
Sets the socket send buffer size. This  has to do with how many bytes can be  sent in a single write(2) service call. Messages larger than that must be segmented into multiple write(2) calls. Note howerver that  CTCPSocket::Write automatically handles any necessary segmentation.\par
Throws:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) if setsockopt(2) fails.\par
}{{{\b Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i nBufferSize}}  Number of bytes which can be sent in one write(2) call \par
}\par
Definition at line 1305 of file CSocket.cpp.\par
\par
References m_Fd.}
{\xe \v setSndLowWaterMark\:CSocket}
{\xe \v CSocket\:setSndLowWaterMark}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CSocket::setSndLowWaterMark (size_t {\i nBytes})}
}\par
{\bkmkstart classCSocket_a18}
{\bkmkend classCSocket_a18}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Sets the new value of the Send Low water mark. This controls the number of bytes which must be written before transferring data to the protocol layers for transmission. Note that some systems don't allow this value to be changed. It is not an error to attempt to change this value on those systems, however you should use getSndLowWaterMark to determine the actual value negotiated by the system.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i nBytes}}  Number of bytes in the low water mark.\par
}Throws:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) if an error from setsockopt is detected other than that the system doesn't support resetting the low water mark. \par
}\par
Definition at line 1026 of file CSocket.cpp.\par
\par
References m_Fd.}
{\xe \v setSndTimeout\:CSocket}
{\xe \v CSocket\:setSndTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CSocket::setSndTimeout (unsigned int {\i nMs})}
}\par
{\bkmkstart classCSocket_a22}
{\bkmkend classCSocket_a22}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Purpose:\par
Set the number of milliseconds in the send timeout. Some systems may not allow this to be set, however it is not an error to try.\par
Throws:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) if setsockop(2) returned an error other than this option is not supported.\par
}{{{\b Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i nMs}}  Number of milliseconds in the desired timeout. \par
}\par
Definition at line 1131 of file CSocket.cpp.\par
\par
References m_Fd.}
{\xe \v setSocketFd\:CSocket}
{\xe \v CSocket\:setSocketFd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CSocket::setSocketFd (const int {\i am_Fd}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCSocket_b0}
{\bkmkend classCSocket_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set accessor function for Socket file descriptor.\par
\par
Definition at line 397 of file CSocket.h.\par
\par
References m_Fd.}
{\xe \v setState\:CSocket}
{\xe \v CSocket\:setState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CSocket::setState (const {\b CSocket::State} {\i am_State}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCSocket_b1}
{\bkmkend classCSocket_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set accessor function for current socket state.\par
\par
Definition at line 401 of file CSocket.h.\par
\par
References m_State, and State.}
{\xe \v Shutdown\:CSocket}
{\xe \v CSocket\:Shutdown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CSocket::Shutdown ()}
}\par
{\bkmkstart classCSocket_a10}
{\bkmkend classCSocket_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Purpose:\par
Shuts down a connection to a remote system. Unlike shutdown(2) this function does not support selectively shutting down reads or writes. Both are unconditionally shutdown. Note that the destructor will automatically call Shutdown if necessary.\par
Exceptions:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CTCPBadSocketState} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPBadSocketState \\*MERGEFORMAT}{\fldrslt pagenum}}}) m_State != Connected.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) shutdown(2) failed. \par
}\par
Definition at line 708 of file CSocket.cpp.\par
\par
References Connected, Disconnected, m_Fd, m_State, and OpenSocket().\par
Referenced by CLogger::Log(), CAlarmLogger::Log(), CServerConnectionEvent::OnConnection(), CServerInstance::Shutdown(), CServerConnectionEvent::~CServerConnectionEvent(), and CServerInstance::~CServerInstance().}
{\xe \v StateName\:CSocket}
{\xe \v CSocket\:StateName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CSocket::StateName ({\b CSocket::State} {\i state}){\f2  [static]}}
}\par
{\bkmkstart classCSocket_d0}
{\bkmkend classCSocket_d0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Purpose: Given a state, returns a text string which describes the state. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i state}}  - State to describe.\par
}NOTE: Since this is a static member which can be called before any instances of CSocket have been created, we call {\b StockStateMap}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCSocket_e0 \\*MERGEFORMAT}{\fldrslt pagenum}}}). \par
\par
Definition at line 1532 of file CSocket.cpp.\par
\par
References m_StateNames, State, and StockStateMap().\par
Referenced by CServerInstance::DescribeSelf(), CServerConnectionEvent::DescribeSelf(), and CTCPBadSocketState::ReasonText().}
{\xe \v StockStateMap\:CSocket}
{\xe \v CSocket\:StockStateMap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CSocket::StockStateMap (){\f2  [static, protected]}}
}\par
{\bkmkstart classCSocket_e0}
{\bkmkend classCSocket_e0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Purpose: Stocks the static member: m_StateNames with the states and their names. This is only done if the map is empty. This function must be updated if the set of states is modified. \par
\par
Definition at line 1544 of file CSocket.cpp.\par
\par
References Bound, Connected, Disconnected, Listening, and m_StateNames.\par
Referenced by CSocket(), OpenSocket(), and StateName().}
{\xe \v Write\:CSocket}
{\xe \v CSocket\:Write}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CSocket::Write (void * {\i pBuffer}, size_t {\i nBytes})}
}\par
{\bkmkstart classCSocket_a12}
{\bkmkend classCSocket_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Purpose:\par
Writes data to the socket. Note that this member will block as needed until all data has been queued to the socket buffers. This may require multiple write(2) function calls if the amount of data to be written is larger than the socket's blocking factor. Note that if the connection is lost during the write, {\b CTCPConnectionLost} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPConnectionLost \\*MERGEFORMAT}{\fldrslt pagenum}}}) will be thrown.\par
Exceptions:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CTCPBadSocketState} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPBadSocketState \\*MERGEFORMAT}{\fldrslt pagenum}}}) m_State != Connected\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) write(2) returned an error condition.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
{\b CTCPConnectionLost} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCPConnectionLost \\*MERGEFORMAT}{\fldrslt pagenum}}}) write(2) indicated an EPIPE condition which says the peer closed the socket. \par
\par
}{{{\b {\b Bug: }}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid There's not a good way to handle failures on the second or later call to write(2). Since we'd like to indicate that part of the write completed before an error occured. The current assumption is that a followup write will produce the same error. Perhaps the best long term thing to do is to define a CTCPSocketIOError which will include as data the number of bytes written along with a {\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) which describes why the write actually failed??\par
} \par
\par
Definition at line 810 of file CSocket.cpp.\par
\par
References Disconnected, m_Fd, and m_State.\par
Referenced by CLogger::Log(), and CAlarmLogger::Log().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_Fd\:CSocket}
{\xe \v CSocket\:m_Fd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CSocket::m_Fd{\f2  [private]}}
}\par
{\bkmkstart classCSocket_o0}
{\bkmkend classCSocket_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Socket.\par
\par
Definition at line 353 of file CSocket.h.\par
\par
Referenced by Accept(), Bind(), Connect(), Debug(), getLinger(), getPeer(), getRcvBufSize(), getRcvLowWaterMark(), getRcvTimeout(), getSndBufSize(), getSndLowWaterMark(), getSndTimeout(), getSocketFd(), isDebug(), isNotRoutable(), isOOBInline(), Listen(), OOBInline(), OpenSocket(), Read(), setLinger(), SetNotRoutable(), setRcvBufSize(), setRcvLowWaterMark(), setRcvTimeout(), setSndBufSize(), setSndLowWaterMark(), setSndTimeout(), setSocketFd(), Shutdown(), and Write().}
{\xe \v m_State\:CSocket}
{\xe \v CSocket\:m_State}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CSocket::State} CSocket::m_State{\f2  [private]}}
}\par
{\bkmkstart classCSocket_o1}
{\bkmkend classCSocket_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
State of socket.\par
\par
Definition at line 354 of file CSocket.h.\par
\par
Referenced by Accept(), Bind(), Connect(), getPeer(), getState(), Listen(), Read(), setState(), Shutdown(), and Write().}
{\xe \v m_StateNames\:CSocket}
{\xe \v CSocket\:m_StateNames}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
map< {\b CSocket::State}, string > CSocket::m_StateNames{\f2  [static, private]}}
}\par
{\bkmkstart classCSocket_r0}
{\bkmkend classCSocket_r0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
State name lookup tbl.\par
\par
Definition at line 348 of file CSocket.cpp.\par
\par
Referenced by StateName(), and StockStateMap().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CSocket.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CSocket.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
StartEventThread  Class Reference\par \pard\plain 
{\tc\tcl2 \v StartEventThread}
{\xe \v StartEventThread}
{\bkmkstart classStartEventThread}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b operator()} (int nargs, char **ppArgs)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator()\:StartEventThread}
{\xe \v StartEventThread\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual int StartEventThread::operator() (int {\i nargs}, char ** {\i ppArgs}){\f2  [inline, protected, virtual]}}
}\par
{\bkmkstart classStartEventThread_b0}
{\bkmkend classStartEventThread_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 312 of file CEvent.cpp.\par
\par
References StartupDelayuSec.}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CEvent.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CStreamIOError  Class Reference\par \pard\plain 
{\tc\tcl2 \v CStreamIOError}
{\xe \v CStreamIOError}
{\bkmkstart classCStreamIOError}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CStreamIOError.h>}\par
Inheritance diagram for CStreamIOError:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCStreamIOError.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef enum {\b CStreamIOError::_IoStreamConditions} {\b IoStreamConditions}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b _IoStreamConditions} \{ {\b EndFile}, 
{\b BadSet}, 
{\b FailSet}
 \}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CStreamIOError} ({\b IoStreamConditions} eReason, const char *pDoing, ios &rStream)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CStreamIOError} ({\b IoStreamConditions} eReason, const string &rDoing, ios &rStream)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CStreamIOError} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CStreamIOError} (const CStreamIOError &aCStreamIOError)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CStreamIOError &aCStreamIOError)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IoStreamConditions} {\b getReason} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ios & {\b getStream} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b getErrorMessage} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const char * {\b ReasonText} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Int_t} {\b ReasonCode} () const\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setReason} (const {\b IoStreamConditions} am_eReason)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CStreamIOError & {\b operator=} (const CStreamIOError &aCStreamIOError)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b IoStreamConditions} {\b m_eReason}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
ios & {\b m_rStream}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char {\b m_sReasonText} [1000]\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char ** {\b m_svErrorMessages} = {\b pErrorMessages}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v IoStreamConditions\:CStreamIOError}
{\xe \v CStreamIOError\:IoStreamConditions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef enum {\b CStreamIOError::_IoStreamConditions}  CStreamIOError::IoStreamConditions}
}\par
{\bkmkstart classCStreamIOError_s0}
{\bkmkend classCStreamIOError_s0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Referenced by CStreamIOError(), getReason(), and setReason().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Enumeration Documentation\par
\pard\plain 
{\xe \v _IoStreamConditions\:CStreamIOError}
{\xe \v CStreamIOError\:_IoStreamConditions}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum CStreamIOError::_IoStreamConditions}
}\par
{\bkmkstart classCStreamIOError_s4}
{\bkmkend classCStreamIOError_s4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{{{\b \par
Enumeration values:}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v EndFile\:CStreamIOError}
{\xe \v CStreamIOError\:EndFile}
{\b {\i {\i EndFile}{\bkmkstart classCStreamIOError_s4s1}
{\bkmkend classCStreamIOError_s4s1}
}}  \par
{\xe \v BadSet\:CStreamIOError}
{\xe \v CStreamIOError\:BadSet}
{\b {\i {\i BadSet}{\bkmkstart classCStreamIOError_s4s2}
{\bkmkend classCStreamIOError_s4s2}
}}  \par
{\xe \v FailSet\:CStreamIOError}
{\xe \v CStreamIOError\:FailSet}
{\b {\i {\i FailSet}{\bkmkstart classCStreamIOError_s4s3}
{\bkmkend classCStreamIOError_s4s3}
}}  \par
}
\par
Definition at line 319 of file CStreamIOError.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CStreamIOError\:CStreamIOError}
{\xe \v CStreamIOError\:CStreamIOError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CStreamIOError::CStreamIOError ({\b IoStreamConditions} {\i eReason}, const char * {\i pDoing}, ios & {\i rStream}){\f2  [inline]}}
}\par
{\bkmkstart classCStreamIOError_a0}
{\bkmkend classCStreamIOError_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 334 of file CStreamIOError.h.\par
\par
References IoStreamConditions, m_eReason, and m_rStream.}
{\xe \v CStreamIOError\:CStreamIOError}
{\xe \v CStreamIOError\:CStreamIOError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CStreamIOError::CStreamIOError ({\b IoStreamConditions} {\i eReason}, const string & {\i rDoing}, ios & {\i rStream}){\f2  [inline]}}
}\par
{\bkmkstart classCStreamIOError_a1}
{\bkmkend classCStreamIOError_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 341 of file CStreamIOError.h.\par
\par
References IoStreamConditions, m_eReason, and m_rStream.}
{\xe \v ~CStreamIOError\:CStreamIOError}
{\xe \v CStreamIOError\:~CStreamIOError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CStreamIOError::~CStreamIOError (){\f2  [inline]}}
}\par
{\bkmkstart classCStreamIOError_a2}
{\bkmkend classCStreamIOError_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 349 of file CStreamIOError.h.\par
}
{\xe \v CStreamIOError\:CStreamIOError}
{\xe \v CStreamIOError\:CStreamIOError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CStreamIOError::CStreamIOError (const CStreamIOError & {\i aCStreamIOError}){\f2  [inline]}}
}\par
{\bkmkstart classCStreamIOError_a3}
{\bkmkend classCStreamIOError_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 354 of file CStreamIOError.h.\par
\par
References m_eReason, and m_rStream.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getErrorMessage\:CStreamIOError}
{\xe \v CStreamIOError\:getErrorMessage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * CStreamIOError::getErrorMessage () const}
}\par
{\bkmkstart classCStreamIOError_a7}
{\bkmkend classCStreamIOError_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 322 of file CStreamIOError.cpp.\par
\par
References FailSet, m_eReason, and m_svErrorMessages.}
{\xe \v getReason\:CStreamIOError}
{\xe \v CStreamIOError\:getReason}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IoStreamConditions} CStreamIOError::getReason () const{\f2  [inline]}}
}\par
{\bkmkstart classCStreamIOError_a5}
{\bkmkend classCStreamIOError_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 384 of file CStreamIOError.h.\par
\par
References IoStreamConditions, and m_eReason.}
{\xe \v getStream\:CStreamIOError}
{\xe \v CStreamIOError\:getStream}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ios& CStreamIOError::getStream (){\f2  [inline]}}
}\par
{\bkmkstart classCStreamIOError_a6}
{\bkmkend classCStreamIOError_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 388 of file CStreamIOError.h.\par
\par
References m_rStream.}
{\xe \v operator=\:CStreamIOError}
{\xe \v CStreamIOError\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CStreamIOError& CStreamIOError::operator= (const CStreamIOError & {\i aCStreamIOError}){\f2  [private]}}
}\par
{\bkmkstart classCStreamIOError_c0}
{\bkmkend classCStreamIOError_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:CStreamIOError}
{\xe \v CStreamIOError\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CStreamIOError::operator== (const CStreamIOError & {\i aCStreamIOError}){\f2  [inline]}}
}\par
{\bkmkstart classCStreamIOError_a4}
{\bkmkend classCStreamIOError_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 373 of file CStreamIOError.h.\par
\par
References m_eReason, m_rStream, and CException::operator==().}
{\xe \v ReasonCode\:CStreamIOError}
{\xe \v CStreamIOError\:ReasonCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Int_t} CStreamIOError::ReasonCode () const{\f2  [virtual]}}
}\par
{\bkmkstart classCStreamIOError_a9}
{\bkmkend classCStreamIOError_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns a code which describes the reason for the exception . This is exception type specific and may be used to do detailed exception analysis and recovery. For example in the {\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) class, the errno at the time of instantiation of the object is returned. The default returns -1 \par
\par
Reimplemented from {\b CException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCException_a9 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 353 of file CStreamIOError.cpp.\par
\par
References Int_t.}
{\xe \v ReasonText\:CStreamIOError}
{\xe \v CStreamIOError\:ReasonText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * CStreamIOError::ReasonText () const{\f2  [virtual]}}
}\par
{\bkmkstart classCStreamIOError_a8}
{\bkmkend classCStreamIOError_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns a const pointer to text which describes the reason the exception was thrown. This is exception type specific. The default action returns a pointer to the constant string: "Unspecified Exception" \par
\par
Reimplemented from {\b CException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCException_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 337 of file CStreamIOError.cpp.\par
}
{\xe \v setReason\:CStreamIOError}
{\xe \v CStreamIOError\:setReason}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CStreamIOError::setReason (const {\b IoStreamConditions} {\i am_eReason}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCStreamIOError_b0}
{\bkmkend classCStreamIOError_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 400 of file CStreamIOError.h.\par
\par
References IoStreamConditions, and m_eReason.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_eReason\:CStreamIOError}
{\xe \v CStreamIOError\:m_eReason}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b IoStreamConditions} CStreamIOError::m_eReason{\f2  [private]}}
}\par
{\bkmkstart classCStreamIOError_o0}
{\bkmkend classCStreamIOError_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 326 of file CStreamIOError.h.\par
\par
Referenced by CStreamIOError(), getErrorMessage(), getReason(), operator==(), and setReason().}
{\xe \v m_rStream\:CStreamIOError}
{\xe \v CStreamIOError\:m_rStream}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
ios& CStreamIOError::m_rStream{\f2  [private]}}
}\par
{\bkmkstart classCStreamIOError_o1}
{\bkmkend classCStreamIOError_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 327 of file CStreamIOError.h.\par
\par
Referenced by CStreamIOError(), getStream(), and operator==().}
{\xe \v m_sReasonText\:CStreamIOError}
{\xe \v CStreamIOError\:m_sReasonText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char CStreamIOError::m_sReasonText[1000]{\f2  [private]}}
}\par
{\bkmkstart classCStreamIOError_o2}
{\bkmkend classCStreamIOError_o2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 328 of file CStreamIOError.h.\par
}
{\xe \v m_svErrorMessages\:CStreamIOError}
{\xe \v CStreamIOError\:m_svErrorMessages}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char ** CStreamIOError::m_svErrorMessages = {\b pErrorMessages}{\f2  [static, private]}}
}\par
{\bkmkstart classCStreamIOError_r0}
{\bkmkend classCStreamIOError_r0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 311 of file CStreamIOError.cpp.\par
\par
Referenced by getErrorMessage().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CStreamIOError.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CStreamIOError.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCLApplication  Class Reference\par \pard\plain 
{\tc\tcl2 \v CTCLApplication}
{\xe \v CTCLApplication}
{\bkmkstart classCTCLApplication}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <TCLApplication.h>}\par
Inheritance diagram for CTCLApplication:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCTCLApplication.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLApplication} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CTCLApplication} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLApplication} (const CTCLApplication &aCTCLApplication)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLApplication & {\b operator=} (const CTCLApplication &aCTCLApplication)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CTCLApplication &aCTCLApplication)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b operator()} ()=0\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void * {\b m_pInit}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CTCLApplication\:CTCLApplication}
{\xe \v CTCLApplication\:CTCLApplication}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLApplication::CTCLApplication (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLApplication_a0}
{\bkmkend classCTCLApplication_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 308 of file TCLApplication.h.\par
\par
References m_pInit, and Tcl_AppInit().}
{\xe \v ~CTCLApplication\:CTCLApplication}
{\xe \v CTCLApplication\:~CTCLApplication}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLApplication::~CTCLApplication (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLApplication_a1}
{\bkmkend classCTCLApplication_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 310 of file TCLApplication.h.\par
}
{\xe \v CTCLApplication\:CTCLApplication}
{\xe \v CTCLApplication\:CTCLApplication}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLApplication::CTCLApplication (const CTCLApplication & {\i aCTCLApplication}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLApplication_a2}
{\bkmkend classCTCLApplication_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 315 of file TCLApplication.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator()\:CTCLApplication}
{\xe \v CTCLApplication\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual int CTCLApplication::operator() (){\f2  [pure virtual]}}
}\par
{\bkmkstart classCTCLApplication_a5}
{\bkmkend classCTCLApplication_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:CTCLApplication}
{\xe \v CTCLApplication\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLApplication& CTCLApplication::operator= (const CTCLApplication & {\i aCTCLApplication}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLApplication_a3}
{\bkmkend classCTCLApplication_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 323 of file TCLApplication.h.\par
\par
References CTCLInterpreterObject::operator=().}
{\xe \v operator==\:CTCLApplication}
{\xe \v CTCLApplication\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLApplication::operator== (const CTCLApplication & {\i aCTCLApplication}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLApplication_a4}
{\bkmkend classCTCLApplication_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 333 of file TCLApplication.h.\par
\par
References CTCLInterpreterObject::operator==().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_pInit\:CTCLApplication}
{\xe \v CTCLApplication\:m_pInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void* CTCLApplication::m_pInit{\f2  [private]}}
}\par
{\bkmkstart classCTCLApplication_o0}
{\bkmkend classCTCLApplication_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 304 of file TCLApplication.h.\par
\par
Referenced by CTCLApplication().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TCLApplication.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCLCommandPackage  Class Reference\par \pard\plain 
{\tc\tcl2 \v CTCLCommandPackage}
{\xe \v CTCLCommandPackage}
{\bkmkstart classCTCLCommandPackage}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <TCLCommandPackage.h>}\par
Inheritance diagram for CTCLCommandPackage:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCTCLCommandPackage.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLCommandPackage} ({\b CTCLInterpreter} *pInterp, const std::string &rSignon=std::string("Unnamed pkg"))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLCommandPackage} ({\b CTCLInterpreter} *pInterp, const char *pSignon="Unnamed pkg")\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CTCLCommandPackage} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLCommandPackage} (const CTCLCommandPackage &aCTCLCommandPackage)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLCommandPackage & {\b operator=} (const CTCLCommandPackage &aCTCLCommandPackage)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CTCLCommandPackage &aCTCLCommandPackage)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b getSignon} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CommandList} {\b getCommandList} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Register} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Unregister} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddProcessor} ({\b CTCLProcessor} *pProcessor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddProcessors} ({\b CommandList} &rList)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CommandListIterator} {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CommandListIterator} {\b end} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSignon} (std::string am_sSignon)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setCommandList} ({\b CommandList} &rList)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b m_sSignon}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CommandList} {\b m_lCommands}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CTCLCommandPackage\:CTCLCommandPackage}
{\xe \v CTCLCommandPackage\:CTCLCommandPackage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLCommandPackage::CTCLCommandPackage ({\b CTCLInterpreter} * {\i pInterp}, const std::string & {\i rSignon} = std::string("Unnamed pkg")){\f2  [inline]}}
}\par
{\bkmkstart classCTCLCommandPackage_a0}
{\bkmkend classCTCLCommandPackage_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 337 of file TCLCommandPackage.h.\par
\par
References m_sSignon.}
{\xe \v CTCLCommandPackage\:CTCLCommandPackage}
{\xe \v CTCLCommandPackage\:CTCLCommandPackage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLCommandPackage::CTCLCommandPackage ({\b CTCLInterpreter} * {\i pInterp}, const char * {\i pSignon} = "Unnamed pkg"){\f2  [inline]}}
}\par
{\bkmkstart classCTCLCommandPackage_a1}
{\bkmkend classCTCLCommandPackage_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 342 of file TCLCommandPackage.h.\par
\par
References m_sSignon.}
{\xe \v ~CTCLCommandPackage\:CTCLCommandPackage}
{\xe \v CTCLCommandPackage\:~CTCLCommandPackage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual CTCLCommandPackage::~CTCLCommandPackage (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCTCLCommandPackage_a2}
{\bkmkend classCTCLCommandPackage_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 347 of file TCLCommandPackage.h.\par
}
{\xe \v CTCLCommandPackage\:CTCLCommandPackage}
{\xe \v CTCLCommandPackage\:CTCLCommandPackage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLCommandPackage::CTCLCommandPackage (const CTCLCommandPackage & {\i aCTCLCommandPackage}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLCommandPackage_a3}
{\bkmkend classCTCLCommandPackage_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 351 of file TCLCommandPackage.h.\par
\par
References m_lCommands, and m_sSignon.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddProcessor\:CTCLCommandPackage}
{\xe \v CTCLCommandPackage\:AddProcessor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLCommandPackage::AddProcessor ({\b CTCLProcessor} * {\i pProcessor}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLCommandPackage_a10}
{\bkmkend classCTCLCommandPackage_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 408 of file TCLCommandPackage.h.\par
\par
References m_lCommands.}
{\xe \v AddProcessors\:CTCLCommandPackage}
{\xe \v CTCLCommandPackage\:AddProcessors}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLCommandPackage::AddProcessors ({\b CommandList} & {\i rList}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLCommandPackage_a11}
{\bkmkend classCTCLCommandPackage_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 411 of file TCLCommandPackage.h.\par
\par
References CommandList, end(), and m_lCommands.}
{\xe \v begin\:CTCLCommandPackage}
{\xe \v CTCLCommandPackage\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CommandListIterator} CTCLCommandPackage::begin (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLCommandPackage_a12}
{\bkmkend classCTCLCommandPackage_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 415 of file TCLCommandPackage.h.\par
\par
References CommandListIterator, and m_lCommands.\par
Referenced by Register(), and Unregister().}
{\xe \v end\:CTCLCommandPackage}
{\xe \v CTCLCommandPackage\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CommandListIterator} CTCLCommandPackage::end (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLCommandPackage_a13}
{\bkmkend classCTCLCommandPackage_a13}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 418 of file TCLCommandPackage.h.\par
\par
References CommandListIterator, and m_lCommands.\par
Referenced by AddProcessors(), Register(), and Unregister().}
{\xe \v getCommandList\:CTCLCommandPackage}
{\xe \v CTCLCommandPackage\:getCommandList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CommandList} CTCLCommandPackage::getCommandList () const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLCommandPackage_a7}
{\bkmkend classCTCLCommandPackage_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 385 of file TCLCommandPackage.h.\par
\par
References CommandList, and m_lCommands.}
{\xe \v getSignon\:CTCLCommandPackage}
{\xe \v CTCLCommandPackage\:getSignon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string CTCLCommandPackage::getSignon () const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLCommandPackage_a6}
{\bkmkend classCTCLCommandPackage_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 381 of file TCLCommandPackage.h.\par
\par
References m_sSignon.}
{\xe \v operator=\:CTCLCommandPackage}
{\xe \v CTCLCommandPackage\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLCommandPackage& CTCLCommandPackage::operator= (const CTCLCommandPackage & {\i aCTCLCommandPackage}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLCommandPackage_a4}
{\bkmkend classCTCLCommandPackage_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 359 of file TCLCommandPackage.h.\par
\par
References m_lCommands, m_sSignon, and CTCLInterpreterObject::operator=().}
{\xe \v operator==\:CTCLCommandPackage}
{\xe \v CTCLCommandPackage\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLCommandPackage::operator== (const CTCLCommandPackage & {\i aCTCLCommandPackage}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLCommandPackage_a5}
{\bkmkend classCTCLCommandPackage_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 371 of file TCLCommandPackage.h.\par
\par
References m_lCommands, m_sSignon, and CTCLInterpreterObject::operator==().}
{\xe \v Register\:CTCLCommandPackage}
{\xe \v CTCLCommandPackage\:Register}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLCommandPackage::Register ()}
}\par
{\bkmkstart classCTCLCommandPackage_a8}
{\bkmkend classCTCLCommandPackage_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 324 of file TCLCommandPackage.cpp.\par
\par
References begin(), CommandListIterator, end(), and CTCLInterpreterObject::getInterpreter().}
{\xe \v setCommandList\:CTCLCommandPackage}
{\xe \v CTCLCommandPackage\:setCommandList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLCommandPackage::setCommandList ({\b CommandList} & {\i rList}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCTCLCommandPackage_b1}
{\bkmkend classCTCLCommandPackage_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 396 of file TCLCommandPackage.h.\par
\par
References CommandList, and m_lCommands.}
{\xe \v setSignon\:CTCLCommandPackage}
{\xe \v CTCLCommandPackage\:setSignon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLCommandPackage::setSignon (std::string {\i am_sSignon}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCTCLCommandPackage_b0}
{\bkmkend classCTCLCommandPackage_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 392 of file TCLCommandPackage.h.\par
\par
References m_sSignon.}
{\xe \v Unregister\:CTCLCommandPackage}
{\xe \v CTCLCommandPackage\:Unregister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLCommandPackage::Unregister ()}
}\par
{\bkmkstart classCTCLCommandPackage_a9}
{\bkmkend classCTCLCommandPackage_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 348 of file TCLCommandPackage.cpp.\par
\par
References begin(), CommandListIterator, and end().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_lCommands\:CTCLCommandPackage}
{\xe \v CTCLCommandPackage\:m_lCommands}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CommandList} CTCLCommandPackage::m_lCommands{\f2  [private]}}
}\par
{\bkmkstart classCTCLCommandPackage_o1}
{\bkmkend classCTCLCommandPackage_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 331 of file TCLCommandPackage.h.\par
\par
Referenced by AddProcessor(), AddProcessors(), begin(), CTCLCommandPackage(), end(), getCommandList(), operator=(), operator==(), and setCommandList().}
{\xe \v m_sSignon\:CTCLCommandPackage}
{\xe \v CTCLCommandPackage\:m_sSignon}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string CTCLCommandPackage::m_sSignon{\f2  [private]}}
}\par
{\bkmkstart classCTCLCommandPackage_o0}
{\bkmkend classCTCLCommandPackage_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 330 of file TCLCommandPackage.h.\par
\par
Referenced by CTCLCommandPackage(), getSignon(), operator=(), operator==(), and setSignon().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TCLCommandPackage.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TCLCommandPackage.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCLException  Class Reference\par \pard\plain 
{\tc\tcl2 \v CTCLException}
{\xe \v CTCLException}
{\bkmkstart classCTCLException}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <TCLException.h>}\par
Inheritance diagram for CTCLException:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCTCLException.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLException} ({\b CTCLInterpreter} &am_rInterpreter, {\b Int_t} am_nReason, const char *pString)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLException} ({\b CTCLInterpreter} &am_rInterpreter, {\b Int_t} am_nReason, const std::string &rString)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CTCLException} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLException} (const CTCLException &aCTCLException)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLException {\b operator=} (const CTCLException &aCTCLException)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CTCLException &aCTCLException)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Int_t} {\b getReason} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddErrorInfo} (const char *pMessage)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddErrorInfo} (const string &rMessage)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddErrorInfo} (const {\b CTCLString} &rMessage)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetErrorCode} (const char *pMessage, const char *pMnemonic="???", const char *pFacility="TCL", const char *pSeverity="FATAL")\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetErrorCode} (const string rMessage, const string &rMnemonic=string("???"), const string &rFacility=string("TCL"), const string &rSeverity=string("FATAL"))\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLResult} {\b GetResult} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const char * {\b ReasonText} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Int_t} {\b ReasonCode} () const\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setInterpreter} ({\b CTCLInterpreter} &am_rInterpreter)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setReason} ({\b Int_t} am_nReason)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Int_t} {\b m_nReason}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CTCLException\:CTCLException}
{\xe \v CTCLException\:CTCLException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLException::CTCLException ({\b CTCLInterpreter} & {\i am_rInterpreter}, {\b Int_t} {\i am_nReason}, const char * {\i pString}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLException_a0}
{\bkmkend classCTCLException_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 331 of file TCLException.h.\par
\par
References Int_t, and m_nReason.}
{\xe \v CTCLException\:CTCLException}
{\xe \v CTCLException\:CTCLException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLException::CTCLException ({\b CTCLInterpreter} & {\i am_rInterpreter}, {\b Int_t} {\i am_nReason}, const std::string & {\i rString}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLException_a1}
{\bkmkend classCTCLException_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 339 of file TCLException.h.\par
\par
References Int_t, and m_nReason.}
{\xe \v ~CTCLException\:CTCLException}
{\xe \v CTCLException\:~CTCLException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual CTCLException::~CTCLException (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCTCLException_a2}
{\bkmkend classCTCLException_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 347 of file TCLException.h.\par
}
{\xe \v CTCLException\:CTCLException}
{\xe \v CTCLException\:CTCLException}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLException::CTCLException (const CTCLException & {\i aCTCLException}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLException_a3}
{\bkmkend classCTCLException_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 351 of file TCLException.h.\par
\par
References m_nReason.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddErrorInfo\:CTCLException}
{\xe \v CTCLException\:AddErrorInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLException::AddErrorInfo (const {\b CTCLString} & {\i rMessage}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLException_a9}
{\bkmkend classCTCLException_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 410 of file TCLException.h.\par
\par
References AddErrorInfo().}
{\xe \v AddErrorInfo\:CTCLException}
{\xe \v CTCLException\:AddErrorInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLException::AddErrorInfo (const string & {\i rMessage}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLException_a8}
{\bkmkend classCTCLException_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 407 of file TCLException.h.\par
\par
References AddErrorInfo().}
{\xe \v AddErrorInfo\:CTCLException}
{\xe \v CTCLException\:AddErrorInfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLException::AddErrorInfo (const char * {\i pMessage})}
}\par
{\bkmkstart classCTCLException_a7}
{\bkmkend classCTCLException_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 313 of file TCLException.cpp.\par
\par
References CTCLInterpreter::getInterpreter(), and CTCLInterpreterObject::getInterpreter().\par
Referenced by AddErrorInfo().}
{\xe \v getReason\:CTCLException}
{\xe \v CTCLException\:getReason}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Int_t} CTCLException::getReason () const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLException_a6}
{\bkmkend classCTCLException_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 385 of file TCLException.h.\par
\par
References Int_t, and m_nReason.\par
Referenced by ReasonCode().}
{\xe \v GetResult\:CTCLException}
{\xe \v CTCLException\:GetResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CTCLResult} CTCLException::GetResult () const}
}\par
{\bkmkstart classCTCLException_a12}
{\bkmkend classCTCLException_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 407 of file TCLException.cpp.\par
\par
References CTCLInterpreterObject::getInterpreter().\par
Referenced by ReasonText().}
{\xe \v operator=\:CTCLException}
{\xe \v CTCLException\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLException CTCLException::operator= (const CTCLException & {\i aCTCLException}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLException_a4}
{\bkmkend classCTCLException_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 360 of file TCLException.h.\par
\par
References m_nReason, CException::operator=(), and CTCLInterpreterObject::operator=().}
{\xe \v operator==\:CTCLException}
{\xe \v CTCLException\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLException::operator== (const CTCLException & {\i aCTCLException}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLException_a5}
{\bkmkend classCTCLException_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 373 of file TCLException.h.\par
\par
References m_nReason, CException::operator==(), and CTCLInterpreterObject::operator==().}
{\xe \v ReasonCode\:CTCLException}
{\xe \v CTCLException\:ReasonCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Int_t} CTCLException::ReasonCode () const{\f2  [virtual]}}
}\par
{\bkmkstart classCTCLException_a14}
{\bkmkend classCTCLException_a14}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns a code which describes the reason for the exception . This is exception type specific and may be used to do detailed exception analysis and recovery. For example in the {\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) class, the errno at the time of instantiation of the object is returned. The default returns -1 \par
\par
Reimplemented from {\b CException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCException_a9 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 390 of file TCLException.cpp.\par
\par
References getReason().}
{\xe \v ReasonText\:CTCLException}
{\xe \v CTCLException\:ReasonText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * CTCLException::ReasonText () const{\f2  [virtual]}}
}\par
{\bkmkstart classCTCLException_a13}
{\bkmkend classCTCLException_a13}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns a const pointer to text which describes the reason the exception was thrown. This is exception type specific. The default action returns a pointer to the constant string: "Unspecified Exception" \par
\par
Reimplemented from {\b CException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCException_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 374 of file TCLException.cpp.\par
\par
References GetResult().}
{\xe \v SetErrorCode\:CTCLException}
{\xe \v CTCLException\:SetErrorCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLException::SetErrorCode (const string {\i rMessage}, const string & {\i rMnemonic} = string("???"), const string & {\i rFacility} = string("TCL"), const string & {\i rSeverity} = string("FATAL")){\f2  [inline]}}
}\par
{\bkmkstart classCTCLException_a11}
{\bkmkend classCTCLException_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 418 of file TCLException.h.\par
\par
References SetErrorCode().}
{\xe \v SetErrorCode\:CTCLException}
{\xe \v CTCLException\:SetErrorCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLException::SetErrorCode (const char * {\i pMessage}, const char * {\i pMnemonic} = "???", const char * {\i pFacility} = "TCL", const char * {\i pSeverity} = "FATAL")}
}\par
{\bkmkstart classCTCLException_a10}
{\bkmkend classCTCLException_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 339 of file TCLException.cpp.\par
\par
References CTCLInterpreter::getInterpreter(), and CTCLInterpreterObject::getInterpreter().\par
Referenced by SetErrorCode().}
{\xe \v setInterpreter\:CTCLException}
{\xe \v CTCLException\:setInterpreter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLException::setInterpreter ({\b CTCLInterpreter} & {\i am_rInterpreter}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCTCLException_b0}
{\bkmkend classCTCLException_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 395 of file TCLException.h.\par
\par
References CTCLInterpreterObject::Bind().}
{\xe \v setReason\:CTCLException}
{\xe \v CTCLException\:setReason}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLException::setReason ({\b Int_t} {\i am_nReason}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCTCLException_b1}
{\bkmkend classCTCLException_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 399 of file TCLException.h.\par
\par
References Int_t, and m_nReason.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_nReason\:CTCLException}
{\xe \v CTCLException\:m_nReason}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Int_t} CTCLException::m_nReason{\f2  [private]}}
}\par
{\bkmkstart classCTCLException_o0}
{\bkmkend classCTCLException_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 321 of file TCLException.h.\par
\par
Referenced by CTCLException(), getReason(), operator=(), operator==(), and setReason().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TCLException.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TCLException.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCLFileHandler  Class Reference\par \pard\plain 
{\tc\tcl2 \v CTCLFileHandler}
{\xe \v CTCLFileHandler}
{\bkmkstart classCTCLFileHandler}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <TCLFileHandler.h>}\par
Inheritance diagram for CTCLFileHandler:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCTCLFileHandler.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLFileHandler} ({\b CTCLInterpreterObject} *pInterp, {\b UInt_t} am_nFid=STDIN_FILENO)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLFileHandler} ({\b CTCLInterpreterObject} *pInterp, FILE *pFile)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLFileHandler} ({\b CTCLInterpreterObject} *pInterp, fstream &rFile)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLFileHandler} ({\b CTCLInterpreter} *pInterp, {\b UInt_t} am_nFid=STDIN_FILENO)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLFileHandler} ({\b CTCLInterpreter} *pInterp, FILE *pFile)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLFileHandler} ({\b CTCLInterpreter} *pInterp, fstream &rFile)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CTCLFileHandler} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLFileHandler} (const CTCLFileHandler &aCTCLFileHandler)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLFileHandler & {\b operator=} (const CTCLFileHandler &aCTCLFileHandler)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CTCLFileHandler &aCTCLFileHandler) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt_t} {\b getFid} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setFid} ({\b UInt_t} am_nFid)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b operator()} (int mask)=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Set} (int mask)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Clear} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b CallbackRelay} (ClientData pObject, int mask)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt_t} {\b m_nFid}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CTCLFileHandler\:CTCLFileHandler}
{\xe \v CTCLFileHandler\:CTCLFileHandler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLFileHandler::CTCLFileHandler ({\b CTCLInterpreterObject} * {\i pInterp}, {\b UInt_t} {\i am_nFid} = STDIN_FILENO){\f2  [inline]}}
}\par
{\bkmkstart classCTCLFileHandler_a0}
{\bkmkend classCTCLFileHandler_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 327 of file TCLFileHandler.h.\par
\par
References CTCLInterpreterObject::getInterpreter(), m_nFid, and UInt_t.}
{\xe \v CTCLFileHandler\:CTCLFileHandler}
{\xe \v CTCLFileHandler\:CTCLFileHandler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLFileHandler::CTCLFileHandler ({\b CTCLInterpreterObject} * {\i pInterp}, FILE * {\i pFile}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLFileHandler_a1}
{\bkmkend classCTCLFileHandler_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 332 of file TCLFileHandler.h.\par
\par
References CTCLInterpreterObject::getInterpreter(), and m_nFid.}
{\xe \v CTCLFileHandler\:CTCLFileHandler}
{\xe \v CTCLFileHandler\:CTCLFileHandler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLFileHandler::CTCLFileHandler ({\b CTCLInterpreterObject} * {\i pInterp}, fstream & {\i rFile}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLFileHandler_a2}
{\bkmkend classCTCLFileHandler_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 337 of file TCLFileHandler.h.\par
\par
References m_nFid.}
{\xe \v CTCLFileHandler\:CTCLFileHandler}
{\xe \v CTCLFileHandler\:CTCLFileHandler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLFileHandler::CTCLFileHandler ({\b CTCLInterpreter} * {\i pInterp}, {\b UInt_t} {\i am_nFid} = STDIN_FILENO){\f2  [inline]}}
}\par
{\bkmkstart classCTCLFileHandler_a3}
{\bkmkend classCTCLFileHandler_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 342 of file TCLFileHandler.h.\par
\par
References m_nFid, and UInt_t.}
{\xe \v CTCLFileHandler\:CTCLFileHandler}
{\xe \v CTCLFileHandler\:CTCLFileHandler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLFileHandler::CTCLFileHandler ({\b CTCLInterpreter} * {\i pInterp}, FILE * {\i pFile}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLFileHandler_a4}
{\bkmkend classCTCLFileHandler_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 347 of file TCLFileHandler.h.\par
\par
References m_nFid.}
{\xe \v CTCLFileHandler\:CTCLFileHandler}
{\xe \v CTCLFileHandler\:CTCLFileHandler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLFileHandler::CTCLFileHandler ({\b CTCLInterpreter} * {\i pInterp}, fstream & {\i rFile}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLFileHandler_a5}
{\bkmkend classCTCLFileHandler_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 352 of file TCLFileHandler.h.\par
\par
References m_nFid.}
{\xe \v ~CTCLFileHandler\:CTCLFileHandler}
{\xe \v CTCLFileHandler\:~CTCLFileHandler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLFileHandler::~CTCLFileHandler (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLFileHandler_a6}
{\bkmkend classCTCLFileHandler_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 357 of file TCLFileHandler.h.\par
\par
References Clear().}
{\xe \v CTCLFileHandler\:CTCLFileHandler}
{\xe \v CTCLFileHandler\:CTCLFileHandler}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLFileHandler::CTCLFileHandler (const CTCLFileHandler & {\i aCTCLFileHandler}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLFileHandler_a7}
{\bkmkend classCTCLFileHandler_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 360 of file TCLFileHandler.h.\par
\par
References m_nFid.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v CallbackRelay\:CTCLFileHandler}
{\xe \v CTCLFileHandler\:CallbackRelay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLFileHandler::CallbackRelay (ClientData {\i pObject}, int {\i mask}){\f2  [static]}}
}\par
{\bkmkstart classCTCLFileHandler_d0}
{\bkmkend classCTCLFileHandler_d0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 321 of file TCLFileHandler.cpp.\par
\par
Referenced by Set().}
{\xe \v Clear\:CTCLFileHandler}
{\xe \v CTCLFileHandler\:Clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLFileHandler::Clear ()}
}\par
{\bkmkstart classCTCLFileHandler_a14}
{\bkmkend classCTCLFileHandler_a14}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 372 of file TCLFileHandler.cpp.\par
\par
References m_nFid.\par
Referenced by ~CTCLFileHandler().}
{\xe \v getFid\:CTCLFileHandler}
{\xe \v CTCLFileHandler\:getFid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt_t} CTCLFileHandler::getFid () const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLFileHandler_a10}
{\bkmkend classCTCLFileHandler_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 388 of file TCLFileHandler.h.\par
\par
References m_nFid, and UInt_t.}
{\xe \v operator()\:CTCLFileHandler}
{\xe \v CTCLFileHandler\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void CTCLFileHandler::operator() (int {\i mask}){\f2  [pure virtual]}}
}\par
{\bkmkstart classCTCLFileHandler_a12}
{\bkmkend classCTCLFileHandler_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator=\:CTCLFileHandler}
{\xe \v CTCLFileHandler\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLFileHandler& CTCLFileHandler::operator= (const CTCLFileHandler & {\i aCTCLFileHandler}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLFileHandler_a8}
{\bkmkend classCTCLFileHandler_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 369 of file TCLFileHandler.h.\par
\par
References m_nFid, and CTCLInterpreterObject::operator=().}
{\xe \v operator==\:CTCLFileHandler}
{\xe \v CTCLFileHandler\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLFileHandler::operator== (const CTCLFileHandler & {\i aCTCLFileHandler}) const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLFileHandler_a9}
{\bkmkend classCTCLFileHandler_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 379 of file TCLFileHandler.h.\par
\par
References m_nFid, and CTCLInterpreterObject::operator==().}
{\xe \v Set\:CTCLFileHandler}
{\xe \v CTCLFileHandler\:Set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLFileHandler::Set (int {\i mask})}
}\par
{\bkmkstart classCTCLFileHandler_a13}
{\bkmkend classCTCLFileHandler_a13}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 348 of file TCLFileHandler.cpp.\par
\par
References CallbackRelay(), and m_nFid.}
{\xe \v setFid\:CTCLFileHandler}
{\xe \v CTCLFileHandler\:setFid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLFileHandler::setFid ({\b UInt_t} {\i am_nFid}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLFileHandler_a11}
{\bkmkend classCTCLFileHandler_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 395 of file TCLFileHandler.h.\par
\par
References m_nFid, and UInt_t.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_nFid\:CTCLFileHandler}
{\xe \v CTCLFileHandler\:m_nFid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt_t} CTCLFileHandler::m_nFid{\f2  [private]}}
}\par
{\bkmkstart classCTCLFileHandler_o0}
{\bkmkend classCTCLFileHandler_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 322 of file TCLFileHandler.h.\par
\par
Referenced by Clear(), CTCLFileHandler(), getFid(), operator=(), operator==(), Set(), and setFid().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TCLFileHandler.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TCLFileHandler.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCLHashTable< T >  Class Template Reference\par \pard\plain 
{\tc\tcl2 \v CTCLHashTable}
{\xe \v CTCLHashTable}
{\bkmkstart classCTCLHashTable}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <TCLHashTable.h>}\par
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLHashTable} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CTCLHashTable} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLHashTable} (Tcl_HashTable am_HashTable)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLHashTable} (const CTCLHashTable &aCTCLHashTable)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLHashTable {\b operator=} (const CTCLHashTable &aCTCLHashTable)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CTCLHashTable &aCTCLHashTable)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Tcl_HashTable * {\b getHashTable} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Enter} (const std::string &rKey, {\b rCTCLTHashTableItem} rValue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b CTCLTHashTableItem} * {\b Find} (const std::string &rsKeyword) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLTHashTableItem} * {\b Delete} (const std::string &rsKeyword)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLTHashTableIterator} {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLTHashTableIterator} {\b end} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Statistics} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setHashTable} (Tcl_HashTable *am_HashTable)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b CTCLHashTableItem}< T > {\b CTCLTHashTableItem}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b CTCLHashTableItem}< T > * {\b pCTCLTHashTableItem}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b CTCLHashTableItem}< T > & {\b rCTCLTHashTableItem}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b CTCLHashTableIterator}< T > {\b CTCLTHashTableIterator}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b CTCLHashTableIterator}< T > * {\b pCTCLTHashTableIterator}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b CTCLHashTableIterator}< T > & {\b rCTCLTHashTableIterator}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Tcl_HashTable {\b m_HashTable}\par
}

{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class T> class CTCLHashTable< T >\par
}

{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v CTCLTHashTableItem\:CTCLHashTable}
{\xe \v CTCLHashTable\:CTCLTHashTableItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> typedef {\b CTCLHashTableItem}<T> CTCLHashTable< T >::CTCLTHashTableItem{\f2  [private]}}
}\par
{\bkmkstart classCTCLHashTable_u0}
{\bkmkend classCTCLHashTable_u0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 327 of file TCLHashTable.h.\par
}
{\xe \v CTCLTHashTableIterator\:CTCLHashTable}
{\xe \v CTCLHashTable\:CTCLTHashTableIterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> typedef {\b CTCLHashTableIterator}<T> CTCLHashTable< T >::CTCLTHashTableIterator{\f2  [private]}}
}\par
{\bkmkstart classCTCLHashTable_u3}
{\bkmkend classCTCLHashTable_u3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 331 of file TCLHashTable.h.\par
}
{\xe \v pCTCLTHashTableItem\:CTCLHashTable}
{\xe \v CTCLHashTable\:pCTCLTHashTableItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> typedef {\b CTCLHashTableItem}<T> * CTCLHashTable< T >::pCTCLTHashTableItem{\f2  [private]}}
}\par
{\bkmkstart classCTCLHashTable_u1}
{\bkmkend classCTCLHashTable_u1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 327 of file TCLHashTable.h.\par
}
{\xe \v pCTCLTHashTableIterator\:CTCLHashTable}
{\xe \v CTCLHashTable\:pCTCLTHashTableIterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> typedef {\b CTCLHashTableIterator}<T> * CTCLHashTable< T >::pCTCLTHashTableIterator{\f2  [private]}}
}\par
{\bkmkstart classCTCLHashTable_u4}
{\bkmkend classCTCLHashTable_u4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 331 of file TCLHashTable.h.\par
}
{\xe \v rCTCLTHashTableItem\:CTCLHashTable}
{\xe \v CTCLHashTable\:rCTCLTHashTableItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> typedef {\b CTCLHashTableItem}<T> & CTCLHashTable< T >::rCTCLTHashTableItem{\f2  [private]}}
}\par
{\bkmkstart classCTCLHashTable_u2}
{\bkmkend classCTCLHashTable_u2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 327 of file TCLHashTable.h.\par
}
{\xe \v rCTCLTHashTableIterator\:CTCLHashTable}
{\xe \v CTCLHashTable\:rCTCLTHashTableIterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> typedef {\b CTCLHashTableIterator}<T> & CTCLHashTable< T >::rCTCLTHashTableIterator{\f2  [private]}}
}\par
{\bkmkstart classCTCLHashTable_u5}
{\bkmkend classCTCLHashTable_u5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 331 of file TCLHashTable.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CTCLHashTable\:CTCLHashTable}
{\xe \v CTCLHashTable\:CTCLHashTable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CTCLHashTable< T >::CTCLHashTable (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLHashTable_a0}
{\bkmkend classCTCLHashTable_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 340 of file TCLHashTable.h.\par
\par
References CTCLHashTable< T >::m_HashTable.}
{\xe \v ~CTCLHashTable\:CTCLHashTable}
{\xe \v CTCLHashTable\:~CTCLHashTable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> virtual CTCLHashTable< T >::~CTCLHashTable (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCTCLHashTable_a1}
{\bkmkend classCTCLHashTable_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 344 of file TCLHashTable.h.\par
}
{\xe \v CTCLHashTable\:CTCLHashTable}
{\xe \v CTCLHashTable\:CTCLHashTable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CTCLHashTable< T >::CTCLHashTable (Tcl_HashTable {\i am_HashTable}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLHashTable_a2}
{\bkmkend classCTCLHashTable_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 349 of file TCLHashTable.h.\par
\par
References CTCLHashTable< T >::m_HashTable.}
{\xe \v CTCLHashTable\:CTCLHashTable}
{\xe \v CTCLHashTable\:CTCLHashTable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CTCLHashTable< T >::CTCLHashTable (const CTCLHashTable< T > & {\i aCTCLHashTable}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLHashTable_a3}
{\bkmkend classCTCLHashTable_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 355 of file TCLHashTable.h.\par
\par
References CTCLHashTable< T >::m_HashTable.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v begin\:CTCLHashTable}
{\xe \v CTCLHashTable\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> {\b CTCLTHashTableIterator} CTCLHashTable< T >::begin (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLHashTable_a10}
{\bkmkend classCTCLHashTable_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 426 of file TCLHashTable.h.\par
}
{\xe \v Delete\:CTCLHashTable}
{\xe \v CTCLHashTable\:Delete}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> {\b CTCLTHashTableItem}* CTCLHashTable< T >::Delete (const std::string & {\i rsKeyword}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLHashTable_a9}
{\bkmkend classCTCLHashTable_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 413 of file TCLHashTable.h.\par
}
{\xe \v end\:CTCLHashTable}
{\xe \v CTCLHashTable\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> {\b CTCLTHashTableIterator} CTCLHashTable< T >::end (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLHashTable_a11}
{\bkmkend classCTCLHashTable_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 431 of file TCLHashTable.h.\par
}
{\xe \v Enter\:CTCLHashTable}
{\xe \v CTCLHashTable\:Enter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CTCLHashTable< T >::Enter (const std::string & {\i rKey}, {\b rCTCLTHashTableItem} {\i rValue}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLHashTable_a7}
{\bkmkend classCTCLHashTable_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 396 of file TCLHashTable.h.\par
\par
References Int_t.}
{\xe \v Find\:CTCLHashTable}
{\xe \v CTCLHashTable\:Find}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> const {\b CTCLTHashTableItem}* CTCLHashTable< T >::Find (const std::string & {\i rsKeyword}) const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLHashTable_a8}
{\bkmkend classCTCLHashTable_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 405 of file TCLHashTable.h.\par
}
{\xe \v getHashTable\:CTCLHashTable}
{\xe \v CTCLHashTable\:getHashTable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> Tcl_HashTable* CTCLHashTable< T >::getHashTable () const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLHashTable_a6}
{\bkmkend classCTCLHashTable_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 381 of file TCLHashTable.h.\par
\par
References CTCLHashTable< T >::m_HashTable.}
{\xe \v operator=\:CTCLHashTable}
{\xe \v CTCLHashTable\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CTCLHashTable CTCLHashTable< T >::operator= (const CTCLHashTable< T > & {\i aCTCLHashTable}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLHashTable_a4}
{\bkmkend classCTCLHashTable_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 362 of file TCLHashTable.h.\par
\par
References CTCLHashTable< T >::m_HashTable.}
{\xe \v operator==\:CTCLHashTable}
{\xe \v CTCLHashTable\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int CTCLHashTable< T >::operator== (const CTCLHashTable< T > & {\i aCTCLHashTable}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLHashTable_a5}
{\bkmkend classCTCLHashTable_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 372 of file TCLHashTable.h.\par
\par
References CTCLHashTable< T >::m_HashTable.}
{\xe \v setHashTable\:CTCLHashTable}
{\xe \v CTCLHashTable\:setHashTable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CTCLHashTable< T >::setHashTable (Tcl_HashTable * {\i am_HashTable}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCTCLHashTable_b0}
{\bkmkend classCTCLHashTable_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 389 of file TCLHashTable.h.\par
\par
References CTCLHashTable< T >::m_HashTable.}
{\xe \v Statistics\:CTCLHashTable}
{\xe \v CTCLHashTable\:Statistics}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> std::string CTCLHashTable< T >::Statistics (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLHashTable_a12}
{\bkmkend classCTCLHashTable_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 438 of file TCLHashTable.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_HashTable\:CTCLHashTable}
{\xe \v CTCLHashTable\:m_HashTable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> Tcl_HashTable CTCLHashTable< T >::m_HashTable{\f2  [private]}}
}\par
{\bkmkstart classCTCLHashTable_o0}
{\bkmkend classCTCLHashTable_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 335 of file TCLHashTable.h.\par
\par
Referenced by CTCLHashTable< T >::CTCLHashTable(), CTCLHashTable< T >::getHashTable(), CTCLHashTable< T >::operator=(), CTCLHashTable< T >::operator==(), and CTCLHashTable< T >::setHashTable().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TCLHashTable.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCLHashTableItem< T >  Class Template Reference\par \pard\plain 
{\tc\tcl2 \v CTCLHashTableItem}
{\xe \v CTCLHashTableItem}
{\bkmkstart classCTCLHashTableItem}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <TCLHashTableItem.h>}\par
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLHashTableItem} (T am_Item)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CTCLHashTableItem} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLHashTableItem} (const CTCLHashTableItem &aCTCLHashTableItem)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLHashTableItem {\b operator=} (const CTCLHashTableItem &aCTCLHashTableItem)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CTCLHashTableItem &aCTCLHashTableItem)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b getItem} () const\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setm_Item} (T am_Item)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T & {\b operator *} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T * {\b operator->} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b m_Item}\par
}

{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class T> class CTCLHashTableItem< T >\par
}

{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CTCLHashTableItem\:CTCLHashTableItem}
{\xe \v CTCLHashTableItem\:CTCLHashTableItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CTCLHashTableItem< T >::CTCLHashTableItem (T {\i am_Item}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLHashTableItem_a0}
{\bkmkend classCTCLHashTableItem_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 307 of file TCLHashTableItem.h.\par
\par
References CTCLHashTableItem< T >::m_Item.}
{\xe \v ~CTCLHashTableItem\:CTCLHashTableItem}
{\xe \v CTCLHashTableItem\:~CTCLHashTableItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> virtual CTCLHashTableItem< T >::~CTCLHashTableItem (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCTCLHashTableItem_a1}
{\bkmkend classCTCLHashTableItem_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 309 of file TCLHashTableItem.h.\par
}
{\xe \v CTCLHashTableItem\:CTCLHashTableItem}
{\xe \v CTCLHashTableItem\:CTCLHashTableItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CTCLHashTableItem< T >::CTCLHashTableItem (const CTCLHashTableItem< T > & {\i aCTCLHashTableItem}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLHashTableItem_a2}
{\bkmkend classCTCLHashTableItem_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 313 of file TCLHashTableItem.h.\par
\par
References CTCLHashTableItem< T >::m_Item.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getItem\:CTCLHashTableItem}
{\xe \v CTCLHashTableItem\:getItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> T CTCLHashTableItem< T >::getItem () const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLHashTableItem_a5}
{\bkmkend classCTCLHashTableItem_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 338 of file TCLHashTableItem.h.\par
\par
References CTCLHashTableItem< T >::m_Item.}
{\xe \v operator *\:CTCLHashTableItem}
{\xe \v CTCLHashTableItem\:operator *}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> T& CTCLHashTableItem< T >::operator * (){\f2  [inline, protected]}}
}\par
{\bkmkstart classCTCLHashTableItem_b1}
{\bkmkend classCTCLHashTableItem_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 350 of file TCLHashTableItem.h.\par
\par
References CTCLHashTableItem< T >::m_Item.}
{\xe \v operator->\:CTCLHashTableItem}
{\xe \v CTCLHashTableItem\:operator->}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> T* CTCLHashTableItem< T >::operator-> (){\f2  [inline, protected]}}
}\par
{\bkmkstart classCTCLHashTableItem_b2}
{\bkmkend classCTCLHashTableItem_b2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 355 of file TCLHashTableItem.h.\par
\par
References CTCLHashTableItem< T >::m_Item.}
{\xe \v operator=\:CTCLHashTableItem}
{\xe \v CTCLHashTableItem\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CTCLHashTableItem CTCLHashTableItem< T >::operator= (const CTCLHashTableItem< T > & {\i aCTCLHashTableItem}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLHashTableItem_a3}
{\bkmkend classCTCLHashTableItem_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 320 of file TCLHashTableItem.h.\par
\par
References CTCLHashTableItem< T >::m_Item.}
{\xe \v operator==\:CTCLHashTableItem}
{\xe \v CTCLHashTableItem\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int CTCLHashTableItem< T >::operator== (const CTCLHashTableItem< T > & {\i aCTCLHashTableItem}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLHashTableItem_a4}
{\bkmkend classCTCLHashTableItem_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 330 of file TCLHashTableItem.h.\par
\par
References CTCLHashTableItem< T >::m_Item.}
{\xe \v setm_Item\:CTCLHashTableItem}
{\xe \v CTCLHashTableItem\:setm_Item}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CTCLHashTableItem< T >::setm_Item (T {\i am_Item}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCTCLHashTableItem_b0}
{\bkmkend classCTCLHashTableItem_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 345 of file TCLHashTableItem.h.\par
\par
References CTCLHashTableItem< T >::m_Item.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_Item\:CTCLHashTableItem}
{\xe \v CTCLHashTableItem\:m_Item}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> T CTCLHashTableItem< T >::m_Item{\f2  [private]}}
}\par
{\bkmkstart classCTCLHashTableItem_o0}
{\bkmkend classCTCLHashTableItem_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 303 of file TCLHashTableItem.h.\par
\par
Referenced by CTCLHashTableItem< T >::CTCLHashTableItem(), CTCLHashTableItem< T >::getItem(), CTCLHashTableItem< T >::operator *(), CTCLHashTableItem< T >::operator->(), CTCLHashTableItem< T >::operator=(), CTCLHashTableItem< T >::operator==(), and CTCLHashTableItem< T >::setm_Item().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TCLHashTableItem.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCLHashTableIterator< T >  Class Template Reference\par \pard\plain 
{\tc\tcl2 \v CTCLHashTableIterator}
{\xe \v CTCLHashTableIterator}
{\bkmkstart classCTCLHashTableIterator}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <TCLHashTableIterator.h>}\par
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLHashTableIterator} (Tcl_HashTable *pTable)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CTCLHashTableIterator} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLHashTableIterator} (const CTCLHashTableIterator &aCTCLHashTableIterator)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLHashTableIterator {\b operator=} (const CTCLHashTableIterator &aCTCLHashTableIterator)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CTCLHashTableIterator &aCTCLHashTableIterator)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Tcl_HashSearch {\b getContext} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLHashTableItem}< T > * {\b getCurrentEntry} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Tcl_HashTable * {\b getHashTable} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setContext} (Tcl_HashSearch am_Context)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setCurrentEntry} ({\b CTCLHashTableItem}< T > *am_pCurrentEntry)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setHashTable} (Tcl_HashTable *am_pHashTable)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLHashTableIterator & {\b operator++} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLHashTableIterator {\b operator++} (int i)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLHashTableItem}< T > & {\b operator *} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLHashTableItem}< T > * {\b operator->} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Initialize} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b CTCLHashTableItem}< T > {\b CTCLTHashTableItem}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b CTCLHashTableItem}< T > * {\b pCTCLTHashTableItem}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Tcl_HashSearch {\b m_Context}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b pCTCLTHashTableItem} {\b m_pCurrentEntry}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Tcl_HashTable * {\b m_pHashTable}\par
}

{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class T> class CTCLHashTableIterator< T >\par
}

{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v CTCLTHashTableItem\:CTCLHashTableIterator}
{\xe \v CTCLHashTableIterator\:CTCLTHashTableItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> typedef {\b CTCLHashTableItem}<T> CTCLHashTableIterator< T >::CTCLTHashTableItem{\f2  [private]}}
}\par
{\bkmkstart classCTCLHashTableIterator_u0}
{\bkmkend classCTCLHashTableIterator_u0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 313 of file TCLHashTableIterator.h.\par
}
{\xe \v pCTCLTHashTableItem\:CTCLHashTableIterator}
{\xe \v CTCLHashTableIterator\:pCTCLTHashTableItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> typedef {\b CTCLHashTableItem}<T> * CTCLHashTableIterator< T >::pCTCLTHashTableItem{\f2  [private]}}
}\par
{\bkmkstart classCTCLHashTableIterator_u1}
{\bkmkend classCTCLHashTableIterator_u1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 313 of file TCLHashTableIterator.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CTCLHashTableIterator\:CTCLHashTableIterator}
{\xe \v CTCLHashTableIterator\:CTCLHashTableIterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CTCLHashTableIterator< T >::CTCLHashTableIterator (Tcl_HashTable * {\i pTable}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLHashTableIterator_a0}
{\bkmkend classCTCLHashTableIterator_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 323 of file TCLHashTableIterator.h.\par
\par
References CTCLHashTableIterator< T >::Initialize(), and CTCLHashTableIterator< T >::m_pHashTable.}
{\xe \v ~CTCLHashTableIterator\:CTCLHashTableIterator}
{\xe \v CTCLHashTableIterator\:~CTCLHashTableIterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> virtual CTCLHashTableIterator< T >::~CTCLHashTableIterator (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCTCLHashTableIterator_a1}
{\bkmkend classCTCLHashTableIterator_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 329 of file TCLHashTableIterator.h.\par
}
{\xe \v CTCLHashTableIterator\:CTCLHashTableIterator}
{\xe \v CTCLHashTableIterator\:CTCLHashTableIterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CTCLHashTableIterator< T >::CTCLHashTableIterator (const CTCLHashTableIterator< T > & {\i aCTCLHashTableIterator}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLHashTableIterator_a2}
{\bkmkend classCTCLHashTableIterator_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 333 of file TCLHashTableIterator.h.\par
\par
References CTCLHashTableIterator< T >::m_Context, CTCLHashTableIterator< T >::m_pCurrentEntry, and CTCLHashTableIterator< T >::m_pHashTable.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getContext\:CTCLHashTableIterator}
{\xe \v CTCLHashTableIterator\:getContext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> Tcl_HashSearch CTCLHashTableIterator< T >::getContext () const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLHashTableIterator_a5}
{\bkmkend classCTCLHashTableIterator_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 366 of file TCLHashTableIterator.h.\par
\par
References CTCLHashTableIterator< T >::m_Context.}
{\xe \v getCurrentEntry\:CTCLHashTableIterator}
{\xe \v CTCLHashTableIterator\:getCurrentEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> {\b CTCLHashTableItem}<T>* CTCLHashTableIterator< T >::getCurrentEntry () const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLHashTableIterator_a6}
{\bkmkend classCTCLHashTableIterator_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 372 of file TCLHashTableIterator.h.\par
}
{\xe \v getHashTable\:CTCLHashTableIterator}
{\xe \v CTCLHashTableIterator\:getHashTable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> Tcl_HashTable* CTCLHashTableIterator< T >::getHashTable () const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLHashTableIterator_a7}
{\bkmkend classCTCLHashTableIterator_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 376 of file TCLHashTableIterator.h.\par
\par
References CTCLHashTableIterator< T >::m_pHashTable.}
{\xe \v Initialize\:CTCLHashTableIterator}
{\xe \v CTCLHashTableIterator\:Initialize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CTCLHashTableIterator< T >::Initialize (){\f2  [inline, protected]}}
}\par
{\bkmkstart classCTCLHashTableIterator_b0}
{\bkmkend classCTCLHashTableIterator_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 425 of file TCLHashTableIterator.h.\par
\par
Referenced by CTCLHashTableIterator< T >::CTCLHashTableIterator().}
{\xe \v operator *\:CTCLHashTableIterator}
{\xe \v CTCLHashTableIterator\:operator *}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> {\b CTCLHashTableItem}<T>& CTCLHashTableIterator< T >::operator * (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLHashTableIterator_a13}
{\bkmkend classCTCLHashTableIterator_a13}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 415 of file TCLHashTableIterator.h.\par
}
{\xe \v operator++\:CTCLHashTableIterator}
{\xe \v CTCLHashTableIterator\:operator++}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CTCLHashTableIterator CTCLHashTableIterator< T >::operator++ (int {\i i}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLHashTableIterator_a12}
{\bkmkend classCTCLHashTableIterator_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 409 of file TCLHashTableIterator.h.\par
}
{\xe \v operator++\:CTCLHashTableIterator}
{\xe \v CTCLHashTableIterator\:operator++}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CTCLHashTableIterator& CTCLHashTableIterator< T >::operator++ (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLHashTableIterator_a11}
{\bkmkend classCTCLHashTableIterator_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 405 of file TCLHashTableIterator.h.\par
\par
References CTCLHashTableIterator< T >::m_Context.}
{\xe \v operator->\:CTCLHashTableIterator}
{\xe \v CTCLHashTableIterator\:operator->}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> {\b CTCLHashTableItem}<T>* CTCLHashTableIterator< T >::operator-> (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLHashTableIterator_a14}
{\bkmkend classCTCLHashTableIterator_a14}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 418 of file TCLHashTableIterator.h.\par
}
{\xe \v operator=\:CTCLHashTableIterator}
{\xe \v CTCLHashTableIterator\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CTCLHashTableIterator CTCLHashTableIterator< T >::operator= (const CTCLHashTableIterator< T > & {\i aCTCLHashTableIterator}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLHashTableIterator_a3}
{\bkmkend classCTCLHashTableIterator_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 344 of file TCLHashTableIterator.h.\par
\par
References CTCLHashTableIterator< T >::m_Context, and CTCLHashTableIterator< T >::m_pHashTable.}
{\xe \v operator==\:CTCLHashTableIterator}
{\xe \v CTCLHashTableIterator\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int CTCLHashTableIterator< T >::operator== (const CTCLHashTableIterator< T > & {\i aCTCLHashTableIterator}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLHashTableIterator_a4}
{\bkmkend classCTCLHashTableIterator_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 356 of file TCLHashTableIterator.h.\par
\par
References CTCLHashTableIterator< T >::m_pCurrentEntry, and CTCLHashTableIterator< T >::m_pHashTable.}
{\xe \v setContext\:CTCLHashTableIterator}
{\xe \v CTCLHashTableIterator\:setContext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CTCLHashTableIterator< T >::setContext (Tcl_HashSearch {\i am_Context}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLHashTableIterator_a8}
{\bkmkend classCTCLHashTableIterator_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 384 of file TCLHashTableIterator.h.\par
\par
References CTCLHashTableIterator< T >::m_Context.}
{\xe \v setCurrentEntry\:CTCLHashTableIterator}
{\xe \v CTCLHashTableIterator\:setCurrentEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CTCLHashTableIterator< T >::setCurrentEntry ({\b CTCLHashTableItem}< T > * {\i am_pCurrentEntry}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLHashTableIterator_a9}
{\bkmkend classCTCLHashTableIterator_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 391 of file TCLHashTableIterator.h.\par
}
{\xe \v setHashTable\:CTCLHashTableIterator}
{\xe \v CTCLHashTableIterator\:setHashTable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CTCLHashTableIterator< T >::setHashTable (Tcl_HashTable * {\i am_pHashTable}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLHashTableIterator_a10}
{\bkmkend classCTCLHashTableIterator_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 397 of file TCLHashTableIterator.h.\par
\par
References CTCLHashTableIterator< T >::m_pHashTable.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_Context\:CTCLHashTableIterator}
{\xe \v CTCLHashTableIterator\:m_Context}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> Tcl_HashSearch CTCLHashTableIterator< T >::m_Context{\f2  [private]}}
}\par
{\bkmkstart classCTCLHashTableIterator_o0}
{\bkmkend classCTCLHashTableIterator_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 315 of file TCLHashTableIterator.h.\par
\par
Referenced by CTCLHashTableIterator< T >::CTCLHashTableIterator(), CTCLHashTableIterator< T >::getContext(), CTCLHashTableIterator< T >::operator++(), CTCLHashTableIterator< T >::operator=(), and CTCLHashTableIterator< T >::setContext().}
{\xe \v m_pCurrentEntry\:CTCLHashTableIterator}
{\xe \v CTCLHashTableIterator\:m_pCurrentEntry}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> {\b pCTCLTHashTableItem} CTCLHashTableIterator< T >::m_pCurrentEntry{\f2  [private]}}
}\par
{\bkmkstart classCTCLHashTableIterator_o1}
{\bkmkend classCTCLHashTableIterator_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 316 of file TCLHashTableIterator.h.\par
\par
Referenced by CTCLHashTableIterator< T >::CTCLHashTableIterator(), and CTCLHashTableIterator< T >::operator==().}
{\xe \v m_pHashTable\:CTCLHashTableIterator}
{\xe \v CTCLHashTableIterator\:m_pHashTable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> Tcl_HashTable* CTCLHashTableIterator< T >::m_pHashTable{\f2  [private]}}
}\par
{\bkmkstart classCTCLHashTableIterator_o2}
{\bkmkend classCTCLHashTableIterator_o2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 317 of file TCLHashTableIterator.h.\par
\par
Referenced by CTCLHashTableIterator< T >::CTCLHashTableIterator(), CTCLHashTableIterator< T >::getHashTable(), CTCLHashTableIterator< T >::operator=(), CTCLHashTableIterator< T >::operator==(), and CTCLHashTableIterator< T >::setHashTable().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TCLHashTableIterator.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCLIdleProcess  Class Reference\par \pard\plain 
{\tc\tcl2 \v CTCLIdleProcess}
{\xe \v CTCLIdleProcess}
{\bkmkstart classCTCLIdleProcess}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <TCLIdleProcess.h>}\par
Inheritance diagram for CTCLIdleProcess:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCTCLIdleProcess.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLIdleProcess} ({\b CTCLInterpreterObject} *pInterp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLIdleProcess} ({\b CTCLInterpreter} *pInterp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CTCLIdleProcess} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CTCLIdleProcess &rRhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Set} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Clear} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b operator()} ()=0\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLIdleProcess} (const CTCLIdleProcess &rRhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLIdleProcess & {\b operator=} (const CTCLIdleProcess &rRhs)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CTCLIdleProcess\:CTCLIdleProcess}
{\xe \v CTCLIdleProcess\:CTCLIdleProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLIdleProcess::CTCLIdleProcess ({\b CTCLInterpreterObject} * {\i pInterp}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLIdleProcess_a0}
{\bkmkend classCTCLIdleProcess_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 327 of file TCLIdleProcess.h.\par
\par
References CTCLInterpreterObject::getInterpreter().}
{\xe \v CTCLIdleProcess\:CTCLIdleProcess}
{\xe \v CTCLIdleProcess\:CTCLIdleProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLIdleProcess::CTCLIdleProcess ({\b CTCLInterpreter} * {\i pInterp}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLIdleProcess_a1}
{\bkmkend classCTCLIdleProcess_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 330 of file TCLIdleProcess.h.\par
}
{\xe \v ~CTCLIdleProcess\:CTCLIdleProcess}
{\xe \v CTCLIdleProcess\:~CTCLIdleProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual CTCLIdleProcess::~CTCLIdleProcess (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCTCLIdleProcess_a2}
{\bkmkend classCTCLIdleProcess_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 333 of file TCLIdleProcess.h.\par
}
{\xe \v CTCLIdleProcess\:CTCLIdleProcess}
{\xe \v CTCLIdleProcess\:CTCLIdleProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLIdleProcess::CTCLIdleProcess (const CTCLIdleProcess & {\i rRhs}){\f2  [private]}}
}\par
{\bkmkstart classCTCLIdleProcess_c0}
{\bkmkend classCTCLIdleProcess_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Clear\:CTCLIdleProcess}
{\xe \v CTCLIdleProcess\:Clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLIdleProcess::Clear (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLIdleProcess_a5}
{\bkmkend classCTCLIdleProcess_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Reimplemented from {\b CTCLTimer} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCLTimer_a9 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 358 of file TCLIdleProcess.h.\par
\par
References CTCLTimer::Clear().}
{\xe \v operator()\:CTCLIdleProcess}
{\xe \v CTCLIdleProcess\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void CTCLIdleProcess::operator() (){\f2  [pure virtual]}}
}\par
{\bkmkstart classCTCLIdleProcess_a6}
{\bkmkend classCTCLIdleProcess_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Implements {\b CTCLTimer} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCLTimer_a6 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
}
{\xe \v operator=\:CTCLIdleProcess}
{\xe \v CTCLIdleProcess\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLIdleProcess& CTCLIdleProcess::operator= (const CTCLIdleProcess & {\i rRhs}){\f2  [private]}}
}\par
{\bkmkstart classCTCLIdleProcess_c1}
{\bkmkend classCTCLIdleProcess_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:CTCLIdleProcess}
{\xe \v CTCLIdleProcess\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLIdleProcess::operator== (const CTCLIdleProcess & {\i rRhs}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLIdleProcess_a3}
{\bkmkend classCTCLIdleProcess_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 349 of file TCLIdleProcess.h.\par
\par
References CTCLInterpreterObject::operator==().}
{\xe \v Set\:CTCLIdleProcess}
{\xe \v CTCLIdleProcess\:Set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLIdleProcess::Set (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLIdleProcess_a4}
{\bkmkend classCTCLIdleProcess_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Reimplemented from {\b CTCLTimer} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCLTimer_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 355 of file TCLIdleProcess.h.\par
\par
References CTCLTimer::Set().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TCLIdleProcess.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCLInterpreter  Class Reference\par \pard\plain 
{\tc\tcl2 \v CTCLInterpreter}
{\xe \v CTCLInterpreter}
{\bkmkstart classCTCLInterpreter}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <TCLInterpreter.h>}\par
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLInterpreter} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CTCLInterpreter} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLInterpreter} (Tcl_Interp *am_pInterpreter)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CTCLInterpreter &aCTCLInterpreter)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Tcl_Interp * {\b getInterpreter} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Eval} (const char *pScript)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Eval} (const {\b CTCLString} &rScript)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b Eval} (const std::string &rScript)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b EvalFile} (const char *pFilename)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b EvalFile} (const {\b CTCLString} &rFilename)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b EvalFile} (const std::string &rFilename)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b GlobalEval} (const char *pScript)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b GlobalEval} (const {\b CTCLString} &rScript)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b GlobalEval} (const std::string &rScript)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b RecordAndEval} (const char *pScript, {\b Bool_t} fEval={\b kfFALSE})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b RecordAndEval} (const {\b CTCLString} &rScript, {\b Bool_t} fEval={\b kfFALSE})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b RecordAndEval} (const std::string &rScript, {\b Bool_t} fEval={\b kfFALSE})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b ExprString} (const char *pExpression)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b ExprString} (const {\b CTCLString} &rExpr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b ExprString} (const std::string &rExpr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Long_t} {\b ExprLong} (const char *pExpression)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Long_t} {\b ExprLong} (std::string &rExpression)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Long_t} {\b ExprLong} (const {\b CTCLString} &rExpr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DFloat_t} {\b ExprDouble} (const char *pExpression)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DFloat_t} {\b ExprDouble} (const {\b CTCLString} &rExpression)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b DFloat_t} {\b ExprDouble} (const std::string &rExpression)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Bool_t} {\b ExprBoolean} (const char *pExpression)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Bool_t} {\b ExprBoolean} (const {\b CTCLString} &rExpression)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Bool_t} {\b ExprBoolean} (const std::string &rExpression)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b TildeSubst} (const char *pFilename) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b TildeSubst} (const {\b CTCLString} &rName) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b TildeSubst} (const std::string &rName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b PosixError} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DetachProcess} (const std::vector< {\b UInt_t} > &rPids) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DetachProcess} ({\b UInt_t} nPids, {\b Int_t} *pPids) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ReapDetachedProcesses} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddCommand} (const char *pCommandName, Tcl_CmdProc *pCommandProcessor, ClientData pData, Tcl_CmdDeleteProc *pDeleteProcessor=(Tcl_CmdDeleteProc *) {\b kpNULL}) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddCommand} (const std::string &rCommandName, Tcl_CmdProc *pCommandProcessor, ClientData pData, Tcl_CmdDeleteProc *pDeleteProcessor=(Tcl_CmdDeleteProc *) {\b kpNULL}) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddCommand} (const {\b CTCLString} &rCommandName, Tcl_CmdProc *pCommandProcessor, ClientData pData, Tcl_CmdDeleteProc *pDeleteProcessor=(Tcl_CmdDeleteProc *) {\b kpNULL}) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnregisterCommand} (const char *pCommandName) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnregisterCommand} (const std::string &rCommandName) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnregisterCommand} (const {\b CTCLString} &rCommandName) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b GetResultString} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Tcl_Interp * {\b operator->} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator Tcl_Interp *} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b ErrnoId} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b SignalId} ({\b UInt_t} nSignal)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b SignalMsg} ({\b UInt_t} nSignal)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setInterpreter} (Tcl_Interp *am_pInterpreter)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLInterpreter} (const CTCLInterpreter &aCTCLInterpreter)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLInterpreter {\b operator=} (const CTCLInterpreter &aCTCLInterpreter)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Tcl_Interp * {\b m_pInterpreter}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CTCLInterpreter\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:CTCLInterpreter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLInterpreter::CTCLInterpreter (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreter_a0}
{\bkmkend classCTCLInterpreter_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 332 of file TCLInterpreter.h.\par
\par
References m_pInterpreter.}
{\xe \v ~CTCLInterpreter\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:~CTCLInterpreter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual CTCLInterpreter::~CTCLInterpreter (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCTCLInterpreter_a1}
{\bkmkend classCTCLInterpreter_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 336 of file TCLInterpreter.h.\par
\par
References m_pInterpreter.}
{\xe \v CTCLInterpreter\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:CTCLInterpreter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLInterpreter::CTCLInterpreter (Tcl_Interp * {\i am_pInterpreter}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreter_a2}
{\bkmkend classCTCLInterpreter_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 341 of file TCLInterpreter.h.\par
\par
References m_pInterpreter.}
{\xe \v CTCLInterpreter\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:CTCLInterpreter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLInterpreter::CTCLInterpreter (const CTCLInterpreter & {\i aCTCLInterpreter}){\f2  [private]}}
}\par
{\bkmkstart classCTCLInterpreter_c0}
{\bkmkend classCTCLInterpreter_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddCommand\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:AddCommand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLInterpreter::AddCommand (const {\b CTCLString} & {\i rCommandName}, Tcl_CmdProc * {\i pCommandProcessor}, ClientData {\i pData}, Tcl_CmdDeleteProc * {\i pDeleteProcessor} = (Tcl_CmdDeleteProc*){\b kpNULL}) const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreter_a38}
{\bkmkend classCTCLInterpreter_a38}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 490 of file TCLInterpreter.h.\par
\par
References AddCommand().}
{\xe \v AddCommand\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:AddCommand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLInterpreter::AddCommand (const std::string & {\i rCommandName}, Tcl_CmdProc * {\i pCommandProcessor}, ClientData {\i pData}, Tcl_CmdDeleteProc * {\i pDeleteProcessor} = (Tcl_CmdDeleteProc*){\b kpNULL}) const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreter_a37}
{\bkmkend classCTCLInterpreter_a37}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 482 of file TCLInterpreter.h.\par
\par
References AddCommand().}
{\xe \v AddCommand\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:AddCommand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLInterpreter::AddCommand (const char * {\i pCommandName}, Tcl_CmdProc * {\i pCommandProcessor}, ClientData {\i pData}, Tcl_CmdDeleteProc * {\i pDeleteProcessor} = (Tcl_CmdDeleteProc *) {\b kpNULL}) const}
}\par
{\bkmkstart classCTCLInterpreter_a36}
{\bkmkend classCTCLInterpreter_a36}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 723 of file TCLInterpreter.cpp.\par
\par
References m_pInterpreter.\par
Referenced by AddCommand(), CTCLProcessor::Register(), and CDAQTCLProcessor::Register().}
{\xe \v DetachProcess\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:DetachProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLInterpreter::DetachProcess ({\b UInt_t} {\i nPids}, {\b Int_t} * {\i pPids}) const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreter_a34}
{\bkmkend classCTCLInterpreter_a34}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 471 of file TCLInterpreter.h.\par
\par
References Int_t, and UInt_t.}
{\xe \v DetachProcess\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:DetachProcess}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLInterpreter::DetachProcess (const std::vector< {\b UInt_t} > & {\i rPids}) const}
}\par
{\bkmkstart classCTCLInterpreter_a33}
{\bkmkend classCTCLInterpreter_a33}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 687 of file TCLInterpreter.cpp.\par
\par
References Int_t, and UInt_t.}
{\xe \v ErrnoId\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:ErrnoId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string CTCLInterpreter::ErrnoId (){\f2  [static]}}
}\par
{\bkmkstart classCTCLInterpreter_d0}
{\bkmkend classCTCLInterpreter_d0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 631 of file TCLInterpreter.cpp.\par
}
{\xe \v Eval\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:Eval}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string CTCLInterpreter::Eval (const std::string & {\i rScript}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreter_a7}
{\bkmkend classCTCLInterpreter_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 385 of file TCLInterpreter.h.\par
\par
References Eval().}
{\xe \v Eval\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:Eval}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string CTCLInterpreter::Eval (const {\b CTCLString} & {\i rScript}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreter_a6}
{\bkmkend classCTCLInterpreter_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 382 of file TCLInterpreter.h.\par
\par
References Eval().}
{\xe \v Eval\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:Eval}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string CTCLInterpreter::Eval (const char * {\i pScript})}
}\par
{\bkmkstart classCTCLInterpreter_a5}
{\bkmkend classCTCLInterpreter_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 321 of file TCLInterpreter.cpp.\par
\par
References m_pInterpreter.\par
Referenced by Eval(), and CTCLSynchronizeCommand::operator()().}
{\xe \v EvalFile\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:EvalFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string CTCLInterpreter::EvalFile (const std::string & {\i rFilename}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreter_a10}
{\bkmkend classCTCLInterpreter_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 395 of file TCLInterpreter.h.\par
\par
References EvalFile().}
{\xe \v EvalFile\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:EvalFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string CTCLInterpreter::EvalFile (const {\b CTCLString} & {\i rFilename}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreter_a9}
{\bkmkend classCTCLInterpreter_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 392 of file TCLInterpreter.h.\par
\par
References EvalFile().}
{\xe \v EvalFile\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:EvalFile}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string CTCLInterpreter::EvalFile (const char * {\i pFilename})}
}\par
{\bkmkstart classCTCLInterpreter_a8}
{\bkmkend classCTCLInterpreter_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 356 of file TCLInterpreter.cpp.\par
\par
References m_pInterpreter.\par
Referenced by EvalFile().}
{\xe \v ExprBoolean\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:ExprBoolean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Bool_t} CTCLInterpreter::ExprBoolean (const std::string & {\i rExpression}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreter_a28}
{\bkmkend classCTCLInterpreter_a28}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 453 of file TCLInterpreter.h.\par
\par
References Bool_t, and ExprBoolean().}
{\xe \v ExprBoolean\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:ExprBoolean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Bool_t} CTCLInterpreter::ExprBoolean (const {\b CTCLString} & {\i rExpression}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreter_a27}
{\bkmkend classCTCLInterpreter_a27}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 450 of file TCLInterpreter.h.\par
\par
References Bool_t, and ExprBoolean().}
{\xe \v ExprBoolean\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:ExprBoolean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Bool_t} CTCLInterpreter::ExprBoolean (const char * {\i pExpression})}
}\par
{\bkmkstart classCTCLInterpreter_a26}
{\bkmkend classCTCLInterpreter_a26}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 551 of file TCLInterpreter.cpp.\par
\par
References Int_t, and m_pInterpreter.\par
Referenced by CAssocArrayBinding< T >::Commit(), CArrayBinding< T >::Commit(), and ExprBoolean().}
{\xe \v ExprDouble\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:ExprDouble}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DFloat_t} CTCLInterpreter::ExprDouble (const std::string & {\i rExpression}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreter_a25}
{\bkmkend classCTCLInterpreter_a25}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 444 of file TCLInterpreter.h.\par
\par
References DFloat_t, and ExprDouble().}
{\xe \v ExprDouble\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:ExprDouble}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DFloat_t} CTCLInterpreter::ExprDouble (const {\b CTCLString} & {\i rExpression}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreter_a24}
{\bkmkend classCTCLInterpreter_a24}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 441 of file TCLInterpreter.h.\par
\par
References DFloat_t, and ExprDouble().}
{\xe \v ExprDouble\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:ExprDouble}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b DFloat_t} CTCLInterpreter::ExprDouble (const char * {\i pExpression})}
}\par
{\bkmkstart classCTCLInterpreter_a23}
{\bkmkend classCTCLInterpreter_a23}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 515 of file TCLInterpreter.cpp.\par
\par
References DFloat_t, Int_t, and m_pInterpreter.\par
Referenced by CAssocArrayBinding< T >::Commit(), CArrayBinding< T >::Commit(), and ExprDouble().}
{\xe \v ExprLong\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:ExprLong}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Long_t} CTCLInterpreter::ExprLong (const {\b CTCLString} & {\i rExpr}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreter_a22}
{\bkmkend classCTCLInterpreter_a22}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 435 of file TCLInterpreter.h.\par
\par
References ExprLong(), and Long_t.}
{\xe \v ExprLong\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:ExprLong}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Long_t} CTCLInterpreter::ExprLong (std::string & {\i rExpression}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreter_a21}
{\bkmkend classCTCLInterpreter_a21}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 432 of file TCLInterpreter.h.\par
\par
References ExprLong(), and Long_t.}
{\xe \v ExprLong\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:ExprLong}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Long_t} CTCLInterpreter::ExprLong (const char * {\i pExpression})}
}\par
{\bkmkstart classCTCLInterpreter_a20}
{\bkmkend classCTCLInterpreter_a20}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 479 of file TCLInterpreter.cpp.\par
\par
References Long_t, and m_pInterpreter.\par
Referenced by CAssocArrayBinding< T >::Commit(), CArrayBinding< T >::Commit(), and ExprLong().}
{\xe \v ExprString\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:ExprString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string CTCLInterpreter::ExprString (const std::string & {\i rExpr}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreter_a19}
{\bkmkend classCTCLInterpreter_a19}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 426 of file TCLInterpreter.h.\par
\par
References ExprString().}
{\xe \v ExprString\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:ExprString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string CTCLInterpreter::ExprString (const {\b CTCLString} & {\i rExpr}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreter_a18}
{\bkmkend classCTCLInterpreter_a18}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 423 of file TCLInterpreter.h.\par
\par
References ExprString().}
{\xe \v ExprString\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:ExprString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string CTCLInterpreter::ExprString (const char * {\i pExpression})}
}\par
{\bkmkstart classCTCLInterpreter_a17}
{\bkmkend classCTCLInterpreter_a17}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 449 of file TCLInterpreter.cpp.\par
\par
References m_pInterpreter.\par
Referenced by ExprString().}
{\xe \v getInterpreter\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:getInterpreter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Tcl_Interp* CTCLInterpreter::getInterpreter (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreter_a4}
{\bkmkend classCTCLInterpreter_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 365 of file TCLInterpreter.h.\par
\par
References m_pInterpreter.\par
Referenced by CTCLException::AddErrorInfo(), CTCLResult::AppendElement(), CTCLResult::Clear(), CAssocArrayBinding< T >::Commit(), CTCLProcessor::DeleteRelay(), CTCLProcessor::EvalRelay(), CTCLVariable::Get(), CVariableBinding< T >::InitBindings(), CTCLVariable::Link(), CTCLResult::operator const char *(), CTCLObject::operator double(), CTCLObject::operator int(), CTCLObject::operator()(), CTCLResult::operator+=(), CTCLObject::operator+=(), CTCLResult::operator=(), CTCLProcessor::ParseBoolean(), CTCLProcessor::ParseDouble(), CTCLProcessor::ParseInt(), CTCLVariable::Set(), CTCLException::SetErrorCode(), CVariableBinding< T >::ShutdownBindings(), CTCLList::Split(), CTCLVariable::Trace(), CTCLVariable::TraceRelay(), CTCLVariable::Unlink(), CTCLVariable::UnTrace(), and CTCLVariable::Update().}
{\xe \v GetResultString\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:GetResultString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string CTCLInterpreter::GetResultString () const}
}\par
{\bkmkstart classCTCLInterpreter_a42}
{\bkmkend classCTCLInterpreter_a42}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 794 of file TCLInterpreter.cpp.\par
\par
References m_pInterpreter.}
{\xe \v GlobalEval\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:GlobalEval}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string CTCLInterpreter::GlobalEval (const std::string & {\i rScript}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreter_a13}
{\bkmkend classCTCLInterpreter_a13}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 404 of file TCLInterpreter.h.\par
\par
References GlobalEval().}
{\xe \v GlobalEval\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:GlobalEval}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string CTCLInterpreter::GlobalEval (const {\b CTCLString} & {\i rScript}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreter_a12}
{\bkmkend classCTCLInterpreter_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 401 of file TCLInterpreter.h.\par
\par
References GlobalEval().}
{\xe \v GlobalEval\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:GlobalEval}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string CTCLInterpreter::GlobalEval (const char * {\i pScript})}
}\par
{\bkmkstart classCTCLInterpreter_a11}
{\bkmkend classCTCLInterpreter_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 391 of file TCLInterpreter.cpp.\par
\par
References m_pInterpreter.\par
Referenced by CAssocArrayBinding< T >::Commit(), GlobalEval(), and CConfigurationManager::InternalReadConfigFile().}
{\xe \v operator Tcl_Interp *\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:operator Tcl_Interp *}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLInterpreter::operator Tcl_Interp * (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreter_a44}
{\bkmkend classCTCLInterpreter_a44}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 514 of file TCLInterpreter.h.\par
\par
References m_pInterpreter.}
{\xe \v operator->\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:operator->}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Tcl_Interp* CTCLInterpreter::operator-> (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreter_a43}
{\bkmkend classCTCLInterpreter_a43}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 509 of file TCLInterpreter.h.\par
\par
References m_pInterpreter.}
{\xe \v operator=\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLInterpreter CTCLInterpreter::operator= (const CTCLInterpreter & {\i aCTCLInterpreter}){\f2  [private]}}
}\par
{\bkmkstart classCTCLInterpreter_c1}
{\bkmkend classCTCLInterpreter_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLInterpreter::operator== (const CTCLInterpreter & {\i aCTCLInterpreter}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreter_a3}
{\bkmkend classCTCLInterpreter_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 355 of file TCLInterpreter.h.\par
\par
References m_pInterpreter.}
{\xe \v PosixError\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:PosixError}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string CTCLInterpreter::PosixError () const}
}\par
{\bkmkstart classCTCLInterpreter_a32}
{\bkmkend classCTCLInterpreter_a32}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 613 of file TCLInterpreter.cpp.\par
\par
References m_pInterpreter.}
{\xe \v ReapDetachedProcesses\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:ReapDetachedProcesses}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLInterpreter::ReapDetachedProcesses () const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreter_a35}
{\bkmkend classCTCLInterpreter_a35}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 474 of file TCLInterpreter.h.\par
}
{\xe \v RecordAndEval\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:RecordAndEval}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string CTCLInterpreter::RecordAndEval (const std::string & {\i rScript}, {\b Bool_t} {\i fEval} = {\b kfFALSE}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreter_a16}
{\bkmkend classCTCLInterpreter_a16}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 415 of file TCLInterpreter.h.\par
\par
References Bool_t, and RecordAndEval().}
{\xe \v RecordAndEval\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:RecordAndEval}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string CTCLInterpreter::RecordAndEval (const {\b CTCLString} & {\i rScript}, {\b Bool_t} {\i fEval} = {\b kfFALSE}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreter_a15}
{\bkmkend classCTCLInterpreter_a15}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 411 of file TCLInterpreter.h.\par
\par
References Bool_t, and RecordAndEval().}
{\xe \v RecordAndEval\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:RecordAndEval}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string CTCLInterpreter::RecordAndEval (const char * {\i pScript}, {\b Bool_t} {\i fEval} = {\b kfFALSE})}
}\par
{\bkmkstart classCTCLInterpreter_a14}
{\bkmkend classCTCLInterpreter_a14}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 415 of file TCLInterpreter.cpp.\par
\par
References Bool_t, and m_pInterpreter.\par
Referenced by RecordAndEval().}
{\xe \v setInterpreter\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:setInterpreter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLInterpreter::setInterpreter (Tcl_Interp * {\i am_pInterpreter}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCTCLInterpreter_b0}
{\bkmkend classCTCLInterpreter_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 371 of file TCLInterpreter.h.\par
\par
References m_pInterpreter.}
{\xe \v SignalId\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:SignalId}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string CTCLInterpreter::SignalId ({\b UInt_t} {\i nSignal}){\f2  [static]}}
}\par
{\bkmkstart classCTCLInterpreter_d1}
{\bkmkend classCTCLInterpreter_d1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 647 of file TCLInterpreter.cpp.\par
\par
References Int_t, and UInt_t.}
{\xe \v SignalMsg\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:SignalMsg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string CTCLInterpreter::SignalMsg ({\b UInt_t} {\i nSignal}){\f2  [static]}}
}\par
{\bkmkstart classCTCLInterpreter_d2}
{\bkmkend classCTCLInterpreter_d2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 667 of file TCLInterpreter.cpp.\par
\par
References UInt_t.}
{\xe \v TildeSubst\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:TildeSubst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string CTCLInterpreter::TildeSubst (const std::string & {\i rName}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreter_a31}
{\bkmkend classCTCLInterpreter_a31}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 462 of file TCLInterpreter.h.\par
\par
References TildeSubst().}
{\xe \v TildeSubst\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:TildeSubst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string CTCLInterpreter::TildeSubst (const {\b CTCLString} & {\i rName}) const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreter_a30}
{\bkmkend classCTCLInterpreter_a30}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 459 of file TCLInterpreter.h.\par
\par
References TildeSubst().}
{\xe \v TildeSubst\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:TildeSubst}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string CTCLInterpreter::TildeSubst (const char * {\i pFilename}) const}
}\par
{\bkmkstart classCTCLInterpreter_a29}
{\bkmkend classCTCLInterpreter_a29}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 583 of file TCLInterpreter.cpp.\par
\par
References m_pInterpreter.\par
Referenced by TildeSubst().}
{\xe \v UnregisterCommand\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:UnregisterCommand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLInterpreter::UnregisterCommand (const {\b CTCLString} & {\i rCommandName}) const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreter_a41}
{\bkmkend classCTCLInterpreter_a41}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 502 of file TCLInterpreter.h.\par
\par
References UnregisterCommand().}
{\xe \v UnregisterCommand\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:UnregisterCommand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLInterpreter::UnregisterCommand (const std::string & {\i rCommandName}) const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreter_a40}
{\bkmkend classCTCLInterpreter_a40}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 499 of file TCLInterpreter.h.\par
\par
References UnregisterCommand().}
{\xe \v UnregisterCommand\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:UnregisterCommand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLInterpreter::UnregisterCommand (const char * {\i pCommandName}) const}
}\par
{\bkmkstart classCTCLInterpreter_a39}
{\bkmkend classCTCLInterpreter_a39}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 766 of file TCLInterpreter.cpp.\par
\par
References m_pInterpreter.\par
Referenced by CTCLProcessor::Unregister(), and UnregisterCommand().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_pInterpreter\:CTCLInterpreter}
{\xe \v CTCLInterpreter\:m_pInterpreter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Tcl_Interp* CTCLInterpreter::m_pInterpreter{\f2  [private]}}
}\par
{\bkmkstart classCTCLInterpreter_o0}
{\bkmkend classCTCLInterpreter_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 327 of file TCLInterpreter.h.\par
\par
Referenced by AddCommand(), CTCLInterpreter(), Eval(), EvalFile(), ExprBoolean(), ExprDouble(), ExprLong(), ExprString(), getInterpreter(), GetResultString(), GlobalEval(), operator Tcl_Interp *(), operator->(), CTCLInterpreterObject::operator=(), operator==(), PosixError(), RecordAndEval(), setInterpreter(), TildeSubst(), UnregisterCommand(), and ~CTCLInterpreter().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TCLInterpreter.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TCLInterpreter.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCLInterpreterObject  Class Reference\par \pard\plain 
{\tc\tcl2 \v CTCLInterpreterObject}
{\xe \v CTCLInterpreterObject}
{\bkmkstart classCTCLInterpreterObject}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <TCLInterpreterObject.h>}\par
Inheritance diagram for CTCLInterpreterObject:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCTCLInterpreterObject.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLInterpreterObject} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CTCLInterpreterObject} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLInterpreterObject} ({\b CTCLInterpreter} *pInterp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLInterpreterObject} (const CTCLInterpreterObject &aCTCLInterpreterObject)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLInterpreterObject & {\b operator=} (const CTCLInterpreterObject &aCTCLInterpreterObject)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CTCLInterpreterObject &aCTCLInterpreterObject) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLInterpreter} * {\b getInterpreter} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLInterpreter} * {\b Bind} ({\b CTCLInterpreter} &rBinding)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLInterpreter} * {\b Bind} ({\b CTCLInterpreter} *pBinding)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnBind} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnUnbind} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLInterpreter} * {\b AssertIfNotBound} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLInterpreter} * {\b m_pInterpreter}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CTCLInterpreterObject\:CTCLInterpreterObject}
{\xe \v CTCLInterpreterObject\:CTCLInterpreterObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLInterpreterObject::CTCLInterpreterObject (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreterObject_a0}
{\bkmkend classCTCLInterpreterObject_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 320 of file TCLInterpreterObject.h.\par
}
{\xe \v ~CTCLInterpreterObject\:CTCLInterpreterObject}
{\xe \v CTCLInterpreterObject\:~CTCLInterpreterObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual CTCLInterpreterObject::~CTCLInterpreterObject (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCTCLInterpreterObject_a1}
{\bkmkend classCTCLInterpreterObject_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 322 of file TCLInterpreterObject.h.\par
\par
References OnUnbind().}
{\xe \v CTCLInterpreterObject\:CTCLInterpreterObject}
{\xe \v CTCLInterpreterObject\:CTCLInterpreterObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLInterpreterObject::CTCLInterpreterObject ({\b CTCLInterpreter} * {\i pInterp}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreterObject_a2}
{\bkmkend classCTCLInterpreterObject_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 326 of file TCLInterpreterObject.h.\par
\par
References OnBind().}
{\xe \v CTCLInterpreterObject\:CTCLInterpreterObject}
{\xe \v CTCLInterpreterObject\:CTCLInterpreterObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLInterpreterObject::CTCLInterpreterObject (const CTCLInterpreterObject & {\i aCTCLInterpreterObject}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreterObject_a3}
{\bkmkend classCTCLInterpreterObject_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 332 of file TCLInterpreterObject.h.\par
\par
References m_pInterpreter, and OnBind().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AssertIfNotBound\:CTCLInterpreterObject}
{\xe \v CTCLInterpreterObject\:AssertIfNotBound}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CTCLInterpreter}* CTCLInterpreterObject::AssertIfNotBound (){\f2  [inline, protected]}}
}\par
{\bkmkstart classCTCLInterpreterObject_b2}
{\bkmkend classCTCLInterpreterObject_b2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 377 of file TCLInterpreterObject.h.\par
\par
References getInterpreter().\par
Referenced by CTCLProcessor::AddRegisteredOnCurrent(), CTCLResult::AppendElement(), CTCLResult::Clear(), CTCLVariable::Get(), CTCLVariable::Link(), CTCLResult::operator const char *(), CTCLObject::operator double(), CTCLObject::operator int(), CTCLObject::operator()(), CTCLResult::operator+=(), CTCLObject::operator+=(), CTCLResult::operator=(), CTCLProcessor::Register(), CDAQTCLProcessor::Register(), CTCLVariable::Set(), CTCLList::Split(), CTCLVariable::Trace(), CTCLVariable::TraceRelay(), CTCLVariable::Unlink(), CTCLProcessor::Unregister(), and CTCLVariable::UnTrace().}
{\xe \v Bind\:CTCLInterpreterObject}
{\xe \v CTCLInterpreterObject\:Bind}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CTCLInterpreter} * CTCLInterpreterObject::Bind ({\b CTCLInterpreter} * {\i pBinding})}
}\par
{\bkmkstart classCTCLInterpreterObject_a8}
{\bkmkend classCTCLInterpreterObject_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 318 of file TCLInterpreterObject.cpp.\par
\par
References m_pInterpreter, OnBind(), and OnUnbind().}
{\xe \v Bind\:CTCLInterpreterObject}
{\xe \v CTCLInterpreterObject\:Bind}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CTCLInterpreter}* CTCLInterpreterObject::Bind ({\b CTCLInterpreter} & {\i rBinding}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreterObject_a7}
{\bkmkend classCTCLInterpreterObject_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 364 of file TCLInterpreterObject.h.\par
\par
Referenced by CTCLProcessor::DeleteRelay(), CTCLProcessor::EvalRelay(), CTCLException::setInterpreter(), Tcl_AppInit(), and CTCLProcessor::UnregisterAll().}
{\xe \v getInterpreter\:CTCLInterpreterObject}
{\xe \v CTCLInterpreterObject\:getInterpreter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CTCLInterpreter}* CTCLInterpreterObject::getInterpreter () const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreterObject_a6}
{\bkmkend classCTCLInterpreterObject_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 359 of file TCLInterpreterObject.h.\par
\par
Referenced by CTCLException::AddErrorInfo(), AssertIfNotBound(), CTCLFileHandler::CTCLFileHandler(), CTCLIdleProcess::CTCLIdleProcess(), CTCLProcessor::DeleteRelay(), CTCLProcessor::EvalRelay(), CTCLException::GetResult(), CTCLProcessor::ParseBoolean(), CTCLProcessor::ParseDouble(), CTCLProcessor::ParseInt(), CTCLCommandPackage::Register(), CTCLException::SetErrorCode(), CTCLProcessor::UnregisterAll(), and CTCLVariable::Update().}
{\xe \v OnBind\:CTCLInterpreterObject}
{\xe \v CTCLInterpreterObject\:OnBind}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void CTCLInterpreterObject::OnBind (){\f2  [inline, protected, virtual]}}
}\par
{\bkmkstart classCTCLInterpreterObject_b0}
{\bkmkend classCTCLInterpreterObject_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 371 of file TCLInterpreterObject.h.\par
\par
Referenced by Bind(), CTCLInterpreterObject(), and operator=().}
{\xe \v OnUnbind\:CTCLInterpreterObject}
{\xe \v CTCLInterpreterObject\:OnUnbind}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void CTCLInterpreterObject::OnUnbind (){\f2  [inline, protected, virtual]}}
}\par
{\bkmkstart classCTCLInterpreterObject_b1}
{\bkmkend classCTCLInterpreterObject_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 372 of file TCLInterpreterObject.h.\par
\par
Referenced by Bind(), operator=(), and ~CTCLInterpreterObject().}
{\xe \v operator=\:CTCLInterpreterObject}
{\xe \v CTCLInterpreterObject\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLInterpreterObject& CTCLInterpreterObject::operator= (const CTCLInterpreterObject & {\i aCTCLInterpreterObject}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreterObject_a4}
{\bkmkend classCTCLInterpreterObject_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 341 of file TCLInterpreterObject.h.\par
\par
References CTCLInterpreter::m_pInterpreter, OnBind(), and OnUnbind().\par
Referenced by CTCLVariable::operator=(), CTCLResult::operator=(), CTCLObject::operator=(), CTCLFileHandler::operator=(), CTCLException::operator=(), CTCLCommandPackage::operator=(), and CTCLApplication::operator=().}
{\xe \v operator==\:CTCLInterpreterObject}
{\xe \v CTCLInterpreterObject\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLInterpreterObject::operator== (const CTCLInterpreterObject & {\i aCTCLInterpreterObject}) const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreterObject_a5}
{\bkmkend classCTCLInterpreterObject_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 352 of file TCLInterpreterObject.h.\par
\par
References m_pInterpreter.\par
Referenced by CTCLVariable::operator==(), CTCLResult::operator==(), CTCLProcessor::operator==(), CTCLIdleProcess::operator==(), CTCLFileHandler::operator==(), CTCLException::operator==(), CTCLCommandPackage::operator==(), and CTCLApplication::operator==().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_pInterpreter\:CTCLInterpreterObject}
{\xe \v CTCLInterpreterObject\:m_pInterpreter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CTCLInterpreter}* CTCLInterpreterObject::m_pInterpreter{\f2  [private]}}
}\par
{\bkmkstart classCTCLInterpreterObject_o0}
{\bkmkend classCTCLInterpreterObject_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 315 of file TCLInterpreterObject.h.\par
\par
Referenced by Bind(), CTCLInterpreterObject(), and operator==().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TCLInterpreterObject.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TCLInterpreterObject.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCLInterpreterStartup  Class Reference\par \pard\plain 
{\tc\tcl2 \v CTCLInterpreterStartup}
{\xe \v CTCLInterpreterStartup}
{\bkmkstart classCTCLInterpreterStartup}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CTCLInterpreterStartup.h>}\par
Inheritance diagram for CTCLInterpreterStartup:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCTCLInterpreterStartup.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLInterpreterStartup} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CTCLInterpreterStartup} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Tcl_Init} (Tcl_Interp *pInterp)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b operator()} (int argc, char **argv)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLInterpreterStartup} (const CTCLInterpreterStartup &aCTCLInterpreterStartup)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Copy Constructor Illegal private and unimplemented.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLInterpreterStartup & {\b operator=} (const CTCLInterpreterStartup &aCTCLInterpreterStartup)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Operator= Assignment Operator Illegal private and unimplemented.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CTCLInterpreterStartup &aCTCLInterpreterStartup) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Operator== Equality Operator Illegal private and unimplemented.}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
Starts up a TCL interpreter. This is suitable for applications which do not require or cannot use a GUI. \par
\par
Definition at line 309 of file CTCLInterpreterStartup.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CTCLInterpreterStartup\:CTCLInterpreterStartup}
{\xe \v CTCLInterpreterStartup\:CTCLInterpreterStartup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLInterpreterStartup::CTCLInterpreterStartup (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLInterpreterStartup_a0}
{\bkmkend classCTCLInterpreterStartup_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 316 of file CTCLInterpreterStartup.h.\par
}
{\xe \v ~CTCLInterpreterStartup\:CTCLInterpreterStartup}
{\xe \v CTCLInterpreterStartup\:~CTCLInterpreterStartup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual CTCLInterpreterStartup::~CTCLInterpreterStartup (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCTCLInterpreterStartup_a1}
{\bkmkend classCTCLInterpreterStartup_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 317 of file CTCLInterpreterStartup.h.\par
}
{\xe \v CTCLInterpreterStartup\:CTCLInterpreterStartup}
{\xe \v CTCLInterpreterStartup\:CTCLInterpreterStartup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLInterpreterStartup::CTCLInterpreterStartup (const CTCLInterpreterStartup & {\i aCTCLInterpreterStartup}){\f2  [private]}}
}\par
{\bkmkstart classCTCLInterpreterStartup_c1}
{\bkmkend classCTCLInterpreterStartup_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Copy Constructor Illegal private and unimplemented.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator()\:CTCLInterpreterStartup}
{\xe \v CTCLInterpreterStartup\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLInterpreterStartup::operator() (int {\i argc}, char ** {\i argv}){\f2  [private, virtual]}}
}\par
{\bkmkstart classCTCLInterpreterStartup_c0}
{\bkmkend classCTCLInterpreterStartup_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Override.\par
Purpose:\par
{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Calls OnInitialize.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Sets up the Tcl interpreter.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Within the Tcl initialization function ({\b CTCLInterpreterStartup::Tcl_Init} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCLInterpreterStartup_e0 \\*MERGEFORMAT}{\fldrslt pagenum}}})) call RegisterExtensions.\par
}Note that the instance of the interpreter is gotten via a call to {\b CEventLoop::getInstance}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEventLoop_d0 \\*MERGEFORMAT}{\fldrslt pagenum}}}) since this is a singleton class.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i argc}}  - Number of "command line" parameters in  \par
{\b {\i argv}}  - "command line" argument strings. \par
}\par
Implements {\b CInterpreterStartup} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCInterpreterStartup_c0 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 329 of file CTCLInterpreterStartup.cpp.\par
\par
References NULL, CInterpreterStartup::OnInitialize(), and Tcl_Init().}
{\xe \v operator=\:CTCLInterpreterStartup}
{\xe \v CTCLInterpreterStartup\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLInterpreterStartup& CTCLInterpreterStartup::operator= (const CTCLInterpreterStartup & {\i aCTCLInterpreterStartup}){\f2  [private]}}
}\par
{\bkmkstart classCTCLInterpreterStartup_c2}
{\bkmkend classCTCLInterpreterStartup_c2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operator= Assignment Operator Illegal private and unimplemented.\par
}
{\xe \v operator==\:CTCLInterpreterStartup}
{\xe \v CTCLInterpreterStartup\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLInterpreterStartup::operator== (const CTCLInterpreterStartup & {\i aCTCLInterpreterStartup}) const{\f2  [private]}}
}\par
{\bkmkstart classCTCLInterpreterStartup_c3}
{\bkmkend classCTCLInterpreterStartup_c3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operator== Equality Operator Illegal private and unimplemented.\par
}
{\xe \v Tcl_Init\:CTCLInterpreterStartup}
{\xe \v CTCLInterpreterStartup\:Tcl_Init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLInterpreterStartup::Tcl_Init (Tcl_Interp * {\i pInterp}){\f2  [static, protected]}}
}\par
{\bkmkstart classCTCLInterpreterStartup_e0}
{\bkmkend classCTCLInterpreterStartup_e0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Initialization.\par
Purpose:\par
Called from the Tcl_Main() function. This static member:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Obtains the object by calling {\b CEventLoop::getInstance}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEventLoop_d0 \\*MERGEFORMAT}{\fldrslt pagenum}}})\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Initializes the interpreter.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Invokes the Object's RegisterExtensions function to load packages, register modules and add application specific commands.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Returns to allow Tcl to start it's main loop.\par
}{{{\b Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i Tcl_Interp}}  * pInterp The interpreter created to run Tcl. \par
}\par
Definition at line 366 of file CTCLInterpreterStartup.cpp.\par
\par
References CEventLoop::getInstance(), NULL, CInterpreterStartup::RegisterExtensions(), and CInterpreterStartup::setInterpreter().\par
Referenced by operator()().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CTCLInterpreterStartup.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CTCLInterpreterStartup.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCLList  Class Reference\par \pard\plain 
{\tc\tcl2 \v CTCLList}
{\xe \v CTCLList}
{\bkmkstart classCTCLList}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <TCLList.h>}\par
Inheritance diagram for CTCLList:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCTCLList.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLList} ({\b CTCLInterpreter} *pInterp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CTCLList} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLList} ({\b CTCLInterpreter} *pInterp, const char *am_pList)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLList} ({\b CTCLInterpreter} *pInterp, const std::string &rList)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLList} (const CTCLList &aCTCLList)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLList & {\b operator=} (const CTCLList &aCTCLList)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CTCLList &aCTCLList)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator!=} (const CTCLList &aCTCLList)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b getList} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Split} ({\b StringArray} &rElements)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Split} (int &argc, char ***argv)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Merge} (const {\b StringArray} &rElements)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Merge} (int argc, char **argv)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setList} (const char *am_pList)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DoAssign} (const CTCLList &rRhs)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b m_pList}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CTCLList\:CTCLList}
{\xe \v CTCLList\:CTCLList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLList::CTCLList ({\b CTCLInterpreter} * {\i pInterp}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLList_a0}
{\bkmkend classCTCLList_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 320 of file TCLList.h.\par
\par
References m_pList.}
{\xe \v ~CTCLList\:CTCLList}
{\xe \v CTCLList\:~CTCLList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLList::~CTCLList (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLList_a1}
{\bkmkend classCTCLList_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 324 of file TCLList.h.\par
\par
References m_pList.}
{\xe \v CTCLList\:CTCLList}
{\xe \v CTCLList\:CTCLList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLList::CTCLList ({\b CTCLInterpreter} * {\i pInterp}, const char * {\i am_pList})}
}\par
{\bkmkstart classCTCLList_a2}
{\bkmkend classCTCLList_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 319 of file TCLList.cpp.\par
\par
References m_pList.}
{\xe \v CTCLList\:CTCLList}
{\xe \v CTCLList\:CTCLList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLList::CTCLList ({\b CTCLInterpreter} * {\i pInterp}, const std::string & {\i rList})}
}\par
{\bkmkstart classCTCLList_a3}
{\bkmkend classCTCLList_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 328 of file TCLList.cpp.\par
\par
References m_pList.}
{\xe \v CTCLList\:CTCLList}
{\xe \v CTCLList\:CTCLList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLList::CTCLList (const CTCLList & {\i aCTCLList}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLList_a4}
{\bkmkend classCTCLList_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 333 of file TCLList.h.\par
\par
References DoAssign().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v DoAssign\:CTCLList}
{\xe \v CTCLList\:DoAssign}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLList::DoAssign (const CTCLList & {\i rRhs}){\f2  [protected]}}
}\par
{\bkmkstart classCTCLList_b1}
{\bkmkend classCTCLList_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 494 of file TCLList.cpp.\par
\par
References m_pList, and setList().\par
Referenced by CTCLList(), and operator=().}
{\xe \v getList\:CTCLList}
{\xe \v CTCLList\:getList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* CTCLList::getList () const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLList_a8}
{\bkmkend classCTCLList_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 362 of file TCLList.h.\par
\par
References m_pList.\par
Referenced by Merge(), and CTCLObject::operator=().}
{\xe \v Merge\:CTCLList}
{\xe \v CTCLList\:Merge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * CTCLList::Merge (int {\i argc}, char ** {\i argv})}
}\par
{\bkmkstart classCTCLList_a12}
{\bkmkend classCTCLList_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 478 of file TCLList.cpp.\par
\par
References getList(), and setList().}
{\xe \v Merge\:CTCLList}
{\xe \v CTCLList\:Merge}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * CTCLList::Merge (const {\b StringArray} & {\i rElements})}
}\par
{\bkmkstart classCTCLList_a11}
{\bkmkend classCTCLList_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 442 of file TCLList.cpp.\par
\par
References getList(), and StringArray.}
{\xe \v operator!=\:CTCLList}
{\xe \v CTCLList\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLList::operator!= (const CTCLList & {\i aCTCLList}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLList_a7}
{\bkmkend classCTCLList_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 355 of file TCLList.h.\par
\par
References operator==().}
{\xe \v operator=\:CTCLList}
{\xe \v CTCLList\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLList& CTCLList::operator= (const CTCLList & {\i aCTCLList}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLList_a5}
{\bkmkend classCTCLList_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 342 of file TCLList.h.\par
\par
References DoAssign().}
{\xe \v operator==\:CTCLList}
{\xe \v CTCLList\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLList::operator== (const CTCLList & {\i aCTCLList})}
}\par
{\bkmkstart classCTCLList_a6}
{\bkmkend classCTCLList_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 344 of file TCLList.cpp.\par
\par
References m_pList.\par
Referenced by operator!=().}
{\xe \v setList\:CTCLList}
{\xe \v CTCLList\:setList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLList::setList (const char * {\i am_pList}){\f2  [protected]}}
}\par
{\bkmkstart classCTCLList_b0}
{\bkmkend classCTCLList_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 370 of file TCLList.cpp.\par
\par
References m_pList.\par
Referenced by DoAssign(), and Merge().}
{\xe \v Split\:CTCLList}
{\xe \v CTCLList\:Split}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLList::Split (int & {\i argc}, char *** {\i argv})}
}\par
{\bkmkstart classCTCLList_a10}
{\bkmkend classCTCLList_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 424 of file TCLList.cpp.\par
\par
References CTCLInterpreterObject::AssertIfNotBound(), CTCLInterpreter::getInterpreter(), and m_pList.}
{\xe \v Split\:CTCLList}
{\xe \v CTCLList\:Split}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLList::Split ({\b StringArray} & {\i rElements})}
}\par
{\bkmkstart classCTCLList_a9}
{\bkmkend classCTCLList_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 387 of file TCLList.cpp.\par
\par
References StringArray.\par
Referenced by CAssocArrayBinding< T >::Commit().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_pList\:CTCLList}
{\xe \v CTCLList\:m_pList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* CTCLList::m_pList{\f2  [private]}}
}\par
{\bkmkstart classCTCLList_o0}
{\bkmkend classCTCLList_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 315 of file TCLList.h.\par
\par
Referenced by CTCLList(), DoAssign(), getList(), operator==(), setList(), Split(), and ~CTCLList().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TCLList.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TCLList.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCLObject  Class Reference\par \pard\plain 
{\tc\tcl2 \v CTCLObject}
{\xe \v CTCLObject}
{\bkmkstart classCTCLObject}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <TCLObject.h>}\par
Inheritance diagram for CTCLObject:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCTCLObject.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLObject} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CTCLObject} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLObject} (Tcl_Obj *am_pObject)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLObject} (const CTCLObject &aCTCLObject)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLObject & {\b operator=} (const CTCLObject &aCTCLObject)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CTCLObject &aCTCLObject) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Tcl_Obj * {\b getObject} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLObject & {\b operator=} (const string &rSource)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLObject & {\b operator=} (const char *pSource)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLObject & {\b operator=} (int nSource)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLObject & {\b operator=} (const {\b CTCLList} &rList)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLObject & {\b operator=} (double dSource)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator string} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator int} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator CTCLList} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator double} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLObject & {\b operator+=} (const CTCLObject &rObject)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLObject & {\b operator+=} (int nItem)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLObject & {\b operator+=} (const string &rItem)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLObject & {\b operator+=} (const char *pItem)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLObject & {\b operator+=} (double Item)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLObject {\b clone} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLObject {\b operator()} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setObject} (Tcl_Obj *am_pObject)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DupIfMust} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Tcl_Obj * {\b m_pObject}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CTCLObject\:CTCLObject}
{\xe \v CTCLObject\:CTCLObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLObject::CTCLObject (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLObject_a0}
{\bkmkend classCTCLObject_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 332 of file TCLObject.h.\par
\par
References m_pObject.\par
Referenced by clone(), and operator()().}
{\xe \v ~CTCLObject\:CTCLObject}
{\xe \v CTCLObject\:~CTCLObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual CTCLObject::~CTCLObject (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCTCLObject_a1}
{\bkmkend classCTCLObject_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 339 of file TCLObject.h.\par
\par
References m_pObject.}
{\xe \v CTCLObject\:CTCLObject}
{\xe \v CTCLObject\:CTCLObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLObject::CTCLObject (Tcl_Obj * {\i am_pObject}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLObject_a2}
{\bkmkend classCTCLObject_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 345 of file TCLObject.h.\par
\par
References m_pObject.}
{\xe \v CTCLObject\:CTCLObject}
{\xe \v CTCLObject\:CTCLObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLObject::CTCLObject (const CTCLObject & {\i aCTCLObject}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLObject_a3}
{\bkmkend classCTCLObject_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 357 of file TCLObject.h.\par
\par
References m_pObject.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v clone\:CTCLObject}
{\xe \v CTCLObject\:clone}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLObject CTCLObject::clone ()}
}\par
{\bkmkstart classCTCLObject_a21}
{\bkmkend classCTCLObject_a21}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 596 of file TCLObject.cpp.\par
\par
References CTCLObject(), and m_pObject.}
{\xe \v DupIfMust\:CTCLObject}
{\xe \v CTCLObject\:DupIfMust}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLObject::DupIfMust (){\f2  [inline, protected]}}
}\par
{\bkmkstart classCTCLObject_b1}
{\bkmkend classCTCLObject_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 429 of file TCLObject.h.\par
\par
References m_pObject.\par
Referenced by operator+=(), and operator=().}
{\xe \v getObject\:CTCLObject}
{\xe \v CTCLObject\:getObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Tcl_Obj* CTCLObject::getObject (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLObject_a6}
{\bkmkend classCTCLObject_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 376 of file TCLObject.h.\par
\par
References m_pObject.}
{\xe \v operator CTCLList\:CTCLObject}
{\xe \v CTCLObject\:operator CTCLList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLObject::operator {\b CTCLList} ()}
}\par
{\bkmkstart classCTCLObject_a14}
{\bkmkend classCTCLObject_a14}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 465 of file TCLObject.cpp.\par
\par
References m_pObject.}
{\xe \v operator double\:CTCLObject}
{\xe \v CTCLObject\:operator double}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLObject::operator double ()}
}\par
{\bkmkstart classCTCLObject_a15}
{\bkmkend classCTCLObject_a15}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 481 of file TCLObject.cpp.\par
\par
References CTCLInterpreterObject::AssertIfNotBound(), CTCLInterpreter::getInterpreter(), and m_pObject.}
{\xe \v operator int\:CTCLObject}
{\xe \v CTCLObject\:operator int}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLObject::operator int ()}
}\par
{\bkmkstart classCTCLObject_a13}
{\bkmkend classCTCLObject_a13}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 445 of file TCLObject.cpp.\par
\par
References CTCLInterpreterObject::AssertIfNotBound(), CTCLInterpreter::getInterpreter(), and m_pObject.}
{\xe \v operator string\:CTCLObject}
{\xe \v CTCLObject\:operator string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLObject::operator string ()}
}\par
{\bkmkstart classCTCLObject_a12}
{\bkmkend classCTCLObject_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 432 of file TCLObject.cpp.\par
\par
References m_pObject.}
{\xe \v operator()\:CTCLObject}
{\xe \v CTCLObject\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLObject CTCLObject::operator() ()}
}\par
{\bkmkstart classCTCLObject_a22}
{\bkmkend classCTCLObject_a22}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 609 of file TCLObject.cpp.\par
\par
References CTCLInterpreterObject::AssertIfNotBound(), CTCLObject(), CTCLInterpreter::getInterpreter(), and m_pObject.}
{\xe \v operator+=\:CTCLObject}
{\xe \v CTCLObject\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLObject & CTCLObject::operator+= (double {\i Item})}
}\par
{\bkmkstart classCTCLObject_a20}
{\bkmkend classCTCLObject_a20}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 577 of file TCLObject.cpp.\par
\par
References CTCLInterpreterObject::AssertIfNotBound(), DupIfMust(), CTCLInterpreter::getInterpreter(), and m_pObject.}
{\xe \v operator+=\:CTCLObject}
{\xe \v CTCLObject\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLObject & CTCLObject::operator+= (const char * {\i pItem})}
}\par
{\bkmkstart classCTCLObject_a19}
{\bkmkend classCTCLObject_a19}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 558 of file TCLObject.cpp.\par
\par
References CTCLInterpreterObject::AssertIfNotBound(), DupIfMust(), CTCLInterpreter::getInterpreter(), and m_pObject.}
{\xe \v operator+=\:CTCLObject}
{\xe \v CTCLObject\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLObject & CTCLObject::operator+= (const string & {\i rItem})}
}\par
{\bkmkstart classCTCLObject_a18}
{\bkmkend classCTCLObject_a18}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 540 of file TCLObject.cpp.\par
\par
References CTCLInterpreterObject::AssertIfNotBound(), DupIfMust(), CTCLInterpreter::getInterpreter(), and m_pObject.}
{\xe \v operator+=\:CTCLObject}
{\xe \v CTCLObject\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLObject & CTCLObject::operator+= (int {\i nItem})}
}\par
{\bkmkstart classCTCLObject_a17}
{\bkmkend classCTCLObject_a17}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 518 of file TCLObject.cpp.\par
\par
References CTCLInterpreterObject::AssertIfNotBound(), DupIfMust(), CTCLInterpreter::getInterpreter(), and m_pObject.}
{\xe \v operator+=\:CTCLObject}
{\xe \v CTCLObject\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLObject & CTCLObject::operator+= (const CTCLObject & {\i rObject})}
}\par
{\bkmkstart classCTCLObject_a16}
{\bkmkend classCTCLObject_a16}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 502 of file TCLObject.cpp.\par
\par
References CTCLInterpreterObject::AssertIfNotBound(), DupIfMust(), CTCLInterpreter::getInterpreter(), and m_pObject.}
{\xe \v operator=\:CTCLObject}
{\xe \v CTCLObject\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLObject & CTCLObject::operator= (double {\i dSource})}
}\par
{\bkmkstart classCTCLObject_a11}
{\bkmkend classCTCLObject_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 418 of file TCLObject.cpp.\par
\par
References DupIfMust(), and m_pObject.}
{\xe \v operator=\:CTCLObject}
{\xe \v CTCLObject\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLObject & CTCLObject::operator= (const {\b CTCLList} & {\i rList})}
}\par
{\bkmkstart classCTCLObject_a10}
{\bkmkend classCTCLObject_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 399 of file TCLObject.cpp.\par
\par
References DupIfMust(), CTCLList::getList(), and m_pObject.}
{\xe \v operator=\:CTCLObject}
{\xe \v CTCLObject\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLObject & CTCLObject::operator= (int {\i nSource})}
}\par
{\bkmkstart classCTCLObject_a9}
{\bkmkend classCTCLObject_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 382 of file TCLObject.cpp.\par
\par
References DupIfMust(), and m_pObject.}
{\xe \v operator=\:CTCLObject}
{\xe \v CTCLObject\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLObject & CTCLObject::operator= (const char * {\i pSource})}
}\par
{\bkmkstart classCTCLObject_a8}
{\bkmkend classCTCLObject_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 364 of file TCLObject.cpp.\par
\par
References m_pObject.}
{\xe \v operator=\:CTCLObject}
{\xe \v CTCLObject\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLObject & CTCLObject::operator= (const string & {\i rSource})}
}\par
{\bkmkstart classCTCLObject_a7}
{\bkmkend classCTCLObject_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 347 of file TCLObject.cpp.\par
\par
References DupIfMust(), and m_pObject.}
{\xe \v operator=\:CTCLObject}
{\xe \v CTCLObject\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLObject & CTCLObject::operator= (const CTCLObject & {\i aCTCLObject})}
}\par
{\bkmkstart classCTCLObject_a4}
{\bkmkend classCTCLObject_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 326 of file TCLObject.cpp.\par
\par
References m_pObject, and CTCLInterpreterObject::operator=().}
{\xe \v operator==\:CTCLObject}
{\xe \v CTCLObject\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLObject::operator== (const CTCLObject & {\i aCTCLObject}) const}
}\par
{\bkmkstart classCTCLObject_a5}
{\bkmkend classCTCLObject_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 309 of file TCLObject.cpp.\par
\par
References m_pObject.}
{\xe \v setObject\:CTCLObject}
{\xe \v CTCLObject\:setObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLObject::setObject (Tcl_Obj * {\i am_pObject}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCTCLObject_b0}
{\bkmkend classCTCLObject_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 385 of file TCLObject.h.\par
\par
References m_pObject.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_pObject\:CTCLObject}
{\xe \v CTCLObject\:m_pObject}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Tcl_Obj* CTCLObject::m_pObject{\f2  [private]}}
}\par
{\bkmkstart classCTCLObject_o0}
{\bkmkend classCTCLObject_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 325 of file TCLObject.h.\par
\par
Referenced by clone(), CTCLObject(), DupIfMust(), getObject(), operator CTCLList(), operator double(), operator int(), operator string(), operator()(), operator+=(), operator=(), operator==(), setObject(), and ~CTCLObject().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TCLObject.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TCLObject.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCLPackagedCommand  Class Reference\par \pard\plain 
{\tc\tcl2 \v CTCLPackagedCommand}
{\xe \v CTCLPackagedCommand}
{\bkmkstart classCTCLPackagedCommand}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <TCLPackagedCommand.h>}\par
Inheritance diagram for CTCLPackagedCommand:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCTCLPackagedCommand.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLPackagedCommand} (const std::string &sCommand, {\b CTCLInterpreter} *pInterp, {\b CTCLCommandPackage} &rPackage)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLPackagedCommand} (const char *pCommand, {\b CTCLInterpreter} *pInterp, {\b CTCLCommandPackage} &rPackage)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CTCLPackagedCommand} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CTCLPackagedCommand &aCTCLPackagedCommand) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLCommandPackage} & {\b getMyPackage} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMyPackage} ({\b CTCLCommandPackage} &am_rMyPackage)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLPackagedCommand} (const CTCLPackagedCommand &aCTCLPackagedCommand)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLPackagedCommand & {\b operator=} (const CTCLPackagedCommand &aCTCLPackagedCommand)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLCommandPackage} & {\b m_rMyPackage}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CTCLPackagedCommand\:CTCLPackagedCommand}
{\xe \v CTCLPackagedCommand\:CTCLPackagedCommand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLPackagedCommand::CTCLPackagedCommand (const std::string & {\i sCommand}, {\b CTCLInterpreter} * {\i pInterp}, {\b CTCLCommandPackage} & {\i rPackage}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLPackagedCommand_a0}
{\bkmkend classCTCLPackagedCommand_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 313 of file TCLPackagedCommand.h.\par
}
{\xe \v CTCLPackagedCommand\:CTCLPackagedCommand}
{\xe \v CTCLPackagedCommand\:CTCLPackagedCommand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLPackagedCommand::CTCLPackagedCommand (const char * {\i pCommand}, {\b CTCLInterpreter} * {\i pInterp}, {\b CTCLCommandPackage} & {\i rPackage}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLPackagedCommand_a1}
{\bkmkend classCTCLPackagedCommand_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 318 of file TCLPackagedCommand.h.\par
}
{\xe \v ~CTCLPackagedCommand\:CTCLPackagedCommand}
{\xe \v CTCLPackagedCommand\:~CTCLPackagedCommand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLPackagedCommand::~CTCLPackagedCommand (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLPackagedCommand_a2}
{\bkmkend classCTCLPackagedCommand_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 323 of file TCLPackagedCommand.h.\par
}
{\xe \v CTCLPackagedCommand\:CTCLPackagedCommand}
{\xe \v CTCLPackagedCommand\:CTCLPackagedCommand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLPackagedCommand::CTCLPackagedCommand (const CTCLPackagedCommand & {\i aCTCLPackagedCommand}){\f2  [private]}}
}\par
{\bkmkstart classCTCLPackagedCommand_c0}
{\bkmkend classCTCLPackagedCommand_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getMyPackage\:CTCLPackagedCommand}
{\xe \v CTCLPackagedCommand\:getMyPackage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CTCLCommandPackage}& CTCLPackagedCommand::getMyPackage (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLPackagedCommand_a4}
{\bkmkend classCTCLPackagedCommand_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 348 of file TCLPackagedCommand.h.\par
}
{\xe \v operator=\:CTCLPackagedCommand}
{\xe \v CTCLPackagedCommand\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLPackagedCommand& CTCLPackagedCommand::operator= (const CTCLPackagedCommand & {\i aCTCLPackagedCommand}){\f2  [private]}}
}\par
{\bkmkstart classCTCLPackagedCommand_c1}
{\bkmkend classCTCLPackagedCommand_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:CTCLPackagedCommand}
{\xe \v CTCLPackagedCommand\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLPackagedCommand::operator== (const CTCLPackagedCommand & {\i aCTCLPackagedCommand}) const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLPackagedCommand_a3}
{\bkmkend classCTCLPackagedCommand_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 338 of file TCLPackagedCommand.h.\par
\par
References m_rMyPackage, and CTCLProcessor::operator==().}
{\xe \v setMyPackage\:CTCLPackagedCommand}
{\xe \v CTCLPackagedCommand\:setMyPackage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLPackagedCommand::setMyPackage ({\b CTCLCommandPackage} & {\i am_rMyPackage}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLPackagedCommand_a5}
{\bkmkend classCTCLPackagedCommand_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 355 of file TCLPackagedCommand.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_rMyPackage\:CTCLPackagedCommand}
{\xe \v CTCLPackagedCommand\:m_rMyPackage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CTCLCommandPackage}& CTCLPackagedCommand::m_rMyPackage{\f2  [private]}}
}\par
{\bkmkstart classCTCLPackagedCommand_o0}
{\bkmkend classCTCLPackagedCommand_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 308 of file TCLPackagedCommand.h.\par
\par
Referenced by operator==().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TCLPackagedCommand.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCLProcessor  Class Reference\par \pard\plain 
{\tc\tcl2 \v CTCLProcessor}
{\xe \v CTCLProcessor}
{\bkmkstart classCTCLProcessor}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <TCLProcessor.h>}\par
Inheritance diagram for CTCLProcessor:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCTCLProcessor.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLProcessor} (const std::string &sCommand, {\b CTCLInterpreter} *pInterp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLProcessor} (const char *pCommand, {\b CTCLInterpreter} *pInterp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CTCLProcessor} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CTCLProcessor &aCTCLProcessor) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b getCommandName} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TCLInterpreterIterator} {\b begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TCLInterpreterIterator} {\b end} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b operator()} ({\b CTCLInterpreter} &rInterpreter, {\b CTCLResult} &rResult, int nArguments, char *pArguments[])=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnDelete} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ParseInt} (const char *pString, int *pInteger)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ParseInt} (const std::string &rString, int *pInteger)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ParseDouble} (const char *pString, double *pDouble)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ParseDouble} (const std::string &rString, double *pDouble)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ParseBoolean} (const char *pString, {\b Bool_t} *pBoolean)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b ParseBoolean} (const std::string &rString, {\b Bool_t} *pBoolean)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b Register} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Unregister} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnregisterAll} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b ConcatenateParameters} (int nArguments, char *pArguments[])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b EvalRelay} (ClientData pData, Tcl_Interp *pInterp, int Argc, char *Argv[])\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DeleteRelay} (ClientData pObject)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b MatchKeyword} (vector< string > &MatchTable, const string &rValue, int NoMatch=-1)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setCommandName} (const std::string &am_sCommandName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setRegisteredOn} (const std::vector< {\b CTCLInterpreter} * > &am_vRegisteredOn)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddRegisteredOnCurrent} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLProcessor} (const CTCLProcessor &aCTCLProcessor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLProcessor & {\b operator=} (const CTCLProcessor &aCTCLProcessor)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b m_sCommandName}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TCLInterpreterList} {\b m_vRegisteredOn}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CTCLProcessor\:CTCLProcessor}
{\xe \v CTCLProcessor\:CTCLProcessor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLProcessor::CTCLProcessor (const std::string & {\i sCommand}, {\b CTCLInterpreter} * {\i pInterp})}
}\par
{\bkmkstart classCTCLProcessor_a0}
{\bkmkend classCTCLProcessor_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 323 of file TCLProcessor.cpp.\par
\par
References m_sCommandName.}
{\xe \v CTCLProcessor\:CTCLProcessor}
{\xe \v CTCLProcessor\:CTCLProcessor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLProcessor::CTCLProcessor (const char * {\i pCommand}, {\b CTCLInterpreter} * {\i pInterp})}
}\par
{\bkmkstart classCTCLProcessor_a1}
{\bkmkend classCTCLProcessor_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 330 of file TCLProcessor.cpp.\par
\par
References m_sCommandName.}
{\xe \v ~CTCLProcessor\:CTCLProcessor}
{\xe \v CTCLProcessor\:~CTCLProcessor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual CTCLProcessor::~CTCLProcessor (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCTCLProcessor_a2}
{\bkmkend classCTCLProcessor_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 334 of file TCLProcessor.h.\par
\par
References UnregisterAll().}
{\xe \v CTCLProcessor\:CTCLProcessor}
{\xe \v CTCLProcessor\:CTCLProcessor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLProcessor::CTCLProcessor (const CTCLProcessor & {\i aCTCLProcessor}){\f2  [private]}}
}\par
{\bkmkstart classCTCLProcessor_c0}
{\bkmkend classCTCLProcessor_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddRegisteredOnCurrent\:CTCLProcessor}
{\xe \v CTCLProcessor\:AddRegisteredOnCurrent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLProcessor::AddRegisteredOnCurrent (){\f2  [inline, protected]}}
}\par
{\bkmkstart classCTCLProcessor_b2}
{\bkmkend classCTCLProcessor_b2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 380 of file TCLProcessor.h.\par
\par
References CTCLInterpreterObject::AssertIfNotBound(), and m_vRegisteredOn.\par
Referenced by CDAQTCLProcessor::Register().}
{\xe \v begin\:CTCLProcessor}
{\xe \v CTCLProcessor\:begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TCLInterpreterIterator} CTCLProcessor::begin (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLProcessor_a5}
{\bkmkend classCTCLProcessor_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 364 of file TCLProcessor.h.\par
\par
References m_vRegisteredOn, and TCLInterpreterIterator.\par
Referenced by DeleteRelay(), and EvalRelay().}
{\xe \v ConcatenateParameters\:CTCLProcessor}
{\xe \v CTCLProcessor\:ConcatenateParameters}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string CTCLProcessor::ConcatenateParameters (int {\i nArguments}, char * {\i pArguments}[]){\f2  [static]}}
}\par
{\bkmkstart classCTCLProcessor_d0}
{\bkmkend classCTCLProcessor_d0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 346 of file TCLProcessor.cpp.\par
}
{\xe \v DeleteRelay\:CTCLProcessor}
{\xe \v CTCLProcessor\:DeleteRelay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLProcessor::DeleteRelay (ClientData {\i pObject}){\f2  [static]}}
}\par
{\bkmkstart classCTCLProcessor_d2}
{\bkmkend classCTCLProcessor_d2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Reimplemented in {\b CDAQTCLProcessor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDAQTCLProcessor_f1 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 489 of file TCLProcessor.cpp.\par
\par
References begin(), CTCLInterpreterObject::Bind(), end(), CTCLInterpreter::getInterpreter(), CTCLInterpreterObject::getInterpreter(), m_vRegisteredOn, OnDelete(), and TCLInterpreterIterator.\par
Referenced by CDAQTCLProcessor::DeleteRelay(), and Register().}
{\xe \v end\:CTCLProcessor}
{\xe \v CTCLProcessor\:end}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TCLInterpreterIterator} CTCLProcessor::end (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLProcessor_a6}
{\bkmkend classCTCLProcessor_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 367 of file TCLProcessor.h.\par
\par
References m_vRegisteredOn, and TCLInterpreterIterator.\par
Referenced by DeleteRelay(), and EvalRelay().}
{\xe \v EvalRelay\:CTCLProcessor}
{\xe \v CTCLProcessor\:EvalRelay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLProcessor::EvalRelay (ClientData {\i pData}, Tcl_Interp * {\i pInterp}, int {\i Argc}, char * {\i Argv}[]){\f2  [static]}}
}\par
{\bkmkstart classCTCLProcessor_d1}
{\bkmkend classCTCLProcessor_d1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 387 of file TCLProcessor.cpp.\par
\par
References begin(), CTCLInterpreterObject::Bind(), end(), CTCLInterpreter::getInterpreter(), CTCLInterpreterObject::getInterpreter(), and TCLInterpreterIterator.\par
Referenced by CDAQTCLProcessor::EvalRelay(), and Register().}
{\xe \v getCommandName\:CTCLProcessor}
{\xe \v CTCLProcessor\:getCommandName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string CTCLProcessor::getCommandName () const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLProcessor_a4}
{\bkmkend classCTCLProcessor_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 360 of file TCLProcessor.h.\par
\par
References m_sCommandName.\par
Referenced by CDAQTCLProcessor::Register().}
{\xe \v MatchKeyword\:CTCLProcessor}
{\xe \v CTCLProcessor\:MatchKeyword}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLProcessor::MatchKeyword (vector< string > & {\i MatchTable}, const string & {\i rValue}, int {\i NoMatch} = -1){\f2  [static]}}
}\par
{\bkmkstart classCTCLProcessor_d3}
{\bkmkend classCTCLProcessor_d3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 706 of file TCLProcessor.cpp.\par
}
{\xe \v OnDelete\:CTCLProcessor}
{\xe \v CTCLProcessor\:OnDelete}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLProcessor::OnDelete (){\f2  [virtual]}}
}\par
{\bkmkstart classCTCLProcessor_a8}
{\bkmkend classCTCLProcessor_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 460 of file TCLProcessor.cpp.\par
\par
Referenced by DeleteRelay().}
{\xe \v operator()\:CTCLProcessor}
{\xe \v CTCLProcessor\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual int CTCLProcessor::operator() ({\b CTCLInterpreter} & {\i rInterpreter}, {\b CTCLResult} & {\i rResult}, int {\i nArguments}, char * {\i pArguments}[]){\f2  [pure virtual]}}
}\par
{\bkmkstart classCTCLProcessor_a7}
{\bkmkend classCTCLProcessor_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Implemented in {\b CTCLSynchronizeCommand} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCLSynchronizeCommand_a3 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
}
{\xe \v operator=\:CTCLProcessor}
{\xe \v CTCLProcessor\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLProcessor& CTCLProcessor::operator= (const CTCLProcessor & {\i aCTCLProcessor}){\f2  [private]}}
}\par
{\bkmkstart classCTCLProcessor_c1}
{\bkmkend classCTCLProcessor_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:CTCLProcessor}
{\xe \v CTCLProcessor\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLProcessor::operator== (const CTCLProcessor & {\i aCTCLProcessor}) const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLProcessor_a3}
{\bkmkend classCTCLProcessor_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 350 of file TCLProcessor.h.\par
\par
References m_sCommandName, m_vRegisteredOn, and CTCLInterpreterObject::operator==().\par
Referenced by CTCLPackagedCommand::operator==(), CTCLSynchronizeCommand::operator==(), and CDAQTCLProcessor::operator==().}
{\xe \v ParseBoolean\:CTCLProcessor}
{\xe \v CTCLProcessor\:ParseBoolean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLProcessor::ParseBoolean (const std::string & {\i rString}, {\b Bool_t} * {\i pBoolean}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLProcessor_a14}
{\bkmkend classCTCLProcessor_a14}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 411 of file TCLProcessor.h.\par
\par
References Bool_t, and ParseBoolean().}
{\xe \v ParseBoolean\:CTCLProcessor}
{\xe \v CTCLProcessor\:ParseBoolean}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLProcessor::ParseBoolean (const char * {\i pString}, {\b Bool_t} * {\i pBoolean})}
}\par
{\bkmkstart classCTCLProcessor_a13}
{\bkmkend classCTCLProcessor_a13}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 604 of file TCLProcessor.cpp.\par
\par
References Bool_t, CTCLInterpreter::getInterpreter(), and CTCLInterpreterObject::getInterpreter().\par
Referenced by ParseBoolean().}
{\xe \v ParseDouble\:CTCLProcessor}
{\xe \v CTCLProcessor\:ParseDouble}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLProcessor::ParseDouble (const std::string & {\i rString}, double * {\i pDouble}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLProcessor_a12}
{\bkmkend classCTCLProcessor_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 406 of file TCLProcessor.h.\par
\par
References ParseDouble().}
{\xe \v ParseDouble\:CTCLProcessor}
{\xe \v CTCLProcessor\:ParseDouble}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLProcessor::ParseDouble (const char * {\i pString}, double * {\i pDouble})}
}\par
{\bkmkstart classCTCLProcessor_a11}
{\bkmkend classCTCLProcessor_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 572 of file TCLProcessor.cpp.\par
\par
References CTCLInterpreter::getInterpreter(), and CTCLInterpreterObject::getInterpreter().\par
Referenced by ParseDouble().}
{\xe \v ParseInt\:CTCLProcessor}
{\xe \v CTCLProcessor\:ParseInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLProcessor::ParseInt (const std::string & {\i rString}, int * {\i pInteger}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLProcessor_a10}
{\bkmkend classCTCLProcessor_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 401 of file TCLProcessor.h.\par
\par
References ParseInt().}
{\xe \v ParseInt\:CTCLProcessor}
{\xe \v CTCLProcessor\:ParseInt}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLProcessor::ParseInt (const char * {\i pString}, int * {\i pInteger})}
}\par
{\bkmkstart classCTCLProcessor_a9}
{\bkmkend classCTCLProcessor_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 533 of file TCLProcessor.cpp.\par
\par
References CTCLInterpreter::getInterpreter(), and CTCLInterpreterObject::getInterpreter().\par
Referenced by ParseInt().}
{\xe \v Register\:CTCLProcessor}
{\xe \v CTCLProcessor\:Register}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLProcessor::Register (){\f2  [virtual]}}
}\par
{\bkmkstart classCTCLProcessor_a15}
{\bkmkend classCTCLProcessor_a15}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Reimplemented in {\b CDAQTCLProcessor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDAQTCLProcessor_a4 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 642 of file TCLProcessor.cpp.\par
\par
References CTCLInterpreter::AddCommand(), CTCLInterpreterObject::AssertIfNotBound(), DeleteRelay(), EvalRelay(), m_sCommandName, and m_vRegisteredOn.}
{\xe \v setCommandName\:CTCLProcessor}
{\xe \v CTCLProcessor\:setCommandName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLProcessor::setCommandName (const std::string & {\i am_sCommandName}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCTCLProcessor_b0}
{\bkmkend classCTCLProcessor_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 374 of file TCLProcessor.h.\par
\par
References m_sCommandName.}
{\xe \v setRegisteredOn\:CTCLProcessor}
{\xe \v CTCLProcessor\:setRegisteredOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLProcessor::setRegisteredOn (const std::vector< {\b CTCLInterpreter} * > & {\i am_vRegisteredOn}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCTCLProcessor_b1}
{\bkmkend classCTCLProcessor_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 377 of file TCLProcessor.h.\par
\par
References m_vRegisteredOn.}
{\xe \v Unregister\:CTCLProcessor}
{\xe \v CTCLProcessor\:Unregister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLProcessor::Unregister ()}
}\par
{\bkmkstart classCTCLProcessor_a16}
{\bkmkend classCTCLProcessor_a16}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 663 of file TCLProcessor.cpp.\par
\par
References CTCLInterpreterObject::AssertIfNotBound(), m_sCommandName, and CTCLInterpreter::UnregisterCommand().\par
Referenced by UnregisterAll().}
{\xe \v UnregisterAll\:CTCLProcessor}
{\xe \v CTCLProcessor\:UnregisterAll}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLProcessor::UnregisterAll ()}
}\par
{\bkmkstart classCTCLProcessor_a17}
{\bkmkend classCTCLProcessor_a17}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 684 of file TCLProcessor.cpp.\par
\par
References CTCLInterpreterObject::Bind(), CTCLInterpreterObject::getInterpreter(), m_vRegisteredOn, and Unregister().\par
Referenced by ~CTCLProcessor().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_sCommandName\:CTCLProcessor}
{\xe \v CTCLProcessor\:m_sCommandName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string CTCLProcessor::m_sCommandName{\f2  [private]}}
}\par
{\bkmkstart classCTCLProcessor_o0}
{\bkmkend classCTCLProcessor_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 324 of file TCLProcessor.h.\par
\par
Referenced by CTCLProcessor(), getCommandName(), operator==(), Register(), setCommandName(), and Unregister().}
{\xe \v m_vRegisteredOn\:CTCLProcessor}
{\xe \v CTCLProcessor\:m_vRegisteredOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b TCLInterpreterList} CTCLProcessor::m_vRegisteredOn{\f2  [private]}}
}\par
{\bkmkstart classCTCLProcessor_o1}
{\bkmkend classCTCLProcessor_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 325 of file TCLProcessor.h.\par
\par
Referenced by AddRegisteredOnCurrent(), begin(), DeleteRelay(), end(), operator==(), Register(), setRegisteredOn(), and UnregisterAll().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TCLProcessor.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TCLProcessor.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCLResult  Class Reference\par \pard\plain 
{\tc\tcl2 \v CTCLResult}
{\xe \v CTCLResult}
{\bkmkstart classCTCLResult}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <TCLResult.h>}\par
Inheritance diagram for CTCLResult:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCTCLResult.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLResult} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CTCLResult} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLResult} ({\b CTCLInterpreter} *pInterp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLResult} (const CTCLResult &aCTCLResult)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLResult & {\b operator=} (const CTCLResult &aCTCLResult)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CTCLResult &aCTCLResult)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLResult & {\b operator=} (const char *pString)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLResult & {\b operator=} (const std::string &rString)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLResult & {\b operator+=} (const char *pString)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLResult & {\b operator+=} (const std::string &rString)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLResult & {\b operator+} (const char *pString)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLResult & {\b operator+} (const std::string &rString)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Clear} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AppendElement} (const char *pString)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AppendElement} (const std::string &rString)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator const char *} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator std::string} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator CTCLString} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CTCLResult\:CTCLResult}
{\xe \v CTCLResult\:CTCLResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLResult::CTCLResult (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLResult_a0}
{\bkmkend classCTCLResult_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 315 of file TCLResult.h.\par
}
{\xe \v ~CTCLResult\:CTCLResult}
{\xe \v CTCLResult\:~CTCLResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLResult::~CTCLResult (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLResult_a1}
{\bkmkend classCTCLResult_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 316 of file TCLResult.h.\par
}
{\xe \v CTCLResult\:CTCLResult}
{\xe \v CTCLResult\:CTCLResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLResult::CTCLResult ({\b CTCLInterpreter} * {\i pInterp}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLResult_a2}
{\bkmkend classCTCLResult_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 320 of file TCLResult.h.\par
}
{\xe \v CTCLResult\:CTCLResult}
{\xe \v CTCLResult\:CTCLResult}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLResult::CTCLResult (const CTCLResult & {\i aCTCLResult}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLResult_a3}
{\bkmkend classCTCLResult_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 326 of file TCLResult.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AppendElement\:CTCLResult}
{\xe \v CTCLResult\:AppendElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLResult::AppendElement (const std::string & {\i rString}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLResult_a14}
{\bkmkend classCTCLResult_a14}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 373 of file TCLResult.h.\par
\par
References AppendElement().}
{\xe \v AppendElement\:CTCLResult}
{\xe \v CTCLResult\:AppendElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLResult::AppendElement (const char * {\i pString})}
}\par
{\bkmkstart classCTCLResult_a13}
{\bkmkend classCTCLResult_a13}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 394 of file TCLResult.cpp.\par
\par
References CTCLInterpreterObject::AssertIfNotBound(), and CTCLInterpreter::getInterpreter().\par
Referenced by AppendElement().}
{\xe \v Clear\:CTCLResult}
{\xe \v CTCLResult\:Clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLResult::Clear ()}
}\par
{\bkmkstart classCTCLResult_a12}
{\bkmkend classCTCLResult_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 377 of file TCLResult.cpp.\par
\par
References CTCLInterpreterObject::AssertIfNotBound(), and CTCLInterpreter::getInterpreter().}
{\xe \v operator const char *\:CTCLResult}
{\xe \v CTCLResult\:operator const char *}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLResult::operator const char * ()}
}\par
{\bkmkstart classCTCLResult_a15}
{\bkmkend classCTCLResult_a15}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 417 of file TCLResult.cpp.\par
\par
References CTCLInterpreterObject::AssertIfNotBound(), and CTCLInterpreter::getInterpreter().}
{\xe \v operator CTCLString\:CTCLResult}
{\xe \v CTCLResult\:operator CTCLString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLResult::operator {\b CTCLString} ()}
}\par
{\bkmkstart classCTCLResult_a17}
{\bkmkend classCTCLResult_a17}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 450 of file TCLResult.cpp.\par
}
{\xe \v operator std::string\:CTCLResult}
{\xe \v CTCLResult\:operator std::string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLResult::operator std::string ()}
}\par
{\bkmkstart classCTCLResult_a16}
{\bkmkend classCTCLResult_a16}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 434 of file TCLResult.cpp.\par
}
{\xe \v operator+\:CTCLResult}
{\xe \v CTCLResult\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLResult& CTCLResult::operator+ (const std::string & {\i rString}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLResult_a11}
{\bkmkend classCTCLResult_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 366 of file TCLResult.h.\par
\par
References operator+=().}
{\xe \v operator+\:CTCLResult}
{\xe \v CTCLResult\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLResult& CTCLResult::operator+ (const char * {\i pString}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLResult_a10}
{\bkmkend classCTCLResult_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 363 of file TCLResult.h.\par
\par
References operator+=().}
{\xe \v operator+=\:CTCLResult}
{\xe \v CTCLResult\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLResult& CTCLResult::operator+= (const std::string & {\i rString}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLResult_a9}
{\bkmkend classCTCLResult_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 360 of file TCLResult.h.\par
\par
References operator+=().}
{\xe \v operator+=\:CTCLResult}
{\xe \v CTCLResult\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLResult & CTCLResult::operator+= (const char * {\i pString})}
}\par
{\bkmkstart classCTCLResult_a8}
{\bkmkend classCTCLResult_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 350 of file TCLResult.cpp.\par
\par
References CTCLInterpreterObject::AssertIfNotBound(), and CTCLInterpreter::getInterpreter().\par
Referenced by operator+(), and operator+=().}
{\xe \v operator=\:CTCLResult}
{\xe \v CTCLResult\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLResult& CTCLResult::operator= (const std::string & {\i rString}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLResult_a7}
{\bkmkend classCTCLResult_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 355 of file TCLResult.h.\par
\par
References operator=().}
{\xe \v operator=\:CTCLResult}
{\xe \v CTCLResult\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLResult & CTCLResult::operator= (const char * {\i pString})}
}\par
{\bkmkstart classCTCLResult_a6}
{\bkmkend classCTCLResult_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 321 of file TCLResult.cpp.\par
\par
References CTCLInterpreterObject::AssertIfNotBound(), and CTCLInterpreter::getInterpreter().}
{\xe \v operator=\:CTCLResult}
{\xe \v CTCLResult\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLResult& CTCLResult::operator= (const CTCLResult & {\i aCTCLResult}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLResult_a4}
{\bkmkend classCTCLResult_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 334 of file TCLResult.h.\par
\par
References CTCLInterpreterObject::operator=().\par
Referenced by operator=().}
{\xe \v operator==\:CTCLResult}
{\xe \v CTCLResult\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLResult::operator== (const CTCLResult & {\i aCTCLResult}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLResult_a5}
{\bkmkend classCTCLResult_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 344 of file TCLResult.h.\par
\par
References CTCLInterpreterObject::operator==().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TCLResult.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TCLResult.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCLString  Class Reference\par \pard\plain 
{\tc\tcl2 \v CTCLString}
{\xe \v CTCLString}
{\bkmkstart classCTCLString}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <TCLString.h>}\par
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLString} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CTCLString} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLString} (const char *pString)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLString} (const std::string &rString)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLString} (const Tcl_DString &rString)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLString} (const CTCLString &aCTCLString)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLString & {\b operator=} (const CTCLString &aCTCLString)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CTCLString &aCTCLString)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator!=} (const CTCLString &aCTCLString)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator>} (const CTCLString &aCTCLString)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator<} (const CTCLString &aCTCLString)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator>=} (const CTCLString &aCTCLString)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator<=} (const CTCLString &aCTCLString)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Tcl_DString & {\b getString} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setString} (const Tcl_DString &am_String)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLString & {\b Append} (const std::string &rString, {\b Int_t} nLength=-1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLString & {\b Append} (const CTCLString &rString, {\b Int_t} nLength=-1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLString & {\b Append} (Tcl_DString &pString, {\b Int_t} nLength=-1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLString & {\b Append} (const char *pString, {\b Int_t} nLength=-1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLString & {\b AppendElement} (const Tcl_DString *pRhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLString & {\b AppendElement} (const CTCLString &rRhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLString & {\b AppendElement} (const std::string &rRhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLString & {\b AppendElement} (const char *pRhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLString & {\b StartSublist} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLString & {\b EndSublist} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt_t} {\b Length} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLString & {\b Truncate} ({\b UInt_t} nNewLength)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Bool_t} {\b isCommand} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Bool_t} {\b Match} (const char *pPattern) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Bool_t} {\b Match} (std::string &rPattern) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Bool_t} {\b Match} (const CTCLString &rPattern) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator const char *} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator std::string} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b operator Tcl_DString *} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLString & {\b operator+=} (const CTCLString &rRhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLString {\b operator+} (const CTCLString &rRhs)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DoAssign} (const CTCLString &rRhs)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Tcl_DString {\b m_String}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CTCLString\:CTCLString}
{\xe \v CTCLString\:CTCLString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLString::CTCLString (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLString_a0}
{\bkmkend classCTCLString_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 321 of file TCLString.h.\par
\par
References m_String.}
{\xe \v ~CTCLString\:CTCLString}
{\xe \v CTCLString\:~CTCLString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLString::~CTCLString (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLString_a1}
{\bkmkend classCTCLString_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 324 of file TCLString.h.\par
\par
References m_String.}
{\xe \v CTCLString\:CTCLString}
{\xe \v CTCLString\:CTCLString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLString::CTCLString (const char * {\i pString}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLString_a2}
{\bkmkend classCTCLString_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 330 of file TCLString.h.\par
\par
References m_String.}
{\xe \v CTCLString\:CTCLString}
{\xe \v CTCLString\:CTCLString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLString::CTCLString (const std::string & {\i rString}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLString_a3}
{\bkmkend classCTCLString_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 335 of file TCLString.h.\par
\par
References m_String.}
{\xe \v CTCLString\:CTCLString}
{\xe \v CTCLString\:CTCLString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLString::CTCLString (const Tcl_DString & {\i rString}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLString_a4}
{\bkmkend classCTCLString_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 339 of file TCLString.h.\par
\par
References m_String.}
{\xe \v CTCLString\:CTCLString}
{\xe \v CTCLString\:CTCLString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLString::CTCLString (const CTCLString & {\i aCTCLString}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLString_a5}
{\bkmkend classCTCLString_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 346 of file TCLString.h.\par
\par
References DoAssign(), and m_String.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Append\:CTCLString}
{\xe \v CTCLString\:Append}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLString & CTCLString::Append (const char * {\i pString}, {\b Int_t} {\i nLength} = -1)}
}\par
{\bkmkstart classCTCLString_a18}
{\bkmkend classCTCLString_a18}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 317 of file TCLString.cpp.\par
\par
References Int_t, and m_String.}
{\xe \v Append\:CTCLString}
{\xe \v CTCLString\:Append}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLString& CTCLString::Append (Tcl_DString & {\i pString}, {\b Int_t} {\i nLength} = -1){\f2  [inline]}}
}\par
{\bkmkstart classCTCLString_a17}
{\bkmkend classCTCLString_a17}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 413 of file TCLString.h.\par
\par
References Append(), and Int_t.}
{\xe \v Append\:CTCLString}
{\xe \v CTCLString\:Append}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLString& CTCLString::Append (const CTCLString & {\i rString}, {\b Int_t} {\i nLength} = -1){\f2  [inline]}}
}\par
{\bkmkstart classCTCLString_a16}
{\bkmkend classCTCLString_a16}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 410 of file TCLString.h.\par
\par
References Append(), Int_t, and m_String.}
{\xe \v Append\:CTCLString}
{\xe \v CTCLString\:Append}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLString& CTCLString::Append (const std::string & {\i rString}, {\b Int_t} {\i nLength} = -1){\f2  [inline]}}
}\par
{\bkmkstart classCTCLString_a15}
{\bkmkend classCTCLString_a15}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 407 of file TCLString.h.\par
\par
References Int_t.\par
Referenced by Append().}
{\xe \v AppendElement\:CTCLString}
{\xe \v CTCLString\:AppendElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLString & CTCLString::AppendElement (const char * {\i pRhs})}
}\par
{\bkmkstart classCTCLString_a22}
{\bkmkend classCTCLString_a22}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 349 of file TCLString.cpp.\par
\par
References m_String.}
{\xe \v AppendElement\:CTCLString}
{\xe \v CTCLString\:AppendElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLString& CTCLString::AppendElement (const std::string & {\i rRhs}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLString_a21}
{\bkmkend classCTCLString_a21}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 426 of file TCLString.h.\par
\par
References AppendElement().}
{\xe \v AppendElement\:CTCLString}
{\xe \v CTCLString\:AppendElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLString& CTCLString::AppendElement (const CTCLString & {\i rRhs}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLString_a20}
{\bkmkend classCTCLString_a20}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 423 of file TCLString.h.\par
\par
References AppendElement(), and m_String.}
{\xe \v AppendElement\:CTCLString}
{\xe \v CTCLString\:AppendElement}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLString& CTCLString::AppendElement (const Tcl_DString * {\i pRhs}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLString_a19}
{\bkmkend classCTCLString_a19}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 420 of file TCLString.h.\par
\par
Referenced by AppendElement(), CVariableBinding< T >::Dump(), and CArrayBinding< T >::Dump().}
{\xe \v DoAssign\:CTCLString}
{\xe \v CTCLString\:DoAssign}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLString::DoAssign (const CTCLString & {\i rRhs}){\f2  [protected]}}
}\par
{\bkmkstart classCTCLString_b0}
{\bkmkend classCTCLString_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 530 of file TCLString.cpp.\par
\par
References m_String.\par
Referenced by CTCLString(), and operator=().}
{\xe \v EndSublist\:CTCLString}
{\xe \v CTCLString\:EndSublist}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLString & CTCLString::EndSublist ()}
}\par
{\bkmkstart classCTCLString_a24}
{\bkmkend classCTCLString_a24}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 398 of file TCLString.cpp.\par
\par
References m_String.}
{\xe \v getString\:CTCLString}
{\xe \v CTCLString\:getString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Tcl_DString& CTCLString::getString (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLString_a13}
{\bkmkend classCTCLString_a13}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 391 of file TCLString.h.\par
\par
References m_String.}
{\xe \v isCommand\:CTCLString}
{\xe \v CTCLString\:isCommand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Bool_t} CTCLString::isCommand () const}
}\par
{\bkmkstart classCTCLString_a27}
{\bkmkend classCTCLString_a27}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 456 of file TCLString.cpp.\par
\par
References Int_t, and m_String.}
{\xe \v Length\:CTCLString}
{\xe \v CTCLString\:Length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt_t} CTCLString::Length () const}
}\par
{\bkmkstart classCTCLString_a25}
{\bkmkend classCTCLString_a25}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 417 of file TCLString.cpp.\par
\par
References m_String.}
{\xe \v Match\:CTCLString}
{\xe \v CTCLString\:Match}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Bool_t} CTCLString::Match (const CTCLString & {\i rPattern}) const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLString_a30}
{\bkmkend classCTCLString_a30}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 445 of file TCLString.h.\par
\par
References Bool_t, m_String, and Match().}
{\xe \v Match\:CTCLString}
{\xe \v CTCLString\:Match}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Bool_t} CTCLString::Match (std::string & {\i rPattern}) const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLString_a29}
{\bkmkend classCTCLString_a29}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 442 of file TCLString.h.\par
\par
References Bool_t, and Match().}
{\xe \v Match\:CTCLString}
{\xe \v CTCLString\:Match}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Bool_t} CTCLString::Match (const char * {\i pPattern}) const}
}\par
{\bkmkstart classCTCLString_a28}
{\bkmkend classCTCLString_a28}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 471 of file TCLString.cpp.\par
\par
References Int_t, and m_String.\par
Referenced by Match().}
{\xe \v operator const char *\:CTCLString}
{\xe \v CTCLString\:operator const char *}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLString::operator const char * () const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLString_a31}
{\bkmkend classCTCLString_a31}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 449 of file TCLString.h.\par
\par
References m_String.}
{\xe \v operator std::string\:CTCLString}
{\xe \v CTCLString\:operator std::string}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLString::operator std::string () const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLString_a32}
{\bkmkend classCTCLString_a32}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 452 of file TCLString.h.\par
\par
References m_String.}
{\xe \v operator Tcl_DString *\:CTCLString}
{\xe \v CTCLString\:operator Tcl_DString *}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLString::operator Tcl_DString * (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLString_a33}
{\bkmkend classCTCLString_a33}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 455 of file TCLString.h.\par
}
{\xe \v operator!=\:CTCLString}
{\xe \v CTCLString\:operator!=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLString::operator!= (const CTCLString & {\i aCTCLString}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLString_a8}
{\bkmkend classCTCLString_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 369 of file TCLString.h.\par
\par
References operator==().}
{\xe \v operator+\:CTCLString}
{\xe \v CTCLString\:operator+}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLString CTCLString::operator+ (const CTCLString & {\i rRhs})}
}\par
{\bkmkstart classCTCLString_a35}
{\bkmkend classCTCLString_a35}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 504 of file TCLString.cpp.\par
}
{\xe \v operator+=\:CTCLString}
{\xe \v CTCLString\:operator+=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLString& CTCLString::operator+= (const CTCLString & {\i rRhs}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLString_a34}
{\bkmkend classCTCLString_a34}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 458 of file TCLString.h.\par
}
{\xe \v operator<\:CTCLString}
{\xe \v CTCLString\:operator<}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLString::operator< (const CTCLString & {\i aCTCLString}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLString_a10}
{\bkmkend classCTCLString_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 377 of file TCLString.h.\par
\par
References m_String.\par
Referenced by operator<=().}
{\xe \v operator<=\:CTCLString}
{\xe \v CTCLString\:operator<=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLString::operator<= (const CTCLString & {\i aCTCLString}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLString_a12}
{\bkmkend classCTCLString_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 385 of file TCLString.h.\par
\par
References operator<(), and operator==().}
{\xe \v operator=\:CTCLString}
{\xe \v CTCLString\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLString& CTCLString::operator= (const CTCLString & {\i aCTCLString}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLString_a6}
{\bkmkend classCTCLString_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 354 of file TCLString.h.\par
\par
References DoAssign().\par
Referenced by setString().}
{\xe \v operator==\:CTCLString}
{\xe \v CTCLString\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLString::operator== (const CTCLString & {\i aCTCLString}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLString_a7}
{\bkmkend classCTCLString_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 364 of file TCLString.h.\par
\par
References m_String.\par
Referenced by operator!=(), operator<=(), and operator>=().}
{\xe \v operator>\:CTCLString}
{\xe \v CTCLString\:operator>}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLString::operator> (const CTCLString & {\i aCTCLString}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLString_a9}
{\bkmkend classCTCLString_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 372 of file TCLString.h.\par
\par
References m_String.\par
Referenced by operator>=().}
{\xe \v operator>=\:CTCLString}
{\xe \v CTCLString\:operator>=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLString::operator>= (const CTCLString & {\i aCTCLString}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLString_a11}
{\bkmkend classCTCLString_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 382 of file TCLString.h.\par
\par
References operator==(), and operator>().}
{\xe \v setString\:CTCLString}
{\xe \v CTCLString\:setString}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLString::setString (const Tcl_DString & {\i am_String}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLString_a14}
{\bkmkend classCTCLString_a14}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 398 of file TCLString.h.\par
\par
References operator=().}
{\xe \v StartSublist\:CTCLString}
{\xe \v CTCLString\:StartSublist}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLString & CTCLString::StartSublist ()}
}\par
{\bkmkstart classCTCLString_a23}
{\bkmkend classCTCLString_a23}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 378 of file TCLString.cpp.\par
\par
References m_String.}
{\xe \v Truncate\:CTCLString}
{\xe \v CTCLString\:Truncate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLString & CTCLString::Truncate ({\b UInt_t} {\i nNewLength})}
}\par
{\bkmkstart classCTCLString_a26}
{\bkmkend classCTCLString_a26}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 432 of file TCLString.cpp.\par
\par
References m_String, and UInt_t.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_String\:CTCLString}
{\xe \v CTCLString\:m_String}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Tcl_DString CTCLString::m_String{\f2  [private]}}
}\par
{\bkmkstart classCTCLString_o0}
{\bkmkend classCTCLString_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 316 of file TCLString.h.\par
\par
Referenced by Append(), AppendElement(), CTCLString(), DoAssign(), EndSublist(), getString(), isCommand(), Length(), Match(), operator const char *(), operator std::string(), operator<(), operator==(), operator>(), StartSublist(), Truncate(), and ~CTCLString().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TCLString.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TCLString.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCLSynchronizeCommand  Class Reference\par \pard\plain 
{\tc\tcl2 \v CTCLSynchronizeCommand}
{\xe \v CTCLSynchronizeCommand}
{\bkmkstart classCTCLSynchronizeCommand}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CTCLSynchronizeCommand.h>}\par
Inheritance diagram for CTCLSynchronizeCommand:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCTCLSynchronizeCommand.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLSynchronizeCommand} ({\b CTCLInterpreter} *pInterp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CTCLSynchronizeCommand} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Base class destructor does the work.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CTCLSynchronizeCommand &aCTCLSynchronizeCommand) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Operator== Equality Operator.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b operator()} ({\b CTCLInterpreter} &rInterp, {\b CTCLResult} &rResult, int nArguments, char *pArguments[])\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLSynchronizeCommand} (const CTCLSynchronizeCommand &aCTCLSynchronizeCommand)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Copy Constructor private, and unimplemented.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLSynchronizeCommand & {\b operator=} (const CTCLSynchronizeCommand &aCTCLSynchronizeCommand)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Operator= Assignment Operator Private and unimplemented.}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
Implements a Tcl command extension sync \{script\}\par
The script parameter is simply evaluated. Since this class is derived from {\b CDAQTCLProcessor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDAQTCLProcessor \\*MERGEFORMAT}{\fldrslt pagenum}}}), however the script is executed syncrhonized to the application's global mutex. Since the global mutex supports recursive locking, it is legal for the script to have synchronized commands embedded within its body. \par
\par
Definition at line 308 of file CTCLSynchronizeCommand.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CTCLSynchronizeCommand\:CTCLSynchronizeCommand}
{\xe \v CTCLSynchronizeCommand\:CTCLSynchronizeCommand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLSynchronizeCommand::CTCLSynchronizeCommand ({\b CTCLInterpreter} * {\i pInterp}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLSynchronizeCommand_a0}
{\bkmkend classCTCLSynchronizeCommand_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Constructs the command. We only need an interpreter as the command name is fixed as "sync" \par
\par
Definition at line 314 of file CTCLSynchronizeCommand.h.\par
}
{\xe \v ~CTCLSynchronizeCommand\:CTCLSynchronizeCommand}
{\xe \v CTCLSynchronizeCommand\:~CTCLSynchronizeCommand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLSynchronizeCommand::~CTCLSynchronizeCommand (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLSynchronizeCommand_a1}
{\bkmkend classCTCLSynchronizeCommand_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Base class destructor does the work.\par
\par
Definition at line 318 of file CTCLSynchronizeCommand.h.\par
}
{\xe \v CTCLSynchronizeCommand\:CTCLSynchronizeCommand}
{\xe \v CTCLSynchronizeCommand\:CTCLSynchronizeCommand}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLSynchronizeCommand::CTCLSynchronizeCommand (const CTCLSynchronizeCommand & {\i aCTCLSynchronizeCommand}){\f2  [private]}}
}\par
{\bkmkstart classCTCLSynchronizeCommand_c0}
{\bkmkend classCTCLSynchronizeCommand_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Copy Constructor private, and unimplemented.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator()\:CTCLSynchronizeCommand}
{\xe \v CTCLSynchronizeCommand\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLSynchronizeCommand::operator() ({\b CTCLInterpreter} & {\i rInterp}, {\b CTCLResult} & {\i rResult}, int {\i nArguments}, char * {\i pArguments}[]){\f2  [virtual]}}
}\par
{\bkmkstart classCTCLSynchronizeCommand_a3}
{\bkmkend classCTCLSynchronizeCommand_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Executes the script passed as argv[1] synchronized to the appliication's global mutex. Note that the Lack of an Argv[1] is not an error, no action will be performed, but the mutex will have been locked and unlocked.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rInterp}}  is the interpreter on which the command is to execute. \par
{\b {\i rResult}}  is the result string to be filled in by the script. \par
{\b {\i nArguments}}  is the number of command line arguments. \par
{\b {\i pArguments}}  is a char** command parameter list. \par
}\par
Implements {\b CTCLProcessor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCLProcessor_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 307 of file CTCLSynchronizeCommand.cpp.\par
\par
References CTCLInterpreter::Eval().}
{\xe \v operator=\:CTCLSynchronizeCommand}
{\xe \v CTCLSynchronizeCommand\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLSynchronizeCommand& CTCLSynchronizeCommand::operator= (const CTCLSynchronizeCommand & {\i aCTCLSynchronizeCommand}){\f2  [private]}}
}\par
{\bkmkstart classCTCLSynchronizeCommand_c1}
{\bkmkend classCTCLSynchronizeCommand_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operator= Assignment Operator Private and unimplemented.\par
}
{\xe \v operator==\:CTCLSynchronizeCommand}
{\xe \v CTCLSynchronizeCommand\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLSynchronizeCommand::operator== (const CTCLSynchronizeCommand & {\i aCTCLSynchronizeCommand}) const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLSynchronizeCommand_a2}
{\bkmkend classCTCLSynchronizeCommand_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operator== Equality Operator.\par
\par
Definition at line 327 of file CTCLSynchronizeCommand.h.\par
\par
References CTCLProcessor::operator==().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CTCLSynchronizeCommand.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CTCLSynchronizeCommand.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCLTimer  Class Reference\par \pard\plain 
{\tc\tcl2 \v CTCLTimer}
{\xe \v CTCLTimer}
{\bkmkstart classCTCLTimer}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <TCLTimer.h>}\par
Inheritance diagram for CTCLTimer:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCTCLTimer.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLTimer} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLTimer} ({\b CTCLInterpreter} *pInterp, {\b UInt_t} nMsec=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CTCLTimer} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Tk_TimerToken {\b getToken} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt_t} {\b getMsec} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Bool_t} {\b IsSet} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b operator()} ()=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Set} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Set} ({\b UInt_t} nms)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Clear} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b CallbackRelay} (ClientData pObject)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setToken} (Tk_TimerToken am_tToken)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMsec} ({\b UInt_t} am_nMsec)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setSet} ({\b Bool_t} am_fSet)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLTimer} (const CTCLTimer &aCTCLTimer)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLTimer & {\b operator=} (const CTCLTimer &aCTCLTimer)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CTCLTimer &aCTCLTimer)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Tk_TimerToken {\b m_tToken}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UInt_t} {\b m_nMsec}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Bool_t} {\b m_fSet}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CTCLTimer\:CTCLTimer}
{\xe \v CTCLTimer\:CTCLTimer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLTimer::CTCLTimer (){\f2  [inline]}}
}\par
{\bkmkstart classCTCLTimer_a0}
{\bkmkend classCTCLTimer_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 324 of file TCLTimer.h.\par
\par
References m_fSet, m_nMsec, and m_tToken.}
{\xe \v CTCLTimer\:CTCLTimer}
{\xe \v CTCLTimer\:CTCLTimer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLTimer::CTCLTimer ({\b CTCLInterpreter} * {\i pInterp}, {\b UInt_t} {\i nMsec} = 0){\f2  [inline]}}
}\par
{\bkmkstart classCTCLTimer_a1}
{\bkmkend classCTCLTimer_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 330 of file TCLTimer.h.\par
\par
References m_fSet, m_nMsec, m_tToken, and UInt_t.}
{\xe \v ~CTCLTimer\:CTCLTimer}
{\xe \v CTCLTimer\:~CTCLTimer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual CTCLTimer::~CTCLTimer (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCTCLTimer_a2}
{\bkmkend classCTCLTimer_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 336 of file TCLTimer.h.\par
\par
References Clear().}
{\xe \v CTCLTimer\:CTCLTimer}
{\xe \v CTCLTimer\:CTCLTimer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLTimer::CTCLTimer (const CTCLTimer & {\i aCTCLTimer}){\f2  [private]}}
}\par
{\bkmkstart classCTCLTimer_c0}
{\bkmkend classCTCLTimer_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v CallbackRelay\:CTCLTimer}
{\xe \v CTCLTimer\:CallbackRelay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLTimer::CallbackRelay (ClientData {\i pObject}){\f2  [static]}}
}\par
{\bkmkstart classCTCLTimer_d0}
{\bkmkend classCTCLTimer_d0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 321 of file TCLTimer.cpp.\par
\par
References m_fSet.\par
Referenced by Set().}
{\xe \v Clear\:CTCLTimer}
{\xe \v CTCLTimer\:Clear}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLTimer::Clear ()}
}\par
{\bkmkstart classCTCLTimer_a9}
{\bkmkend classCTCLTimer_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Reimplemented in {\b CTCLIdleProcess} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCLIdleProcess_a5 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 369 of file TCLTimer.cpp.\par
\par
References m_fSet, and m_tToken.\par
Referenced by CTCLIdleProcess::Clear(), and ~CTCLTimer().}
{\xe \v getMsec\:CTCLTimer}
{\xe \v CTCLTimer\:getMsec}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt_t} CTCLTimer::getMsec () const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLTimer_a4}
{\bkmkend classCTCLTimer_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 360 of file TCLTimer.h.\par
\par
References m_nMsec, and UInt_t.}
{\xe \v getToken\:CTCLTimer}
{\xe \v CTCLTimer\:getToken}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Tk_TimerToken CTCLTimer::getToken () const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLTimer_a3}
{\bkmkend classCTCLTimer_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 356 of file TCLTimer.h.\par
\par
References m_tToken.}
{\xe \v IsSet\:CTCLTimer}
{\xe \v CTCLTimer\:IsSet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Bool_t} CTCLTimer::IsSet () const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLTimer_a5}
{\bkmkend classCTCLTimer_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 364 of file TCLTimer.h.\par
\par
References Bool_t, and m_fSet.}
{\xe \v operator()\:CTCLTimer}
{\xe \v CTCLTimer\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void CTCLTimer::operator() (){\f2  [pure virtual]}}
}\par
{\bkmkstart classCTCLTimer_a6}
{\bkmkend classCTCLTimer_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Implemented in {\b CTCLIdleProcess} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCLIdleProcess_a6 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
}
{\xe \v operator=\:CTCLTimer}
{\xe \v CTCLTimer\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLTimer& CTCLTimer::operator= (const CTCLTimer & {\i aCTCLTimer}){\f2  [private]}}
}\par
{\bkmkstart classCTCLTimer_c1}
{\bkmkend classCTCLTimer_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:CTCLTimer}
{\xe \v CTCLTimer\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLTimer::operator== (const CTCLTimer & {\i aCTCLTimer}){\f2  [private]}}
}\par
{\bkmkstart classCTCLTimer_c2}
{\bkmkend classCTCLTimer_c2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Set\:CTCLTimer}
{\xe \v CTCLTimer\:Set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLTimer::Set ({\b UInt_t} {\i nms}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLTimer_a8}
{\bkmkend classCTCLTimer_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 390 of file TCLTimer.h.\par
\par
References m_nMsec, Set(), and UInt_t.}
{\xe \v Set\:CTCLTimer}
{\xe \v CTCLTimer\:Set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLTimer::Set ()}
}\par
{\bkmkstart classCTCLTimer_a7}
{\bkmkend classCTCLTimer_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Reimplemented in {\b CTCLIdleProcess} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCLIdleProcess_a4 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 344 of file TCLTimer.cpp.\par
\par
References CallbackRelay(), m_fSet, m_nMsec, and m_tToken.\par
Referenced by Set(), and CTCLIdleProcess::Set().}
{\xe \v setMsec\:CTCLTimer}
{\xe \v CTCLTimer\:setMsec}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLTimer::setMsec ({\b UInt_t} {\i am_nMsec}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCTCLTimer_b1}
{\bkmkend classCTCLTimer_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 376 of file TCLTimer.h.\par
\par
References m_nMsec, and UInt_t.}
{\xe \v setSet\:CTCLTimer}
{\xe \v CTCLTimer\:setSet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLTimer::setSet ({\b Bool_t} {\i am_fSet}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCTCLTimer_b2}
{\bkmkend classCTCLTimer_b2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 380 of file TCLTimer.h.\par
\par
References Bool_t, and m_fSet.}
{\xe \v setToken\:CTCLTimer}
{\xe \v CTCLTimer\:setToken}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLTimer::setToken (Tk_TimerToken {\i am_tToken}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCTCLTimer_b0}
{\bkmkend classCTCLTimer_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 372 of file TCLTimer.h.\par
\par
References m_tToken.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_fSet\:CTCLTimer}
{\xe \v CTCLTimer\:m_fSet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Bool_t} CTCLTimer::m_fSet{\f2  [private]}}
}\par
{\bkmkstart classCTCLTimer_o2}
{\bkmkend classCTCLTimer_o2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 319 of file TCLTimer.h.\par
\par
Referenced by CallbackRelay(), Clear(), CTCLTimer(), IsSet(), Set(), and setSet().}
{\xe \v m_nMsec\:CTCLTimer}
{\xe \v CTCLTimer\:m_nMsec}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UInt_t} CTCLTimer::m_nMsec{\f2  [private]}}
}\par
{\bkmkstart classCTCLTimer_o1}
{\bkmkend classCTCLTimer_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 318 of file TCLTimer.h.\par
\par
Referenced by CTCLTimer(), getMsec(), Set(), and setMsec().}
{\xe \v m_tToken\:CTCLTimer}
{\xe \v CTCLTimer\:m_tToken}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Tk_TimerToken CTCLTimer::m_tToken{\f2  [private]}}
}\par
{\bkmkstart classCTCLTimer_o0}
{\bkmkend classCTCLTimer_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 317 of file TCLTimer.h.\par
\par
Referenced by Clear(), CTCLTimer(), getToken(), Set(), and setToken().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TCLTimer.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TCLTimer.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCLVariable  Class Reference\par \pard\plain 
{\tc\tcl2 \v CTCLVariable}
{\xe \v CTCLVariable}
{\bkmkstart classCTCLVariable}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <TCLVariable.h>}\par
Inheritance diagram for CTCLVariable:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCTCLVariable.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLVariable} (std::string am_sVariable, {\b Bool_t} am_fTracing)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLVariable} ({\b CTCLInterpreter} *pInterp, std::string am_sVariable, {\b Bool_t} am_fTracing)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CTCLVariable} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLVariable} (const CTCLVariable &aCTCLVariable)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCLVariable & {\b operator=} (const CTCLVariable &aCTCLVariable)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CTCLVariable &aCTCLVariable) const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b getVariableName} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Bool_t} {\b IsTracing} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setVariableName} (const std::string am_sVariable)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual char * {\b operator()} (char *pName, char *pSubscript, int Flags)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const char * {\b Set} (const char *pValue, int flags=TCL_LEAVE_ERR_MSG|TCL_GLOBAL_ONLY)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const char * {\b Set} (const char *pSubscript, char *pValue, int flags=TCL_LEAVE_ERR_MSG|TCL_GLOBAL_ONLY)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const char * {\b Get} (int flags=TCL_LEAVE_ERR_MSG|TCL_GLOBAL_ONLY, char *pIndex=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Link} (void *pVariable, int Type)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Unlink} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Trace} (int flags=TCL_TRACE_READS|TCL_TRACE_WRITES|TCL_TRACE_UNSETS, char *pIndex=(char *) {\b kpNULL})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnTrace} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Update} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b TraceRelay} (ClientData pObject, Tcl_Interp *pInterpreter, char *pName, char *pIndex, int flags)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTracing} ({\b Bool_t} am_fTracing)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DoAssign} (const CTCLVariable &rRhs)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b m_sVariable}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Bool_t} {\b m_fTracing}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Int_t} {\b m_nTraceFlags}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
std::string {\b m_sTraceIndex}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CTCLVariable\:CTCLVariable}
{\xe \v CTCLVariable\:CTCLVariable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLVariable::CTCLVariable (std::string {\i am_sVariable}, {\b Bool_t} {\i am_fTracing}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLVariable_a0}
{\bkmkend classCTCLVariable_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 320 of file TCLVariable.h.\par
\par
References Bool_t, m_fTracing, and m_sVariable.}
{\xe \v CTCLVariable\:CTCLVariable}
{\xe \v CTCLVariable\:CTCLVariable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLVariable::CTCLVariable ({\b CTCLInterpreter} * {\i pInterp}, std::string {\i am_sVariable}, {\b Bool_t} {\i am_fTracing}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLVariable_a1}
{\bkmkend classCTCLVariable_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 325 of file TCLVariable.h.\par
\par
References Bool_t, m_fTracing, and m_sVariable.}
{\xe \v ~CTCLVariable\:CTCLVariable}
{\xe \v CTCLVariable\:~CTCLVariable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLVariable::~CTCLVariable ()}
}\par
{\bkmkstart classCTCLVariable_a2}
{\bkmkend classCTCLVariable_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 312 of file TCLVariable.cpp.\par
\par
References m_sVariable, and UnTrace().}
{\xe \v CTCLVariable\:CTCLVariable}
{\xe \v CTCLVariable\:CTCLVariable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLVariable::CTCLVariable (const CTCLVariable & {\i aCTCLVariable}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLVariable_a3}
{\bkmkend classCTCLVariable_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 334 of file TCLVariable.h.\par
\par
References DoAssign(), m_fTracing, and m_sVariable.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v DoAssign\:CTCLVariable}
{\xe \v CTCLVariable\:DoAssign}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLVariable::DoAssign (const CTCLVariable & {\i rRhs}){\f2  [protected]}}
}\par
{\bkmkstart classCTCLVariable_b1}
{\bkmkend classCTCLVariable_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 618 of file TCLVariable.cpp.\par
\par
References m_fTracing, m_nTraceFlags, m_sTraceIndex, m_sVariable, Trace(), and UnTrace().\par
Referenced by CTCLVariable(), and operator=().}
{\xe \v Get\:CTCLVariable}
{\xe \v CTCLVariable\:Get}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * CTCLVariable::Get (int {\i flags} = TCL_LEAVE_ERR_MSG|TCL_GLOBAL_ONLY, char * {\i pIndex} = 0){\f2  [virtual]}}
}\par
{\bkmkstart classCTCLVariable_a12}
{\bkmkend classCTCLVariable_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 468 of file TCLVariable.cpp.\par
\par
References CTCLInterpreterObject::AssertIfNotBound(), CTCLInterpreter::getInterpreter(), and m_sVariable.\par
Referenced by CArrayBinding< T >::Commit().}
{\xe \v getVariableName\:CTCLVariable}
{\xe \v CTCLVariable\:getVariableName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string CTCLVariable::getVariableName () const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLVariable_a6}
{\bkmkend classCTCLVariable_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 367 of file TCLVariable.h.\par
\par
References m_sVariable.}
{\xe \v IsTracing\:CTCLVariable}
{\xe \v CTCLVariable\:IsTracing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Bool_t} CTCLVariable::IsTracing () const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLVariable_a7}
{\bkmkend classCTCLVariable_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 371 of file TCLVariable.h.\par
\par
References Bool_t, and m_fTracing.\par
Referenced by setVariableName().}
{\xe \v Link\:CTCLVariable}
{\xe \v CTCLVariable\:Link}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLVariable::Link (void * {\i pVariable}, int {\i Type})}
}\par
{\bkmkstart classCTCLVariable_a13}
{\bkmkend classCTCLVariable_a13}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 495 of file TCLVariable.cpp.\par
\par
References CTCLInterpreterObject::AssertIfNotBound(), CTCLInterpreter::getInterpreter(), and m_sVariable.}
{\xe \v operator()\:CTCLVariable}
{\xe \v CTCLVariable\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char * CTCLVariable::operator() (char * {\i pName}, char * {\i pSubscript}, int {\i Flags}){\f2  [virtual]}}
}\par
{\bkmkstart classCTCLVariable_a9}
{\bkmkend classCTCLVariable_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 326 of file TCLVariable.cpp.\par
}
{\xe \v operator=\:CTCLVariable}
{\xe \v CTCLVariable\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCLVariable& CTCLVariable::operator= (const CTCLVariable & {\i aCTCLVariable}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLVariable_a4}
{\bkmkend classCTCLVariable_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 344 of file TCLVariable.h.\par
\par
References DoAssign(), and CTCLInterpreterObject::operator=().}
{\xe \v operator==\:CTCLVariable}
{\xe \v CTCLVariable\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLVariable::operator== (const CTCLVariable & {\i aCTCLVariable}) const{\f2  [inline]}}
}\par
{\bkmkstart classCTCLVariable_a5}
{\bkmkend classCTCLVariable_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 355 of file TCLVariable.h.\par
\par
References m_fTracing, m_sVariable, and CTCLInterpreterObject::operator==().}
{\xe \v Set\:CTCLVariable}
{\xe \v CTCLVariable\:Set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * CTCLVariable::Set (const char * {\i pSubscript}, char * {\i pValue}, int {\i flags} = TCL_LEAVE_ERR_MSG|TCL_GLOBAL_ONLY){\f2  [virtual]}}
}\par
{\bkmkstart classCTCLVariable_a11}
{\bkmkend classCTCLVariable_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 446 of file TCLVariable.cpp.\par
\par
References CTCLInterpreterObject::AssertIfNotBound(), CTCLInterpreter::getInterpreter(), and m_sVariable.}
{\xe \v Set\:CTCLVariable}
{\xe \v CTCLVariable\:Set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * CTCLVariable::Set (const char * {\i pValue}, int {\i flags} = TCL_LEAVE_ERR_MSG|TCL_GLOBAL_ONLY){\f2  [virtual]}}
}\par
{\bkmkstart classCTCLVariable_a10}
{\bkmkend classCTCLVariable_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 414 of file TCLVariable.cpp.\par
\par
References CTCLInterpreterObject::AssertIfNotBound(), CTCLInterpreter::getInterpreter(), and m_sVariable.}
{\xe \v setTracing\:CTCLVariable}
{\xe \v CTCLVariable\:setTracing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLVariable::setTracing ({\b Bool_t} {\i am_fTracing}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCTCLVariable_b0}
{\bkmkend classCTCLVariable_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 385 of file TCLVariable.h.\par
\par
References Bool_t, and m_fTracing.}
{\xe \v setVariableName\:CTCLVariable}
{\xe \v CTCLVariable\:setVariableName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLVariable::setVariableName (const std::string {\i am_sVariable}){\f2  [inline]}}
}\par
{\bkmkstart classCTCLVariable_a8}
{\bkmkend classCTCLVariable_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 379 of file TCLVariable.h.\par
\par
References IsTracing(), m_sVariable, and UnTrace().}
{\xe \v Trace\:CTCLVariable}
{\xe \v CTCLVariable\:Trace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCLVariable::Trace (int {\i flags} = TCL_TRACE_READS|TCL_TRACE_WRITES|TCL_TRACE_UNSETS, char * {\i pIndex} = (char *) {\b kpNULL})}
}\par
{\bkmkstart classCTCLVariable_a15}
{\bkmkend classCTCLVariable_a15}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 549 of file TCLVariable.cpp.\par
\par
References CTCLInterpreterObject::AssertIfNotBound(), CTCLInterpreter::getInterpreter(), m_fTracing, m_nTraceFlags, m_sTraceIndex, m_sVariable, TraceRelay(), and UnTrace().\par
Referenced by DoAssign().}
{\xe \v TraceRelay\:CTCLVariable}
{\xe \v CTCLVariable\:TraceRelay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char * CTCLVariable::TraceRelay (ClientData {\i pObject}, Tcl_Interp * {\i pInterpreter}, char * {\i pName}, char * {\i pIndex}, int {\i flags}){\f2  [static]}}
}\par
{\bkmkstart classCTCLVariable_d0}
{\bkmkend classCTCLVariable_d0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 370 of file TCLVariable.cpp.\par
\par
References CTCLInterpreterObject::AssertIfNotBound(), and CTCLInterpreter::getInterpreter().\par
Referenced by Trace(), and UnTrace().}
{\xe \v Unlink\:CTCLVariable}
{\xe \v CTCLVariable\:Unlink}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLVariable::Unlink ()}
}\par
{\bkmkstart classCTCLVariable_a14}
{\bkmkend classCTCLVariable_a14}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 532 of file TCLVariable.cpp.\par
\par
References CTCLInterpreterObject::AssertIfNotBound(), CTCLInterpreter::getInterpreter(), and m_sVariable.}
{\xe \v UnTrace\:CTCLVariable}
{\xe \v CTCLVariable\:UnTrace}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLVariable::UnTrace ()}
}\par
{\bkmkstart classCTCLVariable_a16}
{\bkmkend classCTCLVariable_a16}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 592 of file TCLVariable.cpp.\par
\par
References CTCLInterpreterObject::AssertIfNotBound(), CTCLInterpreter::getInterpreter(), m_nTraceFlags, m_sTraceIndex, m_sVariable, and TraceRelay().\par
Referenced by DoAssign(), setVariableName(), Trace(), and ~CTCLVariable().}
{\xe \v Update\:CTCLVariable}
{\xe \v CTCLVariable\:Update}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCLVariable::Update ()}
}\par
{\bkmkstart classCTCLVariable_a17}
{\bkmkend classCTCLVariable_a17}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Invokes Tcl_UpdateLinkedVar on this variable. Intended to be used if the variable is linked to a C/C++ variable that may be modified by the C/C++ code but traced by Tcl. \par
\par
Definition at line 645 of file TCLVariable.cpp.\par
\par
References CTCLInterpreter::getInterpreter(), CTCLInterpreterObject::getInterpreter(), and m_sVariable.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_fTracing\:CTCLVariable}
{\xe \v CTCLVariable\:m_fTracing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Bool_t} CTCLVariable::m_fTracing{\f2  [private]}}
}\par
{\bkmkstart classCTCLVariable_o1}
{\bkmkend classCTCLVariable_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 313 of file TCLVariable.h.\par
\par
Referenced by CTCLVariable(), DoAssign(), IsTracing(), operator==(), setTracing(), and Trace().}
{\xe \v m_nTraceFlags\:CTCLVariable}
{\xe \v CTCLVariable\:m_nTraceFlags}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Int_t} CTCLVariable::m_nTraceFlags{\f2  [private]}}
}\par
{\bkmkstart classCTCLVariable_o2}
{\bkmkend classCTCLVariable_o2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 314 of file TCLVariable.h.\par
\par
Referenced by DoAssign(), Trace(), and UnTrace().}
{\xe \v m_sTraceIndex\:CTCLVariable}
{\xe \v CTCLVariable\:m_sTraceIndex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string CTCLVariable::m_sTraceIndex{\f2  [private]}}
}\par
{\bkmkstart classCTCLVariable_o3}
{\bkmkend classCTCLVariable_o3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 315 of file TCLVariable.h.\par
\par
Referenced by DoAssign(), Trace(), and UnTrace().}
{\xe \v m_sVariable\:CTCLVariable}
{\xe \v CTCLVariable\:m_sVariable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
std::string CTCLVariable::m_sVariable{\f2  [private]}}
}\par
{\bkmkstart classCTCLVariable_o0}
{\bkmkend classCTCLVariable_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 312 of file TCLVariable.h.\par
\par
Referenced by CTCLVariable(), DoAssign(), Get(), getVariableName(), Link(), operator==(), Set(), setVariableName(), Trace(), Unlink(), UnTrace(), Update(), and ~CTCLVariable().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TCLVariable.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b TCLVariable.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCPBadSocketState  Class Reference\par \pard\plain 
{\tc\tcl2 \v CTCPBadSocketState}
{\xe \v CTCPBadSocketState}
{\bkmkstart classCTCPBadSocketState}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CTCPBadSocketState.h>}\par
Inheritance diagram for CTCPBadSocketState:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCTCPBadSocketState.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCPBadSocketState} ({\b CSocket::State} badState, vector< {\b CSocket::State} > okStates, const char *pDoing)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCPBadSocketState} (const CTCPBadSocketState &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CTCPBadSocketState} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCPBadSocketState & {\b operator=} (const CTCPBadSocketState &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CTCPBadSocketState &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CSocket::State} {\b getBadState} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< {\b CSocket::State} > {\b getValidStates} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const char * {\b ReasonText} () const\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setBadState} ({\b CSocket::State} newState)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setValidStates} (const vector< {\b CSocket::State} > &newStates)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CSocket::State} {\b m_BadState}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Incorrect state at time of throw.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
vector< {\b CSocket::State} > {\b m_ValidStates}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i States which would have been ok.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_Message}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Full error message built up here.}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
Encapsulates an exception which will be thrown whenever a {\b CSocket} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCSocket \\*MERGEFORMAT}{\fldrslt pagenum}}}) member is called when the socket is in an invalid state. The exception recognizes that there may be a list of valid states which the socket can be in and will indicate in the exception message the set of valid states. \par
\par
Definition at line 319 of file CTCPBadSocketState.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CTCPBadSocketState\:CTCPBadSocketState}
{\xe \v CTCPBadSocketState\:CTCPBadSocketState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCPBadSocketState::CTCPBadSocketState ({\b CSocket::State} {\i badState}, vector< {\b CSocket::State} > {\i okStates}, const char * {\i pDoing})}
}\par
{\bkmkstart classCTCPBadSocketState_a0}
{\bkmkend classCTCPBadSocketState_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
"Normal Constructor" This constructor is normally used prior to throwing a CTCPBadSocketState object as an exception.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i badState}}  - the state of the {\b CSocket} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCSocket \\*MERGEFORMAT}{\fldrslt pagenum}}}) object which threw the exception which was objectionable. \par
{\b {\i okStates}}  - A vector of states which would have been ok for the socket to have been in at the time it threw. \par
{\b {\i pDoing}}  - A textual description of what the {\b CSocket} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCSocket \\*MERGEFORMAT}{\fldrslt pagenum}}}) object was asked to do when it detected the invalid state. \par
}\par
Definition at line 306 of file CTCPBadSocketState.cpp.\par
\par
References CSocket::State.}
{\xe \v CTCPBadSocketState\:CTCPBadSocketState}
{\xe \v CTCPBadSocketState\:CTCPBadSocketState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCPBadSocketState::CTCPBadSocketState (const CTCPBadSocketState & {\i rhs})}
}\par
{\bkmkstart classCTCPBadSocketState_a1}
{\bkmkend classCTCPBadSocketState_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
"Copy constructor" This constructor creates a new object from a 'reference' object. This is used by the compiler to create temporaries, it is also used by throw to copy the exception to a "spot" where it cannot go out of scope as it travels up the call stack in search of a handler.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rhs}}  - the reference object copied. \par
}\par
Definition at line 323 of file CTCPBadSocketState.cpp.\par
}
{\xe \v ~CTCPBadSocketState\:CTCPBadSocketState}
{\xe \v CTCPBadSocketState\:~CTCPBadSocketState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual CTCPBadSocketState::~CTCPBadSocketState (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCTCPBadSocketState_a2}
{\bkmkend classCTCPBadSocketState_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 333 of file CTCPBadSocketState.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getBadState\:CTCPBadSocketState}
{\xe \v CTCPBadSocketState\:getBadState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CSocket::State} CTCPBadSocketState::getBadState () const{\f2  [inline]}}
}\par
{\bkmkstart classCTCPBadSocketState_a5}
{\bkmkend classCTCPBadSocketState_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 341 of file CTCPBadSocketState.h.\par
\par
References m_BadState, and CSocket::State.}
{\xe \v getValidStates\:CTCPBadSocketState}
{\xe \v CTCPBadSocketState\:getValidStates}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector<{\b CSocket::State}> CTCPBadSocketState::getValidStates () const{\f2  [inline]}}
}\par
{\bkmkstart classCTCPBadSocketState_a6}
{\bkmkend classCTCPBadSocketState_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 343 of file CTCPBadSocketState.h.\par
\par
References m_ValidStates.}
{\xe \v operator=\:CTCPBadSocketState}
{\xe \v CTCPBadSocketState\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCPBadSocketState & CTCPBadSocketState::operator= (const CTCPBadSocketState & {\i rhs})}
}\par
{\bkmkstart classCTCPBadSocketState_a3}
{\bkmkend classCTCPBadSocketState_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Assignement... little different from copy construction however:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Any existing members require cleanup if they are dynamic, since we are already fully constructed.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
We avoid self assignment.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
We return a reference to ourselves after the copy in.\par
}{{{\b Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rhs}}  The right hand side object which is being assigned to us. \par
}\par
Definition at line 341 of file CTCPBadSocketState.cpp.\par
\par
References m_BadState, m_ValidStates, and CException::operator=().}
{\xe \v operator==\:CTCPBadSocketState}
{\xe \v CTCPBadSocketState\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCPBadSocketState::operator== (const CTCPBadSocketState & {\i rhs})}
}\par
{\bkmkstart classCTCPBadSocketState_a4}
{\bkmkend classCTCPBadSocketState_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Equality comparison. Returns int indicating if for all practical purposes this is the same as the rhs. m_Message is not compared as it is  inconsequential. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rhs}}  The object *this is being compared to. \par
}\par
Definition at line 358 of file CTCPBadSocketState.cpp.\par
\par
References m_BadState, m_ValidStates, and CException::operator==().}
{\xe \v ReasonText\:CTCPBadSocketState}
{\xe \v CTCPBadSocketState\:ReasonText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * CTCPBadSocketState::ReasonText () const{\f2  [virtual]}}
}\par
{\bkmkstart classCTCPBadSocketState_a7}
{\bkmkend classCTCPBadSocketState_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Build up and return a text string describing why the  exception was thrown. This is done from the m_BadState, m_ValidStates, and base class {\b WasDoing}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCException_a10 \\*MERGEFORMAT}{\fldrslt pagenum}}}) strings. The final string is of the form:\par
"{\b CSocket} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCSocket \\*MERGEFORMAT}{\fldrslt pagenum}}}) member called while in state m_BadState, Valid states are m_ValidStates, {\b CSocket} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCSocket \\*MERGEFORMAT}{\fldrslt pagenum}}}) was attempting to: {\b WasDoing}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCException_a10 \\*MERGEFORMAT}{\fldrslt pagenum}}})" \par
\par
Reimplemented from {\b CException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCException_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 378 of file CTCPBadSocketState.cpp.\par
\par
References m_BadState, m_Message, m_ValidStates, CSocket::StateName(), and CException::WasDoing().}
{\xe \v setBadState\:CTCPBadSocketState}
{\xe \v CTCPBadSocketState\:setBadState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCPBadSocketState::setBadState ({\b CSocket::State} {\i newState}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCTCPBadSocketState_b0}
{\bkmkend classCTCPBadSocketState_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 349 of file CTCPBadSocketState.h.\par
\par
References m_BadState, and CSocket::State.}
{\xe \v setValidStates\:CTCPBadSocketState}
{\xe \v CTCPBadSocketState\:setValidStates}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCPBadSocketState::setValidStates (const vector< {\b CSocket::State} > & {\i newStates}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCTCPBadSocketState_b1}
{\bkmkend classCTCPBadSocketState_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 351 of file CTCPBadSocketState.h.\par
\par
References m_ValidStates.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_BadState\:CTCPBadSocketState}
{\xe \v CTCPBadSocketState\:m_BadState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CSocket::State} CTCPBadSocketState::m_BadState{\f2  [private]}}
}\par
{\bkmkstart classCTCPBadSocketState_o0}
{\bkmkend classCTCPBadSocketState_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Incorrect state at time of throw.\par
\par
Definition at line 323 of file CTCPBadSocketState.h.\par
\par
Referenced by getBadState(), operator=(), operator==(), ReasonText(), and setBadState().}
{\xe \v m_Message\:CTCPBadSocketState}
{\xe \v CTCPBadSocketState\:m_Message}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CTCPBadSocketState::m_Message{\f2  [private]}}
}\par
{\bkmkstart classCTCPBadSocketState_o2}
{\bkmkend classCTCPBadSocketState_o2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Full error message built up here.\par
\par
Definition at line 325 of file CTCPBadSocketState.h.\par
\par
Referenced by ReasonText().}
{\xe \v m_ValidStates\:CTCPBadSocketState}
{\xe \v CTCPBadSocketState\:m_ValidStates}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
vector<{\b CSocket::State}> CTCPBadSocketState::m_ValidStates{\f2  [private]}}
}\par
{\bkmkstart classCTCPBadSocketState_o1}
{\bkmkend classCTCPBadSocketState_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
States which would have been ok.\par
\par
Definition at line 324 of file CTCPBadSocketState.h.\par
\par
Referenced by getValidStates(), operator=(), operator==(), ReasonText(), and setValidStates().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CTCPBadSocketState.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CTCPBadSocketState.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCPConnectionFailed  Class Reference\par \pard\plain 
{\tc\tcl2 \v CTCPConnectionFailed}
{\xe \v CTCPConnectionFailed}
{\bkmkstart classCTCPConnectionFailed}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CTCPConnectionFailed.h>}\par
Inheritance diagram for CTCPConnectionFailed:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCTCPConnectionFailed.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCPConnectionFailed} (const string &host, const string &service, const char *pDoing)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCPConnectionFailed} (const CTCPConnectionFailed &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CTCPConnectionFailed} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Destructor.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCPConnectionFailed & {\b operator=} (const CTCPConnectionFailed &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CTCPConnectionFailed &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b getHost} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b getService} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const char * {\b ReasonText} () const\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setHost} (const string &rHost)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setService} (const string &rService)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_Host}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Attempted peername.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_Service}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Attempted connection point port.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_ReasonText}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Reason text is built up here.}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
Encapsulates a connection failure exception. Since connect(2) reports failure reasons through errno, this classs derives from {\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}). \par
\par
Definition at line 297 of file CTCPConnectionFailed.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CTCPConnectionFailed\:CTCPConnectionFailed}
{\xe \v CTCPConnectionFailed\:CTCPConnectionFailed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCPConnectionFailed::CTCPConnectionFailed (const string & {\i host}, const string & {\i service}, const char * {\i pDoing})}
}\par
{\bkmkstart classCTCPConnectionFailed_a0}
{\bkmkend classCTCPConnectionFailed_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
'Normal constructor' intended to be used to instantiate an object prior to throwing it as an exception.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i host}}  - Name of the host which to which the connection was attempted \par
{\b {\i service}}  - Textualized service to which the connection was attempted \par
{\b {\i pDoing}}  - Context information describing what {\b CSocket} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCSocket \\*MERGEFORMAT}{\fldrslt pagenum}}}) was doing when the exceptional condition was detected. \par
}\par
Definition at line 298 of file CTCPConnectionFailed.cpp.\par
}
{\xe \v CTCPConnectionFailed\:CTCPConnectionFailed}
{\xe \v CTCPConnectionFailed\:CTCPConnectionFailed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCPConnectionFailed::CTCPConnectionFailed (const CTCPConnectionFailed & {\i rhs})}
}\par
{\bkmkstart classCTCPConnectionFailed_a1}
{\bkmkend classCTCPConnectionFailed_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Copy Constructor. Used by the compiler to create temporaries and by the throw statement to create a copy of the actual exception object to ensure that the exception remains in scope while it travels up the call stack  searching for a handler.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rhs}}  - The reference object which is being copy constructed. \par
}\par
Definition at line 314 of file CTCPConnectionFailed.cpp.\par
}
{\xe \v ~CTCPConnectionFailed\:CTCPConnectionFailed}
{\xe \v CTCPConnectionFailed\:~CTCPConnectionFailed}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCPConnectionFailed::~CTCPConnectionFailed (){\f2  [inline]}}
}\par
{\bkmkstart classCTCPConnectionFailed_a2}
{\bkmkend classCTCPConnectionFailed_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Destructor.\par
\par
Definition at line 312 of file CTCPConnectionFailed.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getHost\:CTCPConnectionFailed}
{\xe \v CTCPConnectionFailed\:getHost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CTCPConnectionFailed::getHost () const{\f2  [inline]}}
}\par
{\bkmkstart classCTCPConnectionFailed_a5}
{\bkmkend classCTCPConnectionFailed_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 320 of file CTCPConnectionFailed.h.\par
\par
References m_Host.}
{\xe \v getService\:CTCPConnectionFailed}
{\xe \v CTCPConnectionFailed\:getService}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CTCPConnectionFailed::getService () const{\f2  [inline]}}
}\par
{\bkmkstart classCTCPConnectionFailed_a6}
{\bkmkend classCTCPConnectionFailed_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 322 of file CTCPConnectionFailed.h.\par
\par
References m_Service.}
{\xe \v operator=\:CTCPConnectionFailed}
{\xe \v CTCPConnectionFailed\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCPConnectionFailed & CTCPConnectionFailed::operator= (const CTCPConnectionFailed & {\i rhs})}
}\par
{\bkmkstart classCTCPConnectionFailed_a3}
{\bkmkend classCTCPConnectionFailed_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Assignment. The functionality is the same as a copy constructor, however the target is a fully constructed object. We protect, therefore against assignment to *this, and since this is not a constructor, we cannot use initializers to assign our members. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rhs}}  - The object we are being assigned to. \par
}\par
Definition at line 328 of file CTCPConnectionFailed.cpp.\par
\par
References m_Host, m_Service, and CErrnoException::operator=().}
{\xe \v operator==\:CTCPConnectionFailed}
{\xe \v CTCPConnectionFailed\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCPConnectionFailed::operator== (const CTCPConnectionFailed & {\i rhs})}
}\par
{\bkmkstart classCTCPConnectionFailed_a4}
{\bkmkend classCTCPConnectionFailed_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Equality compare... This is essentially a member by member compare. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rhs}}  - the object to which we are being compared. \par
}\par
Definition at line 342 of file CTCPConnectionFailed.cpp.\par
\par
References m_Host, m_Service, and CErrnoException::operator==().}
{\xe \v ReasonText\:CTCPConnectionFailed}
{\xe \v CTCPConnectionFailed\:ReasonText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * CTCPConnectionFailed::ReasonText () const{\f2  [virtual]}}
}\par
{\bkmkstart classCTCPConnectionFailed_a7}
{\bkmkend classCTCPConnectionFailed_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns a textual string describing the message. This is going to be something like: Failed to connect to host: m_Host on service port m_Service,  {\b CErrnoException::ReasonText}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}). \par
\par
Reimplemented from {\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 355 of file CTCPConnectionFailed.cpp.\par
\par
References m_Host, m_ReasonText, m_Service, and CErrnoException::ReasonText().}
{\xe \v setHost\:CTCPConnectionFailed}
{\xe \v CTCPConnectionFailed\:setHost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCPConnectionFailed::setHost (const string & {\i rHost}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCTCPConnectionFailed_b0}
{\bkmkend classCTCPConnectionFailed_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 328 of file CTCPConnectionFailed.h.\par
\par
References m_Host.}
{\xe \v setService\:CTCPConnectionFailed}
{\xe \v CTCPConnectionFailed\:setService}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCPConnectionFailed::setService (const string & {\i rService}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCTCPConnectionFailed_b1}
{\bkmkend classCTCPConnectionFailed_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 330 of file CTCPConnectionFailed.h.\par
\par
References m_Service.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_Host\:CTCPConnectionFailed}
{\xe \v CTCPConnectionFailed\:m_Host}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CTCPConnectionFailed::m_Host{\f2  [private]}}
}\par
{\bkmkstart classCTCPConnectionFailed_o0}
{\bkmkend classCTCPConnectionFailed_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Attempted peername.\par
\par
Definition at line 301 of file CTCPConnectionFailed.h.\par
\par
Referenced by getHost(), operator=(), operator==(), ReasonText(), and setHost().}
{\xe \v m_ReasonText\:CTCPConnectionFailed}
{\xe \v CTCPConnectionFailed\:m_ReasonText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CTCPConnectionFailed::m_ReasonText{\f2  [private]}}
}\par
{\bkmkstart classCTCPConnectionFailed_o2}
{\bkmkend classCTCPConnectionFailed_o2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Reason text is built up here.\par
\par
Definition at line 303 of file CTCPConnectionFailed.h.\par
\par
Referenced by ReasonText().}
{\xe \v m_Service\:CTCPConnectionFailed}
{\xe \v CTCPConnectionFailed\:m_Service}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CTCPConnectionFailed::m_Service{\f2  [private]}}
}\par
{\bkmkstart classCTCPConnectionFailed_o1}
{\bkmkend classCTCPConnectionFailed_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Attempted connection point port.\par
\par
Definition at line 302 of file CTCPConnectionFailed.h.\par
\par
Referenced by getService(), operator=(), operator==(), ReasonText(), and setService().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CTCPConnectionFailed.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CTCPConnectionFailed.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCPConnectionLost  Class Reference\par \pard\plain 
{\tc\tcl2 \v CTCPConnectionLost}
{\xe \v CTCPConnectionLost}
{\bkmkstart classCTCPConnectionLost}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CTCPConnectionLost.h>}\par
Inheritance diagram for CTCPConnectionLost:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCTCPConnectionLost.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCPConnectionLost} ({\b CSocket} *pSocket, const char *pDoing)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCPConnectionLost} (const CTCPConnectionLost &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CTCPConnectionLost} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCPConnectionLost & {\b operator=} (const CTCPConnectionLost &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CTCPConnectionLost &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b getHost} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b getPort} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const char * {\b ReasonText} () const\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setHost} (const string &rHost)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPort} (const string &rPort)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Host} ({\b CSocket} *pSocket)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Port} ({\b CSocket} *pSocket)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_Host}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_Port}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_ReasonText}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
Encapsulate the connection lost exception. This exception is thrown when a read is attempted on a busted socket. \par
\par
Definition at line 306 of file CTCPConnectionLost.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CTCPConnectionLost\:CTCPConnectionLost}
{\xe \v CTCPConnectionLost\:CTCPConnectionLost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCPConnectionLost::CTCPConnectionLost ({\b CSocket} * {\i pSocket}, const char * {\i pDoing})}
}\par
{\bkmkstart classCTCPConnectionLost_a0}
{\bkmkend classCTCPConnectionLost_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
'Normal constructor' This is called prior to throwing a connection lost exception. The host and port information are gotten from the  socket. The reason the connection was lost is currently in errno.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i pSocket}}  - the socket which just lost connection. \par
}\par
Definition at line 308 of file CTCPConnectionLost.cpp.\par
\par
References Host(), and Port().}
{\xe \v CTCPConnectionLost\:CTCPConnectionLost}
{\xe \v CTCPConnectionLost\:CTCPConnectionLost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCPConnectionLost::CTCPConnectionLost (const CTCPConnectionLost & {\i rhs})}
}\par
{\bkmkstart classCTCPConnectionLost_a1}
{\bkmkend classCTCPConnectionLost_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Copy constructor.. used by the compiler to generate termporary variables and of course, by throw to create a scope-safe copy of the exception being thrown. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rhs}}  - the reference object being copied. \par
}\par
Definition at line 319 of file CTCPConnectionLost.cpp.\par
}
{\xe \v ~CTCPConnectionLost\:CTCPConnectionLost}
{\xe \v CTCPConnectionLost\:~CTCPConnectionLost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual CTCPConnectionLost::~CTCPConnectionLost (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCTCPConnectionLost_a2}
{\bkmkend classCTCPConnectionLost_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 320 of file CTCPConnectionLost.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getHost\:CTCPConnectionLost}
{\xe \v CTCPConnectionLost\:getHost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CTCPConnectionLost::getHost () const{\f2  [inline]}}
}\par
{\bkmkstart classCTCPConnectionLost_a5}
{\bkmkend classCTCPConnectionLost_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 329 of file CTCPConnectionLost.h.\par
\par
References m_Host.}
{\xe \v getPort\:CTCPConnectionLost}
{\xe \v CTCPConnectionLost\:getPort}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CTCPConnectionLost::getPort () const{\f2  [inline]}}
}\par
{\bkmkstart classCTCPConnectionLost_a6}
{\bkmkend classCTCPConnectionLost_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 331 of file CTCPConnectionLost.h.\par
\par
References m_Port.}
{\xe \v Host\:CTCPConnectionLost}
{\xe \v CTCPConnectionLost\:Host}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCPConnectionLost::Host ({\b CSocket} * {\i pSocket}){\f2  [protected]}}
}\par
{\bkmkstart classCTCPConnectionLost_b2}
{\bkmkend classCTCPConnectionLost_b2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Extract the peer's hostname from the socket. This is done as follows:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The fd of the socket is gotten.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
getpeername(2) is called to get the peer address.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
gethostbyaddr(3) is called to translate this (if possible) to a hostname.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
If gethostbyaddr(3) failed to return a useful hostname, inet_addr(3) is used to translate the peer address into a dotted ip string.\par
}{{{\b Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i pSocket}}  - Pointer to the socket for which this information is to be retrieved.\par
}NOTE: We assume gethostbyaddr(3) and inet_addr(3) are not thread-safe. \par
\par
Definition at line 397 of file CTCPConnectionLost.cpp.\par
\par
References CApplicationSerializer::getInstance(), CSocket::getSocketFd(), CThreadRecursiveMutex::Lock(), m_Host, and CThreadRecursiveMutex::UnLock().\par
Referenced by CTCPConnectionLost().}
{\xe \v operator=\:CTCPConnectionLost}
{\xe \v CTCPConnectionLost\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCPConnectionLost & CTCPConnectionLost::operator= (const CTCPConnectionLost & {\i rhs})}
}\par
{\bkmkstart classCTCPConnectionLost_a3}
{\bkmkend classCTCPConnectionLost_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Assignment operator. Only slightly different than copy construction:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Protect against self assign.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Return *this.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
this is already fully constructed.\par
}{{{\b Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rhs}}  - Reference to rhs of assignment operation. \par
}\par
Definition at line 334 of file CTCPConnectionLost.cpp.\par
\par
References m_Host, m_Port, and CErrnoException::operator=().}
{\xe \v operator==\:CTCPConnectionLost}
{\xe \v CTCPConnectionLost\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCPConnectionLost::operator== (const CTCPConnectionLost & {\i rhs})}
}\par
{\bkmkstart classCTCPConnectionLost_a4}
{\bkmkend classCTCPConnectionLost_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Equality comparison.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rhs}}  The right hand side of the ==. \par
}\par
Definition at line 349 of file CTCPConnectionLost.cpp.\par
\par
References m_Host, m_Port, and CErrnoException::operator==().}
{\xe \v Port\:CTCPConnectionLost}
{\xe \v CTCPConnectionLost\:Port}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCPConnectionLost::Port ({\b CSocket} * {\i pSocket}){\f2  [protected]}}
}\par
{\bkmkstart classCTCPConnectionLost_b3}
{\bkmkend classCTCPConnectionLost_b3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
For a given {\b CSocket} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCSocket \\*MERGEFORMAT}{\fldrslt pagenum}}})* fills in m_Port. This is done by:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Retreiving the socket fd.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Asking getpeername(2) who is attached to the socket.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Asking getservbyport(3) to return the service name from the port.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
If getservbyport(3) failed, the numeric service name is encoded.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
If getpeername(2) failed, the port -unavailable- is returned.\par
}{{{\b Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i pSocket}}  - Pointer to the soket about which we're asking.\par
}NOTE: We assume that getservbyport(3) is not thread safe. \par
\par
Definition at line 437 of file CTCPConnectionLost.cpp.\par
\par
References CApplicationSerializer::getInstance(), CSocket::getSocketFd(), CThreadRecursiveMutex::Lock(), m_Port, and CThreadRecursiveMutex::UnLock().\par
Referenced by CTCPConnectionLost().}
{\xe \v ReasonText\:CTCPConnectionLost}
{\xe \v CTCPConnectionLost\:ReasonText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * CTCPConnectionLost::ReasonText () const{\f2  [virtual]}}
}\par
{\bkmkstart classCTCPConnectionLost_a7}
{\bkmkend classCTCPConnectionLost_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Return the reason for the exception as a textual string of the form:\par
Connection with host m_Host at m_Port was lost: {\b CErrnoException::ReasonText}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}) \par
\par
Reimplemented from {\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 367 of file CTCPConnectionLost.cpp.\par
\par
References m_Host, m_Port, m_ReasonText, and CErrnoException::ReasonText().}
{\xe \v setHost\:CTCPConnectionLost}
{\xe \v CTCPConnectionLost\:setHost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCPConnectionLost::setHost (const string & {\i rHost}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCTCPConnectionLost_b0}
{\bkmkend classCTCPConnectionLost_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 337 of file CTCPConnectionLost.h.\par
\par
References m_Host.}
{\xe \v setPort\:CTCPConnectionLost}
{\xe \v CTCPConnectionLost\:setPort}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCPConnectionLost::setPort (const string & {\i rPort}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCTCPConnectionLost_b1}
{\bkmkend classCTCPConnectionLost_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 340 of file CTCPConnectionLost.h.\par
\par
References m_Port.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_Host\:CTCPConnectionLost}
{\xe \v CTCPConnectionLost\:m_Host}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CTCPConnectionLost::m_Host{\f2  [private]}}
}\par
{\bkmkstart classCTCPConnectionLost_o0}
{\bkmkend classCTCPConnectionLost_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 310 of file CTCPConnectionLost.h.\par
\par
Referenced by getHost(), Host(), operator=(), operator==(), ReasonText(), and setHost().}
{\xe \v m_Port\:CTCPConnectionLost}
{\xe \v CTCPConnectionLost\:m_Port}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CTCPConnectionLost::m_Port{\f2  [private]}}
}\par
{\bkmkstart classCTCPConnectionLost_o1}
{\bkmkend classCTCPConnectionLost_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 311 of file CTCPConnectionLost.h.\par
\par
Referenced by getPort(), operator=(), operator==(), Port(), ReasonText(), and setPort().}
{\xe \v m_ReasonText\:CTCPConnectionLost}
{\xe \v CTCPConnectionLost\:m_ReasonText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CTCPConnectionLost::m_ReasonText{\f2  [private]}}
}\par
{\bkmkstart classCTCPConnectionLost_o2}
{\bkmkend classCTCPConnectionLost_o2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 313 of file CTCPConnectionLost.h.\par
\par
Referenced by ReasonText().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CTCPConnectionLost.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CTCPConnectionLost.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCPNoSuchHost  Class Reference\par \pard\plain 
{\tc\tcl2 \v CTCPNoSuchHost}
{\xe \v CTCPNoSuchHost}
{\bkmkstart classCTCPNoSuchHost}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CTCPNoSuchHost.h>}\par
Inheritance diagram for CTCPNoSuchHost:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCTCPNoSuchHost.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCPNoSuchHost} (const string &hostname, const string &Doing)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCPNoSuchHost} (const CTCPNoSuchHost &rhs)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Copy constructor.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CTCPNoSuchHost} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Destructor.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCPNoSuchHost & {\b operator=} (const CTCPNoSuchHost &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CTCPNoSuchHost &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b gethErrno} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i < Return h_errno at time of instantiation.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b getHost} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i < Return name of failing host.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const char * {\b ReasonText} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b Int_t} {\b ReasonCode} () const\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b sethErrno} (int newVal)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setHost} (const string newVal)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b m_hErrno}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Cached value of errno when instantiated.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_Host}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Host which doesn't exist.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_Reason}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i String for building up reason text.}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
Encapsulates an exception which indicates a failure to translate a host specification string into an IP address. Hosts are translated from two posible string formats\par
{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Hostnames DNS hostnames such as crusher.nscl.msu.edu\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
IPaddresses stringified dotted ip addresses e.g. 35.8.33.224\par
}The exception produces reason strings which describe why the host could not be opened along with contextual information supplied by the application when the object is instantiated. \par
\par
Definition at line 315 of file CTCPNoSuchHost.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CTCPNoSuchHost\:CTCPNoSuchHost}
{\xe \v CTCPNoSuchHost\:CTCPNoSuchHost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCPNoSuchHost::CTCPNoSuchHost (const string & {\i hostname}, const string & {\i Doing})}
}\par
{\bkmkstart classCTCPNoSuchHost_a0}
{\bkmkend classCTCPNoSuchHost_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
'Normal' Constructor for the exception class. Initializes the base class and sets up the initial object state.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i hostname}}  Name of the host which could not be looked up. \par
{\b {\i Doing}}  String which describes what the application was attempting to do when the exceptional condition was thrown. This string is encoded verbatim into the ReasonText.\par
}External Inputs:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
h_errno The (thread) global containing the error number describing why the last host database function called failed. \par
}\par
Definition at line 307 of file CTCPNoSuchHost.cpp.\par
}
{\xe \v CTCPNoSuchHost\:CTCPNoSuchHost}
{\xe \v CTCPNoSuchHost\:CTCPNoSuchHost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCPNoSuchHost::CTCPNoSuchHost (const CTCPNoSuchHost & {\i rhs})}
}\par
{\bkmkstart classCTCPNoSuchHost_a1}
{\bkmkend classCTCPNoSuchHost_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Copy constructor.\par
Copy constructor. Used to build temporaries for e.g. call by value or return by value functional semantics.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rhs}}  - The original object from which the copy is constructed. \par
}\par
Definition at line 321 of file CTCPNoSuchHost.cpp.\par
}
{\xe \v ~CTCPNoSuchHost\:CTCPNoSuchHost}
{\xe \v CTCPNoSuchHost\:~CTCPNoSuchHost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual CTCPNoSuchHost::~CTCPNoSuchHost (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCTCPNoSuchHost_a2}
{\bkmkend classCTCPNoSuchHost_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Destructor.\par
\par
Definition at line 328 of file CTCPNoSuchHost.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v gethErrno\:CTCPNoSuchHost}
{\xe \v CTCPNoSuchHost\:gethErrno}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCPNoSuchHost::gethErrno () const{\f2  [inline]}}
}\par
{\bkmkstart classCTCPNoSuchHost_a5}
{\bkmkend classCTCPNoSuchHost_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
< Return h_errno at time of instantiation.\par
\par
Definition at line 336 of file CTCPNoSuchHost.h.\par
\par
References m_hErrno.}
{\xe \v getHost\:CTCPNoSuchHost}
{\xe \v CTCPNoSuchHost\:getHost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CTCPNoSuchHost::getHost () const{\f2  [inline]}}
}\par
{\bkmkstart classCTCPNoSuchHost_a6}
{\bkmkend classCTCPNoSuchHost_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
< Return name of failing host.\par
\par
Definition at line 338 of file CTCPNoSuchHost.h.\par
\par
References m_Host.}
{\xe \v operator=\:CTCPNoSuchHost}
{\xe \v CTCPNoSuchHost\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCPNoSuchHost & CTCPNoSuchHost::operator= (const CTCPNoSuchHost & {\i rhs})}
}\par
{\bkmkstart classCTCPNoSuchHost_a3}
{\bkmkend classCTCPNoSuchHost_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Assignment operator{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rhs}}  - the right hand side of the assignment. \par
}\par
Definition at line 333 of file CTCPNoSuchHost.cpp.\par
}
{\xe \v operator==\:CTCPNoSuchHost}
{\xe \v CTCPNoSuchHost\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCPNoSuchHost::operator== (const CTCPNoSuchHost & {\i rhs})}
}\par
{\bkmkstart classCTCPNoSuchHost_a4}
{\bkmkend classCTCPNoSuchHost_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Comparison operator.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rhs}}  - the right hand side of the comparison (Who *this is potentially equal to). \par
}\par
Definition at line 347 of file CTCPNoSuchHost.cpp.\par
\par
References m_hErrno, m_Host, and CException::operator==().}
{\xe \v ReasonCode\:CTCPNoSuchHost}
{\xe \v CTCPNoSuchHost\:ReasonCode}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Int_t} CTCPNoSuchHost::ReasonCode () const{\f2  [virtual]}}
}\par
{\bkmkstart classCTCPNoSuchHost_a8}
{\bkmkend classCTCPNoSuchHost_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns the exception specific reason code. In this case, m_hErrno. \par
\par
Reimplemented from {\b CException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCException_a9 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 379 of file CTCPNoSuchHost.cpp.\par
\par
References m_hErrno.}
{\xe \v ReasonText\:CTCPNoSuchHost}
{\xe \v CTCPNoSuchHost\:ReasonText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * CTCPNoSuchHost::ReasonText () const{\f2  [virtual]}}
}\par
{\bkmkstart classCTCPNoSuchHost_a7}
{\bkmkend classCTCPNoSuchHost_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns a textual string indicating why the exception was thrown. This string is suitable for diaplay to a user. The string is of the form: "Host Lookup failed for [m_Host] due to: [hstrerror(m_hErrno)]  while [{\b WasDoing}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCException_a10 \\*MERGEFORMAT}{\fldrslt pagenum}}})]" \par
\par
Reimplemented from {\b CException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCException_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 364 of file CTCPNoSuchHost.cpp.\par
\par
References m_hErrno, m_Host, m_Reason, and CException::WasDoing().}
{\xe \v sethErrno\:CTCPNoSuchHost}
{\xe \v CTCPNoSuchHost\:sethErrno}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCPNoSuchHost::sethErrno (int {\i newVal}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCTCPNoSuchHost_b0}
{\bkmkend classCTCPNoSuchHost_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 344 of file CTCPNoSuchHost.h.\par
\par
References m_hErrno.}
{\xe \v setHost\:CTCPNoSuchHost}
{\xe \v CTCPNoSuchHost\:setHost}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCPNoSuchHost::setHost (const string {\i newVal}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCTCPNoSuchHost_b1}
{\bkmkend classCTCPNoSuchHost_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 346 of file CTCPNoSuchHost.h.\par
\par
References m_Host.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_hErrno\:CTCPNoSuchHost}
{\xe \v CTCPNoSuchHost\:m_hErrno}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCPNoSuchHost::m_hErrno{\f2  [private]}}
}\par
{\bkmkstart classCTCPNoSuchHost_o0}
{\bkmkend classCTCPNoSuchHost_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Cached value of errno when instantiated.\par
\par
Definition at line 319 of file CTCPNoSuchHost.h.\par
\par
Referenced by gethErrno(), operator==(), ReasonCode(), ReasonText(), and sethErrno().}
{\xe \v m_Host\:CTCPNoSuchHost}
{\xe \v CTCPNoSuchHost\:m_Host}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CTCPNoSuchHost::m_Host{\f2  [private]}}
}\par
{\bkmkstart classCTCPNoSuchHost_o1}
{\bkmkend classCTCPNoSuchHost_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Host which doesn't exist.\par
\par
Definition at line 320 of file CTCPNoSuchHost.h.\par
\par
Referenced by getHost(), operator==(), ReasonText(), and setHost().}
{\xe \v m_Reason\:CTCPNoSuchHost}
{\xe \v CTCPNoSuchHost\:m_Reason}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CTCPNoSuchHost::m_Reason{\f2  [private]}}
}\par
{\bkmkstart classCTCPNoSuchHost_o2}
{\bkmkend classCTCPNoSuchHost_o2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
String for building up reason text.\par
\par
Definition at line 321 of file CTCPNoSuchHost.h.\par
\par
Referenced by ReasonText().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CTCPNoSuchHost.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CTCPNoSuchHost.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCPNoSuchService  Class Reference\par \pard\plain 
{\tc\tcl2 \v CTCPNoSuchService}
{\xe \v CTCPNoSuchService}
{\bkmkstart classCTCPNoSuchService}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CTCPNoSuchService.h>}\par
Inheritance diagram for CTCPNoSuchService:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCTCPNoSuchService.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCPNoSuchService} (const string &service, const string &Doing)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCPNoSuchService} (const CTCPNoSuchService &rhs)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Copy Constructor.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CTCPNoSuchService} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Destructor.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTCPNoSuchService & {\b operator=} (const CTCPNoSuchService &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CTCPNoSuchService &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b getService} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i < Return service name.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual const char * {\b ReasonText} () const\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setService} (const string &newVal)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_Service}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i cached value of service.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_Reason}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Where the reason text is built up.}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
Encapsulates an excpetion which indicates a failure to translate a service specification string into a service port number. Service strings can be either a service name which is looked up in e.g. /etc/services or a  stringified service port number. \par
\par
Definition at line 309 of file CTCPNoSuchService.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CTCPNoSuchService\:CTCPNoSuchService}
{\xe \v CTCPNoSuchService\:CTCPNoSuchService}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCPNoSuchService::CTCPNoSuchService (const string & {\i service}, const string & {\i Doing})}
}\par
{\bkmkstart classCTCPNoSuchService_a0}
{\bkmkend classCTCPNoSuchService_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Standard constructor. Initialize the member variables to values determined by the application and environmental parameters.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i service}}  Textualized service which could not be found. This could either be a service name (mis-spelled e.g.) or a textualized service number. \par
{\b {\i Doing}}  Context information provided by the application to describe what it was trying to do when the failure was detected.\par
}External inputs:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
errno (Thread specific) global variable containing the reason getserv database functions failed. \par
}\par
Definition at line 309 of file CTCPNoSuchService.cpp.\par
}
{\xe \v CTCPNoSuchService\:CTCPNoSuchService}
{\xe \v CTCPNoSuchService\:CTCPNoSuchService}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCPNoSuchService::CTCPNoSuchService (const CTCPNoSuchService & {\i rhs})}
}\par
{\bkmkstart classCTCPNoSuchService_a1}
{\bkmkend classCTCPNoSuchService_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Copy Constructor.\par
Copy constructor: Creates an object given a reference object. Used by the language to produce temporaries for .e.g. call by value and return by value function interactions.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rhs}}  The reference object being copied into *this. \par
}\par
Definition at line 322 of file CTCPNoSuchService.cpp.\par
}
{\xe \v ~CTCPNoSuchService\:CTCPNoSuchService}
{\xe \v CTCPNoSuchService\:~CTCPNoSuchService}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual CTCPNoSuchService::~CTCPNoSuchService (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCTCPNoSuchService_a2}
{\bkmkend classCTCPNoSuchService_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Destructor.\par
\par
Definition at line 320 of file CTCPNoSuchService.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getService\:CTCPNoSuchService}
{\xe \v CTCPNoSuchService\:getService}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CTCPNoSuchService::getService () const{\f2  [inline]}}
}\par
{\bkmkstart classCTCPNoSuchService_a5}
{\bkmkend classCTCPNoSuchService_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
< Return service name.\par
\par
Definition at line 328 of file CTCPNoSuchService.h.\par
\par
References m_Service.}
{\xe \v operator=\:CTCPNoSuchService}
{\xe \v CTCPNoSuchService\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTCPNoSuchService & CTCPNoSuchService::operator= (const CTCPNoSuchService & {\i rhs})}
}\par
{\bkmkstart classCTCPNoSuchService_a3}
{\bkmkend classCTCPNoSuchService_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Assignment. Assign *this to a rhs object. Different from copy construction in that:{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
We already exist as a validly constructed object.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
We return a reference to ourselves so that = chaining is supported.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
We prevent self assignment.\par
}{{{\b Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rhs}}  The item to which we are being assigned. \par
}\par
Definition at line 338 of file CTCPNoSuchService.cpp.\par
\par
References m_Service, and CErrnoException::operator=().}
{\xe \v operator==\:CTCPNoSuchService}
{\xe \v CTCPNoSuchService\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTCPNoSuchService::operator== (const CTCPNoSuchService & {\i rhs})}
}\par
{\bkmkstart classCTCPNoSuchService_a4}
{\bkmkend classCTCPNoSuchService_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Equality compare.. This is a field by field compare of the important elements Note that the m_Reason member is unimportant to the compare.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rhs}}  The object *this is being compared to. \par
}\par
Definition at line 353 of file CTCPNoSuchService.cpp.\par
\par
References m_Service, and CErrnoException::operator==().}
{\xe \v ReasonText\:CTCPNoSuchService}
{\xe \v CTCPNoSuchService\:ReasonText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char * CTCPNoSuchService::ReasonText () const{\f2  [virtual]}}
}\par
{\bkmkstart classCTCPNoSuchService_a6}
{\bkmkend classCTCPNoSuchService_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns the reason for the exception. This is a string which is built up from CErrno::ReasonText and other information we have it is of the form: "Unable to translate service [m_Service] becuase: [CErrno::ReasonText()]" \par
\par
Reimplemented from {\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 367 of file CTCPNoSuchService.cpp.\par
\par
References m_Reason, m_Service, and CErrnoException::ReasonText().}
{\xe \v setService\:CTCPNoSuchService}
{\xe \v CTCPNoSuchService\:setService}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTCPNoSuchService::setService (const string & {\i newVal}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCTCPNoSuchService_b0}
{\bkmkend classCTCPNoSuchService_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 334 of file CTCPNoSuchService.h.\par
\par
References m_Service.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_Reason\:CTCPNoSuchService}
{\xe \v CTCPNoSuchService\:m_Reason}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CTCPNoSuchService::m_Reason{\f2  [private]}}
}\par
{\bkmkstart classCTCPNoSuchService_o1}
{\bkmkend classCTCPNoSuchService_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Where the reason text is built up.\par
\par
Definition at line 314 of file CTCPNoSuchService.h.\par
\par
Referenced by ReasonText().}
{\xe \v m_Service\:CTCPNoSuchService}
{\xe \v CTCPNoSuchService\:m_Service}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CTCPNoSuchService::m_Service{\f2  [private]}}
}\par
{\bkmkstart classCTCPNoSuchService_o0}
{\bkmkend classCTCPNoSuchService_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
cached value of service.\par
\par
Definition at line 313 of file CTCPNoSuchService.h.\par
\par
Referenced by getService(), operator=(), operator==(), ReasonText(), and setService().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CTCPNoSuchService.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CTCPNoSuchService.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CThreadRecursiveMutex  Class Reference\par \pard\plain 
{\tc\tcl2 \v CThreadRecursiveMutex}
{\xe \v CThreadRecursiveMutex}
{\bkmkstart classCThreadRecursiveMutex}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid CThreadRecursiveMutex {\b CThreadRecursiveMutex.h}. 
\par
{\f2 #include <CThreadRecursiveMutex.h>}\par
Inheritance diagram for CThreadRecursiveMutex:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCThreadRecursiveMutex.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CThreadRecursiveMutex} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Default Constructor.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CThreadRecursiveMutex} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Destructor.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
DAQThreadMutex {\b getMutex} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i < Retrieve m_Mutex.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
daqthread_t {\b getOwningThread} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i < Retrieve m_tOwningThread.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned {\b getLockLevel} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i < Retrieve m_LockLevel.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
DAQThreadMutex {\b getMonitorMutex} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i < Return m_MonitoMutex.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Lock} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b UnLock} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b TryLock} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b isLocked} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnLockCompletely} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMutex} (const DAQThreadMutex am_Mutex)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setOwningThread} (const daqthread_t am_tOwningThread)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setLockLevel} (const unsigned am_nLockLevel)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setMonitorMutex} (const DAQThreadMutex am_MonitorMutex)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CThreadRecursiveMutex} (const CThreadRecursiveMutex &rRhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CThreadRecursiveMutex &aCThreadRecursiveMutex) const\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
DAQThreadMutex {\b m_Mutex}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Mutex locked.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
daqthread_t {\b m_tOwningThread}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Id of owning thread.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned {\b m_nLockLevel}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Locking depth for owning thread.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
DAQThreadMutex {\b m_MonitorMutex}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Atomicity Mutex.}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid CThreadRecursiveMutex {\b CThreadRecursiveMutex.h}.\par
\par
Provides a mutex which can be locked in a nested manner by a thread. The "nested ness' is managed through the m_nLockLevel and the  m_OwningThread member. Atomicity of the otherwise non-atomic  function is handled by bracketing calls with locks of the mutexe's own m_MonitorMutex Gaurentees:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
No process will be starved.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Processes blocked waiting for the mutex will be served in the order in which they entered the blocking queue. \par
}\par
Definition at line 313 of file CThreadRecursiveMutex.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CThreadRecursiveMutex\:CThreadRecursiveMutex}
{\xe \v CThreadRecursiveMutex\:CThreadRecursiveMutex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CThreadRecursiveMutex::CThreadRecursiveMutex ()}
}\par
{\bkmkstart classCThreadRecursiveMutex_a0}
{\bkmkend classCThreadRecursiveMutex_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Default Constructor.\par
\par
Definition at line 304 of file CThreadRecursiveMutex.cpp.\par
}
{\xe \v ~CThreadRecursiveMutex\:CThreadRecursiveMutex}
{\xe \v CThreadRecursiveMutex\:~CThreadRecursiveMutex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CThreadRecursiveMutex::~CThreadRecursiveMutex ()}
}\par
{\bkmkstart classCThreadRecursiveMutex_a1}
{\bkmkend classCThreadRecursiveMutex_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Destructor.\par
\par
Definition at line 315 of file CThreadRecursiveMutex.cpp.\par
\par
References m_MonitorMutex, m_Mutex, and m_nLockLevel.}
{\xe \v CThreadRecursiveMutex\:CThreadRecursiveMutex}
{\xe \v CThreadRecursiveMutex\:CThreadRecursiveMutex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CThreadRecursiveMutex::CThreadRecursiveMutex (const CThreadRecursiveMutex & {\i rRhs}){\f2  [private]}}
}\par
{\bkmkstart classCThreadRecursiveMutex_c0}
{\bkmkend classCThreadRecursiveMutex_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Copy construction is illegal and hence private and not implemented. \par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v getLockLevel\:CThreadRecursiveMutex}
{\xe \v CThreadRecursiveMutex\:getLockLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned CThreadRecursiveMutex::getLockLevel () const{\f2  [inline]}}
}\par
{\bkmkstart classCThreadRecursiveMutex_a4}
{\bkmkend classCThreadRecursiveMutex_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
< Retrieve m_LockLevel.\par
\par
Definition at line 352 of file CThreadRecursiveMutex.h.\par
\par
References m_nLockLevel.\par
Referenced by CEvent::Disable().}
{\xe \v getMonitorMutex\:CThreadRecursiveMutex}
{\xe \v CThreadRecursiveMutex\:getMonitorMutex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DAQThreadMutex CThreadRecursiveMutex::getMonitorMutex () const{\f2  [inline]}}
}\par
{\bkmkstart classCThreadRecursiveMutex_a5}
{\bkmkend classCThreadRecursiveMutex_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
< Return m_MonitoMutex.\par
\par
Definition at line 356 of file CThreadRecursiveMutex.h.\par
\par
References m_MonitorMutex.}
{\xe \v getMutex\:CThreadRecursiveMutex}
{\xe \v CThreadRecursiveMutex\:getMutex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DAQThreadMutex CThreadRecursiveMutex::getMutex () const{\f2  [inline]}}
}\par
{\bkmkstart classCThreadRecursiveMutex_a2}
{\bkmkend classCThreadRecursiveMutex_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
< Retrieve m_Mutex.\par
\par
Definition at line 344 of file CThreadRecursiveMutex.h.\par
\par
References m_Mutex.}
{\xe \v getOwningThread\:CThreadRecursiveMutex}
{\xe \v CThreadRecursiveMutex\:getOwningThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
daqthread_t CThreadRecursiveMutex::getOwningThread () const{\f2  [inline]}}
}\par
{\bkmkstart classCThreadRecursiveMutex_a3}
{\bkmkend classCThreadRecursiveMutex_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
< Retrieve m_tOwningThread.\par
\par
Definition at line 348 of file CThreadRecursiveMutex.h.\par
\par
References m_tOwningThread.\par
Referenced by CEvent::Disable().}
{\xe \v isLocked\:CThreadRecursiveMutex}
{\xe \v CThreadRecursiveMutex\:isLocked}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CThreadRecursiveMutex::isLocked ()}
}\par
{\bkmkstart classCThreadRecursiveMutex_a9}
{\bkmkend classCThreadRecursiveMutex_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Override.\par
Purpose:\par
Returns non zero if someone, anyone (even self()) owns the mutex. Note that the mutex is considered owned if the lock level is  nonzero. This should even be faster than the base class  implementation. \par
\par
Definition at line 488 of file CThreadRecursiveMutex.cpp.\par
\par
References m_MonitorMutex, and m_nLockLevel.}
{\xe \v Lock\:CThreadRecursiveMutex}
{\xe \v CThreadRecursiveMutex\:Lock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CThreadRecursiveMutex::Lock ()}
}\par
{\bkmkstart classCThreadRecursiveMutex_a6}
{\bkmkend classCThreadRecursiveMutex_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Override.\par
Purpose:\par
Locks the mutex. Returns zero on success, otherwise, errno has the reason for the failure. Note that if we own the mutex the lock level is incremented, otherwise, this function may block. \par
\par
Definition at line 341 of file CThreadRecursiveMutex.cpp.\par
\par
References m_MonitorMutex, m_Mutex, m_nLockLevel, and m_tOwningThread.\par
Referenced by CBufferEvent< T >::AddLink(), CSocket::AddressToHostString(), CSocket::Connect(), CBufferEvent< T >::DeleteLink(), CDAQTCLProcessor::DeleteRelay(), CEvent::Disable(), CEvent::Enable(), CDAQTCLProcessor::EvalRelay(), CBufferEvent< U >::getPendingAddQueue(), CBufferEvent< U >::getPendingDeleteQueue(), CTCPConnectionLost::Host(), CEvent::OnEvent(), CSocket::OpenSocket(), CXtEventLoop::operator()(), CTCPConnectionLost::Port(), CBufferEvent< T >::ProcessAddQueue(), CBufferEvent< T >::ProcessDelQueue(), CServerConnectionEvent::Protocol(), and CSocket::Service().}
{\xe \v operator==\:CThreadRecursiveMutex}
{\xe \v CThreadRecursiveMutex\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CThreadRecursiveMutex::operator== (const CThreadRecursiveMutex & {\i aCThreadRecursiveMutex}) const{\f2  [private]}}
}\par
{\bkmkstart classCThreadRecursiveMutex_c1}
{\bkmkend classCThreadRecursiveMutex_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Assignment is illegal and hence private and not implemented. \par
}
{\xe \v setLockLevel\:CThreadRecursiveMutex}
{\xe \v CThreadRecursiveMutex\:setLockLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CThreadRecursiveMutex::setLockLevel (const unsigned {\i am_nLockLevel}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCThreadRecursiveMutex_b2}
{\bkmkend classCThreadRecursiveMutex_b2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i am_nLockLevel}}  Set m_nLockLevel \par
}Definition at line 371 of file CThreadRecursiveMutex.h.\par
\par
References m_nLockLevel.}
{\xe \v setMonitorMutex\:CThreadRecursiveMutex}
{\xe \v CThreadRecursiveMutex\:setMonitorMutex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CThreadRecursiveMutex::setMonitorMutex (const DAQThreadMutex {\i am_MonitorMutex}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCThreadRecursiveMutex_b3}
{\bkmkend classCThreadRecursiveMutex_b3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i am_MonitorMutex}}  Set m_MonitorMutex \par
}Definition at line 374 of file CThreadRecursiveMutex.h.\par
\par
References m_MonitorMutex.}
{\xe \v setMutex\:CThreadRecursiveMutex}
{\xe \v CThreadRecursiveMutex\:setMutex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CThreadRecursiveMutex::setMutex (const DAQThreadMutex {\i am_Mutex}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCThreadRecursiveMutex_b0}
{\bkmkend classCThreadRecursiveMutex_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i am_Mutex}}  Set m_Mutex \par
}Definition at line 365 of file CThreadRecursiveMutex.h.\par
\par
References m_Mutex.}
{\xe \v setOwningThread\:CThreadRecursiveMutex}
{\xe \v CThreadRecursiveMutex\:setOwningThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CThreadRecursiveMutex::setOwningThread (const daqthread_t {\i am_tOwningThread}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCThreadRecursiveMutex_b1}
{\bkmkend classCThreadRecursiveMutex_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i am_tOwningThread}}  Set m_tOwningThread \par
}Definition at line 368 of file CThreadRecursiveMutex.h.\par
\par
References m_tOwningThread.}
{\xe \v TryLock\:CThreadRecursiveMutex}
{\xe \v CThreadRecursiveMutex\:TryLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CThreadRecursiveMutex::TryLock ()}
}\par
{\bkmkstart classCThreadRecursiveMutex_a8}
{\bkmkend classCThreadRecursiveMutex_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Override\par
Purpose:\par
Tries to lock the mutex.  If the mutex is owned by the running thread the lock succeeds and the lock level is incremented. If the lock level is zero, then trylock is done on the base class and the result is returned. On success, the lock level is incremented. Returns 0 on success, otherwise, errno has reason for failure, if the lock was already held, errno == EAGAIN. \par
\par
Definition at line 450 of file CThreadRecursiveMutex.cpp.\par
\par
References m_MonitorMutex, m_Mutex, m_nLockLevel, and m_tOwningThread.}
{\xe \v UnLock\:CThreadRecursiveMutex}
{\xe \v CThreadRecursiveMutex\:UnLock}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CThreadRecursiveMutex::UnLock ()}
}\par
{\bkmkstart classCThreadRecursiveMutex_a7}
{\bkmkend classCThreadRecursiveMutex_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Override\par
Purpose:\par
Unlocks a locked mutex. If the mutex is already locked by us, the lock level is decremented. The mutex is not actually released until the lock level goes to zero. If we don't own the mutex, and error results. Returns zero on success, otherwise, errno has the reason for the failure. \par
\par
Definition at line 396 of file CThreadRecursiveMutex.cpp.\par
\par
References m_MonitorMutex, m_Mutex, m_nLockLevel, and m_tOwningThread.\par
Referenced by CBufferEvent< T >::AddLink(), CSocket::AddressToHostString(), CSocket::Connect(), CBufferEvent< T >::DeleteLink(), CDAQTCLProcessor::DeleteRelay(), CEvent::Enable(), CDAQTCLProcessor::EvalRelay(), CBufferEvent< U >::getPendingAddQueue(), CBufferEvent< U >::getPendingDeleteQueue(), CTCPConnectionLost::Host(), CEvent::OnEvent(), CSocket::OpenSocket(), CXtEventLoop::operator()(), CTCPConnectionLost::Port(), CBufferEvent< T >::ProcessAddQueue(), CBufferEvent< T >::ProcessDelQueue(), CServerConnectionEvent::Protocol(), and CSocket::Service().}
{\xe \v UnLockCompletely\:CThreadRecursiveMutex}
{\xe \v CThreadRecursiveMutex\:UnLockCompletely}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CThreadRecursiveMutex::UnLockCompletely ()}
}\par
{\bkmkstart classCThreadRecursiveMutex_a10}
{\bkmkend classCThreadRecursiveMutex_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type:\par
Purpose:\par
Releases all lock levels. If we don't  already own the mutex, this call is a no-op, otherwise, the m_nLockLevel variable is set to zero and the underlying semaphore is unlocked. \par
\par
Definition at line 511 of file CThreadRecursiveMutex.cpp.\par
\par
References m_MonitorMutex, m_Mutex, m_nLockLevel, and m_tOwningThread.\par
Referenced by CEvent::Disable(), and CFileEvent::Exit().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_MonitorMutex\:CThreadRecursiveMutex}
{\xe \v CThreadRecursiveMutex\:m_MonitorMutex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DAQThreadMutex CThreadRecursiveMutex::m_MonitorMutex{\f2  [private]}}
}\par
{\bkmkstart classCThreadRecursiveMutex_o3}
{\bkmkend classCThreadRecursiveMutex_o3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Atomicity Mutex.\par
\par
Definition at line 321 of file CThreadRecursiveMutex.h.\par
\par
Referenced by getMonitorMutex(), isLocked(), Lock(), setMonitorMutex(), TryLock(), UnLock(), UnLockCompletely(), and ~CThreadRecursiveMutex().}
{\xe \v m_Mutex\:CThreadRecursiveMutex}
{\xe \v CThreadRecursiveMutex\:m_Mutex}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
DAQThreadMutex CThreadRecursiveMutex::m_Mutex{\f2  [private]}}
}\par
{\bkmkstart classCThreadRecursiveMutex_o0}
{\bkmkend classCThreadRecursiveMutex_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Mutex locked.\par
\par
Definition at line 318 of file CThreadRecursiveMutex.h.\par
\par
Referenced by getMutex(), Lock(), setMutex(), TryLock(), UnLock(), UnLockCompletely(), and ~CThreadRecursiveMutex().}
{\xe \v m_nLockLevel\:CThreadRecursiveMutex}
{\xe \v CThreadRecursiveMutex\:m_nLockLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned CThreadRecursiveMutex::m_nLockLevel{\f2  [private]}}
}\par
{\bkmkstart classCThreadRecursiveMutex_o2}
{\bkmkend classCThreadRecursiveMutex_o2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Locking depth for owning thread.\par
\par
Definition at line 320 of file CThreadRecursiveMutex.h.\par
\par
Referenced by getLockLevel(), isLocked(), Lock(), setLockLevel(), TryLock(), UnLock(), UnLockCompletely(), and ~CThreadRecursiveMutex().}
{\xe \v m_tOwningThread\:CThreadRecursiveMutex}
{\xe \v CThreadRecursiveMutex\:m_tOwningThread}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
daqthread_t CThreadRecursiveMutex::m_tOwningThread{\f2  [private]}}
}\par
{\bkmkstart classCThreadRecursiveMutex_o1}
{\bkmkend classCThreadRecursiveMutex_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Id of owning thread.\par
\par
Definition at line 319 of file CThreadRecursiveMutex.h.\par
\par
Referenced by getOwningThread(), Lock(), setOwningThread(), TryLock(), UnLock(), and UnLockCompletely().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CThreadRecursiveMutex.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CThreadRecursiveMutex.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Time_t  Struct Reference\par \pard\plain 
{\tc\tcl2 \v Time_t}
{\xe \v Time_t}
{\bkmkstart structTime__t}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <histotypes.h>}\par
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UShort_t} {\b month}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UShort_t} {\b day}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UShort_t} {\b year}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UShort_t} {\b hours}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UShort_t} {\b min}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b UShort_t} {\b sec}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v day\:Time_t}
{\xe \v Time_t\:day}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UShort_t} Time_t::day}
}\par
{\bkmkstart structTime__t_m1}
{\bkmkend structTime__t_m1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 345 of file histotypes.h.\par
}
{\xe \v hours\:Time_t}
{\xe \v Time_t\:hours}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UShort_t} Time_t::hours}
}\par
{\bkmkstart structTime__t_m3}
{\bkmkend structTime__t_m3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 346 of file histotypes.h.\par
}
{\xe \v min\:Time_t}
{\xe \v Time_t\:min}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UShort_t} Time_t::min}
}\par
{\bkmkstart structTime__t_m4}
{\bkmkend structTime__t_m4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 346 of file histotypes.h.\par
}
{\xe \v month\:Time_t}
{\xe \v Time_t\:month}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UShort_t} Time_t::month}
}\par
{\bkmkstart structTime__t_m0}
{\bkmkend structTime__t_m0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 345 of file histotypes.h.\par
}
{\xe \v sec\:Time_t}
{\xe \v Time_t\:sec}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UShort_t} Time_t::sec}
}\par
{\bkmkstart structTime__t_m5}
{\bkmkend structTime__t_m5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 346 of file histotypes.h.\par
}
{\xe \v year\:Time_t}
{\xe \v Time_t\:year}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b UShort_t} Time_t::year}
}\par
{\bkmkstart structTime__t_m2}
{\bkmkend structTime__t_m2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 345 of file histotypes.h.\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b histotypes.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTimerEvent  Class Reference\par \pard\plain 
{\tc\tcl2 \v CTimerEvent}
{\xe \v CTimerEvent}
{\bkmkstart classCTimerEvent}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CTimerEvent.h>}\par
Inheritance diagram for CTimerEvent:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCTimerEvent.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTimerEvent} (unsigned long nms, bool fRepeat)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTimerEvent} (const char *pName, unsigned long nms, bool fRepeat)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTimerEvent} (const string &rName, unsigned long nms, bool fRepeat)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CTimerEvent} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTimerMonitor} & {\b getMonitor} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Allow manipulation of the event monitor:.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTimerGenericReactor} & {\b getReactor} ()\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Allow manipulation of the event reactor:.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Enable} (unsigned long nms, bool fRepeat=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Enable} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetTimeout} (unsigned long nms)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Repeat} (bool fRepeat=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnTimer} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b InternalOnTimer} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b DescribeSelf} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTimerEvent} (const CTimerEvent &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTimerEvent & {\b operator=} (const CTimerEvent &rhs)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CTimerEvent &rhs)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTimerMonitor} & {\b m_rMonitor}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Refer to the timer monitor maintained.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTimerGenericReactor} & {\b m_rReactor}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Refers to the callback reactor.}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
CTimerEvent encapsulates a thread which manages a single timer event. The timer event is capable of waiting for a fixed period of time. Timer events are either one-shot or are multi-shot. Each timer event can be dynamically switched between one-shot and multi-shot. \par
\par
Definition at line 317 of file CTimerEvent.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CTimerEvent\:CTimerEvent}
{\xe \v CTimerEvent\:CTimerEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTimerEvent::CTimerEvent (unsigned long {\i nms}, bool {\i fRepeat})}
}\par
{\bkmkstart classCTimerEvent_a0}
{\bkmkend classCTimerEvent_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct an anonymous CTimerEvent.  {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i nms}}  - Number of milliseconds before timer expires. \par
{\b {\i fRepeat}}  - True if the timer is a recurring timer. \par
}\par
Definition at line 330 of file CTimerEvent.cpp.\par
\par
References getMonitor(), getReactor(), m_rMonitor, m_rReactor, CEvent::setReactivity(), and CTimerMonitor::setTimeout().}
{\xe \v CTimerEvent\:CTimerEvent}
{\xe \v CTimerEvent\:CTimerEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTimerEvent::CTimerEvent (const char * {\i pName}, unsigned long {\i nms}, bool {\i fRepeat})}
}\par
{\bkmkstart classCTimerEvent_a1}
{\bkmkend classCTimerEvent_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct an named CTimerEvent where the name is given as an char* p C String. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i pName}}  - Pointer to object name..  \par
{\b {\i nms}}  - Number of milliseconds before timer expires. \par
{\b {\i fRepeat}}  - True if the timer is a recurring timer. \par
}\par
Definition at line 347 of file CTimerEvent.cpp.\par
\par
References m_rMonitor, CEvent::setReactivity(), and CTimerMonitor::setTimeout().}
{\xe \v CTimerEvent\:CTimerEvent}
{\xe \v CTimerEvent\:CTimerEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTimerEvent::CTimerEvent (const string & {\i rName}, unsigned long {\i nms}, bool {\i fRepeat})}
}\par
{\bkmkstart classCTimerEvent_a2}
{\bkmkend classCTimerEvent_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct an named CTimerEvent where the name is given as an STL String. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rName}}  - Reference to object name..  \par
{\b {\i nms}}  - Number of milliseconds before timer expires. \par
{\b {\i fRepeat}}  - True if the timer is a recurring timer. \par
}\par
Definition at line 364 of file CTimerEvent.cpp.\par
\par
References m_rMonitor, CEvent::setReactivity(), and CTimerMonitor::setTimeout().}
{\xe \v ~CTimerEvent\:CTimerEvent}
{\xe \v CTimerEvent\:~CTimerEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTimerEvent::~CTimerEvent (){\f2  [virtual]}}
}\par
{\bkmkstart classCTimerEvent_a3}
{\bkmkend classCTimerEvent_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Destroy a timer event. This involves simply deleteing the monitor and the reactor: \par
\par
Definition at line 380 of file CTimerEvent.cpp.\par
\par
References m_rMonitor, and m_rReactor.}
{\xe \v CTimerEvent\:CTimerEvent}
{\xe \v CTimerEvent\:CTimerEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTimerEvent::CTimerEvent (const CTimerEvent & {\i rhs}){\f2  [private]}}
}\par
{\bkmkstart classCTimerEvent_c0}
{\bkmkend classCTimerEvent_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v DescribeSelf\:CTimerEvent}
{\xe \v CTimerEvent\:DescribeSelf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CTimerEvent::DescribeSelf (){\f2  [virtual]}}
}\par
{\bkmkstart classCTimerEvent_a12}
{\bkmkend classCTimerEvent_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called to produce a string description of self. \par
\par
Reimplemented from {\b CEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent_a16 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 464 of file CTimerEvent.cpp.\par
\par
References CEvent::DescribeSelf().}
{\xe \v Enable\:CTimerEvent}
{\xe \v CTimerEvent\:Enable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTimerEvent::Enable (){\f2  [inline]}}
}\par
{\bkmkstart classCTimerEvent_a7}
{\bkmkend classCTimerEvent_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Enable execution of the event. This is intended to be called from outside the Event thread. This allows us to directly schedule the object as a thread, rather than going through the rigmarole required by {\b CEvent::Schedule} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent_b3 \\*MERGEFORMAT}{\fldrslt pagenum}}})\par
{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Enabling an active thread is a no-op.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
The enable state is a flag, not a counter, so only a single disable is required to kill the thread regardless of the number of Enable calls. \par
}\par
Reimplemented from {\b CEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent_a11 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 369 of file CTimerEvent.h.\par
\par
References CEvent::Enable().}
{\xe \v Enable\:CTimerEvent}
{\xe \v CTimerEvent\:Enable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTimerEvent::Enable (unsigned long {\i nms}, bool {\i fRepeat} = true)}
}\par
{\bkmkstart classCTimerEvent_a6}
{\bkmkend classCTimerEvent_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Overload for Enable specific to timers... since one shot timers are allowed, this member is supplied to setup the timer and start it in one operation.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i nms}}  - Number of milliseconds before timer expires. \par
{\b {\i fRepeat-}}  true if this is a repetitive timer. \par
}\par
Definition at line 396 of file CTimerEvent.cpp.\par
\par
References CEvent::Enable(), m_rMonitor, CTimerMonitor::Repeat(), CEvent::setReactivity(), and CTimerMonitor::setTimeout().}
{\xe \v getMonitor\:CTimerEvent}
{\xe \v CTimerEvent\:getMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CTimerMonitor}& CTimerEvent::getMonitor (){\f2  [inline]}}
}\par
{\bkmkstart classCTimerEvent_a4}
{\bkmkend classCTimerEvent_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Allow manipulation of the event monitor:.\par
\par
Reimplemented from {\b CEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 359 of file CTimerEvent.h.\par
\par
Referenced by CTimerEvent().}
{\xe \v getReactor\:CTimerEvent}
{\xe \v CTimerEvent\:getReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CTimerGenericReactor}& CTimerEvent::getReactor (){\f2  [inline]}}
}\par
{\bkmkstart classCTimerEvent_a5}
{\bkmkend classCTimerEvent_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Allow manipulation of the event reactor:.\par
\par
Reimplemented from {\b CEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent_a9 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 362 of file CTimerEvent.h.\par
\par
Referenced by CTimerEvent().}
{\xe \v InternalOnTimer\:CTimerEvent}
{\xe \v CTimerEvent\:InternalOnTimer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTimerEvent::InternalOnTimer ()}
}\par
{\bkmkstart classCTimerEvent_a11}
{\bkmkend classCTimerEvent_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called directly from the reactor. {
\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
1.\tab Calls the user overridable member.\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
2.\tab If the timer is a single shot timer, the thread is disabled from continuing. \par
}\par
Definition at line 441 of file CTimerEvent.cpp.\par
\par
References CTimerMonitor::getOneShot(), m_rMonitor, OnTimer(), and CEvent::setEnable().\par
Referenced by CTimerEvent::CTimerGenericReactor::OnEvent().}
{\xe \v OnTimer\:CTimerEvent}
{\xe \v CTimerEvent\:OnTimer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTimerEvent::OnTimer (){\f2  [virtual]}}
}\par
{\bkmkstart classCTimerEvent_a10}
{\bkmkend classCTimerEvent_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called internally - user overridable event code. No-OP for now: \par
\par
Definition at line 456 of file CTimerEvent.cpp.\par
\par
Referenced by InternalOnTimer().}
{\xe \v operator=\:CTimerEvent}
{\xe \v CTimerEvent\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTimerEvent& CTimerEvent::operator= (const CTimerEvent & {\i rhs}){\f2  [private]}}
}\par
{\bkmkstart classCTimerEvent_c1}
{\bkmkend classCTimerEvent_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:CTimerEvent}
{\xe \v CTimerEvent\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTimerEvent::operator== (const CTimerEvent & {\i rhs}){\f2  [private]}}
}\par
{\bkmkstart classCTimerEvent_c2}
{\bkmkend classCTimerEvent_c2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Repeat\:CTimerEvent}
{\xe \v CTimerEvent\:Repeat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTimerEvent::Repeat (bool {\i fRepeat} = true)}
}\par
{\bkmkstart classCTimerEvent_a9}
{\bkmkend classCTimerEvent_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set the flag indicating if the timer is a repeating or single shot: {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i fRepeat}}  - True if this is a repetetitve timer. \par
}\par
Definition at line 421 of file CTimerEvent.cpp.\par
\par
References m_rMonitor, and CTimerMonitor::Repeat().}
{\xe \v SetTimeout\:CTimerEvent}
{\xe \v CTimerEvent\:SetTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTimerEvent::SetTimeout (unsigned long {\i nms})}
}\par
{\bkmkstart classCTimerEvent_a8}
{\bkmkend classCTimerEvent_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Re-export the members of the monitor which allow control over the timer. This member sets the timeout.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i nms}}  - Number of milliseconds before timeout fires. \par
}\par
Definition at line 410 of file CTimerEvent.cpp.\par
\par
References m_rMonitor, CEvent::setReactivity(), and CTimerMonitor::setTimeout().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_rMonitor\:CTimerEvent}
{\xe \v CTimerEvent\:m_rMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CTimerMonitor}& CTimerEvent::m_rMonitor{\f2  [private]}}
}\par
{\bkmkstart classCTimerEvent_o0}
{\bkmkend classCTimerEvent_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Refer to the timer monitor maintained.\par
\par
Reimplemented from {\b CEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent_o4 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 335 of file CTimerEvent.h.\par
\par
Referenced by CTimerEvent(), Enable(), InternalOnTimer(), Repeat(), SetTimeout(), and ~CTimerEvent().}
{\xe \v m_rReactor\:CTimerEvent}
{\xe \v CTimerEvent\:m_rReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CTimerGenericReactor}& CTimerEvent::m_rReactor{\f2  [private]}}
}\par
{\bkmkstart classCTimerEvent_o1}
{\bkmkend classCTimerEvent_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Refers to the callback reactor.\par
\par
Reimplemented from {\b CEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent_o5 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 336 of file CTimerEvent.h.\par
\par
Referenced by CTimerEvent(), and ~CTimerEvent().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CTimerEvent.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CTimerEvent.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTimerEvent::CTimerGenericReactor  Class Reference\par \pard\plain 
{\tc\tcl2 \v CTimerEvent::CTimerGenericReactor}
{\xe \v CTimerEvent::CTimerGenericReactor}
{\bkmkstart classCTimerEvent_1_1CTimerGenericReactor}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid Inheritance diagram for CTimerEvent::CTimerGenericReactor:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCTimerEvent_1_1CTimerGenericReactor.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTimerGenericReactor} ({\b CTimerEvent} &rOwner)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTimerGenericReactor} (const char *pName, {\b CTimerEvent} &rOwner)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b OnEvent} ({\b CEventMonitor} &rMonitor)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTimerEvent} & {\b m_rOwner}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i My Owner.}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
{\b CTimerGenericReactor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTimerEvent_1_1CTimerGenericReactor \\*MERGEFORMAT}{\fldrslt pagenum}}}) - is a timer reactor which allows the timer event to look to the programmer like a monolithic entitiy. It calls the {\b CTimerEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTimerEvent \\*MERGEFORMAT}{\fldrslt pagenum}}}) classe's OnEvent when the timer fires. \par
\par
Definition at line 324 of file CTimerEvent.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CTimerGenericReactor\:CTimerEvent::CTimerGenericReactor}
{\xe \v CTimerEvent::CTimerGenericReactor\:CTimerGenericReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTimerEvent::CTimerGenericReactor::CTimerGenericReactor ({\b CTimerEvent} & {\i rOwner})}
}\par
{\bkmkstart classCTimerEvent_1_1CTimerGenericReactor_a0}
{\bkmkend classCTimerEvent_1_1CTimerGenericReactor_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct a generic reactor for the {\b CTimerEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTimerEvent \\*MERGEFORMAT}{\fldrslt pagenum}}}) class. The reactor is a callback reactor which acts to make the event class appear monolithic to anyone who users it.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i const}}  char* pName - Name of the reactor. \par
{\b {\i {\b CTimerEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTimerEvent \\*MERGEFORMAT}{\fldrslt pagenum}}})&}}  rOwner - The event to which I"ve been attached. \par
}\par
Definition at line 299 of file CTimerEvent.cpp.\par
}
{\xe \v CTimerGenericReactor\:CTimerEvent::CTimerGenericReactor}
{\xe \v CTimerEvent::CTimerGenericReactor\:CTimerGenericReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTimerEvent::CTimerGenericReactor::CTimerGenericReactor (const char * {\i pName}, {\b CTimerEvent} & {\i rOwner})}
}\par
{\bkmkstart classCTimerEvent_1_1CTimerGenericReactor_a1}
{\bkmkend classCTimerEvent_1_1CTimerGenericReactor_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 303 of file CTimerEvent.cpp.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v OnEvent\:CTimerEvent::CTimerGenericReactor}
{\xe \v CTimerEvent::CTimerGenericReactor\:OnEvent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTimerEvent::CTimerGenericReactor::OnEvent ({\b CEventMonitor} & {\i rMonitor}){\f2  [virtual]}}
}\par
{\bkmkstart classCTimerEvent_1_1CTimerGenericReactor_a2}
{\bkmkend classCTimerEvent_1_1CTimerGenericReactor_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
This is the actual callback relay. When called, this  member function just calls m_rMonitor's OnTimer. OnTimer is called because oneshot timers must be treated specailly to ensure that the thread exits. \par
\par
Reimplemented from {\b CReactor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCReactor_a6 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 315 of file CTimerEvent.cpp.\par
\par
References CTimerEvent::InternalOnTimer(), and m_rOwner.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_rOwner\:CTimerEvent::CTimerGenericReactor}
{\xe \v CTimerEvent::CTimerGenericReactor\:m_rOwner}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CTimerEvent}& CTimerEvent::CTimerGenericReactor::m_rOwner{\f2  [private]}}
}\par
{\bkmkstart classCTimerEvent_1_1CTimerGenericReactor_o0}
{\bkmkend classCTimerEvent_1_1CTimerGenericReactor_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
My Owner.\par
\par
Definition at line 326 of file CTimerEvent.h.\par
\par
Referenced by OnEvent().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CTimerEvent.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CTimerEvent.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTimerMonitor  Class Reference\par \pard\plain 
{\tc\tcl2 \v CTimerMonitor}
{\xe \v CTimerMonitor}
{\bkmkstart classCTimerMonitor}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CTimerMonitor.h>}\par
Inheritance diagram for CTimerMonitor:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCTimerMonitor.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTimerMonitor} (bool am_fOneShot=true, bool am_fTimedWait=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTimerMonitor} (const string &rName, bool am_fOneShot=true, bool am_fTimedWait=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTimerMonitor} (const char *pName, bool am_fOneShot=true, bool am_fFired=false, bool am_fTimedWait=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CTimerMonitor} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CTimerMonitor &aCTimerMonitor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getOneShot} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b getFired} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b CEventMonitor::result} {\b operator()} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Repeat} (bool fRepeat=true)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b setTimeout} (int nTimeout={\b FOREVER})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual string {\b DescribeSelf} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setOneShot} (bool am_fOneShot)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setFired} (bool am_fFired)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTimerMonitor} (const CTimerMonitor &aCTimerMonitor)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Copy construction is forbidden for now.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTimerMonitor {\b operator=} (const CTimerMonitor &aCTimerMonitor)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Assignment is forbidden for now.}\par
\par}
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b m_fOneShot}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b m_fFired}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
Encapsulates an event monitor for timers. Timers can be either repeating or oneshot. A oneshot timer willl fire once after a delay and  then refuse to fire until it's time is reset.\par
Repeating timers essentially reset their time after each instance of an event. \par
\par
Definition at line 311 of file CTimerMonitor.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CTimerMonitor\:CTimerMonitor}
{\xe \v CTimerMonitor\:CTimerMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTimerMonitor::CTimerMonitor (bool {\i am_fOneShot} = true, bool {\i am_fTimedWait} = true){\f2  [inline]}}
}\par
{\bkmkstart classCTimerMonitor_a0}
{\bkmkend classCTimerMonitor_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Fired flag \par
\par
Definition at line 320 of file CTimerMonitor.h.\par
\par
References CNamedObject::AppendClassInfo(), m_fFired, and m_fOneShot.}
{\xe \v CTimerMonitor\:CTimerMonitor}
{\xe \v CTimerMonitor\:CTimerMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTimerMonitor::CTimerMonitor (const string & {\i rName}, bool {\i am_fOneShot} = true, bool {\i am_fTimedWait} = true){\f2  [inline]}}
}\par
{\bkmkstart classCTimerMonitor_a1}
{\bkmkend classCTimerMonitor_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 328 of file CTimerMonitor.h.\par
\par
References CNamedObject::AppendClassInfo(), m_fFired, and m_fOneShot.}
{\xe \v CTimerMonitor\:CTimerMonitor}
{\xe \v CTimerMonitor\:CTimerMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTimerMonitor::CTimerMonitor (const char * {\i pName}, bool {\i am_fOneShot} = true, bool {\i am_fFired} = false, bool {\i am_fTimedWait} = true){\f2  [inline]}}
}\par
{\bkmkstart classCTimerMonitor_a2}
{\bkmkend classCTimerMonitor_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 337 of file CTimerMonitor.h.\par
\par
References CNamedObject::AppendClassInfo(), m_fFired, and m_fOneShot.}
{\xe \v ~CTimerMonitor\:CTimerMonitor}
{\xe \v CTimerMonitor\:~CTimerMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTimerMonitor::~CTimerMonitor (){\f2  [inline]}}
}\par
{\bkmkstart classCTimerMonitor_a3}
{\bkmkend classCTimerMonitor_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 347 of file CTimerMonitor.h.\par
}
{\xe \v CTimerMonitor\:CTimerMonitor}
{\xe \v CTimerMonitor\:CTimerMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTimerMonitor::CTimerMonitor (const CTimerMonitor & {\i aCTimerMonitor}){\f2  [private]}}
}\par
{\bkmkstart classCTimerMonitor_c0}
{\bkmkend classCTimerMonitor_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Copy construction is forbidden for now.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v DescribeSelf\:CTimerMonitor}
{\xe \v CTimerMonitor\:DescribeSelf}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CTimerMonitor::DescribeSelf (){\f2  [virtual]}}
}\par
{\bkmkstart classCTimerMonitor_a10}
{\bkmkend classCTimerMonitor_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Selector\par
Purpose: Produces a string describing the object: 1. Calls CEventMonitor::DecribeSelf 2. Dumps the state of the oneshot and timed flags. \par
\par
Reimplemented from {\b CNamedObject} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNamedObject_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 400 of file CTimerMonitor.cpp.\par
\par
References CNamedObject::DescribeSelf().}
{\xe \v getFired\:CTimerMonitor}
{\xe \v CTimerMonitor\:getFired}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CTimerMonitor::getFired () const{\f2  [inline]}}
}\par
{\bkmkstart classCTimerMonitor_a6}
{\bkmkend classCTimerMonitor_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 371 of file CTimerMonitor.h.\par
\par
References m_fFired.}
{\xe \v getOneShot\:CTimerMonitor}
{\xe \v CTimerMonitor\:getOneShot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CTimerMonitor::getOneShot () const{\f2  [inline]}}
}\par
{\bkmkstart classCTimerMonitor_a5}
{\bkmkend classCTimerMonitor_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 366 of file CTimerMonitor.h.\par
\par
References m_fOneShot.\par
Referenced by CTimerEvent::InternalOnTimer().}
{\xe \v operator()\:CTimerMonitor}
{\xe \v CTimerMonitor\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CEventMonitor::result} CTimerMonitor::operator() (){\f2  [virtual]}}
}\par
{\bkmkstart classCTimerMonitor_a7}
{\bkmkend classCTimerMonitor_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: override behavior\par
Purpose: Waits for the timer as follows: 1. If m_fOneshot is false, this function blocks for m_tvTimeout time, then returns Occured 2. If m_fOneshot is true, but m_fFired is false, blocks for m_tvTimeout, sets m_fFired and returns Occured 3. If m_fOneshot and m_fFired are both true, returns TimedOut \par
\par
Implements {\b CEventMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEventMonitor_a7 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 318 of file CTimerMonitor.cpp.\par
\par
References CEventMonitor::getTimeout(), m_fFired, m_fOneShot, CEventMonitor::Occurred, and CEventMonitor::TimedOut.}
{\xe \v operator=\:CTimerMonitor}
{\xe \v CTimerMonitor\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTimerMonitor CTimerMonitor::operator= (const CTimerMonitor & {\i aCTimerMonitor}){\f2  [private]}}
}\par
{\bkmkstart classCTimerMonitor_c1}
{\bkmkend classCTimerMonitor_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Assignment is forbidden for now.\par
}
{\xe \v operator==\:CTimerMonitor}
{\xe \v CTimerMonitor\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTimerMonitor::operator== (const CTimerMonitor & {\i aCTimerMonitor}){\f2  [inline]}}
}\par
{\bkmkstart classCTimerMonitor_a4}
{\bkmkend classCTimerMonitor_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 350 of file CTimerMonitor.h.\par
\par
References m_fFired, m_fOneShot, and CEventMonitor::operator==().}
{\xe \v Repeat\:CTimerMonitor}
{\xe \v CTimerMonitor\:Repeat}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTimerMonitor::Repeat (bool {\i fRepeat} = true)}
}\par
{\bkmkstart classCTimerMonitor_a8}
{\bkmkend classCTimerMonitor_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Mutator\par
Purpose: Sets m_fOneshot to the value of its parameter. \par
\par
Definition at line 364 of file CTimerMonitor.cpp.\par
\par
References m_fFired, and m_fOneShot.\par
Referenced by CTimerEvent::Enable(), and CTimerEvent::Repeat().}
{\xe \v setFired\:CTimerMonitor}
{\xe \v CTimerMonitor\:setFired}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTimerMonitor::setFired (bool {\i am_fFired}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCTimerMonitor_b1}
{\bkmkend classCTimerMonitor_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 384 of file CTimerMonitor.h.\par
\par
References m_fFired.}
{\xe \v setOneShot\:CTimerMonitor}
{\xe \v CTimerMonitor\:setOneShot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTimerMonitor::setOneShot (bool {\i am_fOneShot}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCTimerMonitor_b0}
{\bkmkend classCTimerMonitor_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 379 of file CTimerMonitor.h.\par
\par
References m_fOneShot.}
{\xe \v setTimeout\:CTimerMonitor}
{\xe \v CTimerMonitor\:setTimeout}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CTimerMonitor::setTimeout (int {\i nTimeout} = {\b FOREVER}){\f2  [virtual]}}
}\par
{\bkmkstart classCTimerMonitor_a9}
{\bkmkend classCTimerMonitor_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operation Type: Mutator\par
Purpose: Calls {\b CEventMonitor::setTimeout} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEventMonitor_b0 \\*MERGEFORMAT}{\fldrslt pagenum}}}) and clears m_fFired. The wait flag FOREVER results in a MAXINT being passed to {\b CEventMonitor::setTimeout} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEventMonitor_b0 \\*MERGEFORMAT}{\fldrslt pagenum}}}) \par
\par
Reimplemented from {\b CEventMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEventMonitor_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 382 of file CTimerMonitor.cpp.\par
\par
References m_fFired, and CEventMonitor::setTimeout().\par
Referenced by CTimerEvent::CTimerEvent(), CTimerEvent::Enable(), and CTimerEvent::SetTimeout().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_fFired\:CTimerMonitor}
{\xe \v CTimerMonitor\:m_fFired}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CTimerMonitor::m_fFired{\f2  [private]}}
}\par
{\bkmkstart classCTimerMonitor_o1}
{\bkmkend classCTimerMonitor_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Oneshot flag \par
\par
Definition at line 314 of file CTimerMonitor.h.\par
\par
Referenced by CTimerMonitor(), getFired(), operator()(), operator==(), Repeat(), setFired(), and setTimeout().}
{\xe \v m_fOneShot\:CTimerMonitor}
{\xe \v CTimerMonitor\:m_fOneShot}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CTimerMonitor::m_fOneShot{\f2  [private]}}
}\par
{\bkmkstart classCTimerMonitor_o0}
{\bkmkend classCTimerMonitor_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 313 of file CTimerMonitor.h.\par
\par
Referenced by CTimerMonitor(), getOneShot(), operator()(), operator==(), Repeat(), and setOneShot().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CTimerMonitor.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CTimerMonitor.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTKInterpreterStartup  Class Reference\par \pard\plain 
{\tc\tcl2 \v CTKInterpreterStartup}
{\xe \v CTKInterpreterStartup}
{\bkmkstart classCTKInterpreterStartup}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CTKInterpreterStartup.h>}\par
Inheritance diagram for CTKInterpreterStartup:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCTKInterpreterStartup.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTKInterpreterStartup} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CTKInterpreterStartup} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Tk_Init} (Tcl_Interp *pInterp)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTKInterpreterStartup} (const CTKInterpreterStartup &aCTKInterpreterStartup)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Copy Constructor illegal, private, unimplemented.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CTKInterpreterStartup & {\b operator=} (const CTKInterpreterStartup &aCTKInterpreterStartup)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Operator= Assignment Operator illegal, private, unimplemented.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CTKInterpreterStartup &aCTKInterpreterStartup) const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Operator== Equality Operator illegal, private, unimplemented.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b operator()} (int argc, char **argv)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
Encapsulates the startup of a Tk/wish interpreter. An application must subclass this, Implement RegisterExtensions. \par
\par
Definition at line 311 of file CTKInterpreterStartup.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CTKInterpreterStartup\:CTKInterpreterStartup}
{\xe \v CTKInterpreterStartup\:CTKInterpreterStartup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTKInterpreterStartup::CTKInterpreterStartup (){\f2  [inline]}}
}\par
{\bkmkstart classCTKInterpreterStartup_a0}
{\bkmkend classCTKInterpreterStartup_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 314 of file CTKInterpreterStartup.h.\par
}
{\xe \v ~CTKInterpreterStartup\:CTKInterpreterStartup}
{\xe \v CTKInterpreterStartup\:~CTKInterpreterStartup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual CTKInterpreterStartup::~CTKInterpreterStartup (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classCTKInterpreterStartup_a1}
{\bkmkend classCTKInterpreterStartup_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 315 of file CTKInterpreterStartup.h.\par
}
{\xe \v CTKInterpreterStartup\:CTKInterpreterStartup}
{\xe \v CTKInterpreterStartup\:CTKInterpreterStartup}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTKInterpreterStartup::CTKInterpreterStartup (const CTKInterpreterStartup & {\i aCTKInterpreterStartup}){\f2  [private]}}
}\par
{\bkmkstart classCTKInterpreterStartup_c0}
{\bkmkend classCTKInterpreterStartup_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Copy Constructor illegal, private, unimplemented.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v operator()\:CTKInterpreterStartup}
{\xe \v CTKInterpreterStartup\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTKInterpreterStartup::operator() (int {\i argc}, char ** {\i argv}){\f2  [private, virtual]}}
}\par
{\bkmkstart classCTKInterpreterStartup_c3}
{\bkmkend classCTKInterpreterStartup_c3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Starts up the Tk interpreter.\par
{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Calls OnInitialize to allow users to do early initialization.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Starts the Tk interpreter by callling Tk_Main.\par
}The static member Tk_Init is passed as  the application initialization function.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i argc}}  The number of "command line" parameters \par
{\b {\i argv}}  Vector of pointers to the "command line" parameter strings. \par
}\par
Implements {\b CInterpreterStartup} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCInterpreterStartup_c0 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 307 of file CTKInterpreterStartup.cpp.\par
\par
References CInterpreterStartup::OnInitialize(), and Tk_Init().}
{\xe \v operator=\:CTKInterpreterStartup}
{\xe \v CTKInterpreterStartup\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CTKInterpreterStartup& CTKInterpreterStartup::operator= (const CTKInterpreterStartup & {\i aCTKInterpreterStartup}){\f2  [private]}}
}\par
{\bkmkstart classCTKInterpreterStartup_c1}
{\bkmkend classCTKInterpreterStartup_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operator= Assignment Operator illegal, private, unimplemented.\par
}
{\xe \v operator==\:CTKInterpreterStartup}
{\xe \v CTKInterpreterStartup\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTKInterpreterStartup::operator== (const CTKInterpreterStartup & {\i aCTKInterpreterStartup}) const{\f2  [private]}}
}\par
{\bkmkstart classCTKInterpreterStartup_c2}
{\bkmkend classCTKInterpreterStartup_c2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Operator== Equality Operator illegal, private, unimplemented.\par
}
{\xe \v Tk_Init\:CTKInterpreterStartup}
{\xe \v CTKInterpreterStartup\:Tk_Init}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CTKInterpreterStartup::Tk_Init (Tcl_Interp * {\i pInterp}){\f2  [static, protected]}}
}\par
{\bkmkstart classCTKInterpreterStartup_e0}
{\bkmkend classCTKInterpreterStartup_e0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called by Tk_Main to do application  specific initialization.\par
{\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Establishes object context by invoking {\b CEventLoop::getInstance}() ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEventLoop_d0 \\*MERGEFORMAT}{\fldrslt pagenum}}}) \par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Invokes RegisterExtensions so that applicaiton packages and commands can be registered on the interpreter.\par
\pard\plain \s82\fi-360\li1080\widctlpar\jclisttab\tx1080{\*\pn \pnlvlbody\ilvl0\ls3\pnrnot0\pndec }\ls3\adjustright \fs20\cgrid 
Finally returns to the Tk event loop..\par
}{{{\b Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i pInterp}}  Pointer to the Tcl interpreter created by Tk_Main. \par
}\par
Definition at line 342 of file CTKInterpreterStartup.cpp.\par
\par
References CEventLoop::getInstance(), CInterpreterStartup::RegisterExtensions(), CInterpreterStartup::setInterpreter(), and Tk_Init().\par
Referenced by operator()(), and Tk_Init().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CTKInterpreterStartup.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CTKInterpreterStartup.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TopLevelShell  Class Reference\par \pard\plain 
{\tc\tcl2 \v TopLevelShell}
{\xe \v TopLevelShell}
{\bkmkstart classTopLevelShell}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMShell.h>}\par
Inheritance diagram for TopLevelShell:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classTopLevelShell.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b TopLevelShell} (String shellname, {\b XMWidget} *parent)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~TopLevelShell} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b RealizeIconic} (Boolean val)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Boolean {\b GetIconic} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetIconName} (String {\b name})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b GetIconName} (String {\b name})\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v TopLevelShell\:TopLevelShell}
{\xe \v TopLevelShell\:TopLevelShell}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TopLevelShell::TopLevelShell (String {\i shellname}, {\b XMWidget} * {\i parent})}
}\par
{\bkmkstart classTopLevelShell_a0}
{\bkmkend classTopLevelShell_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 418 of file XMShell.cpp.\par
}
{\xe \v ~TopLevelShell\:TopLevelShell}
{\xe \v TopLevelShell\:~TopLevelShell}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
TopLevelShell::~TopLevelShell (){\f2  [inline]}}
}\par
{\bkmkstart classTopLevelShell_a1}
{\bkmkend classTopLevelShell_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 358 of file XMShell.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v GetIconic\:TopLevelShell}
{\xe \v TopLevelShell\:GetIconic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Boolean TopLevelShell::GetIconic (){\f2  [inline]}}
}\par
{\bkmkstart classTopLevelShell_a3}
{\bkmkend classTopLevelShell_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 362 of file XMShell.h.\par
\par
References XMWidget::GetAttribute().}
{\xe \v GetIconName\:TopLevelShell}
{\xe \v TopLevelShell\:GetIconName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TopLevelShell::GetIconName (String {\i name}){\f2  [inline]}}
}\par
{\bkmkstart classTopLevelShell_a5}
{\bkmkend classTopLevelShell_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 371 of file XMShell.h.\par
\par
References XMWidget::GetAttribute(), and XMWidget::name.}
{\xe \v RealizeIconic\:TopLevelShell}
{\xe \v TopLevelShell\:RealizeIconic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TopLevelShell::RealizeIconic (Boolean {\i val}){\f2  [inline]}}
}\par
{\bkmkstart classTopLevelShell_a2}
{\bkmkend classTopLevelShell_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 360 of file XMShell.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v SetIconName\:TopLevelShell}
{\xe \v TopLevelShell\:SetIconName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void TopLevelShell::SetIconName (String {\i name}){\f2  [inline]}}
}\par
{\bkmkstart classTopLevelShell_a4}
{\bkmkend classTopLevelShell_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 369 of file XMShell.h.\par
\par
References XMWidget::name, and XMWidget::SetAttribute().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMShell.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMShell.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTypeFreeBinding  Class Reference\par \pard\plain 
{\tc\tcl2 \v CTypeFreeBinding}
{\xe \v CTypeFreeBinding}
{\bkmkstart classCTypeFreeBinding}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CTypeFreeBinding.h>}\par
Inheritance diagram for CTypeFreeBinding:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCTypeFreeBinding.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b InitBindings} ({\b CTCLInterpreter} &rInterp)=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b Commit} ({\b CTCLInterpreter} &rInterp)=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b ShutdownBindings} ({\b CTCLInterpreter} &rInterp)=0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b Dump} (int fd)=0\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
Provides a non-templated ABC for configuration variable bindings. this is required to allow the {\b CConfigurationManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCConfigurationManager \\*MERGEFORMAT}{\fldrslt pagenum}}}) class to hold a list of bindings. For information about the member functions, see {\b CBinding} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBinding \\*MERGEFORMAT}{\fldrslt pagenum}}}) \par
\par
Definition at line 299 of file CTypeFreeBinding.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Commit\:CTypeFreeBinding}
{\xe \v CTypeFreeBinding\:Commit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void CTypeFreeBinding::Commit ({\b CTCLInterpreter} & {\i rInterp}){\f2  [pure virtual]}}
}\par
{\bkmkstart classCTypeFreeBinding_a1}
{\bkmkend classCTypeFreeBinding_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Implemented in {\b CArrayBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCArrayBinding_a11 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CAssocArrayBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCAssocArrayBinding_a13 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBinding_a1 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b CVariableBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCVariableBinding_a14 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Referenced by CCommit::operator()().}
{\xe \v Dump\:CTypeFreeBinding}
{\xe \v CTypeFreeBinding\:Dump}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void CTypeFreeBinding::Dump (int {\i fd}){\f2  [pure virtual]}}
}\par
{\bkmkstart classCTypeFreeBinding_a3}
{\bkmkend classCTypeFreeBinding_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Implemented in {\b CArrayBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCArrayBinding_a13 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CAssocArrayBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCAssocArrayBinding_a15 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBinding_a2 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b CVariableBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCVariableBinding_a16 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Referenced by CDumpBinding::operator()().}
{\xe \v InitBindings\:CTypeFreeBinding}
{\xe \v CTypeFreeBinding\:InitBindings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void CTypeFreeBinding::InitBindings ({\b CTCLInterpreter} & {\i rInterp}){\f2  [pure virtual]}}
}\par
{\bkmkstart classCTypeFreeBinding_a0}
{\bkmkend classCTypeFreeBinding_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Implemented in {\b CArrayBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCArrayBinding_a10 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CAssocArrayBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCAssocArrayBinding_a12 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBinding_a0 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b CVariableBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCVariableBinding_a13 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Referenced by CInitBinding::operator()().}
{\xe \v ShutdownBindings\:CTypeFreeBinding}
{\xe \v CTypeFreeBinding\:ShutdownBindings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void CTypeFreeBinding::ShutdownBindings ({\b CTCLInterpreter} & {\i rInterp}){\f2  [pure virtual]}}
}\par
{\bkmkstart classCTypeFreeBinding_a2}
{\bkmkend classCTypeFreeBinding_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Implemented in {\b CArrayBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCArrayBinding_a12 \\*MERGEFORMAT}{\fldrslt pagenum}}}), {\b CAssocArrayBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCAssocArrayBinding_a14 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b CVariableBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCVariableBinding_a15 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Referenced by CShutdownBinding::operator()().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CTypeFreeBinding.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CVariableBinding< T >  Class Template Reference\par \pard\plain 
{\tc\tcl2 \v CVariableBinding}
{\xe \v CVariableBinding}
{\bkmkstart classCVariableBinding}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CVariableBinding.h>}\par
Inheritance diagram for CVariableBinding< T >:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCVariableBinding.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVariableBinding} (T &variable, const string &rName, T tInitialValue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVariableBinding} (T &variable, const char *pName, T tInitialValue)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~CVariableBinding} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b getVariable} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b getName} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b getInitValue} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b getVarType} () const\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setVariable} (T value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setPointer} (T *ptr)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setName} (const string &rName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setName} (const char *pName)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setInitialValue} (T value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setVariableType} (int type)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b InitBindings} ({\b CTCLInterpreter} &rInterp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b Commit} ({\b CTCLInterpreter} &rInterp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b ShutdownBindings} ({\b CTCLInterpreter} &rInterp)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b Dump} (int fd)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CVariableBinding} (const CVariableBinding &rBinding)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CVariableBinding & {\b operator=} (const CVariableBinding &rBinding)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CVariableBinding &rBinding)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T * {\b m_pVariable}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Pointer to the config variable.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_sName}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Name of the variable (for Tcl binding).}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T {\b m_tInitialValue}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Initial value of the variable.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b m_TCLVariableType}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Type of binding (for TCL).}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid 
{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class T> class CVariableBinding< T >\par
}

\par
CVariableBinding is a class which encapsulates a configuration scalar variable. The Variable is maintained by the user of this class. The InitBindings makes a link to the variable. The Commit does nothing The ShutdownBindings member removes the link. \par
\par
Definition at line 316 of file CVariableBinding.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CVariableBinding\:CVariableBinding}
{\xe \v CVariableBinding\:CVariableBinding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CVariableBinding< T >::CVariableBinding (T & {\i variable}, const string & {\i rname}, T {\i tInitialValue})}
}\par
{\bkmkstart classCVariableBinding_a0}
{\bkmkend classCVariableBinding_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct a variable binding from the variable, a name, and initial value. The name is expressed as a string:{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i variable}}  - reference to the variable to bind. \par
{\b {\i rname}}  - Reference to the string containing the name of the TCL variable which will be bound. \par
{\b {\i tInitialValue}}  - Initial value to give the variable prior to  reading the config file.. a default. \par
}\par
Definition at line 308 of file CVariableBinding.cpp.\par
}
{\xe \v CVariableBinding\:CVariableBinding}
{\xe \v CVariableBinding\:CVariableBinding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CVariableBinding< T >::CVariableBinding (T & {\i variable}, const char * {\i pName}, T {\i tInitialValue})}
}\par
{\bkmkstart classCVariableBinding_a1}
{\bkmkend classCVariableBinding_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Construct a variable binding from the variable reference asciz string pointer and initial value:{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i variable}}  - Reference to the variable to configure. \par
{\b {\i pName}}  - Reference to char* string to give name. \par
{\b {\i tInitialValue}}  - Initial value to give to the variable. \par
}\par
Definition at line 325 of file CVariableBinding.cpp.\par
}
{\xe \v ~CVariableBinding\:CVariableBinding}
{\xe \v CVariableBinding\:~CVariableBinding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CVariableBinding< T >::~CVariableBinding (){\f2  [inline]}}
}\par
{\bkmkstart classCVariableBinding_a2}
{\bkmkend classCVariableBinding_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 326 of file CVariableBinding.h.\par
}
{\xe \v CVariableBinding\:CVariableBinding}
{\xe \v CVariableBinding\:CVariableBinding}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CVariableBinding< T >::CVariableBinding (const CVariableBinding< T > & {\i rBinding}){\f2  [private]}}
}\par
{\bkmkstart classCVariableBinding_c0}
{\bkmkend classCVariableBinding_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Commit\:CVariableBinding}
{\xe \v CVariableBinding\:Commit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CVariableBinding< T >::Commit ({\b CTCLInterpreter} & {\i rInterp}){\f2  [virtual]}}
}\par
{\bkmkstart classCVariableBinding_a14}
{\bkmkend classCVariableBinding_a14}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Commit - no commit operation is required. Since the variable was linked, it already has any changed value.{{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rInterp}}  - The interpreter which read in the config file. \par
}\par
Implements {\b CBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBinding_a1 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 357 of file CVariableBinding.cpp.\par
}
{\xe \v Dump\:CVariableBinding}
{\xe \v CVariableBinding\:Dump}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CVariableBinding< T >::Dump (int {\i fd}){\f2  [virtual]}}
}\par
{\bkmkstart classCVariableBinding_a16}
{\bkmkend classCVariableBinding_a16}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
This function is called just prior to deleting the interpreter. Any cleanup actions required by the binding should be done at this point. For example, if Init mapped a C variable to a TCL variable, that mapping should be broken. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rInterp}}  - The interpreter about to be deleted. virtual void {\b ShutdownBindings}(CTCLInterpreter& rInterp) ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCVariableBinding_a15 \\*MERGEFORMAT}{\fldrslt pagenum}}})= 0; /*! This function is called to write the set of Tcl commands required to duplicate the current state. Note that this may not be identical to the set of commands which produced the configuration. \par
}\par
Implements {\b CBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBinding_a2 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 386 of file CVariableBinding.cpp.\par
\par
References CTCLString::AppendElement(), CBinding< T >::ItemToString(), CVariableBinding< T >::m_pVariable, and CVariableBinding< T >::m_sName.}
{\xe \v getInitValue\:CVariableBinding}
{\xe \v CVariableBinding\:getInitValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> T CVariableBinding< T >::getInitValue () const{\f2  [inline]}}
}\par
{\bkmkstart classCVariableBinding_a5}
{\bkmkend classCVariableBinding_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 342 of file CVariableBinding.h.\par
\par
References CVariableBinding< T >::m_tInitialValue.}
{\xe \v getName\:CVariableBinding}
{\xe \v CVariableBinding\:getName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> string CVariableBinding< T >::getName () const{\f2  [inline]}}
}\par
{\bkmkstart classCVariableBinding_a4}
{\bkmkend classCVariableBinding_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 339 of file CVariableBinding.h.\par
\par
References CVariableBinding< T >::m_sName.}
{\xe \v getVariable\:CVariableBinding}
{\xe \v CVariableBinding\:getVariable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> T CVariableBinding< T >::getVariable () const{\f2  [inline]}}
}\par
{\bkmkstart classCVariableBinding_a3}
{\bkmkend classCVariableBinding_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 336 of file CVariableBinding.h.\par
\par
References CVariableBinding< T >::m_pVariable.}
{\xe \v getVarType\:CVariableBinding}
{\xe \v CVariableBinding\:getVarType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int CVariableBinding< T >::getVarType () const{\f2  [inline]}}
}\par
{\bkmkstart classCVariableBinding_a6}
{\bkmkend classCVariableBinding_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 345 of file CVariableBinding.h.\par
\par
References CVariableBinding< T >::m_TCLVariableType.}
{\xe \v InitBindings\:CVariableBinding}
{\xe \v CVariableBinding\:InitBindings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CVariableBinding< T >::InitBindings ({\b CTCLInterpreter} & {\i rInterp}){\f2  [virtual]}}
}\par
{\bkmkstart classCVariableBinding_a13}
{\bkmkend classCVariableBinding_a13}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initialize bindings prior to reading the configuration file. In this case, the TCL variable is bound to the thing referenced by the m_pVariable pointer. {{{\b \par
Parameters: }}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rInterp}}  - The interpreter which will be used to read the config file. \par
}\par
Implements {\b CBinding< T >} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBinding_a0 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 341 of file CVariableBinding.cpp.\par
\par
References CTCLInterpreter::getInterpreter(), CVariableBinding< T >::m_pVariable, CVariableBinding< T >::m_sName, CVariableBinding< T >::m_TCLVariableType, and CVariableBinding< T >::m_tInitialValue.}
{\xe \v operator=\:CVariableBinding}
{\xe \v CVariableBinding\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> CVariableBinding& CVariableBinding< T >::operator= (const CVariableBinding< T > & {\i rBinding}){\f2  [private]}}
}\par
{\bkmkstart classCVariableBinding_c1}
{\bkmkend classCVariableBinding_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:CVariableBinding}
{\xe \v CVariableBinding\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int CVariableBinding< T >::operator== (const CVariableBinding< T > & {\i rBinding}){\f2  [private]}}
}\par
{\bkmkstart classCVariableBinding_c2}
{\bkmkend classCVariableBinding_c2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v setInitialValue\:CVariableBinding}
{\xe \v CVariableBinding\:setInitialValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CVariableBinding< T >::setInitialValue (T {\i value}){\f2  [inline]}}
}\par
{\bkmkstart classCVariableBinding_a11}
{\bkmkend classCVariableBinding_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 362 of file CVariableBinding.h.\par
\par
References CVariableBinding< T >::m_tInitialValue.}
{\xe \v setName\:CVariableBinding}
{\xe \v CVariableBinding\:setName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CVariableBinding< T >::setName (const char * {\i pName}){\f2  [inline]}}
}\par
{\bkmkstart classCVariableBinding_a10}
{\bkmkend classCVariableBinding_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 359 of file CVariableBinding.h.\par
\par
References CVariableBinding< T >::m_sName.}
{\xe \v setName\:CVariableBinding}
{\xe \v CVariableBinding\:setName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CVariableBinding< T >::setName (const string & {\i rName}){\f2  [inline]}}
}\par
{\bkmkstart classCVariableBinding_a9}
{\bkmkend classCVariableBinding_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 356 of file CVariableBinding.h.\par
\par
References CVariableBinding< T >::m_sName.}
{\xe \v setPointer\:CVariableBinding}
{\xe \v CVariableBinding\:setPointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CVariableBinding< T >::setPointer (T * {\i ptr}){\f2  [inline]}}
}\par
{\bkmkstart classCVariableBinding_a8}
{\bkmkend classCVariableBinding_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 353 of file CVariableBinding.h.\par
\par
References CVariableBinding< T >::m_pVariable.}
{\xe \v setVariable\:CVariableBinding}
{\xe \v CVariableBinding\:setVariable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CVariableBinding< T >::setVariable (T {\i value}){\f2  [inline]}}
}\par
{\bkmkstart classCVariableBinding_a7}
{\bkmkend classCVariableBinding_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 350 of file CVariableBinding.h.\par
\par
References CVariableBinding< T >::m_pVariable.}
{\xe \v setVariableType\:CVariableBinding}
{\xe \v CVariableBinding\:setVariableType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CVariableBinding< T >::setVariableType (int {\i type}){\f2  [inline]}}
}\par
{\bkmkstart classCVariableBinding_a12}
{\bkmkend classCVariableBinding_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 365 of file CVariableBinding.h.\par
\par
References CVariableBinding< T >::m_TCLVariableType.}
{\xe \v ShutdownBindings\:CVariableBinding}
{\xe \v CVariableBinding\:ShutdownBindings}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void CVariableBinding< T >::ShutdownBindings ({\b CTCLInterpreter} & {\i rInterp}){\f2  [virtual]}}
}\par
{\bkmkstart classCVariableBinding_a15}
{\bkmkend classCVariableBinding_a15}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Implements {\b CTypeFreeBinding} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTypeFreeBinding_a2 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 366 of file CVariableBinding.cpp.\par
\par
References CTCLInterpreter::getInterpreter(), and CVariableBinding< T >::m_sName.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_pVariable\:CVariableBinding}
{\xe \v CVariableBinding\:m_pVariable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> T* CVariableBinding< T >::m_pVariable{\f2  [private]}}
}\par
{\bkmkstart classCVariableBinding_o0}
{\bkmkend classCVariableBinding_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Pointer to the config variable.\par
\par
Definition at line 318 of file CVariableBinding.h.\par
\par
Referenced by CVariableBinding< T >::Dump(), CVariableBinding< T >::getVariable(), CVariableBinding< T >::InitBindings(), CVariableBinding< T >::setPointer(), and CVariableBinding< T >::setVariable().}
{\xe \v m_sName\:CVariableBinding}
{\xe \v CVariableBinding\:m_sName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> string CVariableBinding< T >::m_sName{\f2  [private]}}
}\par
{\bkmkstart classCVariableBinding_o1}
{\bkmkend classCVariableBinding_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Name of the variable (for Tcl binding).\par
\par
Definition at line 319 of file CVariableBinding.h.\par
\par
Referenced by CVariableBinding< T >::Dump(), CVariableBinding< T >::getName(), CVariableBinding< T >::InitBindings(), CVariableBinding< T >::setName(), and CVariableBinding< T >::ShutdownBindings().}
{\xe \v m_TCLVariableType\:CVariableBinding}
{\xe \v CVariableBinding\:m_TCLVariableType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int CVariableBinding< T >::m_TCLVariableType{\f2  [private]}}
}\par
{\bkmkstart classCVariableBinding_o3}
{\bkmkend classCVariableBinding_o3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Type of binding (for TCL).\par
\par
Definition at line 321 of file CVariableBinding.h.\par
\par
Referenced by CVariableBinding< T >::getVarType(), CVariableBinding< T >::InitBindings(), and CVariableBinding< T >::setVariableType().}
{\xe \v m_tInitialValue\:CVariableBinding}
{\xe \v CVariableBinding\:m_tInitialValue}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> T CVariableBinding< T >::m_tInitialValue{\f2  [private]}}
}\par
{\bkmkstart classCVariableBinding_o2}
{\bkmkend classCVariableBinding_o2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Initial value of the variable.\par
\par
Definition at line 320 of file CVariableBinding.h.\par
\par
Referenced by CVariableBinding< T >::getInitValue(), CVariableBinding< T >::InitBindings(), and CVariableBinding< T >::setInitialValue().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CVariableBinding.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CVariableBinding.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMApplication  Class Reference\par \pard\plain 
{\tc\tcl2 \v XMApplication}
{\xe \v XMApplication}
{\bkmkstart classXMApplication}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMWidget.h>}\par
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMApplication} (char *cl, Cardinal *argc, char **argv, XrmOptionDescList options=NULL, Cardinal noptions=0, const char **fallback_resources=NULL, ArgList args=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Begin} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
XtAppContext {\b GetContext} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Widget {\b getid} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Manage} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnManage} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Realize} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnRealize} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetAttribute} (String attribute, XtArgVal value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetAttribute} (String attribute, void *value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b GetAttribute} (String attribute, void *value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b GetAttribute} (String attribute, XtArgVal value)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
XtAppContext {\b application}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Widget {\b toplevel_shell}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMWidgetName} {\b app_class}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v XMApplication\:XMApplication}
{\xe \v XMApplication\:XMApplication}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMApplication::XMApplication (char * {\i cl}, Cardinal * {\i argc}, char ** {\i argv}, XrmOptionDescList {\i options} = NULL, Cardinal {\i noptions} = 0, const char ** {\i fallback_resources} = NULL, ArgList {\i args} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMApplication_a0}
{\bkmkend classXMApplication_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 320 of file XMWidget.h.\par
\par
References app_class, application, and toplevel_shell.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Begin\:XMApplication}
{\xe \v XMApplication\:Begin}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMApplication::Begin (){\f2  [inline]}}
}\par
{\bkmkstart classXMApplication_a1}
{\bkmkend classXMApplication_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 336 of file XMWidget.h.\par
\par
References application, and toplevel_shell.}
{\xe \v GetAttribute\:XMApplication}
{\xe \v XMApplication\:GetAttribute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMApplication::GetAttribute (String {\i attribute}, XtArgVal {\i value}){\f2  [inline]}}
}\par
{\bkmkstart classXMApplication_a11}
{\bkmkend classXMApplication_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 356 of file XMWidget.h.\par
\par
References toplevel_shell.}
{\xe \v GetAttribute\:XMApplication}
{\xe \v XMApplication\:GetAttribute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMApplication::GetAttribute (String {\i attribute}, void * {\i value}){\f2  [inline]}}
}\par
{\bkmkstart classXMApplication_a10}
{\bkmkend classXMApplication_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 354 of file XMWidget.h.\par
\par
References toplevel_shell.}
{\xe \v GetContext\:XMApplication}
{\xe \v XMApplication\:GetContext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XtAppContext XMApplication::GetContext (){\f2  [inline]}}
}\par
{\bkmkstart classXMApplication_a2}
{\bkmkend classXMApplication_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 342 of file XMWidget.h.\par
\par
References application.}
{\xe \v getid\:XMApplication}
{\xe \v XMApplication\:getid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Widget XMApplication::getid (){\f2  [inline]}}
}\par
{\bkmkstart classXMApplication_a3}
{\bkmkend classXMApplication_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 343 of file XMWidget.h.\par
\par
References toplevel_shell.\par
Referenced by XMWidget::XMWidget().}
{\xe \v Manage\:XMApplication}
{\xe \v XMApplication\:Manage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMApplication::Manage (){\f2  [inline]}}
}\par
{\bkmkstart classXMApplication_a4}
{\bkmkend classXMApplication_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 344 of file XMWidget.h.\par
\par
References toplevel_shell.}
{\xe \v Realize\:XMApplication}
{\xe \v XMApplication\:Realize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMApplication::Realize (){\f2  [inline]}}
}\par
{\bkmkstart classXMApplication_a6}
{\bkmkend classXMApplication_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 346 of file XMWidget.h.\par
\par
References toplevel_shell.}
{\xe \v SetAttribute\:XMApplication}
{\xe \v XMApplication\:SetAttribute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMApplication::SetAttribute (String {\i attribute}, void * {\i value}){\f2  [inline]}}
}\par
{\bkmkstart classXMApplication_a9}
{\bkmkend classXMApplication_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 351 of file XMWidget.h.\par
\par
References toplevel_shell.}
{\xe \v SetAttribute\:XMApplication}
{\xe \v XMApplication\:SetAttribute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMApplication::SetAttribute (String {\i attribute}, XtArgVal {\i value}){\f2  [inline]}}
}\par
{\bkmkstart classXMApplication_a8}
{\bkmkend classXMApplication_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 349 of file XMWidget.h.\par
\par
References toplevel_shell.}
{\xe \v UnManage\:XMApplication}
{\xe \v XMApplication\:UnManage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMApplication::UnManage (){\f2  [inline]}}
}\par
{\bkmkstart classXMApplication_a5}
{\bkmkend classXMApplication_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 345 of file XMWidget.h.\par
\par
References toplevel_shell.}
{\xe \v UnRealize\:XMApplication}
{\xe \v XMApplication\:UnRealize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMApplication::UnRealize (){\f2  [inline]}}
}\par
{\bkmkstart classXMApplication_a7}
{\bkmkend classXMApplication_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 347 of file XMWidget.h.\par
\par
References toplevel_shell.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v app_class\:XMApplication}
{\xe \v XMApplication\:app_class}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMWidgetName} XMApplication::app_class{\f2  [protected]}}
}\par
{\bkmkstart classXMApplication_n2}
{\bkmkend classXMApplication_n2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 318 of file XMWidget.h.\par
\par
Referenced by XMApplication().}
{\xe \v application\:XMApplication}
{\xe \v XMApplication\:application}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XtAppContext XMApplication::application{\f2  [protected]}}
}\par
{\bkmkstart classXMApplication_n0}
{\bkmkend classXMApplication_n0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 316 of file XMWidget.h.\par
\par
Referenced by Begin(), GetContext(), and XMApplication().}
{\xe \v toplevel_shell\:XMApplication}
{\xe \v XMApplication\:toplevel_shell}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Widget XMApplication::toplevel_shell{\f2  [protected]}}
}\par
{\bkmkstart classXMApplication_n1}
{\bkmkend classXMApplication_n1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 317 of file XMWidget.h.\par
\par
Referenced by Begin(), GetAttribute(), getid(), Manage(), Realize(), SetAttribute(), UnManage(), UnRealize(), and XMApplication().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMWidget.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMArrowButton  Class Reference\par \pard\plain 
{\tc\tcl2 \v XMArrowButton}
{\xe \v XMArrowButton}
{\bkmkstart classXMArrowButton}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMPushbutton.h>}\par
Inheritance diagram for XMArrowButton:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classXMArrowButton.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMArrowButton} (char *n, Widget parent, void(*cb)({\b XMWidget} *, XtPointer, XtPointer)=NULL, XtPointer cd=NULL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMArrowButton} (char *n, {\b XMWidget} &parent, void(*cb)({\b XMWidget} *, XtPointer, XtPointer)=NULL, XtPointer cd=NULL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Callback_data} * {\b AddCallback} (void(*cb)({\b XMWidget} *, XtPointer, XtPointer)=NULL, XtPointer cd=NULL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PointLeft} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PointRight} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PointUp} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b PointDown} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned char {\b Direction} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b Label} (XmString label)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b Label} (String label)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b SetMnemonic} (KeySym k)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v XMArrowButton\:XMArrowButton}
{\xe \v XMArrowButton\:XMArrowButton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMArrowButton::XMArrowButton (char * {\i n}, Widget {\i parent}, void(* {\i cb})({\b XMWidget} *, XtPointer, XtPointer) = NULL, XtPointer {\i cd} = NULL){\f2  [inline]}}
}\par
{\bkmkstart classXMArrowButton_a0}
{\bkmkend classXMArrowButton_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 538 of file XMPushbutton.h.\par
\par
References XMWidget::AddCallback(), and XMButton::Enable().}
{\xe \v XMArrowButton\:XMArrowButton}
{\xe \v XMArrowButton\:XMArrowButton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMArrowButton::XMArrowButton (char * {\i n}, {\b XMWidget} & {\i parent}, void(* {\i cb})({\b XMWidget} *, XtPointer, XtPointer) = NULL, XtPointer {\i cd} = NULL){\f2  [inline]}}
}\par
{\bkmkstart classXMArrowButton_a1}
{\bkmkend classXMArrowButton_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 547 of file XMPushbutton.h.\par
\par
References XMWidget::AddCallback(), and XMButton::Enable().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddCallback\:XMArrowButton}
{\xe \v XMArrowButton\:AddCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Callback_data}* XMArrowButton::AddCallback (void(* {\i cb})({\b XMWidget} *, XtPointer, XtPointer) = NULL, XtPointer {\i cd} = NULL){\f2  [inline]}}
}\par
{\bkmkstart classXMArrowButton_a2}
{\bkmkend classXMArrowButton_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 559 of file XMPushbutton.h.\par
\par
References XMWidget::AddCallback().}
{\xe \v Direction\:XMArrowButton}
{\xe \v XMArrowButton\:Direction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned char XMArrowButton::Direction (){\f2  [inline]}}
}\par
{\bkmkstart classXMArrowButton_a7}
{\bkmkend classXMArrowButton_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 577 of file XMPushbutton.h.\par
\par
References XMWidget::GetAttribute().}
{\xe \v Label\:XMArrowButton}
{\xe \v XMArrowButton\:Label}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void XMArrowButton::Label (String {\i label}){\f2  [inline, virtual]}}
}\par
{\bkmkstart classXMArrowButton_a9}
{\bkmkend classXMArrowButton_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Reimplemented from {\b XMButton} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classXMButton_a3 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 588 of file XMPushbutton.h.\par
}
{\xe \v Label\:XMArrowButton}
{\xe \v XMArrowButton\:Label}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void XMArrowButton::Label (XmString {\i label}){\f2  [inline, virtual]}}
}\par
{\bkmkstart classXMArrowButton_a8}
{\bkmkend classXMArrowButton_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Reimplemented from {\b XMButton} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classXMButton_a2 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 587 of file XMPushbutton.h.\par
}
{\xe \v PointDown\:XMArrowButton}
{\xe \v XMArrowButton\:PointDown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMArrowButton::PointDown (){\f2  [inline]}}
}\par
{\bkmkstart classXMArrowButton_a6}
{\bkmkend classXMArrowButton_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 573 of file XMPushbutton.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v PointLeft\:XMArrowButton}
{\xe \v XMArrowButton\:PointLeft}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMArrowButton::PointLeft (){\f2  [inline]}}
}\par
{\bkmkstart classXMArrowButton_a3}
{\bkmkend classXMArrowButton_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 564 of file XMPushbutton.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v PointRight\:XMArrowButton}
{\xe \v XMArrowButton\:PointRight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMArrowButton::PointRight (){\f2  [inline]}}
}\par
{\bkmkstart classXMArrowButton_a4}
{\bkmkend classXMArrowButton_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 567 of file XMPushbutton.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v PointUp\:XMArrowButton}
{\xe \v XMArrowButton\:PointUp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMArrowButton::PointUp (){\f2  [inline]}}
}\par
{\bkmkstart classXMArrowButton_a5}
{\bkmkend classXMArrowButton_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 570 of file XMPushbutton.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v SetMnemonic\:XMArrowButton}
{\xe \v XMArrowButton\:SetMnemonic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void XMArrowButton::SetMnemonic (KeySym {\i k}){\f2  [inline, virtual]}}
}\par
{\bkmkstart classXMArrowButton_a10}
{\bkmkend classXMArrowButton_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Reimplemented from {\b XMButton} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classXMButton_a4 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 589 of file XMPushbutton.h.\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMPushbutton.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMBulletinBoard  Class Reference\par \pard\plain 
{\tc\tcl2 \v XMBulletinBoard}
{\xe \v XMBulletinBoard}
{\bkmkstart classXMBulletinBoard}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMManagers.h>}\par
Inheritance diagram for XMBulletinBoard:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classXMBulletinBoard.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMBulletinBoard} (char *n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMBulletinBoard} (Widget w)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMBulletinBoard} (char *n, {\b XMApplication} &parent, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMBulletinBoard} (char *n, Widget parent, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMBulletinBoard} (char *n, {\b XMWidget} &parent, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AllowOverlap} (Boolean allow)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Margins} (Dimension ymargin, Dimension xmargin=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetShadowType} (unsigned char type)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetAbsPosition} ({\b XMWidget} &w, int x, int y)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMBulletinBoard} (char *n, WidgetClass cl, Widget parent, ArgList l, Cardinal num_args)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v XMBulletinBoard\:XMBulletinBoard}
{\xe \v XMBulletinBoard\:XMBulletinBoard}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMBulletinBoard::XMBulletinBoard (char * {\i n}, WidgetClass {\i cl}, Widget {\i parent}, ArgList {\i l}, Cardinal {\i num_args}){\f2  [inline, protected]}}
}\par
{\bkmkstart classXMBulletinBoard_b0}
{\bkmkend classXMBulletinBoard_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 376 of file XMManagers.h.\par
}
{\xe \v XMBulletinBoard\:XMBulletinBoard}
{\xe \v XMBulletinBoard\:XMBulletinBoard}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMBulletinBoard::XMBulletinBoard (char * {\i n}){\f2  [inline]}}
}\par
{\bkmkstart classXMBulletinBoard_a0}
{\bkmkend classXMBulletinBoard_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 382 of file XMManagers.h.\par
}
{\xe \v XMBulletinBoard\:XMBulletinBoard}
{\xe \v XMBulletinBoard\:XMBulletinBoard}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMBulletinBoard::XMBulletinBoard (Widget {\i w}){\f2  [inline]}}
}\par
{\bkmkstart classXMBulletinBoard_a1}
{\bkmkend classXMBulletinBoard_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 383 of file XMManagers.h.\par
}
{\xe \v XMBulletinBoard\:XMBulletinBoard}
{\xe \v XMBulletinBoard\:XMBulletinBoard}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMBulletinBoard::XMBulletinBoard (char * {\i n}, {\b XMApplication} & {\i parent}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMBulletinBoard_a2}
{\bkmkend classXMBulletinBoard_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 384 of file XMManagers.h.\par
}
{\xe \v XMBulletinBoard\:XMBulletinBoard}
{\xe \v XMBulletinBoard\:XMBulletinBoard}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMBulletinBoard::XMBulletinBoard (char * {\i n}, Widget {\i parent}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMBulletinBoard_a3}
{\bkmkend classXMBulletinBoard_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 388 of file XMManagers.h.\par
}
{\xe \v XMBulletinBoard\:XMBulletinBoard}
{\xe \v XMBulletinBoard\:XMBulletinBoard}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMBulletinBoard::XMBulletinBoard (char * {\i n}, {\b XMWidget} & {\i parent}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMBulletinBoard_a4}
{\bkmkend classXMBulletinBoard_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 392 of file XMManagers.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AllowOverlap\:XMBulletinBoard}
{\xe \v XMBulletinBoard\:AllowOverlap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMBulletinBoard::AllowOverlap (Boolean {\i allow}){\f2  [inline]}}
}\par
{\bkmkstart classXMBulletinBoard_a5}
{\bkmkend classXMBulletinBoard_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 398 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v Margins\:XMBulletinBoard}
{\xe \v XMBulletinBoard\:Margins}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMBulletinBoard::Margins (Dimension {\i ymargin}, Dimension {\i xmargin} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMBulletinBoard_a6}
{\bkmkend classXMBulletinBoard_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 401 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v SetAbsPosition\:XMBulletinBoard}
{\xe \v XMBulletinBoard\:SetAbsPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMBulletinBoard::SetAbsPosition ({\b XMWidget} & {\i w}, int {\i x}, int {\i y}){\f2  [inline]}}
}\par
{\bkmkstart classXMBulletinBoard_a8}
{\bkmkend classXMBulletinBoard_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 410 of file XMManagers.h.\par
\par
References XMManager::SetConstraint().}
{\xe \v SetShadowType\:XMBulletinBoard}
{\xe \v XMBulletinBoard\:SetShadowType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMBulletinBoard::SetShadowType (unsigned char {\i type}){\f2  [inline]}}
}\par
{\bkmkstart classXMBulletinBoard_a7}
{\bkmkend classXMBulletinBoard_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 405 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMManagers.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMButton  Class Reference\par \pard\plain 
{\tc\tcl2 \v XMButton}
{\xe \v XMButton}
{\bkmkstart classXMButton}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMPushbutton.h>}\par
Inheritance diagram for XMButton:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classXMButton.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b Enable} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b Disable} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b Label} (XmString label)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b Label} (String label)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b SetMnemonic} (KeySym k)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMButton} (char *n, WidgetClass c, Widget parent)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMButton} (char *n, WidgetClass c, {\b XMWidget} &parent)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMButton} (Widget w)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetAccelerator} (char *translation, char *prompt)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v XMButton\:XMButton}
{\xe \v XMButton\:XMButton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMButton::XMButton (char * {\i n}, WidgetClass {\i c}, Widget {\i parent}){\f2  [inline]}}
}\par
{\bkmkstart classXMButton_a5}
{\bkmkend classXMButton_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 349 of file XMPushbutton.h.\par
}
{\xe \v XMButton\:XMButton}
{\xe \v XMButton\:XMButton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMButton::XMButton (char * {\i n}, WidgetClass {\i c}, {\b XMWidget} & {\i parent}){\f2  [inline]}}
}\par
{\bkmkstart classXMButton_a6}
{\bkmkend classXMButton_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 352 of file XMPushbutton.h.\par
}
{\xe \v XMButton\:XMButton}
{\xe \v XMButton\:XMButton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMButton::XMButton (Widget {\i w}){\f2  [inline]}}
}\par
{\bkmkstart classXMButton_a7}
{\bkmkend classXMButton_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 355 of file XMPushbutton.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Disable\:XMButton}
{\xe \v XMButton\:Disable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void XMButton::Disable (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classXMButton_a1}
{\bkmkend classXMButton_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 320 of file XMPushbutton.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v Enable\:XMButton}
{\xe \v XMButton\:Enable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void XMButton::Enable (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classXMButton_a0}
{\bkmkend classXMButton_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 316 of file XMPushbutton.h.\par
\par
References XMWidget::SetAttribute().\par
Referenced by XMArrowButton::XMArrowButton(), XMCascadeButton::XMCascadeButton(), XMPushButton::XMPushButton(), and XMToggleButton::XMToggleButton().}
{\xe \v Label\:XMButton}
{\xe \v XMButton\:Label}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void XMButton::Label (String {\i label}){\f2  [inline, virtual]}}
}\par
{\bkmkstart classXMButton_a3}
{\bkmkend classXMButton_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Reimplemented in {\b XMArrowButton} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classXMArrowButton_a9 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 332 of file XMPushbutton.h.\par
\par
References Label().}
{\xe \v Label\:XMButton}
{\xe \v XMButton\:Label}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void XMButton::Label (XmString {\i label}){\f2  [inline, virtual]}}
}\par
{\bkmkstart classXMButton_a2}
{\bkmkend classXMButton_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Reimplemented in {\b XMArrowButton} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classXMArrowButton_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 328 of file XMPushbutton.h.\par
\par
References XMWidget::SetAttribute().\par
Referenced by XMPulldown::BuildMenu(), Label(), and XMPulldown::Label().}
{\xe \v SetAccelerator\:XMButton}
{\xe \v XMButton\:SetAccelerator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMButton::SetAccelerator (char * {\i translation}, char * {\i prompt}){\f2  [inline]}}
}\par
{\bkmkstart classXMButton_a8}
{\bkmkend classXMButton_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 358 of file XMPushbutton.h.\par
\par
References XMWidget::id.}
{\xe \v SetMnemonic\:XMButton}
{\xe \v XMButton\:SetMnemonic}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual void XMButton::SetMnemonic (KeySym {\i k}){\f2  [inline, virtual]}}
}\par
{\bkmkstart classXMButton_a4}
{\bkmkend classXMButton_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Reimplemented in {\b XMArrowButton} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classXMArrowButton_a10 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 342 of file XMPushbutton.h.\par
\par
References XMWidget::SetAttribute().\par
Referenced by XMPulldown::BuildMenu().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMPushbutton.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMButtonList  Class Reference\par \pard\plain 
{\tc\tcl2 \v XMButtonList}
{\xe \v XMButtonList}
{\bkmkstart classXMButtonList}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMWlist.h>}\par
Inheritance diagram for XMButtonList:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classXMButtonList.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Enable} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Disable} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Disable\:XMButtonList}
{\xe \v XMButtonList\:Disable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMButtonList::Disable (){\f2  [inline]}}
}\par
{\bkmkstart classXMButtonList_a1}
{\bkmkend classXMButtonList_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 385 of file XMWlist.h.\par
\par
References XMWidgetList::SetAttribute().}
{\xe \v Enable\:XMButtonList}
{\xe \v XMButtonList\:Enable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMButtonList::Enable (){\f2  [inline]}}
}\par
{\bkmkstart classXMButtonList_a0}
{\bkmkend classXMButtonList_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 382 of file XMWlist.h.\par
\par
References XMWidgetList::SetAttribute().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMWlist.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMCallback< T >  Class Template Reference\par \pard\plain 
{\tc\tcl2 \v XMCallback}
{\xe \v XMCallback}
{\bkmkstart classXMCallback}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMCallback.h>}\par
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Types\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void(T::* {\b T_Action} )({\b XMWidget} *, XtPointer, XtPointer)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMCallback} (T *object)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMCallback} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~XMCallback} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Register} ({\b XMWidget} *w, String reason, void(T::*callback)({\b XMWidget} *, XtPointer, XtPointer), XtPointer userdata)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnRegister} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Relay} (XtPointer calld)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Static Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b _Dispatch_Callback_Relay} (Widget w, XtPointer ud, XtPointer cd)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
T * {\b instance}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
String {\b callbackreason}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b T_Action} {\b callbackaction}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b callbackset}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
XtPointer {\b callbackuserd}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMWidget} * {\b wid}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
XMCallback< T > * {\b self}\par
}

{
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid 
template<class T> class XMCallback< T >\par
}

{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Typedef Documentation\par
\pard\plain 
{\xe \v T_Action\:XMCallback}
{\xe \v XMCallback\:T_Action}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> typedef void(T::* XMCallback< T >::T_Action)({\b XMWidget} *, XtPointer, XtPointer)}
}\par
{\bkmkstart classXMCallback_s0}
{\bkmkend classXMCallback_s0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 316 of file XMCallback.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v XMCallback\:XMCallback}
{\xe \v XMCallback\:XMCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> XMCallback< T >::XMCallback (T * {\i object}){\f2  [inline]}}
}\par
{\bkmkstart classXMCallback_a0}
{\bkmkend classXMCallback_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 322 of file XMCallback.h.\par
}
{\xe \v XMCallback\:XMCallback}
{\xe \v XMCallback\:XMCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> XMCallback< T >::XMCallback (){\f2  [inline]}}
}\par
{\bkmkstart classXMCallback_a1}
{\bkmkend classXMCallback_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 334 of file XMCallback.h.\par
}
{\xe \v ~XMCallback\:XMCallback}
{\xe \v XMCallback\:~XMCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> XMCallback< T >::~XMCallback (){\f2  [inline]}}
}\par
{\bkmkstart classXMCallback_a2}
{\bkmkend classXMCallback_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 335 of file XMCallback.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v _Dispatch_Callback_Relay\:XMCallback}
{\xe \v XMCallback\:_Dispatch_Callback_Relay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void XMCallback< T >::_Dispatch_Callback_Relay (Widget {\i w}, XtPointer {\i ud}, XtPointer {\i cd}){\f2  [inline, static, private]}}
}\par
{\bkmkstart classXMCallback_f0}
{\bkmkend classXMCallback_f0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 407 of file XMCallback.h.\par
}
{\xe \v Register\:XMCallback}
{\xe \v XMCallback\:Register}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void XMCallback< T >::Register ({\b XMWidget} * {\i w}, String {\i reason}, void(T::* {\i callback})({\b XMWidget} *, XtPointer, XtPointer), XtPointer {\i userdata}){\f2  [inline]}}
}\par
{\bkmkstart classXMCallback_a3}
{\bkmkend classXMCallback_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 340 of file XMCallback.h.\par
}
{\xe \v Relay\:XMCallback}
{\xe \v XMCallback\:Relay}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void XMCallback< T >::Relay (XtPointer {\i calld}){\f2  [inline]}}
}\par
{\bkmkstart classXMCallback_a5}
{\bkmkend classXMCallback_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 386 of file XMCallback.h.\par
\par
Referenced by XMCallback< Shell >::_Dispatch_Callback_Relay().}
{\xe \v UnRegister\:XMCallback}
{\xe \v XMCallback\:UnRegister}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> void XMCallback< T >::UnRegister (){\f2  [inline]}}
}\par
{\bkmkstart classXMCallback_a4}
{\bkmkend classXMCallback_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 366 of file XMCallback.h.\par
\par
Referenced by XMCallback< Shell >::~XMCallback().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v callbackaction\:XMCallback}
{\xe \v XMCallback\:callbackaction}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> {\b T_Action} XMCallback< T >::callbackaction{\f2  [private]}}
}\par
{\bkmkstart classXMCallback_o2}
{\bkmkend classXMCallback_o2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 398 of file XMCallback.h.\par
\par
Referenced by XMCallback< Shell >::Register(), XMCallback< Shell >::UnRegister(), and XMCallback< Shell >::XMCallback().}
{\xe \v callbackreason\:XMCallback}
{\xe \v XMCallback\:callbackreason}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> String XMCallback< T >::callbackreason{\f2  [private]}}
}\par
{\bkmkstart classXMCallback_o1}
{\bkmkend classXMCallback_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 397 of file XMCallback.h.\par
\par
Referenced by XMCallback< Shell >::Register(), XMCallback< Shell >::UnRegister(), and XMCallback< Shell >::XMCallback().}
{\xe \v callbackset\:XMCallback}
{\xe \v XMCallback\:callbackset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> int XMCallback< T >::callbackset{\f2  [private]}}
}\par
{\bkmkstart classXMCallback_o3}
{\bkmkend classXMCallback_o3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 399 of file XMCallback.h.\par
\par
Referenced by XMCallback< Shell >::Register(), XMCallback< Shell >::UnRegister(), and XMCallback< Shell >::XMCallback().}
{\xe \v callbackuserd\:XMCallback}
{\xe \v XMCallback\:callbackuserd}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> XtPointer XMCallback< T >::callbackuserd{\f2  [private]}}
}\par
{\bkmkstart classXMCallback_o4}
{\bkmkend classXMCallback_o4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 400 of file XMCallback.h.\par
\par
Referenced by XMCallback< Shell >::Register(), XMCallback< Shell >::Relay(), XMCallback< Shell >::UnRegister(), and XMCallback< Shell >::XMCallback().}
{\xe \v instance\:XMCallback}
{\xe \v XMCallback\:instance}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> T* XMCallback< T >::instance{\f2  [private]}}
}\par
{\bkmkstart classXMCallback_o0}
{\bkmkend classXMCallback_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 391 of file XMCallback.h.\par
\par
Referenced by XMCallback< Shell >::Relay(), and XMCallback< Shell >::XMCallback().}
{\xe \v self\:XMCallback}
{\xe \v XMCallback\:self}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> XMCallback<T>* XMCallback< T >::self{\f2  [private]}}
}\par
{\bkmkstart classXMCallback_o6}
{\bkmkend classXMCallback_o6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 402 of file XMCallback.h.\par
\par
Referenced by XMCallback< Shell >::Register(), XMCallback< Shell >::UnRegister(), and XMCallback< Shell >::XMCallback().}
{\xe \v wid\:XMCallback}
{\xe \v XMCallback\:wid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
template<class T> {\b XMWidget}* XMCallback< T >::wid{\f2  [private]}}
}\par
{\bkmkstart classXMCallback_o5}
{\bkmkend classXMCallback_o5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 401 of file XMCallback.h.\par
\par
Referenced by XMCallback< Shell >::Register(), XMCallback< Shell >::Relay(), XMCallback< Shell >::UnRegister(), and XMCallback< Shell >::XMCallback().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMCallback.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMCascadeButton  Class Reference\par \pard\plain 
{\tc\tcl2 \v XMCascadeButton}
{\xe \v XMCascadeButton}
{\bkmkstart classXMCascadeButton}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMPushbutton.h>}\par
Inheritance diagram for XMCascadeButton:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classXMCascadeButton.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetAssociatedMenu} ({\b XMWidget} &w)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetAssociatedMenu} (Widget w)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMCascadeButton} (char *n, Widget parent, void(*cb)({\b XMWidget} *, XtPointer, XtPointer)=NULL, XtPointer cd=NULL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMCascadeButton} (char *n, {\b XMWidget} &parent, void(*cb)({\b XMWidget} *, XtPointer, XtPointer)=NULL, XtPointer cd=NULL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMCascadeButton} (Widget w)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Callback_data} * {\b AddCallback} (void(*cb)({\b XMWidget} *, XtPointer, XtPointer)=NULL, XtPointer cd=NULL)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v XMCascadeButton\:XMCascadeButton}
{\xe \v XMCascadeButton\:XMCascadeButton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMCascadeButton::XMCascadeButton (char * {\i n}, Widget {\i parent}, void(* {\i cb})({\b XMWidget} *, XtPointer, XtPointer) = NULL, XtPointer {\i cd} = NULL){\f2  [inline]}}
}\par
{\bkmkstart classXMCascadeButton_a2}
{\bkmkend classXMCascadeButton_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 431 of file XMPushbutton.h.\par
\par
References XMWidget::AddCallback(), and XMButton::Enable().}
{\xe \v XMCascadeButton\:XMCascadeButton}
{\xe \v XMCascadeButton\:XMCascadeButton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMCascadeButton::XMCascadeButton (char * {\i n}, {\b XMWidget} & {\i parent}, void(* {\i cb})({\b XMWidget} *, XtPointer, XtPointer) = NULL, XtPointer {\i cd} = NULL){\f2  [inline]}}
}\par
{\bkmkstart classXMCascadeButton_a3}
{\bkmkend classXMCascadeButton_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 441 of file XMPushbutton.h.\par
\par
References XMWidget::AddCallback(), and XMButton::Enable().}
{\xe \v XMCascadeButton\:XMCascadeButton}
{\xe \v XMCascadeButton\:XMCascadeButton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMCascadeButton::XMCascadeButton (Widget {\i w}){\f2  [inline]}}
}\par
{\bkmkstart classXMCascadeButton_a4}
{\bkmkend classXMCascadeButton_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 451 of file XMPushbutton.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddCallback\:XMCascadeButton}
{\xe \v XMCascadeButton\:AddCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Callback_data}* XMCascadeButton::AddCallback (void(* {\i cb})({\b XMWidget} *, XtPointer, XtPointer) = NULL, XtPointer {\i cd} = NULL){\f2  [inline]}}
}\par
{\bkmkstart classXMCascadeButton_a5}
{\bkmkend classXMCascadeButton_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 455 of file XMPushbutton.h.\par
\par
References XMWidget::AddCallback().}
{\xe \v SetAssociatedMenu\:XMCascadeButton}
{\xe \v XMCascadeButton\:SetAssociatedMenu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMCascadeButton::SetAssociatedMenu (Widget {\i w}){\f2  [inline]}}
}\par
{\bkmkstart classXMCascadeButton_a1}
{\bkmkend classXMCascadeButton_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 421 of file XMPushbutton.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v SetAssociatedMenu\:XMCascadeButton}
{\xe \v XMCascadeButton\:SetAssociatedMenu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMCascadeButton::SetAssociatedMenu ({\b XMWidget} & {\i w}){\f2  [inline]}}
}\par
{\bkmkstart classXMCascadeButton_a0}
{\bkmkend classXMCascadeButton_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 417 of file XMPushbutton.h.\par
\par
References XMWidget::getid(), and XMWidget::SetAttribute().\par
Referenced by XMPulldown::BuildMenu().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMPushbutton.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMForm  Class Reference\par \pard\plain 
{\tc\tcl2 \v XMForm}
{\xe \v XMForm}
{\bkmkstart classXMForm}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMManagers.h>}\par
Inheritance diagram for XMForm:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classXMForm.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMForm} (char *{\b name})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMForm} (Widget {\b id})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMForm} (char *n, {\b XMApplication} &parent, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMForm} (char *n, Widget parent, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMForm} (char *n, {\b XMWidget} &parent, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetFractionBase} (int n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetHorizontalSpacing} (Dimension n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetRubberPositioning} (Boolean on)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetVerticalSpacing} (Dimension n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetBottomAttachment} ({\b XMWidget} &wid, unsigned char method)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetBottomAttachment} (Widget wid, unsigned char method)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetBottomOffset} ({\b XMWidget} &wid, int off)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetBottomPosition} ({\b XMWidget} &wid, int position)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetBottomWidget} ({\b XMWidget} &wid, {\b XMWidget} &bound)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetBottomWidget} ({\b XMWidget} &wid, Widget bound)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetLeftAttachment} ({\b XMWidget} &wid, unsigned char method)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetLeftAttachment} (Widget wid, unsigned char method)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetLeftOffset} ({\b XMWidget} &wid, int offset)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetLeftPosition} ({\b XMWidget} &wid, int position)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetLeftWidget} ({\b XMWidget} &wid, {\b XMWidget} &bound)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetLeftWidget} ({\b XMWidget} &wid, Widget bound)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetRightAttachment} ({\b XMWidget} &wid, unsigned char method)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetRightAttachment} (Widget wid, unsigned char method)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetRightOffset} ({\b XMWidget} &wid, int offset)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetRightPosition} ({\b XMWidget} &wid, int position)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetRightWidget} ({\b XMWidget} &wid, {\b XMWidget} &bound)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetRightWidget} ({\b XMWidget} &wid, Widget bound)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetTopAttachment} ({\b XMWidget} &wid, unsigned char method)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetTopAttachment} (Widget wid, unsigned char method)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetTopOffset} ({\b XMWidget} &wid, int offset)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetTopPosition} ({\b XMWidget} &wid, int position)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetTopWidget} ({\b XMWidget} &wid, {\b XMWidget} &bound)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetTopWidget} ({\b XMWidget} &wid, Widget bound)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetTopWidget} (Widget wid, Widget bound)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetTopWidget} (Widget wid, {\b XMWidget} &bound)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v XMForm\:XMForm}
{\xe \v XMForm\:XMForm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMForm::XMForm (char * {\i name}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a0}
{\bkmkend classXMForm_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 456 of file XMManagers.h.\par
\par
References XMWidget::name.}
{\xe \v XMForm\:XMForm}
{\xe \v XMForm\:XMForm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMForm::XMForm (Widget {\i id}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a1}
{\bkmkend classXMForm_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 457 of file XMManagers.h.\par
\par
References XMWidget::id.}
{\xe \v XMForm\:XMForm}
{\xe \v XMForm\:XMForm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMForm::XMForm (char * {\i n}, {\b XMApplication} & {\i parent}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a2}
{\bkmkend classXMForm_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 458 of file XMManagers.h.\par
\par
References XMWidget::getid().}
{\xe \v XMForm\:XMForm}
{\xe \v XMForm\:XMForm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMForm::XMForm (char * {\i n}, Widget {\i parent}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a3}
{\bkmkend classXMForm_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 462 of file XMManagers.h.\par
}
{\xe \v XMForm\:XMForm}
{\xe \v XMForm\:XMForm}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMForm::XMForm (char * {\i n}, {\b XMWidget} & {\i parent}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a4}
{\bkmkend classXMForm_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 466 of file XMManagers.h.\par
\par
References XMWidget::getid().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v SetBottomAttachment\:XMForm}
{\xe \v XMForm\:SetBottomAttachment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMForm::SetBottomAttachment (Widget {\i wid}, unsigned char {\i method}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a10}
{\bkmkend classXMForm_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 491 of file XMManagers.h.\par
\par
References XMManager::SetConstraint().}
{\xe \v SetBottomAttachment\:XMForm}
{\xe \v XMForm\:SetBottomAttachment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMForm::SetBottomAttachment ({\b XMWidget} & {\i wid}, unsigned char {\i method}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a9}
{\bkmkend classXMForm_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 488 of file XMManagers.h.\par
\par
References XMManager::SetConstraint().}
{\xe \v SetBottomOffset\:XMForm}
{\xe \v XMForm\:SetBottomOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMForm::SetBottomOffset ({\b XMWidget} & {\i wid}, int {\i off}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a11}
{\bkmkend classXMForm_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 495 of file XMManagers.h.\par
\par
References XMManager::SetConstraint().}
{\xe \v SetBottomPosition\:XMForm}
{\xe \v XMForm\:SetBottomPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMForm::SetBottomPosition ({\b XMWidget} & {\i wid}, int {\i position}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a12}
{\bkmkend classXMForm_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 498 of file XMManagers.h.\par
\par
References XMManager::SetConstraint().}
{\xe \v SetBottomWidget\:XMForm}
{\xe \v XMForm\:SetBottomWidget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMForm::SetBottomWidget ({\b XMWidget} & {\i wid}, Widget {\i bound}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a14}
{\bkmkend classXMForm_a14}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 504 of file XMManagers.h.\par
\par
References XMManager::SetConstraint().}
{\xe \v SetBottomWidget\:XMForm}
{\xe \v XMForm\:SetBottomWidget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMForm::SetBottomWidget ({\b XMWidget} & {\i wid}, {\b XMWidget} & {\i bound}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a13}
{\bkmkend classXMForm_a13}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 501 of file XMManagers.h.\par
\par
References XMWidget::getid(), and XMManager::SetConstraint().}
{\xe \v SetFractionBase\:XMForm}
{\xe \v XMForm\:SetFractionBase}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMForm::SetFractionBase (int {\i n}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a5}
{\bkmkend classXMForm_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 473 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v SetHorizontalSpacing\:XMForm}
{\xe \v XMForm\:SetHorizontalSpacing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMForm::SetHorizontalSpacing (Dimension {\i n}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a6}
{\bkmkend classXMForm_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 476 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v SetLeftAttachment\:XMForm}
{\xe \v XMForm\:SetLeftAttachment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMForm::SetLeftAttachment (Widget {\i wid}, unsigned char {\i method}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a16}
{\bkmkend classXMForm_a16}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 512 of file XMManagers.h.\par
\par
References XMManager::SetConstraint().}
{\xe \v SetLeftAttachment\:XMForm}
{\xe \v XMForm\:SetLeftAttachment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMForm::SetLeftAttachment ({\b XMWidget} & {\i wid}, unsigned char {\i method}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a15}
{\bkmkend classXMForm_a15}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 509 of file XMManagers.h.\par
\par
References XMManager::SetConstraint().}
{\xe \v SetLeftOffset\:XMForm}
{\xe \v XMForm\:SetLeftOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMForm::SetLeftOffset ({\b XMWidget} & {\i wid}, int {\i offset}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a17}
{\bkmkend classXMForm_a17}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 515 of file XMManagers.h.\par
\par
References XMManager::SetConstraint().}
{\xe \v SetLeftPosition\:XMForm}
{\xe \v XMForm\:SetLeftPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMForm::SetLeftPosition ({\b XMWidget} & {\i wid}, int {\i position}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a18}
{\bkmkend classXMForm_a18}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 518 of file XMManagers.h.\par
\par
References XMManager::SetConstraint().}
{\xe \v SetLeftWidget\:XMForm}
{\xe \v XMForm\:SetLeftWidget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMForm::SetLeftWidget ({\b XMWidget} & {\i wid}, Widget {\i bound}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a20}
{\bkmkend classXMForm_a20}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 524 of file XMManagers.h.\par
\par
References XMManager::SetConstraint().}
{\xe \v SetLeftWidget\:XMForm}
{\xe \v XMForm\:SetLeftWidget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMForm::SetLeftWidget ({\b XMWidget} & {\i wid}, {\b XMWidget} & {\i bound}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a19}
{\bkmkend classXMForm_a19}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 521 of file XMManagers.h.\par
\par
References XMWidget::getid(), and XMManager::SetConstraint().}
{\xe \v SetRightAttachment\:XMForm}
{\xe \v XMForm\:SetRightAttachment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMForm::SetRightAttachment (Widget {\i wid}, unsigned char {\i method}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a22}
{\bkmkend classXMForm_a22}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 532 of file XMManagers.h.\par
\par
References XMManager::SetConstraint().}
{\xe \v SetRightAttachment\:XMForm}
{\xe \v XMForm\:SetRightAttachment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMForm::SetRightAttachment ({\b XMWidget} & {\i wid}, unsigned char {\i method}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a21}
{\bkmkend classXMForm_a21}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 529 of file XMManagers.h.\par
\par
References XMManager::SetConstraint().}
{\xe \v SetRightOffset\:XMForm}
{\xe \v XMForm\:SetRightOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMForm::SetRightOffset ({\b XMWidget} & {\i wid}, int {\i offset}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a23}
{\bkmkend classXMForm_a23}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 535 of file XMManagers.h.\par
\par
References XMManager::SetConstraint().}
{\xe \v SetRightPosition\:XMForm}
{\xe \v XMForm\:SetRightPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMForm::SetRightPosition ({\b XMWidget} & {\i wid}, int {\i position}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a24}
{\bkmkend classXMForm_a24}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 538 of file XMManagers.h.\par
\par
References XMManager::SetConstraint().}
{\xe \v SetRightWidget\:XMForm}
{\xe \v XMForm\:SetRightWidget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMForm::SetRightWidget ({\b XMWidget} & {\i wid}, Widget {\i bound}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a26}
{\bkmkend classXMForm_a26}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 544 of file XMManagers.h.\par
\par
References XMManager::SetConstraint().}
{\xe \v SetRightWidget\:XMForm}
{\xe \v XMForm\:SetRightWidget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMForm::SetRightWidget ({\b XMWidget} & {\i wid}, {\b XMWidget} & {\i bound}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a25}
{\bkmkend classXMForm_a25}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 541 of file XMManagers.h.\par
\par
References XMWidget::getid(), and XMManager::SetConstraint().}
{\xe \v SetRubberPositioning\:XMForm}
{\xe \v XMForm\:SetRubberPositioning}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMForm::SetRubberPositioning (Boolean {\i on}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a7}
{\bkmkend classXMForm_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 479 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v SetTopAttachment\:XMForm}
{\xe \v XMForm\:SetTopAttachment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMForm::SetTopAttachment (Widget {\i wid}, unsigned char {\i method}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a28}
{\bkmkend classXMForm_a28}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 551 of file XMManagers.h.\par
\par
References XMManager::SetConstraint().}
{\xe \v SetTopAttachment\:XMForm}
{\xe \v XMForm\:SetTopAttachment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMForm::SetTopAttachment ({\b XMWidget} & {\i wid}, unsigned char {\i method}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a27}
{\bkmkend classXMForm_a27}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 548 of file XMManagers.h.\par
\par
References XMManager::SetConstraint().}
{\xe \v SetTopOffset\:XMForm}
{\xe \v XMForm\:SetTopOffset}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMForm::SetTopOffset ({\b XMWidget} & {\i wid}, int {\i offset}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a29}
{\bkmkend classXMForm_a29}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 554 of file XMManagers.h.\par
\par
References XMManager::SetConstraint().}
{\xe \v SetTopPosition\:XMForm}
{\xe \v XMForm\:SetTopPosition}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMForm::SetTopPosition ({\b XMWidget} & {\i wid}, int {\i position}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a30}
{\bkmkend classXMForm_a30}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 557 of file XMManagers.h.\par
\par
References XMManager::SetConstraint().}
{\xe \v SetTopWidget\:XMForm}
{\xe \v XMForm\:SetTopWidget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMForm::SetTopWidget (Widget {\i wid}, {\b XMWidget} & {\i bound}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a34}
{\bkmkend classXMForm_a34}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 569 of file XMManagers.h.\par
\par
References XMWidget::getid(), and XMManager::SetConstraint().}
{\xe \v SetTopWidget\:XMForm}
{\xe \v XMForm\:SetTopWidget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMForm::SetTopWidget (Widget {\i wid}, Widget {\i bound}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a33}
{\bkmkend classXMForm_a33}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 566 of file XMManagers.h.\par
\par
References XMManager::SetConstraint().}
{\xe \v SetTopWidget\:XMForm}
{\xe \v XMForm\:SetTopWidget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMForm::SetTopWidget ({\b XMWidget} & {\i wid}, Widget {\i bound}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a32}
{\bkmkend classXMForm_a32}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 563 of file XMManagers.h.\par
\par
References XMManager::SetConstraint().}
{\xe \v SetTopWidget\:XMForm}
{\xe \v XMForm\:SetTopWidget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMForm::SetTopWidget ({\b XMWidget} & {\i wid}, {\b XMWidget} & {\i bound}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a31}
{\bkmkend classXMForm_a31}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 560 of file XMManagers.h.\par
\par
References XMWidget::getid(), and XMManager::SetConstraint().}
{\xe \v SetVerticalSpacing\:XMForm}
{\xe \v XMForm\:SetVerticalSpacing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMForm::SetVerticalSpacing (Dimension {\i n}){\f2  [inline]}}
}\par
{\bkmkstart classXMForm_a8}
{\bkmkend classXMForm_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 482 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMManagers.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMFrame  Class Reference\par \pard\plain 
{\tc\tcl2 \v XMFrame}
{\xe \v XMFrame}
{\bkmkstart classXMFrame}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMManagers.h>}\par
Inheritance diagram for XMFrame:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classXMFrame.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMFrame} (char *{\b name})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMFrame} (Widget {\b id})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMFrame} (char *n, {\b XMApplication} &parent, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMFrame} (char *n, {\b XMWidget} &parent, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMFrame} (char *n, Widget parent, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Margins} (Dimension height, Dimension width=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetShadowType} (unsigned char type)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v XMFrame\:XMFrame}
{\xe \v XMFrame\:XMFrame}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMFrame::XMFrame (char * {\i name}){\f2  [inline]}}
}\par
{\bkmkstart classXMFrame_a0}
{\bkmkend classXMFrame_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 425 of file XMManagers.h.\par
\par
References XMWidget::name.}
{\xe \v XMFrame\:XMFrame}
{\xe \v XMFrame\:XMFrame}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMFrame::XMFrame (Widget {\i id}){\f2  [inline]}}
}\par
{\bkmkstart classXMFrame_a1}
{\bkmkend classXMFrame_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 426 of file XMManagers.h.\par
\par
References XMWidget::id.}
{\xe \v XMFrame\:XMFrame}
{\xe \v XMFrame\:XMFrame}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMFrame::XMFrame (char * {\i n}, {\b XMApplication} & {\i parent}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMFrame_a2}
{\bkmkend classXMFrame_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 427 of file XMManagers.h.\par
}
{\xe \v XMFrame\:XMFrame}
{\xe \v XMFrame\:XMFrame}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMFrame::XMFrame (char * {\i n}, {\b XMWidget} & {\i parent}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMFrame_a3}
{\bkmkend classXMFrame_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 430 of file XMManagers.h.\par
}
{\xe \v XMFrame\:XMFrame}
{\xe \v XMFrame\:XMFrame}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMFrame::XMFrame (char * {\i n}, Widget {\i parent}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMFrame_a4}
{\bkmkend classXMFrame_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 433 of file XMManagers.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v Margins\:XMFrame}
{\xe \v XMFrame\:Margins}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMFrame::Margins (Dimension {\i height}, Dimension {\i width} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMFrame_a5}
{\bkmkend classXMFrame_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 438 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v SetShadowType\:XMFrame}
{\xe \v XMFrame\:SetShadowType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMFrame::SetShadowType (unsigned char {\i type}){\f2  [inline]}}
}\par
{\bkmkstart classXMFrame_a6}
{\bkmkend classXMFrame_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 442 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMManagers.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMHorizontalSeparator  Class Reference\par \pard\plain 
{\tc\tcl2 \v XMHorizontalSeparator}
{\xe \v XMHorizontalSeparator}
{\bkmkstart classXMHorizontalSeparator}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMSeparators.h>}\par
Inheritance diagram for XMHorizontalSeparator:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classXMHorizontalSeparator.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMHorizontalSeparator} (char *n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMHorizontalSeparator} (char *n, Widget parent, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMHorizontalSeparator} (char *n, {\b XMWidget} &parent, ArgList l=NULL, Cardinal num_args=0)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v XMHorizontalSeparator\:XMHorizontalSeparator}
{\xe \v XMHorizontalSeparator\:XMHorizontalSeparator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMHorizontalSeparator::XMHorizontalSeparator (char * {\i n}){\f2  [inline]}}
}\par
{\bkmkstart classXMHorizontalSeparator_a0}
{\bkmkend classXMHorizontalSeparator_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 333 of file XMSeparators.h.\par
\par
References XMWidget::Manage().}
{\xe \v XMHorizontalSeparator\:XMHorizontalSeparator}
{\xe \v XMHorizontalSeparator\:XMHorizontalSeparator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMHorizontalSeparator::XMHorizontalSeparator (char * {\i n}, Widget {\i parent}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMHorizontalSeparator_a1}
{\bkmkend classXMHorizontalSeparator_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 334 of file XMSeparators.h.\par
\par
References XMWidget::Manage(), and XMSeparator::SetOrientation().}
{\xe \v XMHorizontalSeparator\:XMHorizontalSeparator}
{\xe \v XMHorizontalSeparator\:XMHorizontalSeparator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMHorizontalSeparator::XMHorizontalSeparator (char * {\i n}, {\b XMWidget} & {\i parent}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMHorizontalSeparator_a2}
{\bkmkend classXMHorizontalSeparator_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 339 of file XMSeparators.h.\par
\par
References XMWidget::Manage(), and XMSeparator::SetOrientation().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMSeparators.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMLabel  Class Reference\par \pard\plain 
{\tc\tcl2 \v XMLabel}
{\xe \v XMLabel}
{\bkmkstart classXMLabel}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMLabel.h>}\par
Inheritance diagram for XMLabel:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classXMLabel.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMLabel} (char *n, {\b XMWidget} &parent, char *text, ArgList args=NULL, Cardinal arg_count=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMLabel} (char *n, Widget parent, char *text, ArgList args=NULL, Cardinal arg_count=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMLabel} (char *n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMLabel} (Widget w)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetLabel} (char *text)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetLabel} (XmString lbl)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v XMLabel\:XMLabel}
{\xe \v XMLabel\:XMLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMLabel::XMLabel (char * {\i n}, {\b XMWidget} & {\i parent}, char * {\i text}, ArgList {\i args} = NULL, Cardinal {\i arg_count} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMLabel_a0}
{\bkmkend classXMLabel_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 303 of file XMLabel.h.\par
\par
References SetLabel().}
{\xe \v XMLabel\:XMLabel}
{\xe \v XMLabel\:XMLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMLabel::XMLabel (char * {\i n}, Widget {\i parent}, char * {\i text}, ArgList {\i args} = NULL, Cardinal {\i arg_count} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMLabel_a1}
{\bkmkend classXMLabel_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 309 of file XMLabel.h.\par
\par
References SetLabel().}
{\xe \v XMLabel\:XMLabel}
{\xe \v XMLabel\:XMLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMLabel::XMLabel (char * {\i n}){\f2  [inline]}}
}\par
{\bkmkstart classXMLabel_a2}
{\bkmkend classXMLabel_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 315 of file XMLabel.h.\par
}
{\xe \v XMLabel\:XMLabel}
{\xe \v XMLabel\:XMLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMLabel::XMLabel (Widget {\i w}){\f2  [inline]}}
}\par
{\bkmkstart classXMLabel_a3}
{\bkmkend classXMLabel_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 317 of file XMLabel.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v SetLabel\:XMLabel}
{\xe \v XMLabel\:SetLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMLabel::SetLabel (XmString {\i lbl}){\f2  [inline]}}
}\par
{\bkmkstart classXMLabel_a5}
{\bkmkend classXMLabel_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 324 of file XMLabel.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v SetLabel\:XMLabel}
{\xe \v XMLabel\:SetLabel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMLabel::SetLabel (char * {\i text}){\f2  [inline]}}
}\par
{\bkmkstart classXMLabel_a4}
{\bkmkend classXMLabel_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 319 of file XMLabel.h.\par
\par
References XMWidget::SetAttribute().\par
Referenced by XMLabel().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMLabel.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMList  Class Reference\par \pard\plain 
{\tc\tcl2 \v XMList}
{\xe \v XMList}
{\bkmkstart classXMList}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMList.h>}\par
Inheritance diagram for XMList:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classXMList.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMList} (char *n, {\b XMWidget} &parent, int rows=10, ArgList args=NULL, Cardinal arg_count=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMList} (char *n, Widget parent, int rows=10, ArgList args=NULL, Cardinal arg_count=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMList} (char *n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMList} (Widget w)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v XMList\:XMList}
{\xe \v XMList\:XMList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMList::XMList (char * {\i n}, {\b XMWidget} & {\i parent}, int {\i rows} = 10, ArgList {\i args} = NULL, Cardinal {\i arg_count} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMList_a0}
{\bkmkend classXMList_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 447 of file XMList.h.\par
\par
References XMWidget::Manage(), and XMListBaseClass::SetRows().}
{\xe \v XMList\:XMList}
{\xe \v XMList\:XMList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMList::XMList (char * {\i n}, Widget {\i parent}, int {\i rows} = 10, ArgList {\i args} = NULL, Cardinal {\i arg_count} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMList_a1}
{\bkmkend classXMList_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 453 of file XMList.h.\par
\par
References XMWidget::Manage(), and XMListBaseClass::SetRows().}
{\xe \v XMList\:XMList}
{\xe \v XMList\:XMList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMList::XMList (char * {\i n}){\f2  [inline]}}
}\par
{\bkmkstart classXMList_a2}
{\bkmkend classXMList_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 459 of file XMList.h.\par
\par
References XMWidget::Manage().}
{\xe \v XMList\:XMList}
{\xe \v XMList\:XMList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMList::XMList (Widget {\i w}){\f2  [inline]}}
}\par
{\bkmkstart classXMList_a3}
{\bkmkend classXMList_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 460 of file XMList.h.\par
\par
References XMWidget::Manage().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMList.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMListBaseClass  Class Reference\par \pard\plain 
{\tc\tcl2 \v XMListBaseClass}
{\xe \v XMListBaseClass}
{\bkmkstart classXMListBaseClass}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMList.h>}\par
Inheritance diagram for XMListBaseClass:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classXMListBaseClass.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMListBaseClass} (char *n, WidgetClass cl, {\b XMWidget} &parent, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMListBaseClass} (char *n, WidgetClass cl, Widget parent, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMListBaseClass} (char *n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMListBaseClass} (Widget w)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AutoSelect} (Boolean enable=True)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetDoubleClickTime} (int ms=100)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetRows} (int rows)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetScrollPolicy} (int policy=XmAS_NEEDED)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetSelectionPolicy} (int policy=XmSINGLE_SELECT)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetListCount} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
XmStringTable {\b GetListValues} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b GetSelectedListCount} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
XmStringTable {\b GetSelectedItems} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Callback_data} * {\b AddbrowseSelectionCallback} (void(*callback)({\b XMWidget} *, XtPointer, XtPointer), XtPointer user_data=NULL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Callback_data} * {\b AddDefaultActionCallback} (void(*callback)({\b XMWidget} *, XtPointer, XtPointer), XtPointer user_data=NULL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Callback_data} * {\b AddExtendedSelectionCallback} (void(*callback)({\b XMWidget} *, XtPointer, XtPointer), XtPointer user_data=NULL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Callback_data} * {\b AddMultipleSelectionCallback} (void(*callback)({\b XMWidget} *, XtPointer, XtPointer), XtPointer user_data=NULL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Callback_data} * {\b AddSingleSelectionCallback} (void(*callback)({\b XMWidget} *, XtPointer, XtPointer), XtPointer user_data=NULL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddItem} (char *item, int position=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ClearItems} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DeleteItem} (char *item)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DeleteItem} (int loc=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DeleteItems} (int loc, int count=1)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DeselectAll} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DeselectItem} (char *item)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DeselectItem} (int pos=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetBottomItem} (int position=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SelectItem} (int pos=0)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v XMListBaseClass\:XMListBaseClass}
{\xe \v XMListBaseClass\:XMListBaseClass}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMListBaseClass::XMListBaseClass (char * {\i n}, WidgetClass {\i cl}, {\b XMWidget} & {\i parent}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMListBaseClass_a0}
{\bkmkend classXMListBaseClass_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 311 of file XMList.h.\par
}
{\xe \v XMListBaseClass\:XMListBaseClass}
{\xe \v XMListBaseClass\:XMListBaseClass}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMListBaseClass::XMListBaseClass (char * {\i n}, WidgetClass {\i cl}, Widget {\i parent}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMListBaseClass_a1}
{\bkmkend classXMListBaseClass_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 314 of file XMList.h.\par
}
{\xe \v XMListBaseClass\:XMListBaseClass}
{\xe \v XMListBaseClass\:XMListBaseClass}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMListBaseClass::XMListBaseClass (char * {\i n}){\f2  [inline]}}
}\par
{\bkmkstart classXMListBaseClass_a2}
{\bkmkend classXMListBaseClass_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 318 of file XMList.h.\par
}
{\xe \v XMListBaseClass\:XMListBaseClass}
{\xe \v XMListBaseClass\:XMListBaseClass}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMListBaseClass::XMListBaseClass (Widget {\i w}){\f2  [inline]}}
}\par
{\bkmkstart classXMListBaseClass_a3}
{\bkmkend classXMListBaseClass_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 319 of file XMList.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddbrowseSelectionCallback\:XMListBaseClass}
{\xe \v XMListBaseClass\:AddbrowseSelectionCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Callback_data}* XMListBaseClass::AddbrowseSelectionCallback (void(* {\i callback})({\b XMWidget} *, XtPointer, XtPointer), XtPointer {\i user_data} = NULL){\f2  [inline]}}
}\par
{\bkmkstart classXMListBaseClass_a13}
{\bkmkend classXMListBaseClass_a13}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 364 of file XMList.h.\par
\par
References XMWidget::AddCallback().}
{\xe \v AddDefaultActionCallback\:XMListBaseClass}
{\xe \v XMListBaseClass\:AddDefaultActionCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Callback_data}* XMListBaseClass::AddDefaultActionCallback (void(* {\i callback})({\b XMWidget} *, XtPointer, XtPointer), XtPointer {\i user_data} = NULL){\f2  [inline]}}
}\par
{\bkmkstart classXMListBaseClass_a14}
{\bkmkend classXMListBaseClass_a14}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 370 of file XMList.h.\par
\par
References XMWidget::AddCallback().}
{\xe \v AddExtendedSelectionCallback\:XMListBaseClass}
{\xe \v XMListBaseClass\:AddExtendedSelectionCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Callback_data}* XMListBaseClass::AddExtendedSelectionCallback (void(* {\i callback})({\b XMWidget} *, XtPointer, XtPointer), XtPointer {\i user_data} = NULL){\f2  [inline]}}
}\par
{\bkmkstart classXMListBaseClass_a15}
{\bkmkend classXMListBaseClass_a15}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 377 of file XMList.h.\par
\par
References XMWidget::AddCallback().}
{\xe \v AddItem\:XMListBaseClass}
{\xe \v XMListBaseClass\:AddItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMListBaseClass::AddItem (char * {\i item}, int {\i position} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMListBaseClass_a18}
{\bkmkend classXMListBaseClass_a18}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 401 of file XMList.h.\par
\par
References XMWidget::id.}
{\xe \v AddMultipleSelectionCallback\:XMListBaseClass}
{\xe \v XMListBaseClass\:AddMultipleSelectionCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Callback_data}* XMListBaseClass::AddMultipleSelectionCallback (void(* {\i callback})({\b XMWidget} *, XtPointer, XtPointer), XtPointer {\i user_data} = NULL){\f2  [inline]}}
}\par
{\bkmkstart classXMListBaseClass_a16}
{\bkmkend classXMListBaseClass_a16}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 384 of file XMList.h.\par
\par
References XMWidget::AddCallback().}
{\xe \v AddSingleSelectionCallback\:XMListBaseClass}
{\xe \v XMListBaseClass\:AddSingleSelectionCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Callback_data}* XMListBaseClass::AddSingleSelectionCallback (void(* {\i callback})({\b XMWidget} *, XtPointer, XtPointer), XtPointer {\i user_data} = NULL){\f2  [inline]}}
}\par
{\bkmkstart classXMListBaseClass_a17}
{\bkmkend classXMListBaseClass_a17}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 391 of file XMList.h.\par
\par
References XMWidget::AddCallback().}
{\xe \v AutoSelect\:XMListBaseClass}
{\xe \v XMListBaseClass\:AutoSelect}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMListBaseClass::AutoSelect (Boolean {\i enable} = True){\f2  [inline]}}
}\par
{\bkmkstart classXMListBaseClass_a4}
{\bkmkend classXMListBaseClass_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 323 of file XMList.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v ClearItems\:XMListBaseClass}
{\xe \v XMListBaseClass\:ClearItems}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMListBaseClass::ClearItems (){\f2  [inline]}}
}\par
{\bkmkstart classXMListBaseClass_a19}
{\bkmkend classXMListBaseClass_a19}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 406 of file XMList.h.\par
\par
References XMWidget::id.}
{\xe \v DeleteItem\:XMListBaseClass}
{\xe \v XMListBaseClass\:DeleteItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMListBaseClass::DeleteItem (int {\i loc} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMListBaseClass_a21}
{\bkmkend classXMListBaseClass_a21}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 412 of file XMList.h.\par
\par
References XMWidget::id.}
{\xe \v DeleteItem\:XMListBaseClass}
{\xe \v XMListBaseClass\:DeleteItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMListBaseClass::DeleteItem (char * {\i item}){\f2  [inline]}}
}\par
{\bkmkstart classXMListBaseClass_a20}
{\bkmkend classXMListBaseClass_a20}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 407 of file XMList.h.\par
\par
References XMWidget::id.}
{\xe \v DeleteItems\:XMListBaseClass}
{\xe \v XMListBaseClass\:DeleteItems}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMListBaseClass::DeleteItems (int {\i loc}, int {\i count} = 1){\f2  [inline]}}
}\par
{\bkmkstart classXMListBaseClass_a22}
{\bkmkend classXMListBaseClass_a22}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 415 of file XMList.h.\par
\par
References XMWidget::id.}
{\xe \v DeselectAll\:XMListBaseClass}
{\xe \v XMListBaseClass\:DeselectAll}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMListBaseClass::DeselectAll (){\f2  [inline]}}
}\par
{\bkmkstart classXMListBaseClass_a23}
{\bkmkend classXMListBaseClass_a23}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 418 of file XMList.h.\par
\par
References XMWidget::id.}
{\xe \v DeselectItem\:XMListBaseClass}
{\xe \v XMListBaseClass\:DeselectItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMListBaseClass::DeselectItem (int {\i pos} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMListBaseClass_a25}
{\bkmkend classXMListBaseClass_a25}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 427 of file XMList.h.\par
\par
References XMWidget::id.}
{\xe \v DeselectItem\:XMListBaseClass}
{\xe \v XMListBaseClass\:DeselectItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMListBaseClass::DeselectItem (char * {\i item}){\f2  [inline]}}
}\par
{\bkmkstart classXMListBaseClass_a24}
{\bkmkend classXMListBaseClass_a24}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 421 of file XMList.h.\par
\par
References XMWidget::id.}
{\xe \v GetListCount\:XMListBaseClass}
{\xe \v XMListBaseClass\:GetListCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int XMListBaseClass::GetListCount (){\f2  [inline]}}
}\par
{\bkmkstart classXMListBaseClass_a9}
{\bkmkend classXMListBaseClass_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 340 of file XMList.h.\par
\par
References XMWidget::GetAttribute().}
{\xe \v GetListValues\:XMListBaseClass}
{\xe \v XMListBaseClass\:GetListValues}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XmStringTable XMListBaseClass::GetListValues (){\f2  [inline]}}
}\par
{\bkmkstart classXMListBaseClass_a10}
{\bkmkend classXMListBaseClass_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 345 of file XMList.h.\par
\par
References XMWidget::GetAttribute().}
{\xe \v GetSelectedItems\:XMListBaseClass}
{\xe \v XMListBaseClass\:GetSelectedItems}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XmStringTable XMListBaseClass::GetSelectedItems (){\f2  [inline]}}
}\par
{\bkmkstart classXMListBaseClass_a12}
{\bkmkend classXMListBaseClass_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 357 of file XMList.h.\par
\par
References XMWidget::GetAttribute().}
{\xe \v GetSelectedListCount\:XMListBaseClass}
{\xe \v XMListBaseClass\:GetSelectedListCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int XMListBaseClass::GetSelectedListCount (){\f2  [inline]}}
}\par
{\bkmkstart classXMListBaseClass_a11}
{\bkmkend classXMListBaseClass_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 351 of file XMList.h.\par
\par
References XMWidget::GetAttribute().}
{\xe \v SelectItem\:XMListBaseClass}
{\xe \v XMListBaseClass\:SelectItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMListBaseClass::SelectItem (int {\i pos} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMListBaseClass_a27}
{\bkmkend classXMListBaseClass_a27}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 434 of file XMList.h.\par
\par
References XMWidget::id.}
{\xe \v SetBottomItem\:XMListBaseClass}
{\xe \v XMListBaseClass\:SetBottomItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMListBaseClass::SetBottomItem (int {\i position} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMListBaseClass_a26}
{\bkmkend classXMListBaseClass_a26}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 430 of file XMList.h.\par
\par
References XMWidget::id.}
{\xe \v SetDoubleClickTime\:XMListBaseClass}
{\xe \v XMListBaseClass\:SetDoubleClickTime}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMListBaseClass::SetDoubleClickTime (int {\i ms} = 100){\f2  [inline]}}
}\par
{\bkmkstart classXMListBaseClass_a5}
{\bkmkend classXMListBaseClass_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 326 of file XMList.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v SetRows\:XMListBaseClass}
{\xe \v XMListBaseClass\:SetRows}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMListBaseClass::SetRows (int {\i rows}){\f2  [inline]}}
}\par
{\bkmkstart classXMListBaseClass_a6}
{\bkmkend classXMListBaseClass_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 330 of file XMList.h.\par
\par
References XMWidget::SetAttribute().\par
Referenced by XMList::XMList(), and XMScrolledList::XMScrolledList().}
{\xe \v SetScrollPolicy\:XMListBaseClass}
{\xe \v XMListBaseClass\:SetScrollPolicy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMListBaseClass::SetScrollPolicy (int {\i policy} = XmAS_NEEDED){\f2  [inline]}}
}\par
{\bkmkstart classXMListBaseClass_a7}
{\bkmkend classXMListBaseClass_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 333 of file XMList.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v SetSelectionPolicy\:XMListBaseClass}
{\xe \v XMListBaseClass\:SetSelectionPolicy}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMListBaseClass::SetSelectionPolicy (int {\i policy} = XmSINGLE_SELECT){\f2  [inline]}}
}\par
{\bkmkstart classXMListBaseClass_a8}
{\bkmkend classXMListBaseClass_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 336 of file XMList.h.\par
\par
References XMWidget::SetAttribute().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMList.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMMainWindow  Class Reference\par \pard\plain 
{\tc\tcl2 \v XMMainWindow}
{\xe \v XMMainWindow}
{\bkmkstart classXMMainWindow}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMManagers.h>}\par
Inheritance diagram for XMMainWindow:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classXMMainWindow.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMMainWindow} (char *{\b name})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMMainWindow} (Widget {\b id})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMMainWindow} (char *{\b name}, {\b XMApplication} &parent, ArgList l=NULL, Cardinal arg_count=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMMainWindow} (char *{\b name}, {\b XMWidget} &parent, ArgList l=NULL, Cardinal arg_count=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMMainWindow} (char *{\b name}, Widget &parent, ArgList l=NULL, Cardinal arg_count=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetAreas} ({\b XMWidget} *menubar=NULL, {\b XMWidget} *commandwindow=NULL, {\b XMWidget} *horizontalscroller=NULL, {\b XMWidget} *verticalscroller=NULL, {\b XMWidget} *workregion=NULL, {\b XMWidget} *messagewidget=NULL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ShowSeparator} (Boolean show)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b CommandWindowLocation} (unsigned char where)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v XMMainWindow\:XMMainWindow}
{\xe \v XMMainWindow\:XMMainWindow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMMainWindow::XMMainWindow (char * {\i name}){\f2  [inline]}}
}\par
{\bkmkstart classXMMainWindow_a0}
{\bkmkend classXMMainWindow_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 702 of file XMManagers.h.\par
\par
References XMWidget::name.}
{\xe \v XMMainWindow\:XMMainWindow}
{\xe \v XMMainWindow\:XMMainWindow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMMainWindow::XMMainWindow (Widget {\i id}){\f2  [inline]}}
}\par
{\bkmkstart classXMMainWindow_a1}
{\bkmkend classXMMainWindow_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 703 of file XMManagers.h.\par
\par
References XMWidget::id.}
{\xe \v XMMainWindow\:XMMainWindow}
{\xe \v XMMainWindow\:XMMainWindow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMMainWindow::XMMainWindow (char * {\i name}, {\b XMApplication} & {\i parent}, ArgList {\i l} = NULL, Cardinal {\i arg_count} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMMainWindow_a2}
{\bkmkend classXMMainWindow_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 704 of file XMManagers.h.\par
\par
References XMWidget::name.}
{\xe \v XMMainWindow\:XMMainWindow}
{\xe \v XMMainWindow\:XMMainWindow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMMainWindow::XMMainWindow (char * {\i name}, {\b XMWidget} & {\i parent}, ArgList {\i l} = NULL, Cardinal {\i arg_count} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMMainWindow_a3}
{\bkmkend classXMMainWindow_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 708 of file XMManagers.h.\par
\par
References XMWidget::name.}
{\xe \v XMMainWindow\:XMMainWindow}
{\xe \v XMMainWindow\:XMMainWindow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMMainWindow::XMMainWindow (char * {\i name}, Widget & {\i parent}, ArgList {\i l} = NULL, Cardinal {\i arg_count} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMMainWindow_a4}
{\bkmkend classXMMainWindow_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 712 of file XMManagers.h.\par
\par
References XMWidget::name.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v CommandWindowLocation\:XMMainWindow}
{\xe \v XMMainWindow\:CommandWindowLocation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMMainWindow::CommandWindowLocation (unsigned char {\i where}){\f2  [inline]}}
}\par
{\bkmkstart classXMMainWindow_a7}
{\bkmkend classXMMainWindow_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 727 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v SetAreas\:XMMainWindow}
{\xe \v XMMainWindow\:SetAreas}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMMainWindow::SetAreas ({\b XMWidget} * {\i menubar} = NULL, {\b XMWidget} * {\i commandwindow} = NULL, {\b XMWidget} * {\i horizontalscroller} = NULL, {\b XMWidget} * {\i verticalscroller} = NULL, {\b XMWidget} * {\i workregion} = NULL, {\b XMWidget} * {\i messagewidget} = NULL)}
}\par
{\bkmkstart classXMMainWindow_a5}
{\bkmkend classXMMainWindow_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 322 of file XMManagers.cpp.\par
\par
References XMWidget::getid(), and XMWidget::SetAttribute().}
{\xe \v ShowSeparator\:XMMainWindow}
{\xe \v XMMainWindow\:ShowSeparator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMMainWindow::ShowSeparator (Boolean {\i show}){\f2  [inline]}}
}\par
{\bkmkstart classXMMainWindow_a6}
{\bkmkend classXMMainWindow_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 724 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMManagers.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMManagers.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMManagedWidget  Class Reference\par \pard\plain 
{\tc\tcl2 \v XMManagedWidget}
{\xe \v XMManagedWidget}
{\bkmkstart classXMManagedWidget}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMWidget.h>}\par
Inheritance diagram for XMManagedWidget:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classXMManagedWidget.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMManagedWidget} (char *n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMManagedWidget} (char *n, WidgetClass cl, Widget parent, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMManagedWidget} (char *n, WidgetClass cl, {\b XMWidget} &parent, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMManagedWidget} (Widget w)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v XMManagedWidget\:XMManagedWidget}
{\xe \v XMManagedWidget\:XMManagedWidget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMManagedWidget::XMManagedWidget (char * {\i n}){\f2  [inline]}}
}\par
{\bkmkstart classXMManagedWidget_a0}
{\bkmkend classXMManagedWidget_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 442 of file XMWidget.h.\par
\par
Referenced by XMPulldown::AddSeparator().}
{\xe \v XMManagedWidget\:XMManagedWidget}
{\xe \v XMManagedWidget\:XMManagedWidget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMManagedWidget::XMManagedWidget (char * {\i n}, WidgetClass {\i cl}, Widget {\i parent}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMManagedWidget_a1}
{\bkmkend classXMManagedWidget_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 447 of file XMWidget.h.\par
\par
References XMWidget::Manage().}
{\xe \v XMManagedWidget\:XMManagedWidget}
{\xe \v XMManagedWidget\:XMManagedWidget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMManagedWidget::XMManagedWidget (char * {\i n}, WidgetClass {\i cl}, {\b XMWidget} & {\i parent}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMManagedWidget_a2}
{\bkmkend classXMManagedWidget_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 451 of file XMWidget.h.\par
\par
References XMWidget::Manage().}
{\xe \v XMManagedWidget\:XMManagedWidget}
{\xe \v XMManagedWidget\:XMManagedWidget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMManagedWidget::XMManagedWidget (Widget {\i w}){\f2  [inline]}}
}\par
{\bkmkstart classXMManagedWidget_a3}
{\bkmkend classXMManagedWidget_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 455 of file XMWidget.h.\par
}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMWidget.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMManager  Class Reference\par \pard\plain 
{\tc\tcl2 \v XMManager}
{\xe \v XMManager}
{\bkmkstart classXMManager}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMManagers.h>}\par
Inheritance diagram for XMManager:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classXMManager.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMManager} (char *n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMManager} (Widget w)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMManager} (char *n, WidgetClass cl, {\b XMApplication} &parent, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMManager} (char *n, WidgetClass cl, Widget parent, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMManager} (char *n, WidgetClass cl, {\b XMWidget} &parent, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Callback_data} * {\b AddHelpCallback} (void(*callback)({\b XMWidget} *, XtPointer, XtPointer), XtPointer client_data)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetNavigationType} (XmNavigationType navtype=XmNONE)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b TraversalOn} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b TraverseOff} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetConstraint} ({\b XMWidget} &w, String constraint, XtArgVal value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetConstraint} ({\b XMWidget} &w, String constraint, void *value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetConstraint} (Widget w, String constraint, XtArgVal value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetConstraint} (Widget w, String constraint, void *value)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v XMManager\:XMManager}
{\xe \v XMManager\:XMManager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMManager::XMManager (char * {\i n}){\f2  [inline]}}
}\par
{\bkmkstart classXMManager_a0}
{\bkmkend classXMManager_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 318 of file XMManagers.h.\par
}
{\xe \v XMManager\:XMManager}
{\xe \v XMManager\:XMManager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMManager::XMManager (Widget {\i w}){\f2  [inline]}}
}\par
{\bkmkstart classXMManager_a1}
{\bkmkend classXMManager_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 319 of file XMManagers.h.\par
}
{\xe \v XMManager\:XMManager}
{\xe \v XMManager\:XMManager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMManager::XMManager (char * {\i n}, WidgetClass {\i cl}, {\b XMApplication} & {\i parent}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMManager_a2}
{\bkmkend classXMManager_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 320 of file XMManagers.h.\par
}
{\xe \v XMManager\:XMManager}
{\xe \v XMManager\:XMManager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMManager::XMManager (char * {\i n}, WidgetClass {\i cl}, Widget {\i parent}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMManager_a3}
{\bkmkend classXMManager_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 325 of file XMManagers.h.\par
}
{\xe \v XMManager\:XMManager}
{\xe \v XMManager\:XMManager}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMManager::XMManager (char * {\i n}, WidgetClass {\i cl}, {\b XMWidget} & {\i parent}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMManager_a4}
{\bkmkend classXMManager_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 329 of file XMManagers.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddHelpCallback\:XMManager}
{\xe \v XMManager\:AddHelpCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Callback_data}* XMManager::AddHelpCallback (void(* {\i callback})({\b XMWidget} *, XtPointer, XtPointer), XtPointer {\i client_data}){\f2  [inline]}}
}\par
{\bkmkstart classXMManager_a5}
{\bkmkend classXMManager_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 335 of file XMManagers.h.\par
\par
References XMWidget::AddCallback().}
{\xe \v SetConstraint\:XMManager}
{\xe \v XMManager\:SetConstraint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMManager::SetConstraint (Widget {\i w}, String {\i constraint}, void * {\i value}){\f2  [inline]}}
}\par
{\bkmkstart classXMManager_a12}
{\bkmkend classXMManager_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 365 of file XMManagers.h.\par
}
{\xe \v SetConstraint\:XMManager}
{\xe \v XMManager\:SetConstraint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMManager::SetConstraint (Widget {\i w}, String {\i constraint}, XtArgVal {\i value}){\f2  [inline]}}
}\par
{\bkmkstart classXMManager_a11}
{\bkmkend classXMManager_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 362 of file XMManagers.h.\par
}
{\xe \v SetConstraint\:XMManager}
{\xe \v XMManager\:SetConstraint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMManager::SetConstraint ({\b XMWidget} & {\i w}, String {\i constraint}, void * {\i value}){\f2  [inline]}}
}\par
{\bkmkstart classXMManager_a10}
{\bkmkend classXMManager_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 359 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v SetConstraint\:XMManager}
{\xe \v XMManager\:SetConstraint}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMManager::SetConstraint ({\b XMWidget} & {\i w}, String {\i constraint}, XtArgVal {\i value}){\f2  [inline]}}
}\par
{\bkmkstart classXMManager_a9}
{\bkmkend classXMManager_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 356 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().\par
Referenced by XMBulletinBoard::SetAbsPosition(), XMForm::SetBottomAttachment(), XMForm::SetBottomOffset(), XMForm::SetBottomPosition(), XMForm::SetBottomWidget(), XMForm::SetLeftAttachment(), XMForm::SetLeftOffset(), XMForm::SetLeftPosition(), XMForm::SetLeftWidget(), XMForm::SetRightAttachment(), XMForm::SetRightOffset(), XMForm::SetRightPosition(), XMForm::SetRightWidget(), XMForm::SetTopAttachment(), XMForm::SetTopOffset(), XMForm::SetTopPosition(), and XMForm::SetTopWidget().}
{\xe \v SetNavigationType\:XMManager}
{\xe \v XMManager\:SetNavigationType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMManager::SetNavigationType (XmNavigationType {\i navtype} = XmNONE){\f2  [inline]}}
}\par
{\bkmkstart classXMManager_a6}
{\bkmkend classXMManager_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 339 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v TraversalOn\:XMManager}
{\xe \v XMManager\:TraversalOn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMManager::TraversalOn (){\f2  [inline]}}
}\par
{\bkmkstart classXMManager_a7}
{\bkmkend classXMManager_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 343 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v TraverseOff\:XMManager}
{\xe \v XMManager\:TraverseOff}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMManager::TraverseOff (){\f2  [inline]}}
}\par
{\bkmkstart classXMManager_a8}
{\bkmkend classXMManager_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 346 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMManagers.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMMenuBar  Class Reference\par \pard\plain 
{\tc\tcl2 \v XMMenuBar}
{\xe \v XMMenuBar}
{\bkmkstart classXMMenuBar}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMMenus.h>}\par
Inheritance diagram for XMMenuBar:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classXMMenuBar.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMMenuBar} (char *n, Widget parent, Cardinal num_menus, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMMenuBar} (char *n, {\b XMWidget} &parent, Cardinal num_menus, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~XMMenuBar} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMPulldown} * {\b AddPulldown} (char *n, int max_items, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMPulldown} * {\b AddHelpPulldown} (char *n, int max_items, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b NumMenus} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMPulldown} * {\b GetPulldown} (char *n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMPulldown} * {\b GetPulldown} (Cardinal index)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMPulldown} * {\b GetHelpPulldown} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMMenuItem} * {\b GetMenuItem} (char *n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMPulldown} * {\b GetNextPulldown} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMPulldown} * {\b GetFirstPulldown} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b mbCreate} (Widget parent, Cardinal num_menus, ArgList l, Cardinal num_args)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMPulldown} * {\b help_pulldown}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMPulldown} ** {\b menu_items}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Cardinal {\b menu_cursor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Cardinal {\b menu_count}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Cardinal {\b max_menu_items}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v XMMenuBar\:XMMenuBar}
{\xe \v XMMenuBar\:XMMenuBar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMMenuBar::XMMenuBar (char * {\i n}, Widget {\i parent}, Cardinal {\i num_menus}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMMenuBar_a0}
{\bkmkend classXMMenuBar_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 423 of file XMMenus.h.\par
\par
References mbCreate().}
{\xe \v XMMenuBar\:XMMenuBar}
{\xe \v XMMenuBar\:XMMenuBar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMMenuBar::XMMenuBar (char * {\i n}, {\b XMWidget} & {\i parent}, Cardinal {\i num_menus}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMMenuBar_a1}
{\bkmkend classXMMenuBar_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 429 of file XMMenus.h.\par
\par
References XMWidget::getid(), and mbCreate().}
{\xe \v ~XMMenuBar\:XMMenuBar}
{\xe \v XMMenuBar\:~XMMenuBar}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMMenuBar::~XMMenuBar ()}
}\par
{\bkmkstart classXMMenuBar_a2}
{\bkmkend classXMMenuBar_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 751 of file XMMenus.cpp.\par
\par
References max_menu_items, and menu_items.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddHelpPulldown\:XMMenuBar}
{\xe \v XMMenuBar\:AddHelpPulldown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMPulldown} * XMMenuBar::AddHelpPulldown (char * {\i n}, int {\i max_items}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0)}
}\par
{\bkmkstart classXMMenuBar_a4}
{\bkmkend classXMMenuBar_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Method Description: {\b XMMenuBar::AddHelpPulldown} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classXMMenuBar_a4 \\*MERGEFORMAT}{\fldrslt pagenum}}}) - Adds a pulldown menu which will be registerd as the help menu for the bar. Formal Parameters: char *n: Name/label of the pulldown menu. int max_items: Maximum number of items in the pulldown. ArgList l: Possibly null argument list containing resource overrides. Cardinal num_args: Possibly zero count of arguments in l. Returns: Pointer to the pulldown object created. \par
\par
Definition at line 835 of file XMMenus.cpp.\par
\par
References AddPulldown(), exit(), XMPulldown::GetCascadeButton(), XMWidget::getid(), help_pulldown, and XMWidget::SetAttribute().}
{\xe \v AddPulldown\:XMMenuBar}
{\xe \v XMMenuBar\:AddPulldown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMPulldown} * XMMenuBar::AddPulldown (char * {\i n}, int {\i max_items}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0)}
}\par
{\bkmkstart classXMMenuBar_a3}
{\bkmkend classXMMenuBar_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 789 of file XMMenus.cpp.\par
\par
References exit(), max_menu_items, menu_count, and menu_items.\par
Referenced by AddHelpPulldown().}
{\xe \v GetFirstPulldown\:XMMenuBar}
{\xe \v XMMenuBar\:GetFirstPulldown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMPulldown}* XMMenuBar::GetFirstPulldown (){\f2  [inline]}}
}\par
{\bkmkstart classXMMenuBar_a11}
{\bkmkend classXMMenuBar_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 460 of file XMMenus.h.\par
\par
References GetNextPulldown(), and menu_cursor.}
{\xe \v GetHelpPulldown\:XMMenuBar}
{\xe \v XMMenuBar\:GetHelpPulldown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMPulldown}* XMMenuBar::GetHelpPulldown (){\f2  [inline]}}
}\par
{\bkmkstart classXMMenuBar_a8}
{\bkmkend classXMMenuBar_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 453 of file XMMenus.h.\par
}
{\xe \v GetMenuItem\:XMMenuBar}
{\xe \v XMMenuBar\:GetMenuItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMMenuItem} * XMMenuBar::GetMenuItem (char * {\i n})}
}\par
{\bkmkstart classXMMenuBar_a9}
{\bkmkend classXMMenuBar_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 885 of file XMMenus.cpp.\par
\par
References XMPulldown::FindMenuItem(), menu_count, and menu_items.}
{\xe \v GetNextPulldown\:XMMenuBar}
{\xe \v XMMenuBar\:GetNextPulldown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMPulldown} * XMMenuBar::GetNextPulldown ()}
}\par
{\bkmkstart classXMMenuBar_a10}
{\bkmkend classXMMenuBar_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 906 of file XMMenus.cpp.\par
\par
References menu_count, menu_cursor, and menu_items.\par
Referenced by GetFirstPulldown().}
{\xe \v GetPulldown\:XMMenuBar}
{\xe \v XMMenuBar\:GetPulldown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMPulldown}* XMMenuBar::GetPulldown (Cardinal {\i index}){\f2  [inline]}}
}\par
{\bkmkstart classXMMenuBar_a7}
{\bkmkend classXMMenuBar_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 450 of file XMMenus.h.\par
\par
References menu_count.}
{\xe \v GetPulldown\:XMMenuBar}
{\xe \v XMMenuBar\:GetPulldown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMPulldown} * XMMenuBar::GetPulldown (char * {\i n})}
}\par
{\bkmkstart classXMMenuBar_a6}
{\bkmkend classXMMenuBar_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 864 of file XMMenus.cpp.\par
\par
References XMWidget::getname(), menu_count, and menu_items.}
{\xe \v mbCreate\:XMMenuBar}
{\xe \v XMMenuBar\:mbCreate}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMMenuBar::mbCreate (Widget {\i parent}, Cardinal {\i num_menus}, ArgList {\i l}, Cardinal {\i num_args}){\f2  [protected]}}
}\par
{\bkmkstart classXMMenuBar_b0}
{\bkmkend classXMMenuBar_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 718 of file XMMenus.cpp.\par
\par
References exit(), help_pulldown, XMWidget::id, max_menu_items, menu_count, menu_items, and XMWidget::name.\par
Referenced by XMMenuBar().}
{\xe \v NumMenus\:XMMenuBar}
{\xe \v XMMenuBar\:NumMenus}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int XMMenuBar::NumMenus (){\f2  [inline]}}
}\par
{\bkmkstart classXMMenuBar_a5}
{\bkmkend classXMMenuBar_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 448 of file XMMenus.h.\par
\par
References menu_count.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v help_pulldown\:XMMenuBar}
{\xe \v XMMenuBar\:help_pulldown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMPulldown}* XMMenuBar::help_pulldown{\f2  [protected]}}
}\par
{\bkmkstart classXMMenuBar_n0}
{\bkmkend classXMMenuBar_n0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 412 of file XMMenus.h.\par
\par
Referenced by AddHelpPulldown(), and mbCreate().}
{\xe \v max_menu_items\:XMMenuBar}
{\xe \v XMMenuBar\:max_menu_items}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Cardinal XMMenuBar::max_menu_items{\f2  [protected]}}
}\par
{\bkmkstart classXMMenuBar_n4}
{\bkmkend classXMMenuBar_n4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 416 of file XMMenus.h.\par
\par
Referenced by AddPulldown(), mbCreate(), and ~XMMenuBar().}
{\xe \v menu_count\:XMMenuBar}
{\xe \v XMMenuBar\:menu_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Cardinal XMMenuBar::menu_count{\f2  [protected]}}
}\par
{\bkmkstart classXMMenuBar_n3}
{\bkmkend classXMMenuBar_n3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 415 of file XMMenus.h.\par
\par
Referenced by AddPulldown(), GetMenuItem(), GetNextPulldown(), GetPulldown(), mbCreate(), and NumMenus().}
{\xe \v menu_cursor\:XMMenuBar}
{\xe \v XMMenuBar\:menu_cursor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Cardinal XMMenuBar::menu_cursor{\f2  [protected]}}
}\par
{\bkmkstart classXMMenuBar_n2}
{\bkmkend classXMMenuBar_n2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 414 of file XMMenus.h.\par
\par
Referenced by GetFirstPulldown(), and GetNextPulldown().}
{\xe \v menu_items\:XMMenuBar}
{\xe \v XMMenuBar\:menu_items}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMPulldown}** XMMenuBar::menu_items{\f2  [protected]}}
}\par
{\bkmkstart classXMMenuBar_n1}
{\bkmkend classXMMenuBar_n1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 413 of file XMMenus.h.\par
\par
Referenced by AddPulldown(), GetMenuItem(), GetNextPulldown(), GetPulldown(), mbCreate(), and ~XMMenuBar().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMMenus.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMMenus.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMMenuItem  Struct Reference\par \pard\plain 
{\tc\tcl2 \v XMMenuItem}
{\xe \v XMMenuItem}
{\bkmkstart structXMMenuItem}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMMenus.h>}\par
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMWidget} * {\b item}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMMenuEntryType} {\b type}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v item\:XMMenuItem}
{\xe \v XMMenuItem\:item}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMWidget}* XMMenuItem::item}
}\par
{\bkmkstart structXMMenuItem_m0}
{\bkmkend structXMMenuItem_m0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 313 of file XMMenus.h.\par
\par
Referenced by XMPulldown::BuildMenu(), XMPulldown::FindMenuItem(), and XMPulldown::~XMPulldown().}
{\xe \v type\:XMMenuItem}
{\xe \v XMMenuItem\:type}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMMenuEntryType} XMMenuItem::type}
}\par
{\bkmkstart structXMMenuItem_m1}
{\bkmkend structXMMenuItem_m1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 314 of file XMMenus.h.\par
\par
Referenced by XMPulldown::BuildMenu(), XMPulldown::FindMenuItem(), and XMPulldown::~XMPulldown().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this struct was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMMenus.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMPanedWindow  Class Reference\par \pard\plain 
{\tc\tcl2 \v XMPanedWindow}
{\xe \v XMPanedWindow}
{\bkmkstart classXMPanedWindow}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMManagers.h>}\par
Inheritance diagram for XMPanedWindow:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classXMPanedWindow.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMPanedWindow} (char *{\b name})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMPanedWindow} (Widget {\b id})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMPanedWindow} (char *n, {\b XMWidget} &parent, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMPanedWindow} (char *n, Widget parent, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Margins} (Dimension vert, Dimension hor)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetSashHeight} (Dimension height)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetSashIndent} (Position indent)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetSeparator} (Boolean enabled)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetPaneSpacing} (Dimension spacing)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AllowResize} ({\b XMWidget} &wid, Boolean allow)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MaxPaneSize} ({\b XMWidget} &wid, Dimension max)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b MinPaneSize} ({\b XMWidget} &wid, Dimension min)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SkipAdjust} ({\b XMWidget} &wid, Boolean skip)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v XMPanedWindow\:XMPanedWindow}
{\xe \v XMPanedWindow\:XMPanedWindow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMPanedWindow::XMPanedWindow (char * {\i name}){\f2  [inline]}}
}\par
{\bkmkstart classXMPanedWindow_a0}
{\bkmkend classXMPanedWindow_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 649 of file XMManagers.h.\par
\par
References XMWidget::name.}
{\xe \v XMPanedWindow\:XMPanedWindow}
{\xe \v XMPanedWindow\:XMPanedWindow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMPanedWindow::XMPanedWindow (Widget {\i id}){\f2  [inline]}}
}\par
{\bkmkstart classXMPanedWindow_a1}
{\bkmkend classXMPanedWindow_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 650 of file XMManagers.h.\par
\par
References XMWidget::id.}
{\xe \v XMPanedWindow\:XMPanedWindow}
{\xe \v XMPanedWindow\:XMPanedWindow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMPanedWindow::XMPanedWindow (char * {\i n}, {\b XMWidget} & {\i parent}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMPanedWindow_a2}
{\bkmkend classXMPanedWindow_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 651 of file XMManagers.h.\par
}
{\xe \v XMPanedWindow\:XMPanedWindow}
{\xe \v XMPanedWindow\:XMPanedWindow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMPanedWindow::XMPanedWindow (char * {\i n}, Widget {\i parent}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMPanedWindow_a3}
{\bkmkend classXMPanedWindow_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 655 of file XMManagers.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AllowResize\:XMPanedWindow}
{\xe \v XMPanedWindow\:AllowResize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMPanedWindow::AllowResize ({\b XMWidget} & {\i wid}, Boolean {\i allow}){\f2  [inline]}}
}\par
{\bkmkstart classXMPanedWindow_a9}
{\bkmkend classXMPanedWindow_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 681 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v Margins\:XMPanedWindow}
{\xe \v XMPanedWindow\:Margins}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMPanedWindow::Margins (Dimension {\i vert}, Dimension {\i hor}){\f2  [inline]}}
}\par
{\bkmkstart classXMPanedWindow_a4}
{\bkmkend classXMPanedWindow_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 662 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v MaxPaneSize\:XMPanedWindow}
{\xe \v XMPanedWindow\:MaxPaneSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMPanedWindow::MaxPaneSize ({\b XMWidget} & {\i wid}, Dimension {\i max}){\f2  [inline]}}
}\par
{\bkmkstart classXMPanedWindow_a10}
{\bkmkend classXMPanedWindow_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 684 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v MinPaneSize\:XMPanedWindow}
{\xe \v XMPanedWindow\:MinPaneSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMPanedWindow::MinPaneSize ({\b XMWidget} & {\i wid}, Dimension {\i min}){\f2  [inline]}}
}\par
{\bkmkstart classXMPanedWindow_a11}
{\bkmkend classXMPanedWindow_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 687 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v SetPaneSpacing\:XMPanedWindow}
{\xe \v XMPanedWindow\:SetPaneSpacing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMPanedWindow::SetPaneSpacing (Dimension {\i spacing}){\f2  [inline]}}
}\par
{\bkmkstart classXMPanedWindow_a8}
{\bkmkend classXMPanedWindow_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 675 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v SetSashHeight\:XMPanedWindow}
{\xe \v XMPanedWindow\:SetSashHeight}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMPanedWindow::SetSashHeight (Dimension {\i height}){\f2  [inline]}}
}\par
{\bkmkstart classXMPanedWindow_a5}
{\bkmkend classXMPanedWindow_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 666 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v SetSashIndent\:XMPanedWindow}
{\xe \v XMPanedWindow\:SetSashIndent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMPanedWindow::SetSashIndent (Position {\i indent}){\f2  [inline]}}
}\par
{\bkmkstart classXMPanedWindow_a6}
{\bkmkend classXMPanedWindow_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 669 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v SetSeparator\:XMPanedWindow}
{\xe \v XMPanedWindow\:SetSeparator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMPanedWindow::SetSeparator (Boolean {\i enabled}){\f2  [inline]}}
}\par
{\bkmkstart classXMPanedWindow_a7}
{\bkmkend classXMPanedWindow_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 672 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v SkipAdjust\:XMPanedWindow}
{\xe \v XMPanedWindow\:SkipAdjust}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMPanedWindow::SkipAdjust ({\b XMWidget} & {\i wid}, Boolean {\i skip}){\f2  [inline]}}
}\par
{\bkmkstart classXMPanedWindow_a12}
{\bkmkend classXMPanedWindow_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 690 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMManagers.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMPulldown  Class Reference\par \pard\plain 
{\tc\tcl2 \v XMPulldown}
{\xe \v XMPulldown}
{\bkmkstart classXMPulldown}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMMenus.h>}\par
Inheritance diagram for XMPulldown:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classXMPulldown.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMPulldown} (char *n, Widget &parent, Cardinal max_items, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMPulldown} (char *n, {\b XMWidget} &parent, Cardinal max_items, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b ~XMPulldown} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Label} (char *label)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b RadioMenu} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b RadioForceOne} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b NoRadioMenu} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b RadioNoForceOne} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMPushButton} * {\b AddMenuButton} (char *n, void(*callback)({\b XMWidget} *, XtPointer, XtPointer)=NULL, XtPointer client_data=NULL, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMToggleButton} * {\b AddMenuToggleButton} (char *n, void(*callback)({\b XMWidget} *, XtPointer, XtPointer)=NULL, XtPointer client_data=NULL, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMWidget} * {\b AddSeparator} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
XMPulldown * {\b AddSubmenu} (char *n, int max_items, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b MenuSize} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b MaxMenuSize} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMMenuItem} * {\b GetMenuItem} (Cardinal index)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMMenuItem} * {\b FindMenuItem} (char *n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMWidget} * {\b GetCascadeButton} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMMenuItem} * {\b GetNextMenuItem} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMMenuItem} * {\b GetFirstMenuItem} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b BuildMenu} (Cardinal max_items, Widget parent, ArgList l, Cardinal num_args)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMCascadeButton} * {\b pd_button}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMMenuItem} * {\b menu_items}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Cardinal {\b menu_count}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Cardinal {\b max_menu_items}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Cardinal {\b menu_cursor}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v XMPulldown\:XMPulldown}
{\xe \v XMPulldown\:XMPulldown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMPulldown::XMPulldown (char * {\i n}, Widget & {\i parent}, Cardinal {\i max_items}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMPulldown_a0}
{\bkmkend classXMPulldown_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 329 of file XMMenus.h.\par
\par
References BuildMenu().\par
Referenced by AddSubmenu().}
{\xe \v XMPulldown\:XMPulldown}
{\xe \v XMPulldown\:XMPulldown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMPulldown::XMPulldown (char * {\i n}, {\b XMWidget} & {\i parent}, Cardinal {\i max_items}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMPulldown_a1}
{\bkmkend classXMPulldown_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 335 of file XMMenus.h.\par
\par
References BuildMenu(), and XMWidget::getid().}
{\xe \v ~XMPulldown\:XMPulldown}
{\xe \v XMPulldown\:~XMPulldown}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMPulldown::~XMPulldown ()}
}\par
{\bkmkstart classXMPulldown_a2}
{\bkmkend classXMPulldown_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 379 of file XMMenus.cpp.\par
\par
References Button, XMMenuItem::item, menu_count, menu_items, pd_button, Separator, Submenu, ToggleButton, XMMenuItem::type, and Unused.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddMenuButton\:XMPulldown}
{\xe \v XMPulldown\:AddMenuButton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMPushButton} * XMPulldown::AddMenuButton (char * {\i n}, void(* {\i callback})({\b XMWidget} *, XtPointer, XtPointer) = NULL, XtPointer {\i client_data} = NULL, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0)}
}\par
{\bkmkstart classXMPulldown_a8}
{\bkmkend classXMPulldown_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 442 of file XMMenus.cpp.\par
\par
References Button, exit(), max_menu_items, menu_count, menu_items, XMWidget::name, and XMWidget::SetAttribute().}
{\xe \v AddMenuToggleButton\:XMPulldown}
{\xe \v XMPulldown\:AddMenuToggleButton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMToggleButton} * XMPulldown::AddMenuToggleButton (char * {\i n}, void(* {\i callback})({\b XMWidget} *, XtPointer, XtPointer) = NULL, XtPointer {\i client_data} = NULL, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0)}
}\par
{\bkmkstart classXMPulldown_a9}
{\bkmkend classXMPulldown_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 500 of file XMMenus.cpp.\par
\par
References exit(), max_menu_items, menu_count, menu_items, XMWidget::name, XMWidget::SetAttribute(), and ToggleButton.}
{\xe \v AddSeparator\:XMPulldown}
{\xe \v XMPulldown\:AddSeparator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMWidget} * XMPulldown::AddSeparator ()}
}\par
{\bkmkstart classXMPulldown_a10}
{\bkmkend classXMPulldown_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 548 of file XMMenus.cpp.\par
\par
References exit(), max_menu_items, menu_count, menu_items, Separator, and XMManagedWidget::XMManagedWidget().}
{\xe \v AddSubmenu\:XMPulldown}
{\xe \v XMPulldown\:AddSubmenu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMPulldown * XMPulldown::AddSubmenu (char * {\i n}, int {\i max_items}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0)}
}\par
{\bkmkstart classXMPulldown_a11}
{\bkmkend classXMPulldown_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 600 of file XMMenus.cpp.\par
\par
References exit(), max_menu_items, menu_count, menu_items, Submenu, and XMPulldown().}
{\xe \v BuildMenu\:XMPulldown}
{\xe \v XMPulldown\:BuildMenu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMPulldown::BuildMenu (Cardinal {\i max_items}, Widget {\i parent}, ArgList {\i l}, Cardinal {\i num_args}){\f2  [protected]}}
}\par
{\bkmkstart classXMPulldown_b0}
{\bkmkend classXMPulldown_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 332 of file XMMenus.cpp.\par
\par
References exit(), XMWidget::id, XMMenuItem::item, XMButton::Label(), max_menu_items, menu_count, menu_items, XMWidget::name, pd_button, XMCascadeButton::SetAssociatedMenu(), XMButton::SetMnemonic(), XMMenuItem::type, and Unused.\par
Referenced by XMPulldown().}
{\xe \v FindMenuItem\:XMPulldown}
{\xe \v XMPulldown\:FindMenuItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMMenuItem} * XMPulldown::FindMenuItem (char * {\i n})}
}\par
{\bkmkstart classXMPulldown_a15}
{\bkmkend classXMPulldown_a15}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 641 of file XMMenus.cpp.\par
\par
References Button, exit(), XMWidget::getname(), XMMenuItem::item, menu_count, menu_items, Separator, Submenu, ToggleButton, XMMenuItem::type, and Unused.\par
Referenced by XMMenuBar::GetMenuItem().}
{\xe \v GetCascadeButton\:XMPulldown}
{\xe \v XMPulldown\:GetCascadeButton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMWidget}* XMPulldown::GetCascadeButton (){\f2  [inline]}}
}\par
{\bkmkstart classXMPulldown_a16}
{\bkmkend classXMPulldown_a16}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 394 of file XMMenus.h.\par
\par
Referenced by XMMenuBar::AddHelpPulldown().}
{\xe \v GetFirstMenuItem\:XMPulldown}
{\xe \v XMPulldown\:GetFirstMenuItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMMenuItem}* XMPulldown::GetFirstMenuItem (){\f2  [inline]}}
}\par
{\bkmkstart classXMPulldown_a18}
{\bkmkend classXMPulldown_a18}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 400 of file XMMenus.h.\par
\par
References GetNextMenuItem(), and menu_cursor.}
{\xe \v GetMenuItem\:XMPulldown}
{\xe \v XMPulldown\:GetMenuItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMMenuItem}* XMPulldown::GetMenuItem (Cardinal {\i index}){\f2  [inline]}}
}\par
{\bkmkstart classXMPulldown_a14}
{\bkmkend classXMPulldown_a14}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 390 of file XMMenus.h.\par
\par
References menu_count.}
{\xe \v GetNextMenuItem\:XMPulldown}
{\xe \v XMPulldown\:GetNextMenuItem}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMMenuItem} * XMPulldown::GetNextMenuItem ()}
}\par
{\bkmkstart classXMPulldown_a17}
{\bkmkend classXMPulldown_a17}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 680 of file XMMenus.cpp.\par
\par
References menu_count, menu_cursor, and menu_items.\par
Referenced by GetFirstMenuItem().}
{\xe \v Label\:XMPulldown}
{\xe \v XMPulldown\:Label}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMPulldown::Label (char * {\i label}){\f2  [inline]}}
}\par
{\bkmkstart classXMPulldown_a3}
{\bkmkend classXMPulldown_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 345 of file XMMenus.h.\par
\par
References XMButton::Label().}
{\xe \v MaxMenuSize\:XMPulldown}
{\xe \v XMPulldown\:MaxMenuSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int XMPulldown::MaxMenuSize (){\f2  [inline]}}
}\par
{\bkmkstart classXMPulldown_a13}
{\bkmkend classXMPulldown_a13}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 389 of file XMMenus.h.\par
\par
References max_menu_items.}
{\xe \v MenuSize\:XMPulldown}
{\xe \v XMPulldown\:MenuSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int XMPulldown::MenuSize (){\f2  [inline]}}
}\par
{\bkmkstart classXMPulldown_a12}
{\bkmkend classXMPulldown_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 388 of file XMMenus.h.\par
\par
References menu_count.}
{\xe \v NoRadioMenu\:XMPulldown}
{\xe \v XMPulldown\:NoRadioMenu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMPulldown::NoRadioMenu (){\f2  [inline]}}
}\par
{\bkmkstart classXMPulldown_a6}
{\bkmkend classXMPulldown_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 355 of file XMMenus.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v RadioForceOne\:XMPulldown}
{\xe \v XMPulldown\:RadioForceOne}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMPulldown::RadioForceOne (){\f2  [inline]}}
}\par
{\bkmkstart classXMPulldown_a5}
{\bkmkend classXMPulldown_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 351 of file XMMenus.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v RadioMenu\:XMPulldown}
{\xe \v XMPulldown\:RadioMenu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMPulldown::RadioMenu (){\f2  [inline]}}
}\par
{\bkmkstart classXMPulldown_a4}
{\bkmkend classXMPulldown_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 349 of file XMMenus.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v RadioNoForceOne\:XMPulldown}
{\xe \v XMPulldown\:RadioNoForceOne}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMPulldown::RadioNoForceOne (){\f2  [inline]}}
}\par
{\bkmkstart classXMPulldown_a7}
{\bkmkend classXMPulldown_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 357 of file XMMenus.h.\par
\par
References XMWidget::SetAttribute().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v max_menu_items\:XMPulldown}
{\xe \v XMPulldown\:max_menu_items}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Cardinal XMPulldown::max_menu_items{\f2  [protected]}}
}\par
{\bkmkstart classXMPulldown_n3}
{\bkmkend classXMPulldown_n3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 322 of file XMMenus.h.\par
\par
Referenced by AddMenuButton(), AddMenuToggleButton(), AddSeparator(), AddSubmenu(), BuildMenu(), and MaxMenuSize().}
{\xe \v menu_count\:XMPulldown}
{\xe \v XMPulldown\:menu_count}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Cardinal XMPulldown::menu_count{\f2  [protected]}}
}\par
{\bkmkstart classXMPulldown_n2}
{\bkmkend classXMPulldown_n2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 321 of file XMMenus.h.\par
\par
Referenced by AddMenuButton(), AddMenuToggleButton(), AddSeparator(), AddSubmenu(), BuildMenu(), FindMenuItem(), GetMenuItem(), GetNextMenuItem(), MenuSize(), and ~XMPulldown().}
{\xe \v menu_cursor\:XMPulldown}
{\xe \v XMPulldown\:menu_cursor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Cardinal XMPulldown::menu_cursor{\f2  [protected]}}
}\par
{\bkmkstart classXMPulldown_n4}
{\bkmkend classXMPulldown_n4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 323 of file XMMenus.h.\par
\par
Referenced by GetFirstMenuItem(), and GetNextMenuItem().}
{\xe \v menu_items\:XMPulldown}
{\xe \v XMPulldown\:menu_items}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMMenuItem}* XMPulldown::menu_items{\f2  [protected]}}
}\par
{\bkmkstart classXMPulldown_n1}
{\bkmkend classXMPulldown_n1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 320 of file XMMenus.h.\par
\par
Referenced by AddMenuButton(), AddMenuToggleButton(), AddSeparator(), AddSubmenu(), BuildMenu(), FindMenuItem(), GetNextMenuItem(), and ~XMPulldown().}
{\xe \v pd_button\:XMPulldown}
{\xe \v XMPulldown\:pd_button}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMCascadeButton}* XMPulldown::pd_button{\f2  [protected]}}
}\par
{\bkmkstart classXMPulldown_n0}
{\bkmkend classXMPulldown_n0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 319 of file XMMenus.h.\par
\par
Referenced by BuildMenu(), and ~XMPulldown().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMMenus.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMMenus.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMPushButton  Class Reference\par \pard\plain 
{\tc\tcl2 \v XMPushButton}
{\xe \v XMPushButton}
{\bkmkstart classXMPushButton}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMPushbutton.h>}\par
Inheritance diagram for XMPushButton:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classXMPushButton.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMPushButton} (char *n, Widget parent, void(*cb)({\b XMWidget} *, XtPointer, XtPointer)=NULL, XtPointer cd=NULL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMPushButton} (char *n, {\b XMWidget} &parent, void(*cb)({\b XMWidget} *, XtPointer, XtPointer)=NULL, XtPointer cd=NULL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMPushButton} (Widget w)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Callback_data} * {\b AddCallback} (void(*cb)({\b XMWidget} *, XtPointer, XtPointer)=NULL, XtPointer cd=NULL)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v XMPushButton\:XMPushButton}
{\xe \v XMPushButton\:XMPushButton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMPushButton::XMPushButton (char * {\i n}, Widget {\i parent}, void(* {\i cb})({\b XMWidget} *, XtPointer, XtPointer) = NULL, XtPointer {\i cd} = NULL){\f2  [inline]}}
}\par
{\bkmkstart classXMPushButton_a0}
{\bkmkend classXMPushButton_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 377 of file XMPushbutton.h.\par
\par
References XMWidget::AddCallback(), and XMButton::Enable().}
{\xe \v XMPushButton\:XMPushButton}
{\xe \v XMPushButton\:XMPushButton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMPushButton::XMPushButton (char * {\i n}, {\b XMWidget} & {\i parent}, void(* {\i cb})({\b XMWidget} *, XtPointer, XtPointer) = NULL, XtPointer {\i cd} = NULL){\f2  [inline]}}
}\par
{\bkmkstart classXMPushButton_a1}
{\bkmkend classXMPushButton_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 387 of file XMPushbutton.h.\par
\par
References XMWidget::AddCallback(), and XMButton::Enable().}
{\xe \v XMPushButton\:XMPushButton}
{\xe \v XMPushButton\:XMPushButton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMPushButton::XMPushButton (Widget {\i w}){\f2  [inline]}}
}\par
{\bkmkstart classXMPushButton_a2}
{\bkmkend classXMPushButton_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 397 of file XMPushbutton.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddCallback\:XMPushButton}
{\xe \v XMPushButton\:AddCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Callback_data}* XMPushButton::AddCallback (void(* {\i cb})({\b XMWidget} *, XtPointer, XtPointer) = NULL, XtPointer {\i cd} = NULL){\f2  [inline]}}
}\par
{\bkmkstart classXMPushButton_a3}
{\bkmkend classXMPushButton_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 400 of file XMPushbutton.h.\par
\par
References XMWidget::AddCallback().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMPushbutton.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMRowColumn  Class Reference\par \pard\plain 
{\tc\tcl2 \v XMRowColumn}
{\xe \v XMRowColumn}
{\bkmkstart classXMRowColumn}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMManagers.h>}\par
Inheritance diagram for XMRowColumn:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classXMRowColumn.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMRowColumn} (char *{\b name})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMRowColumn} (Widget {\b id})\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMRowColumn} (char *{\b name}, {\b XMApplication} &parent, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMRowColumn} (char *{\b name}, {\b XMWidget} &parent, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMRowColumn} (char *{\b name}, Widget parent, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetAlignment} (unsigned char alignment)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetEntryClass} (WidgetClass type)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Align} (Boolean align)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetHomogenous} (Boolean homog)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Margins} (Dimension vertical, Dimension horizontal)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetRowColumns} (int numcols)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetOrientation} (unsigned char orientation)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetPacking} (unsigned char packmethod)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b RadioMenu} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b RadioForceOne} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b NoRadioMenu} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b RadioNoForceOne} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetSpacing} (Dimension spacing)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Callback_data} * {\b AddEntryCallback} (void(*callback)({\b XMWidget} *, XtPointer, XtPointer), XtPointer client_data)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v XMRowColumn\:XMRowColumn}
{\xe \v XMRowColumn\:XMRowColumn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMRowColumn::XMRowColumn (char * {\i name}){\f2  [inline]}}
}\par
{\bkmkstart classXMRowColumn_a0}
{\bkmkend classXMRowColumn_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 584 of file XMManagers.h.\par
\par
References XMWidget::name.}
{\xe \v XMRowColumn\:XMRowColumn}
{\xe \v XMRowColumn\:XMRowColumn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMRowColumn::XMRowColumn (Widget {\i id}){\f2  [inline]}}
}\par
{\bkmkstart classXMRowColumn_a1}
{\bkmkend classXMRowColumn_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 585 of file XMManagers.h.\par
\par
References XMWidget::id.}
{\xe \v XMRowColumn\:XMRowColumn}
{\xe \v XMRowColumn\:XMRowColumn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMRowColumn::XMRowColumn (char * {\i name}, {\b XMApplication} & {\i parent}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMRowColumn_a2}
{\bkmkend classXMRowColumn_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 586 of file XMManagers.h.\par
\par
References XMWidget::name.}
{\xe \v XMRowColumn\:XMRowColumn}
{\xe \v XMRowColumn\:XMRowColumn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMRowColumn::XMRowColumn (char * {\i name}, {\b XMWidget} & {\i parent}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMRowColumn_a3}
{\bkmkend classXMRowColumn_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 589 of file XMManagers.h.\par
\par
References XMWidget::name.}
{\xe \v XMRowColumn\:XMRowColumn}
{\xe \v XMRowColumn\:XMRowColumn}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMRowColumn::XMRowColumn (char * {\i name}, Widget {\i parent}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMRowColumn_a4}
{\bkmkend classXMRowColumn_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 592 of file XMManagers.h.\par
\par
References XMWidget::name.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddEntryCallback\:XMRowColumn}
{\xe \v XMRowColumn\:AddEntryCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Callback_data}* XMRowColumn::AddEntryCallback (void(* {\i callback})({\b XMWidget} *, XtPointer, XtPointer), XtPointer {\i client_data}){\f2  [inline]}}
}\par
{\bkmkstart classXMRowColumn_a18}
{\bkmkend classXMRowColumn_a18}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 639 of file XMManagers.h.\par
\par
References XMWidget::AddCallback().}
{\xe \v Align\:XMRowColumn}
{\xe \v XMRowColumn\:Align}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMRowColumn::Align (Boolean {\i align}){\f2  [inline]}}
}\par
{\bkmkstart classXMRowColumn_a7}
{\bkmkend classXMRowColumn_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 604 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v Margins\:XMRowColumn}
{\xe \v XMRowColumn\:Margins}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMRowColumn::Margins (Dimension {\i vertical}, Dimension {\i horizontal}){\f2  [inline]}}
}\par
{\bkmkstart classXMRowColumn_a9}
{\bkmkend classXMRowColumn_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 610 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v NoRadioMenu\:XMRowColumn}
{\xe \v XMRowColumn\:NoRadioMenu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMRowColumn::NoRadioMenu (){\f2  [inline]}}
}\par
{\bkmkstart classXMRowColumn_a15}
{\bkmkend classXMRowColumn_a15}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 628 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v RadioForceOne\:XMRowColumn}
{\xe \v XMRowColumn\:RadioForceOne}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMRowColumn::RadioForceOne (){\f2  [inline]}}
}\par
{\bkmkstart classXMRowColumn_a14}
{\bkmkend classXMRowColumn_a14}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 626 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v RadioMenu\:XMRowColumn}
{\xe \v XMRowColumn\:RadioMenu}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMRowColumn::RadioMenu (){\f2  [inline]}}
}\par
{\bkmkstart classXMRowColumn_a13}
{\bkmkend classXMRowColumn_a13}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 624 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v RadioNoForceOne\:XMRowColumn}
{\xe \v XMRowColumn\:RadioNoForceOne}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMRowColumn::RadioNoForceOne (){\f2  [inline]}}
}\par
{\bkmkstart classXMRowColumn_a16}
{\bkmkend classXMRowColumn_a16}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 630 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v SetAlignment\:XMRowColumn}
{\xe \v XMRowColumn\:SetAlignment}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMRowColumn::SetAlignment (unsigned char {\i alignment}){\f2  [inline]}}
}\par
{\bkmkstart classXMRowColumn_a5}
{\bkmkend classXMRowColumn_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 598 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v SetEntryClass\:XMRowColumn}
{\xe \v XMRowColumn\:SetEntryClass}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMRowColumn::SetEntryClass (WidgetClass {\i type}){\f2  [inline]}}
}\par
{\bkmkstart classXMRowColumn_a6}
{\bkmkend classXMRowColumn_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 601 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v SetHomogenous\:XMRowColumn}
{\xe \v XMRowColumn\:SetHomogenous}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMRowColumn::SetHomogenous (Boolean {\i homog}){\f2  [inline]}}
}\par
{\bkmkstart classXMRowColumn_a8}
{\bkmkend classXMRowColumn_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 607 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v SetOrientation\:XMRowColumn}
{\xe \v XMRowColumn\:SetOrientation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMRowColumn::SetOrientation (unsigned char {\i orientation}){\f2  [inline]}}
}\par
{\bkmkstart classXMRowColumn_a11}
{\bkmkend classXMRowColumn_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 618 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v SetPacking\:XMRowColumn}
{\xe \v XMRowColumn\:SetPacking}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMRowColumn::SetPacking (unsigned char {\i packmethod}){\f2  [inline]}}
}\par
{\bkmkstart classXMRowColumn_a12}
{\bkmkend classXMRowColumn_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 621 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v SetRowColumns\:XMRowColumn}
{\xe \v XMRowColumn\:SetRowColumns}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMRowColumn::SetRowColumns (int {\i numcols}){\f2  [inline]}}
}\par
{\bkmkstart classXMRowColumn_a10}
{\bkmkend classXMRowColumn_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 615 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v SetSpacing\:XMRowColumn}
{\xe \v XMRowColumn\:SetSpacing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMRowColumn::SetSpacing (Dimension {\i spacing}){\f2  [inline]}}
}\par
{\bkmkstart classXMRowColumn_a17}
{\bkmkend classXMRowColumn_a17}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 632 of file XMManagers.h.\par
\par
References XMWidget::SetAttribute().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMManagers.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMScale  Class Reference\par \pard\plain 
{\tc\tcl2 \v XMScale}
{\xe \v XMScale}
{\bkmkstart classXMScale}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMScale.h>}\par
Inheritance diagram for XMScale:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classXMScale.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMScale} (char *n, {\b XMWidget} &parent, ArgList args=NULL, Cardinal arg_count=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMScale} (char *n, Widget parent, ArgList args=NULL, Cardinal arg_count=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMScale} (char *n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMScale} (Widget w)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetRange} (int hi, int lo=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Value} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Value} (int value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Callback_data} * {\b AddDragCallback} (void(*callback)({\b XMWidget} *, XtPointer, XtPointer), XtPointer user_data=NULL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Callback_data} * {\b AddChangedCallback} (void(*callback)({\b XMWidget} *, XtPointer, XtPointer), XtPointer user_data=NULL)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v XMScale\:XMScale}
{\xe \v XMScale\:XMScale}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMScale::XMScale (char * {\i n}, {\b XMWidget} & {\i parent}, ArgList {\i args} = NULL, Cardinal {\i arg_count} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMScale_a0}
{\bkmkend classXMScale_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 302 of file XMScale.h.\par
}
{\xe \v XMScale\:XMScale}
{\xe \v XMScale\:XMScale}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMScale::XMScale (char * {\i n}, Widget {\i parent}, ArgList {\i args} = NULL, Cardinal {\i arg_count} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMScale_a1}
{\bkmkend classXMScale_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 307 of file XMScale.h.\par
}
{\xe \v XMScale\:XMScale}
{\xe \v XMScale\:XMScale}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMScale::XMScale (char * {\i n}){\f2  [inline]}}
}\par
{\bkmkstart classXMScale_a2}
{\bkmkend classXMScale_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 312 of file XMScale.h.\par
}
{\xe \v XMScale\:XMScale}
{\xe \v XMScale\:XMScale}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMScale::XMScale (Widget {\i w}){\f2  [inline]}}
}\par
{\bkmkstart classXMScale_a3}
{\bkmkend classXMScale_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 313 of file XMScale.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddChangedCallback\:XMScale}
{\xe \v XMScale\:AddChangedCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Callback_data}* XMScale::AddChangedCallback (void(* {\i callback})({\b XMWidget} *, XtPointer, XtPointer), XtPointer {\i user_data} = NULL){\f2  [inline]}}
}\par
{\bkmkstart classXMScale_a8}
{\bkmkend classXMScale_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 339 of file XMScale.h.\par
\par
References XMWidget::AddCallback().}
{\xe \v AddDragCallback\:XMScale}
{\xe \v XMScale\:AddDragCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Callback_data}* XMScale::AddDragCallback (void(* {\i callback})({\b XMWidget} *, XtPointer, XtPointer), XtPointer {\i user_data} = NULL){\f2  [inline]}}
}\par
{\bkmkstart classXMScale_a7}
{\bkmkend classXMScale_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 334 of file XMScale.h.\par
\par
References XMWidget::AddCallback().}
{\xe \v SetRange\:XMScale}
{\xe \v XMScale\:SetRange}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMScale::SetRange (int {\i hi}, int {\i lo} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMScale_a4}
{\bkmkend classXMScale_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 317 of file XMScale.h.\par
\par
References XMWidget::id.}
{\xe \v Value\:XMScale}
{\xe \v XMScale\:Value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMScale::Value (int {\i value}){\f2  [inline]}}
}\par
{\bkmkstart classXMScale_a6}
{\bkmkend classXMScale_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 328 of file XMScale.h.\par
\par
References XMWidget::id.}
{\xe \v Value\:XMScale}
{\xe \v XMScale\:Value}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int XMScale::Value (){\f2  [inline]}}
}\par
{\bkmkstart classXMScale_a5}
{\bkmkend classXMScale_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 323 of file XMScale.h.\par
\par
References XMWidget::id.}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMScale.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMScrolledList  Class Reference\par \pard\plain 
{\tc\tcl2 \v XMScrolledList}
{\xe \v XMScrolledList}
{\bkmkstart classXMScrolledList}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMList.h>}\par
Inheritance diagram for XMScrolledList:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classXMScrolledList.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMScrolledList} (char *n, {\b XMWidget} &parent, int rows=10, ArgList args=NULL, Cardinal arg_count=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMScrolledList} (char *n, Widget parent, int rows=10, ArgList args=NULL, Cardinal arg_count=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Widget {\b GetScrolledWindow} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Manage} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnManage} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Widget {\b scrolled_widget}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v XMScrolledList\:XMScrolledList}
{\xe \v XMScrolledList\:XMScrolledList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMScrolledList::XMScrolledList (char * {\i n}, {\b XMWidget} & {\i parent}, int {\i rows} = 10, ArgList {\i args} = NULL, Cardinal {\i arg_count} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMScrolledList_a0}
{\bkmkend classXMScrolledList_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 474 of file XMList.h.\par
\par
References XMWidget::getid(), XMWidget::id, Manage(), scrolled_widget, and XMListBaseClass::SetRows().}
{\xe \v XMScrolledList\:XMScrolledList}
{\xe \v XMScrolledList\:XMScrolledList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMScrolledList::XMScrolledList (char * {\i n}, Widget {\i parent}, int {\i rows} = 10, ArgList {\i args} = NULL, Cardinal {\i arg_count} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMScrolledList_a1}
{\bkmkend classXMScrolledList_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 484 of file XMList.h.\par
\par
References XMWidget::id, Manage(), scrolled_widget, and XMListBaseClass::SetRows().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v GetScrolledWindow\:XMScrolledList}
{\xe \v XMScrolledList\:GetScrolledWindow}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Widget XMScrolledList::GetScrolledWindow (){\f2  [inline]}}
}\par
{\bkmkstart classXMScrolledList_a2}
{\bkmkend classXMScrolledList_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 494 of file XMList.h.\par
\par
References scrolled_widget.}
{\xe \v Manage\:XMScrolledList}
{\xe \v XMScrolledList\:Manage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMScrolledList::Manage (){\f2  [inline]}}
}\par
{\bkmkstart classXMScrolledList_a3}
{\bkmkend classXMScrolledList_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Reimplemented from {\b XMWidget} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classXMWidget_a16 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 498 of file XMList.h.\par
\par
References XMWidget::id, and scrolled_widget.\par
Referenced by XMScrolledList().}
{\xe \v UnManage\:XMScrolledList}
{\xe \v XMScrolledList\:UnManage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMScrolledList::UnManage (){\f2  [inline]}}
}\par
{\bkmkstart classXMScrolledList_a4}
{\bkmkend classXMScrolledList_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Reimplemented from {\b XMWidget} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classXMWidget_a17 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 502 of file XMList.h.\par
\par
References XMWidget::id, and scrolled_widget.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v scrolled_widget\:XMScrolledList}
{\xe \v XMScrolledList\:scrolled_widget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Widget XMScrolledList::scrolled_widget{\f2  [protected]}}
}\par
{\bkmkstart classXMScrolledList_n0}
{\bkmkend classXMScrolledList_n0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 471 of file XMList.h.\par
\par
Referenced by GetScrolledWindow(), Manage(), UnManage(), and XMScrolledList().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMList.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMScrolledText  Class Reference\par \pard\plain 
{\tc\tcl2 \v XMScrolledText}
{\xe \v XMScrolledText}
{\bkmkstart classXMScrolledText}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMText.h>}\par
Inheritance diagram for XMScrolledText:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classXMScrolledText.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMScrolledText} (char *n, {\b XMWidget} &parent, int rows=20, int columns=40, ArgList args=NULL, Cardinal arg_count=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMScrolledText} (char *n, Widget parent, int rows=20, int columns=40, ArgList args=NULL, Cardinal arg_count=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetMaxLength} (int maxlen)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ClearText} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b AddText} (char *string)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Widget {\b Scroller} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b text_length}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b max_text_length}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Widget {\b scroller}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v XMScrolledText\:XMScrolledText}
{\xe \v XMScrolledText\:XMScrolledText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMScrolledText::XMScrolledText (char * {\i n}, {\b XMWidget} & {\i parent}, int {\i rows} = 20, int {\i columns} = 40, ArgList {\i args} = NULL, Cardinal {\i arg_count} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMScrolledText_a0}
{\bkmkend classXMScrolledText_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 404 of file XMText.h.\par
\par
References XMWidget::getid(), XMWidget::id, max_text_length, scroller, XMText::SetColumns(), XMText::SetRows(), and text_length.}
{\xe \v XMScrolledText\:XMScrolledText}
{\xe \v XMScrolledText\:XMScrolledText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMScrolledText::XMScrolledText (char * {\i n}, Widget {\i parent}, int {\i rows} = 20, int {\i columns} = 40, ArgList {\i args} = NULL, Cardinal {\i arg_count} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMScrolledText_a1}
{\bkmkend classXMScrolledText_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 415 of file XMText.h.\par
\par
References XMWidget::id, max_text_length, scroller, XMText::SetColumns(), XMText::SetRows(), and text_length.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddText\:XMScrolledText}
{\xe \v XMScrolledText\:AddText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMScrolledText::AddText (char * {\i string}){\f2  [inline]}}
}\par
{\bkmkstart classXMScrolledText_a4}
{\bkmkend classXMScrolledText_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 434 of file XMText.h.\par
\par
References XMWidget::id, max_text_length, and text_length.}
{\xe \v ClearText\:XMScrolledText}
{\xe \v XMScrolledText\:ClearText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMScrolledText::ClearText (){\f2  [inline]}}
}\par
{\bkmkstart classXMScrolledText_a3}
{\bkmkend classXMScrolledText_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 430 of file XMText.h.\par
\par
References XMWidget::id, and text_length.}
{\xe \v Scroller\:XMScrolledText}
{\xe \v XMScrolledText\:Scroller}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Widget XMScrolledText::Scroller (){\f2  [inline]}}
}\par
{\bkmkstart classXMScrolledText_a5}
{\bkmkend classXMScrolledText_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 447 of file XMText.h.\par
\par
References scroller.}
{\xe \v SetMaxLength\:XMScrolledText}
{\xe \v XMScrolledText\:SetMaxLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMScrolledText::SetMaxLength (int {\i maxlen}){\f2  [inline]}}
}\par
{\bkmkstart classXMScrolledText_a2}
{\bkmkend classXMScrolledText_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Reimplemented from {\b XMText} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classXMText_a6 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 429 of file XMText.h.\par
\par
References max_text_length.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v max_text_length\:XMScrolledText}
{\xe \v XMScrolledText\:max_text_length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int XMScrolledText::max_text_length{\f2  [protected]}}
}\par
{\bkmkstart classXMScrolledText_n1}
{\bkmkend classXMScrolledText_n1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 398 of file XMText.h.\par
\par
Referenced by AddText(), SetMaxLength(), and XMScrolledText().}
{\xe \v scroller\:XMScrolledText}
{\xe \v XMScrolledText\:scroller}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Widget XMScrolledText::scroller{\f2  [protected]}}
}\par
{\bkmkstart classXMScrolledText_n2}
{\bkmkend classXMScrolledText_n2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 399 of file XMText.h.\par
\par
Referenced by Scroller(), and XMScrolledText().}
{\xe \v text_length\:XMScrolledText}
{\xe \v XMScrolledText\:text_length}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int XMScrolledText::text_length{\f2  [protected]}}
}\par
{\bkmkstart classXMScrolledText_n0}
{\bkmkend classXMScrolledText_n0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 397 of file XMText.h.\par
\par
Referenced by AddText(), ClearText(), and XMScrolledText().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMText.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMSeparator  Class Reference\par \pard\plain 
{\tc\tcl2 \v XMSeparator}
{\xe \v XMSeparator}
{\bkmkstart classXMSeparator}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMSeparators.h>}\par
Inheritance diagram for XMSeparator:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classXMSeparator.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMSeparator} (char *n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMSeparator} (char *n, Widget parent, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMSeparator} (char *n, {\b XMWidget} &parent, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMSeparator} (Widget w)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetShadowType} (unsigned char newtype)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetOrientation} (unsigned char orientation)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v XMSeparator\:XMSeparator}
{\xe \v XMSeparator\:XMSeparator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMSeparator::XMSeparator (char * {\i n}){\f2  [inline]}}
}\par
{\bkmkstart classXMSeparator_a0}
{\bkmkend classXMSeparator_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 305 of file XMSeparators.h.\par
}
{\xe \v XMSeparator\:XMSeparator}
{\xe \v XMSeparator\:XMSeparator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMSeparator::XMSeparator (char * {\i n}, Widget {\i parent}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMSeparator_a1}
{\bkmkend classXMSeparator_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 306 of file XMSeparators.h.\par
}
{\xe \v XMSeparator\:XMSeparator}
{\xe \v XMSeparator\:XMSeparator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMSeparator::XMSeparator (char * {\i n}, {\b XMWidget} & {\i parent}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMSeparator_a2}
{\bkmkend classXMSeparator_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 310 of file XMSeparators.h.\par
}
{\xe \v XMSeparator\:XMSeparator}
{\xe \v XMSeparator\:XMSeparator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMSeparator::XMSeparator (Widget {\i w}){\f2  [inline]}}
}\par
{\bkmkstart classXMSeparator_a3}
{\bkmkend classXMSeparator_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 314 of file XMSeparators.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v SetOrientation\:XMSeparator}
{\xe \v XMSeparator\:SetOrientation}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMSeparator::SetOrientation (unsigned char {\i orientation}){\f2  [inline]}}
}\par
{\bkmkstart classXMSeparator_a5}
{\bkmkend classXMSeparator_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 321 of file XMSeparators.h.\par
\par
References XMWidget::SetAttribute().\par
Referenced by XMHorizontalSeparator::XMHorizontalSeparator(), and XMVerticalSeparator::XMVerticalSeparator().}
{\xe \v SetShadowType\:XMSeparator}
{\xe \v XMSeparator\:SetShadowType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMSeparator::SetShadowType (unsigned char {\i newtype}){\f2  [inline]}}
}\par
{\bkmkstart classXMSeparator_a4}
{\bkmkend classXMSeparator_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 318 of file XMSeparators.h.\par
\par
References XMWidget::SetAttribute().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMSeparators.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMText  Class Reference\par \pard\plain 
{\tc\tcl2 \v XMText}
{\xe \v XMText}
{\bkmkstart classXMText}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMText.h>}\par
Inheritance diagram for XMText:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classXMText.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMText} (char *n, {\b XMWidget} &parent, int rows=1, int columns=30, ArgList args=NULL, Cardinal arg_count=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMText} (char *n, Widget parent, int rows=1, int columns=30, ArgList args=NULL, Cardinal arg_count=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMText} (char *n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMText} (Widget w)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetColumns} (int columns)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetRows} (int rows)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetMaxLength} (int len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b EnableWordWrap} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b DisableWordWrap} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b GetText} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetText} (char *txt)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetEditing} (Boolean enable)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v XMText\:XMText}
{\xe \v XMText\:XMText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMText::XMText (char * {\i n}, {\b XMWidget} & {\i parent}, int {\i rows} = 1, int {\i columns} = 30, ArgList {\i args} = NULL, Cardinal {\i arg_count} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMText_a0}
{\bkmkend classXMText_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 305 of file XMText.h.\par
\par
References SetColumns(), and SetRows().}
{\xe \v XMText\:XMText}
{\xe \v XMText\:XMText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMText::XMText (char * {\i n}, Widget {\i parent}, int {\i rows} = 1, int {\i columns} = 30, ArgList {\i args} = NULL, Cardinal {\i arg_count} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMText_a1}
{\bkmkend classXMText_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 312 of file XMText.h.\par
\par
References SetColumns(), and SetRows().}
{\xe \v XMText\:XMText}
{\xe \v XMText\:XMText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMText::XMText (char * {\i n}){\f2  [inline]}}
}\par
{\bkmkstart classXMText_a2}
{\bkmkend classXMText_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 319 of file XMText.h.\par
}
{\xe \v XMText\:XMText}
{\xe \v XMText\:XMText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMText::XMText (Widget {\i w}){\f2  [inline]}}
}\par
{\bkmkstart classXMText_a3}
{\bkmkend classXMText_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 320 of file XMText.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v DisableWordWrap\:XMText}
{\xe \v XMText\:DisableWordWrap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMText::DisableWordWrap (){\f2  [inline]}}
}\par
{\bkmkstart classXMText_a8}
{\bkmkend classXMText_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 336 of file XMText.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v EnableWordWrap\:XMText}
{\xe \v XMText\:EnableWordWrap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMText::EnableWordWrap (){\f2  [inline]}}
}\par
{\bkmkstart classXMText_a7}
{\bkmkend classXMText_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 333 of file XMText.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v GetText\:XMText}
{\xe \v XMText\:GetText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* XMText::GetText (){\f2  [inline]}}
}\par
{\bkmkstart classXMText_a9}
{\bkmkend classXMText_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 339 of file XMText.h.\par
\par
References XMWidget::id.}
{\xe \v SetColumns\:XMText}
{\xe \v XMText\:SetColumns}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMText::SetColumns (int {\i columns}){\f2  [inline]}}
}\par
{\bkmkstart classXMText_a4}
{\bkmkend classXMText_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 324 of file XMText.h.\par
\par
References XMWidget::SetAttribute().\par
Referenced by XMScrolledText::XMScrolledText(), and XMText().}
{\xe \v SetEditing\:XMText}
{\xe \v XMText\:SetEditing}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMText::SetEditing (Boolean {\i enable}){\f2  [inline]}}
}\par
{\bkmkstart classXMText_a11}
{\bkmkend classXMText_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 344 of file XMText.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v SetMaxLength\:XMText}
{\xe \v XMText\:SetMaxLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMText::SetMaxLength (int {\i len}){\f2  [inline]}}
}\par
{\bkmkstart classXMText_a6}
{\bkmkend classXMText_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Reimplemented in {\b XMScrolledText} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classXMScrolledText_a2 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 330 of file XMText.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v SetRows\:XMText}
{\xe \v XMText\:SetRows}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMText::SetRows (int {\i rows}){\f2  [inline]}}
}\par
{\bkmkstart classXMText_a5}
{\bkmkend classXMText_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 327 of file XMText.h.\par
\par
References XMWidget::SetAttribute().\par
Referenced by XMScrolledText::XMScrolledText(), and XMText().}
{\xe \v SetText\:XMText}
{\xe \v XMText\:SetText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMText::SetText (char * {\i txt}){\f2  [inline]}}
}\par
{\bkmkstart classXMText_a10}
{\bkmkend classXMText_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 341 of file XMText.h.\par
\par
References XMWidget::id.}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMText.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMTextField  Class Reference\par \pard\plain 
{\tc\tcl2 \v XMTextField}
{\xe \v XMTextField}
{\bkmkstart classXMTextField}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMText.h>}\par
Inheritance diagram for XMTextField:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classXMTextField.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMTextField} (char *n, {\b XMWidget} &parent, int columns=30, ArgList args=NULL, Cardinal arg_count=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMTextField} (char *n, Widget parent, int columns=30, ArgList args=NULL, Cardinal arg_count=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMTextField} (char *n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMTextField} (Widget w)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetColumns} (int columns)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetMaxLength} (int len)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b EnableWordWrap} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b GetText} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetText} (char *txt)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Callback_data} * {\b AddActivateCallback} (void(*callback)({\b XMWidget} *, XtPointer, XtPointer), XtPointer user_data=NULL)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v XMTextField\:XMTextField}
{\xe \v XMTextField\:XMTextField}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMTextField::XMTextField (char * {\i n}, {\b XMWidget} & {\i parent}, int {\i columns} = 30, ArgList {\i args} = NULL, Cardinal {\i arg_count} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMTextField_a0}
{\bkmkend classXMTextField_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 356 of file XMText.h.\par
\par
References SetColumns().}
{\xe \v XMTextField\:XMTextField}
{\xe \v XMTextField\:XMTextField}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMTextField::XMTextField (char * {\i n}, Widget {\i parent}, int {\i columns} = 30, ArgList {\i args} = NULL, Cardinal {\i arg_count} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMTextField_a1}
{\bkmkend classXMTextField_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 363 of file XMText.h.\par
\par
References SetColumns().}
{\xe \v XMTextField\:XMTextField}
{\xe \v XMTextField\:XMTextField}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMTextField::XMTextField (char * {\i n}){\f2  [inline]}}
}\par
{\bkmkstart classXMTextField_a2}
{\bkmkend classXMTextField_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 369 of file XMText.h.\par
}
{\xe \v XMTextField\:XMTextField}
{\xe \v XMTextField\:XMTextField}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMTextField::XMTextField (Widget {\i w}){\f2  [inline]}}
}\par
{\bkmkstart classXMTextField_a3}
{\bkmkend classXMTextField_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 370 of file XMText.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddActivateCallback\:XMTextField}
{\xe \v XMTextField\:AddActivateCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Callback_data}* XMTextField::AddActivateCallback (void(* {\i callback})({\b XMWidget} *, XtPointer, XtPointer), XtPointer {\i user_data} = NULL){\f2  [inline]}}
}\par
{\bkmkstart classXMTextField_a9}
{\bkmkend classXMTextField_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 388 of file XMText.h.\par
\par
References XMWidget::AddCallback().}
{\xe \v EnableWordWrap\:XMTextField}
{\xe \v XMTextField\:EnableWordWrap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMTextField::EnableWordWrap (){\f2  [inline]}}
}\par
{\bkmkstart classXMTextField_a6}
{\bkmkend classXMTextField_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 380 of file XMText.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v GetText\:XMTextField}
{\xe \v XMTextField\:GetText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* XMTextField::GetText (){\f2  [inline]}}
}\par
{\bkmkstart classXMTextField_a7}
{\bkmkend classXMTextField_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 383 of file XMText.h.\par
\par
References XMWidget::id.}
{\xe \v SetColumns\:XMTextField}
{\xe \v XMTextField\:SetColumns}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMTextField::SetColumns (int {\i columns}){\f2  [inline]}}
}\par
{\bkmkstart classXMTextField_a4}
{\bkmkend classXMTextField_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 374 of file XMText.h.\par
\par
References XMWidget::SetAttribute().\par
Referenced by XMTextField().}
{\xe \v SetMaxLength\:XMTextField}
{\xe \v XMTextField\:SetMaxLength}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMTextField::SetMaxLength (int {\i len}){\f2  [inline]}}
}\par
{\bkmkstart classXMTextField_a5}
{\bkmkend classXMTextField_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 377 of file XMText.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v SetText\:XMTextField}
{\xe \v XMTextField\:SetText}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMTextField::SetText (char * {\i txt}){\f2  [inline]}}
}\par
{\bkmkstart classXMTextField_a8}
{\bkmkend classXMTextField_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 385 of file XMText.h.\par
\par
References XMWidget::id.}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMText.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMToggleButton  Class Reference\par \pard\plain 
{\tc\tcl2 \v XMToggleButton}
{\xe \v XMToggleButton}
{\bkmkstart classXMToggleButton}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMPushbutton.h>}\par
Inheritance diagram for XMToggleButton:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classXMToggleButton.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMToggleButton} (char *n, Widget parent, void(*cb)({\b XMWidget} *, XtPointer, XtPointer)=NULL, XtPointer cd=NULL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMToggleButton} (char *n, {\b XMWidget} &parent, void(*cb)({\b XMWidget} *, XtPointer, XtPointer)=NULL, XtPointer cd=NULL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMToggleButton} (Widget w)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Callback_data} * {\b AddCallback} (void(*cb)({\b XMWidget} *, XtPointer, XtPointer)=NULL, XtPointer cd=NULL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b ShowIndicator} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b HideIndicator} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Diamond} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Box} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetState} (Boolean state)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Set} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnSet} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Boolean {\b GetState} ()\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v XMToggleButton\:XMToggleButton}
{\xe \v XMToggleButton\:XMToggleButton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMToggleButton::XMToggleButton (char * {\i n}, Widget {\i parent}, void(* {\i cb})({\b XMWidget} *, XtPointer, XtPointer) = NULL, XtPointer {\i cd} = NULL){\f2  [inline]}}
}\par
{\bkmkstart classXMToggleButton_a0}
{\bkmkend classXMToggleButton_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 471 of file XMPushbutton.h.\par
\par
References XMWidget::AddCallback(), and XMButton::Enable().}
{\xe \v XMToggleButton\:XMToggleButton}
{\xe \v XMToggleButton\:XMToggleButton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMToggleButton::XMToggleButton (char * {\i n}, {\b XMWidget} & {\i parent}, void(* {\i cb})({\b XMWidget} *, XtPointer, XtPointer) = NULL, XtPointer {\i cd} = NULL){\f2  [inline]}}
}\par
{\bkmkstart classXMToggleButton_a1}
{\bkmkend classXMToggleButton_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 481 of file XMPushbutton.h.\par
\par
References XMWidget::AddCallback(), and XMButton::Enable().}
{\xe \v XMToggleButton\:XMToggleButton}
{\xe \v XMToggleButton\:XMToggleButton}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMToggleButton::XMToggleButton (Widget {\i w}){\f2  [inline]}}
}\par
{\bkmkstart classXMToggleButton_a2}
{\bkmkend classXMToggleButton_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 490 of file XMPushbutton.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddCallback\:XMToggleButton}
{\xe \v XMToggleButton\:AddCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Callback_data}* XMToggleButton::AddCallback (void(* {\i cb})({\b XMWidget} *, XtPointer, XtPointer) = NULL, XtPointer {\i cd} = NULL){\f2  [inline]}}
}\par
{\bkmkstart classXMToggleButton_a3}
{\bkmkend classXMToggleButton_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 497 of file XMPushbutton.h.\par
\par
References XMWidget::AddCallback().}
{\xe \v Box\:XMToggleButton}
{\xe \v XMToggleButton\:Box}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMToggleButton::Box (){\f2  [inline]}}
}\par
{\bkmkstart classXMToggleButton_a7}
{\bkmkend classXMToggleButton_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 511 of file XMPushbutton.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v Diamond\:XMToggleButton}
{\xe \v XMToggleButton\:Diamond}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMToggleButton::Diamond (){\f2  [inline]}}
}\par
{\bkmkstart classXMToggleButton_a6}
{\bkmkend classXMToggleButton_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 508 of file XMPushbutton.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v GetState\:XMToggleButton}
{\xe \v XMToggleButton\:GetState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Boolean XMToggleButton::GetState (){\f2  [inline]}}
}\par
{\bkmkstart classXMToggleButton_a11}
{\bkmkend classXMToggleButton_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 521 of file XMPushbutton.h.\par
\par
References XMWidget::GetAttribute().}
{\xe \v HideIndicator\:XMToggleButton}
{\xe \v XMToggleButton\:HideIndicator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMToggleButton::HideIndicator (){\f2  [inline]}}
}\par
{\bkmkstart classXMToggleButton_a5}
{\bkmkend classXMToggleButton_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 506 of file XMPushbutton.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v Set\:XMToggleButton}
{\xe \v XMToggleButton\:Set}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMToggleButton::Set (){\f2  [inline]}}
}\par
{\bkmkstart classXMToggleButton_a9}
{\bkmkend classXMToggleButton_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 517 of file XMPushbutton.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v SetState\:XMToggleButton}
{\xe \v XMToggleButton\:SetState}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMToggleButton::SetState (Boolean {\i state}){\f2  [inline]}}
}\par
{\bkmkstart classXMToggleButton_a8}
{\bkmkend classXMToggleButton_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 515 of file XMPushbutton.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v ShowIndicator\:XMToggleButton}
{\xe \v XMToggleButton\:ShowIndicator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMToggleButton::ShowIndicator (){\f2  [inline]}}
}\par
{\bkmkstart classXMToggleButton_a4}
{\bkmkend classXMToggleButton_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 504 of file XMPushbutton.h.\par
\par
References XMWidget::SetAttribute().}
{\xe \v UnSet\:XMToggleButton}
{\xe \v XMToggleButton\:UnSet}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMToggleButton::UnSet (){\f2  [inline]}}
}\par
{\bkmkstart classXMToggleButton_a10}
{\bkmkend classXMToggleButton_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 519 of file XMPushbutton.h.\par
\par
References XMWidget::SetAttribute().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMPushbutton.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMVerticalSeparator  Class Reference\par \pard\plain 
{\tc\tcl2 \v XMVerticalSeparator}
{\xe \v XMVerticalSeparator}
{\bkmkstart classXMVerticalSeparator}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMSeparators.h>}\par
Inheritance diagram for XMVerticalSeparator:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classXMVerticalSeparator.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMVerticalSeparator} (char *n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMVerticalSeparator} (char *n, Widget parent, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMVerticalSeparator} (char *n, {\b XMWidget} &parent, ArgList l=NULL, Cardinal num_args=0)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v XMVerticalSeparator\:XMVerticalSeparator}
{\xe \v XMVerticalSeparator\:XMVerticalSeparator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMVerticalSeparator::XMVerticalSeparator (char * {\i n}){\f2  [inline]}}
}\par
{\bkmkstart classXMVerticalSeparator_a0}
{\bkmkend classXMVerticalSeparator_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 353 of file XMSeparators.h.\par
\par
References XMWidget::Manage().}
{\xe \v XMVerticalSeparator\:XMVerticalSeparator}
{\xe \v XMVerticalSeparator\:XMVerticalSeparator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMVerticalSeparator::XMVerticalSeparator (char * {\i n}, Widget {\i parent}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMVerticalSeparator_a1}
{\bkmkend classXMVerticalSeparator_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 354 of file XMSeparators.h.\par
\par
References XMWidget::Manage(), and XMSeparator::SetOrientation().}
{\xe \v XMVerticalSeparator\:XMVerticalSeparator}
{\xe \v XMVerticalSeparator\:XMVerticalSeparator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMVerticalSeparator::XMVerticalSeparator (char * {\i n}, {\b XMWidget} & {\i parent}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMVerticalSeparator_a2}
{\bkmkend classXMVerticalSeparator_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 359 of file XMSeparators.h.\par
\par
References XMWidget::Manage(), and XMSeparator::SetOrientation().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMSeparators.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMWidget  Class Reference\par \pard\plain 
{\tc\tcl2 \v XMWidget}
{\xe \v XMWidget}
{\bkmkstart classXMWidget}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMWidget.h>}\par
Inheritance diagram for XMWidget:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classXMWidget.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMWidget} (char *n)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMWidget} (Widget w)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMWidget} (char *n, WidgetClass cl, {\b XMApplication} &parent, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMWidget} (char *n, WidgetClass cl, Widget parent, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMWidget} (char *n, WidgetClass cl, XMWidget &parent, ArgList l=NULL, Cardinal num_args=0)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~XMWidget} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Widget {\b getid} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Widget {\b getparent} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b getname} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetAttribute} (String attribute, XtArgVal value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetAttribute} (String attribute, void *value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b GetAttribute} (String attribute, void *value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b GetAttribute} (String attribute, XtArgVal value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Callback_data} * {\b AddCallback} (String reason, void(*proc)(XMWidget *, XtPointer, XtPointer), XtPointer data=NULL)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Map} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnMap} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Manage} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnManage} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Realize} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b UnRealize} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b Create} (char *n, WidgetClass cl, Widget parent, ArgList l, Cardinal num_args)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Widget {\b id}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMWidgetName} {\b name}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v XMWidget\:XMWidget}
{\xe \v XMWidget\:XMWidget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMWidget::XMWidget (char * {\i n}){\f2  [inline]}}
}\par
{\bkmkstart classXMWidget_a0}
{\bkmkend classXMWidget_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 375 of file XMWidget.h.\par
\par
References name.}
{\xe \v XMWidget\:XMWidget}
{\xe \v XMWidget\:XMWidget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMWidget::XMWidget (Widget {\i w}){\f2  [inline]}}
}\par
{\bkmkstart classXMWidget_a1}
{\bkmkend classXMWidget_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 380 of file XMWidget.h.\par
\par
References id, and name.}
{\xe \v XMWidget\:XMWidget}
{\xe \v XMWidget\:XMWidget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMWidget::XMWidget (char * {\i n}, WidgetClass {\i cl}, {\b XMApplication} & {\i parent}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMWidget_a2}
{\bkmkend classXMWidget_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 385 of file XMWidget.h.\par
\par
References Create(), and XMApplication::getid().}
{\xe \v XMWidget\:XMWidget}
{\xe \v XMWidget\:XMWidget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMWidget::XMWidget (char * {\i n}, WidgetClass {\i cl}, Widget {\i parent}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMWidget_a3}
{\bkmkend classXMWidget_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 390 of file XMWidget.h.\par
\par
References Create().}
{\xe \v XMWidget\:XMWidget}
{\xe \v XMWidget\:XMWidget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMWidget::XMWidget (char * {\i n}, WidgetClass {\i cl}, XMWidget & {\i parent}, ArgList {\i l} = NULL, Cardinal {\i num_args} = 0){\f2  [inline]}}
}\par
{\bkmkstart classXMWidget_a4}
{\bkmkend classXMWidget_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 395 of file XMWidget.h.\par
\par
References Create(), and getid().}
{\xe \v ~XMWidget\:XMWidget}
{\xe \v XMWidget\:~XMWidget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
virtual XMWidget::~XMWidget (){\f2  [inline, virtual]}}
}\par
{\bkmkstart classXMWidget_a5}
{\bkmkend classXMWidget_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 400 of file XMWidget.h.\par
\par
References id.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v AddCallback\:XMWidget}
{\xe \v XMWidget\:AddCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Callback_data}* XMWidget::AddCallback (String {\i reason}, void(* {\i proc})(XMWidget *, XtPointer, XtPointer), XtPointer {\i data} = NULL){\f2  [inline]}}
}\par
{\bkmkstart classXMWidget_a13}
{\bkmkend classXMWidget_a13}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 419 of file XMWidget.h.\par
\par
References XMAddCallback().\par
Referenced by XMTextField::AddActivateCallback(), XMListBaseClass::AddbrowseSelectionCallback(), XMArrowButton::AddCallback(), XMToggleButton::AddCallback(), XMCascadeButton::AddCallback(), XMPushButton::AddCallback(), XMScale::AddChangedCallback(), XMListBaseClass::AddDefaultActionCallback(), XMScale::AddDragCallback(), XMRowColumn::AddEntryCallback(), XMListBaseClass::AddExtendedSelectionCallback(), XMManager::AddHelpCallback(), XMListBaseClass::AddMultipleSelectionCallback(), XMListBaseClass::AddSingleSelectionCallback(), XMArrowButton::XMArrowButton(), XMCascadeButton::XMCascadeButton(), XMPushButton::XMPushButton(), and XMToggleButton::XMToggleButton().}
{\xe \v Create\:XMWidget}
{\xe \v XMWidget\:Create}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMWidget::Create (char * {\i n}, WidgetClass {\i cl}, Widget {\i parent}, ArgList {\i l}, Cardinal {\i num_args}){\f2  [inline, protected]}}
}\par
{\bkmkstart classXMWidget_b0}
{\bkmkend classXMWidget_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 366 of file XMWidget.h.\par
\par
References id, and name.\par
Referenced by XMWidget().}
{\xe \v GetAttribute\:XMWidget}
{\xe \v XMWidget\:GetAttribute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMWidget::GetAttribute (String {\i attribute}, XtArgVal {\i value}){\f2  [inline]}}
}\par
{\bkmkstart classXMWidget_a12}
{\bkmkend classXMWidget_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 416 of file XMWidget.h.\par
\par
References id.}
{\xe \v GetAttribute\:XMWidget}
{\xe \v XMWidget\:GetAttribute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMWidget::GetAttribute (String {\i attribute}, void * {\i value}){\f2  [inline]}}
}\par
{\bkmkstart classXMWidget_a11}
{\bkmkend classXMWidget_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 414 of file XMWidget.h.\par
\par
References id.\par
Referenced by XMArrowButton::Direction(), Shell::GetGeometry(), TopLevelShell::GetIconic(), TopLevelShell::GetIconName(), XMListBaseClass::GetListCount(), XMListBaseClass::GetListValues(), Shell::GetSaveUnder(), XMListBaseClass::GetSelectedItems(), XMListBaseClass::GetSelectedListCount(), XMToggleButton::GetState(), and Shell::IsResizeAllowed().}
{\xe \v getid\:XMWidget}
{\xe \v XMWidget\:getid}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Widget XMWidget::getid (){\f2  [inline]}}
}\par
{\bkmkstart classXMWidget_a6}
{\bkmkend classXMWidget_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 404 of file XMWidget.h.\par
\par
References id.\par
Referenced by XMMenuBar::AddHelpPulldown(), XMCallback< Shell >::Register(), XMMainWindow::SetAreas(), XMCascadeButton::SetAssociatedMenu(), XMForm::SetBottomWidget(), XMForm::SetLeftWidget(), XMForm::SetRightWidget(), XMForm::SetTopWidget(), Shell::Shell(), XMCallback< Shell >::UnRegister(), XM_help(), XMAddCallback(), XMForm::XMForm(), XMMenuBar::XMMenuBar(), XMPulldown::XMPulldown(), XMRemoveCallback(), XMScrolledList::XMScrolledList(), XMScrolledText::XMScrolledText(), and XMWidget().}
{\xe \v getname\:XMWidget}
{\xe \v XMWidget\:getname}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* XMWidget::getname (){\f2  [inline]}}
}\par
{\bkmkstart classXMWidget_a8}
{\bkmkend classXMWidget_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 406 of file XMWidget.h.\par
\par
References name.\par
Referenced by XMPulldown::FindMenuItem(), and XMMenuBar::GetPulldown().}
{\xe \v getparent\:XMWidget}
{\xe \v XMWidget\:getparent}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Widget XMWidget::getparent (){\f2  [inline]}}
}\par
{\bkmkstart classXMWidget_a7}
{\bkmkend classXMWidget_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 405 of file XMWidget.h.\par
\par
References id.}
{\xe \v Manage\:XMWidget}
{\xe \v XMWidget\:Manage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMWidget::Manage (){\f2  [inline]}}
}\par
{\bkmkstart classXMWidget_a16}
{\bkmkend classXMWidget_a16}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Reimplemented in {\b XMScrolledList} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classXMScrolledList_a3 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b Shell} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classShell_a9 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 433 of file XMWidget.h.\par
\par
References id.\par
Referenced by XMHorizontalSeparator::XMHorizontalSeparator(), XMList::XMList(), XMManagedWidget::XMManagedWidget(), and XMVerticalSeparator::XMVerticalSeparator().}
{\xe \v Map\:XMWidget}
{\xe \v XMWidget\:Map}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMWidget::Map (){\f2  [inline]}}
}\par
{\bkmkstart classXMWidget_a14}
{\bkmkend classXMWidget_a14}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 431 of file XMWidget.h.\par
\par
References id.}
{\xe \v Realize\:XMWidget}
{\xe \v XMWidget\:Realize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMWidget::Realize (){\f2  [inline]}}
}\par
{\bkmkstart classXMWidget_a18}
{\bkmkend classXMWidget_a18}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Reimplemented in {\b Shell} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classShell_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 435 of file XMWidget.h.\par
\par
References id.}
{\xe \v SetAttribute\:XMWidget}
{\xe \v XMWidget\:SetAttribute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMWidget::SetAttribute (String {\i attribute}, void * {\i value}){\f2  [inline]}}
}\par
{\bkmkstart classXMWidget_a10}
{\bkmkend classXMWidget_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 411 of file XMWidget.h.\par
\par
References id.}
{\xe \v SetAttribute\:XMWidget}
{\xe \v XMWidget\:SetAttribute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMWidget::SetAttribute (String {\i attribute}, XtArgVal {\i value}){\f2  [inline]}}
}\par
{\bkmkstart classXMWidget_a9}
{\bkmkend classXMWidget_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 409 of file XMWidget.h.\par
\par
References id.\par
Referenced by XMMenuBar::AddHelpPulldown(), XMPulldown::AddMenuButton(), XMPulldown::AddMenuToggleButton(), XMRowColumn::Align(), XMBulletinBoard::AllowOverlap(), Shell::AllowResize(), XMPanedWindow::AllowResize(), XMListBaseClass::AutoSelect(), XMToggleButton::Box(), XMMainWindow::CommandWindowLocation(), XMToggleButton::Diamond(), XMButton::Disable(), XMText::DisableWordWrap(), XMButton::Enable(), XMTextField::EnableWordWrap(), XMText::EnableWordWrap(), XMToggleButton::HideIndicator(), XMButton::Label(), XMPanedWindow::Margins(), XMRowColumn::Margins(), XMFrame::Margins(), XMBulletinBoard::Margins(), XMPanedWindow::MaxPaneSize(), XMPanedWindow::MinPaneSize(), XMPulldown::NoRadioMenu(), XMRowColumn::NoRadioMenu(), XMArrowButton::PointDown(), XMArrowButton::PointLeft(), XMArrowButton::PointRight(), XMArrowButton::PointUp(), XMPulldown::RadioForceOne(), XMRowColumn::RadioForceOne(), XMPulldown::RadioMenu(), XMRowColumn::RadioMenu(), XMPulldown::RadioNoForceOne(), XMRowColumn::RadioNoForceOne(), TopLevelShell::RealizeIconic(), XMToggleButton::Set(), XMRowColumn::SetAlignment(), XMMainWindow::SetAreas(), XMCascadeButton::SetAssociatedMenu(), XMWidgetList::SetAttribute(), XMTextField::SetColumns(), XMText::SetColumns(), XMManager::SetConstraint(), XMListBaseClass::SetDoubleClickTime(), XMText::SetEditing(), XMRowColumn::SetEntryClass(), XMForm::SetFractionBase(), Shell::SetGeometry(), XMRowColumn::SetHomogenous(), XMForm::SetHorizontalSpacing(), TopLevelShell::SetIconName(), XMLabel::SetLabel(), XMTextField::SetMaxLength(), XMText::SetMaxLength(), XMButton::SetMnemonic(), XMManager::SetNavigationType(), XMSeparator::SetOrientation(), XMRowColumn::SetOrientation(), XMRowColumn::SetPacking(), XMPanedWindow::SetPaneSpacing(), XMRowColumn::SetRowColumns(), XMText::SetRows(), XMListBaseClass::SetRows(), XMForm::SetRubberPositioning(), XMPanedWindow::SetSashHeight(), XMPanedWindow::SetSashIndent(), Shell::SetSaveUnder(), XMListBaseClass::SetScrollPolicy(), XMListBaseClass::SetSelectionPolicy(), XMPanedWindow::SetSeparator(), XMSeparator::SetShadowType(), XMFrame::SetShadowType(), XMBulletinBoard::SetShadowType(), XMRowColumn::SetSpacing(), XMToggleButton::SetState(), XMForm::SetVerticalSpacing(), XMToggleButton::ShowIndicator(), XMMainWindow::ShowSeparator(), XMPanedWindow::SkipAdjust(), XMManager::TraversalOn(), XMManager::TraverseOff(), and XMToggleButton::UnSet().}
{\xe \v UnManage\:XMWidget}
{\xe \v XMWidget\:UnManage}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMWidget::UnManage (){\f2  [inline]}}
}\par
{\bkmkstart classXMWidget_a17}
{\bkmkend classXMWidget_a17}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Reimplemented in {\b XMScrolledList} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classXMScrolledList_a4 \\*MERGEFORMAT}{\fldrslt pagenum}}}), and {\b Shell} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classShell_a10 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 434 of file XMWidget.h.\par
\par
References id.\par
Referenced by XMUnmanageChild().}
{\xe \v UnMap\:XMWidget}
{\xe \v XMWidget\:UnMap}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMWidget::UnMap (){\f2  [inline]}}
}\par
{\bkmkstart classXMWidget_a15}
{\bkmkend classXMWidget_a15}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 432 of file XMWidget.h.\par
\par
References id.}
{\xe \v UnRealize\:XMWidget}
{\xe \v XMWidget\:UnRealize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMWidget::UnRealize (){\f2  [inline]}}
}\par
{\bkmkstart classXMWidget_a19}
{\bkmkend classXMWidget_a19}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 436 of file XMWidget.h.\par
\par
References id.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v id\:XMWidget}
{\xe \v XMWidget\:id}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Widget XMWidget::id{\f2  [protected]}}
}\par
{\bkmkstart classXMWidget_n0}
{\bkmkend classXMWidget_n0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 364 of file XMWidget.h.\par
\par
Referenced by XMListBaseClass::AddItem(), XMScrolledText::AddText(), XMPulldown::BuildMenu(), XMListBaseClass::ClearItems(), XMScrolledText::ClearText(), Create(), XMListBaseClass::DeleteItem(), XMListBaseClass::DeleteItems(), XMListBaseClass::DeselectAll(), XMListBaseClass::DeselectItem(), GetAttribute(), getid(), getparent(), XMTextField::GetText(), XMText::GetText(), Manage(), Shell::Manage(), XMScrolledList::Manage(), Map(), XMMenuBar::mbCreate(), Realize(), Shell::Realize(), XMListBaseClass::SelectItem(), XMButton::SetAccelerator(), SetAttribute(), XMListBaseClass::SetBottomItem(), XMScale::SetRange(), XMTextField::SetText(), XMText::SetText(), Shell::Shell(), UnManage(), Shell::UnManage(), XMScrolledList::UnManage(), UnMap(), UnRealize(), XMScale::Value(), XMForm::XMForm(), XMFrame::XMFrame(), XMMainWindow::XMMainWindow(), XMPanedWindow::XMPanedWindow(), XMRowColumn::XMRowColumn(), XMScrolledList::XMScrolledList(), XMScrolledText::XMScrolledText(), XMWidget(), and ~XMWidget().}
{\xe \v name\:XMWidget}
{\xe \v XMWidget\:name}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b XMWidgetName} XMWidget::name{\f2  [protected]}}
}\par
{\bkmkstart classXMWidget_n1}
{\bkmkend classXMWidget_n1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 365 of file XMWidget.h.\par
\par
Referenced by XMPulldown::AddMenuButton(), XMPulldown::AddMenuToggleButton(), XMPulldown::BuildMenu(), Create(), TopLevelShell::GetIconName(), getname(), XMMenuBar::mbCreate(), TopLevelShell::SetIconName(), XMForm::XMForm(), XMFrame::XMFrame(), XMMainWindow::XMMainWindow(), XMPanedWindow::XMPanedWindow(), XMRowColumn::XMRowColumn(), and XMWidget().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following file:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMWidget.h}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMWidgetList  Class Reference\par \pard\plain 
{\tc\tcl2 \v XMWidgetList}
{\xe \v XMWidgetList}
{\bkmkstart classXMWidgetList}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <XMWlist.h>}\par
Inheritance diagram for XMWidgetList:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classXMWidgetList.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b XMWidgetList} (int num=LIST_DEFAULT_SIZE)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetAttribute} (String attribute, XtArgVal value)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetAttribute} (String attribute, void *value)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v XMWidgetList\:XMWidgetList}
{\xe \v XMWidgetList\:XMWidgetList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMWidgetList::XMWidgetList (int {\i num} = LIST_DEFAULT_SIZE){\f2  [inline]}}
}\par
{\bkmkstart classXMWidgetList_a0}
{\bkmkend classXMWidgetList_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 374 of file XMWlist.h.\par
\par
References LIST_DEFAULT_SIZE.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v SetAttribute\:XMWidgetList}
{\xe \v XMWidgetList\:SetAttribute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMWidgetList::SetAttribute (String {\i attribute}, void * {\i value})}
}\par
{\bkmkstart classXMWidgetList_a2}
{\bkmkend classXMWidgetList_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 322 of file XMWlist.cpp.\par
\par
References Generic_List< XMWidget >::Exists(), Generic_List< XMWidget >::InitIteration(), Generic_List< XMWidget >::Next(), and XMWidget::SetAttribute().}
{\xe \v SetAttribute\:XMWidgetList}
{\xe \v XMWidgetList\:SetAttribute}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMWidgetList::SetAttribute (String {\i attribute}, XtArgVal {\i value})}
}\par
{\bkmkstart classXMWidgetList_a1}
{\bkmkend classXMWidgetList_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 312 of file XMWlist.cpp.\par
\par
References Generic_List< XMWidget >::Exists(), Generic_List< XMWidget >::InitIteration(), Generic_List< XMWidget >::Next(), and XMWidget::SetAttribute().\par
Referenced by XMButtonList::Disable(), and XMButtonList::Enable().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMWlist.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b XMWlist.cpp}\par
}}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CXtEventLoop  Class Reference\par \pard\plain 
{\tc\tcl2 \v CXtEventLoop}
{\xe \v CXtEventLoop}
{\bkmkstart classCXtEventLoop}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\f2 #include <CXtEventLoop.h>}\par
Inheritance diagram for CXtEventLoop:\par
{
\pard\plain 
\par\pard \qc {\field\flddirty {\*\fldinst INCLUDEPICTURE classCXtEventLoop.png \\d \\*MERGEFORMAT}{\fldrslt IMAGE}}\par
}
\par
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Public Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CXtEventLoop} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual {\b ~CXtEventLoop} ()\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Widget {\b getTopLevel} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Returns the m_TopLevel member data.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
XtAppContext {\b getAppContext} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Returns the application context.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
XrmOptionDescRec * {\b getOptionTable} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Returs a pointer to the option table.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char ** {\b getFallbackResources} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Returns a pointer to the fallback resource list.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b getApplicationClass} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Returns the application class name.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b getOptionCount} () const\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Returns the number of options in the Option list.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b exit} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Protected Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setTopLevel} (const Widget am_TopLevel)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set the value of the top level widget:.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setAppContext} (XtAppContext newContext)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Sets a new value for the application context.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setOptionTable} (XrmOptionDescRec *pTable)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set a new option table pointer.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setFallbackResources} (char **resources)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set new fallback resource list.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setApplicationClass} (const string &ClassName)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set a new application class string.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b setOptionCount} (unsigned int nCount)\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Set the number of items in the option list.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual Widget {\b InitializeApplication} (int &argc, char **argv)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b SetupApplicationResources} (Widget TopLevel)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual void {\b SetupWidgetTree} (Widget TopLevel)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Methods\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
virtual int {\b operator()} (int argc, char **argv)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CXtEventLoop} (const CXtEventLoop &aCXtEventLoop)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
CXtEventLoop & {\b operator=} (const CXtEventLoop &aCXtEventLoop)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b operator==} (const CXtEventLoop &aCXtEventLoop) const\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Private Attributes\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
Widget {\b m_TopLevel}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
XtAppContext {\b m_AppContext}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Xt application context.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
XrmOptionDescRec * {\b m_pOptionTable}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Command line option table (optional).}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
unsigned int {\b m_nOptionCount}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Number of options.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char ** {\b m_ppcFallbackResources}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Application fall back resourcelist.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
string {\b m_sClass}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Application class.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
bool {\b m_fExit}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i TRUE when supposed to exit.}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
Encapsulates an occurance of an Xt event loop.  The main loop synchronizes the event loop thread with the application each pass through the  Xt event loop e.g. the event loop looks like:\par
while(1) \{ XtGetEvent() LockMutex() XtDispatchEvent(); UnlockMutex(); yield(); // Let someone else run. \}\par
This implies that work procedures and timer procs are also synchonrized to the application. Note that this synchronization can be costly if there are work procedures continuously active. \par
\par
Definition at line 328 of file CXtEventLoop.h.\par
\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Constructor & Destructor Documentation\par
\pard\plain 
{\xe \v CXtEventLoop\:CXtEventLoop}
{\xe \v CXtEventLoop\:CXtEventLoop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CXtEventLoop::CXtEventLoop ()}
}\par
{\bkmkstart classCXtEventLoop_a0}
{\bkmkend classCXtEventLoop_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
The constructor is essentially a no-op. The base class already is checking for duplication of the singleton. We'll just let the exception pass up and through us  satisfying the condition that if an exception fires we prevent full construction.\par
The real work of initializing the Xt application is done in operator(), when we have a thread context of our own. \par
\par
Definition at line 314 of file CXtEventLoop.cpp.\par
\par
References FALSE.}
{\xe \v ~CXtEventLoop\:CXtEventLoop}
{\xe \v CXtEventLoop\:~CXtEventLoop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CXtEventLoop::~CXtEventLoop (){\f2  [virtual]}}
}\par
{\bkmkstart classCXtEventLoop_a1}
{\bkmkend classCXtEventLoop_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
In theory the application specific code will destroy all application data and objects including the Xt application context and therefore this function is also a no-op.\par
Subclasses should either replace/supplement this or tear down the Xt stuff prior to destruction. \par
\par
Definition at line 334 of file CXtEventLoop.cpp.\par
}
{\xe \v CXtEventLoop\:CXtEventLoop}
{\xe \v CXtEventLoop\:CXtEventLoop}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CXtEventLoop::CXtEventLoop (const CXtEventLoop & {\i aCXtEventLoop}){\f2  [private]}}
}\par
{\bkmkstart classCXtEventLoop_c1}
{\bkmkend classCXtEventLoop_c1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Copy construction, assignment and equality comparison are invalid and hence declared privatge and not implemented. \par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Function Documentation\par
\pard\plain 
{\xe \v exit\:CXtEventLoop}
{\xe \v CXtEventLoop\:exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CXtEventLoop::exit (){\f2  [inline]}}
}\par
{\bkmkstart classCXtEventLoop_a8}
{\bkmkend classCXtEventLoop_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 427 of file CXtEventLoop.h.\par
\par
References m_fExit, and TRUE.}
{\xe \v getAppContext\:CXtEventLoop}
{\xe \v CXtEventLoop\:getAppContext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XtAppContext CXtEventLoop::getAppContext () const{\f2  [inline]}}
}\par
{\bkmkstart classCXtEventLoop_a3}
{\bkmkend classCXtEventLoop_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns the application context.\par
\par
Definition at line 367 of file CXtEventLoop.h.\par
\par
References m_AppContext.}
{\xe \v getApplicationClass\:CXtEventLoop}
{\xe \v CXtEventLoop\:getApplicationClass}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CXtEventLoop::getApplicationClass () const{\f2  [inline]}}
}\par
{\bkmkstart classCXtEventLoop_a6}
{\bkmkend classCXtEventLoop_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns the application class name.\par
\par
Definition at line 382 of file CXtEventLoop.h.\par
\par
References m_sClass.}
{\xe \v getFallbackResources\:CXtEventLoop}
{\xe \v CXtEventLoop\:getFallbackResources}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char** CXtEventLoop::getFallbackResources () const{\f2  [inline]}}
}\par
{\bkmkstart classCXtEventLoop_a5}
{\bkmkend classCXtEventLoop_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns a pointer to the fallback resource list.\par
\par
Definition at line 377 of file CXtEventLoop.h.\par
\par
References m_ppcFallbackResources.}
{\xe \v getOptionCount\:CXtEventLoop}
{\xe \v CXtEventLoop\:getOptionCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int CXtEventLoop::getOptionCount () const{\f2  [inline]}}
}\par
{\bkmkstart classCXtEventLoop_a7}
{\bkmkend classCXtEventLoop_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns the number of options in the Option list.\par
\par
Definition at line 387 of file CXtEventLoop.h.\par
\par
References m_nOptionCount.}
{\xe \v getOptionTable\:CXtEventLoop}
{\xe \v CXtEventLoop\:getOptionTable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XrmOptionDescRec* CXtEventLoop::getOptionTable () const{\f2  [inline]}}
}\par
{\bkmkstart classCXtEventLoop_a4}
{\bkmkend classCXtEventLoop_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returs a pointer to the option table.\par
\par
Definition at line 372 of file CXtEventLoop.h.\par
\par
References m_pOptionTable.}
{\xe \v getTopLevel\:CXtEventLoop}
{\xe \v CXtEventLoop\:getTopLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Widget CXtEventLoop::getTopLevel () const{\f2  [inline]}}
}\par
{\bkmkstart classCXtEventLoop_a2}
{\bkmkend classCXtEventLoop_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Returns the m_TopLevel member data.\par
\par
Definition at line 362 of file CXtEventLoop.h.\par
\par
References m_TopLevel.}
{\xe \v InitializeApplication\:CXtEventLoop}
{\xe \v CXtEventLoop\:InitializeApplication}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Widget CXtEventLoop::InitializeApplication (int & {\i argc}, char ** {\i argv}){\f2  [protected, virtual]}}
}\par
{\bkmkstart classCXtEventLoop_b6}
{\bkmkend classCXtEventLoop_b6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called to initialize the X toolkit. Default behavior is to call XtAppinit(), and return its result.\par
A typical implementation of a subclass will might setup an options table and call setOptionTable and setOptionCount, Override the default class name via setApplicationClass, and  fill in a set of fallback resources via setFallbackResources \par
\par
Definition at line 354 of file CXtEventLoop.cpp.\par
\par
References m_AppContext, m_nOptionCount, m_pOptionTable, m_ppcFallbackResources, m_sClass, and m_TopLevel.\par
Referenced by operator()().}
{\xe \v operator()\:CXtEventLoop}
{\xe \v CXtEventLoop\:operator()}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CXtEventLoop::operator() (int {\i argc}, char ** {\i argv}){\f2  [private, virtual]}}
}\par
{\bkmkstart classCXtEventLoop_c0}
{\bkmkend classCXtEventLoop_c0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Entry point for the Xt event loop thread. The initialization functions are called to allow the application to set up the application widget set. After this is done, the event loop is entered. Each call of XtDispatchEvent is bracketed by calls to lock/unlock the application serializatio mutex.\par
Note that throughout the entire initialization of the Xt, the global mutex is held. \par
\par
Implements {\b CEventLoop} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEventLoop_c0 \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\par
Definition at line 420 of file CXtEventLoop.cpp.\par
\par
References CApplicationSerializer::getInstance(), InitializeApplication(), CThreadRecursiveMutex::Lock(), m_AppContext, m_fExit, m_TopLevel, SetupApplicationResources(), SetupWidgetTree(), and CThreadRecursiveMutex::UnLock().}
{\xe \v operator=\:CXtEventLoop}
{\xe \v CXtEventLoop\:operator=}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
CXtEventLoop& CXtEventLoop::operator= (const CXtEventLoop & {\i aCXtEventLoop}){\f2  [private]}}
}\par
{\bkmkstart classCXtEventLoop_c2}
{\bkmkend classCXtEventLoop_c2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v operator==\:CXtEventLoop}
{\xe \v CXtEventLoop\:operator==}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int CXtEventLoop::operator== (const CXtEventLoop & {\i aCXtEventLoop}) const{\f2  [private]}}
}\par
{\bkmkstart classCXtEventLoop_c3}
{\bkmkend classCXtEventLoop_c3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v setAppContext\:CXtEventLoop}
{\xe \v CXtEventLoop\:setAppContext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CXtEventLoop::setAppContext (XtAppContext {\i newContext}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCXtEventLoop_b1}
{\bkmkend classCXtEventLoop_b1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Sets a new value for the application context.\par
\par
Definition at line 398 of file CXtEventLoop.h.\par
\par
References m_AppContext.}
{\xe \v setApplicationClass\:CXtEventLoop}
{\xe \v CXtEventLoop\:setApplicationClass}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CXtEventLoop::setApplicationClass (const string & {\i ClassName}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCXtEventLoop_b4}
{\bkmkend classCXtEventLoop_b4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set a new application class string.\par
\par
Definition at line 411 of file CXtEventLoop.h.\par
\par
References m_sClass.}
{\xe \v setFallbackResources\:CXtEventLoop}
{\xe \v CXtEventLoop\:setFallbackResources}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CXtEventLoop::setFallbackResources (char ** {\i resources}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCXtEventLoop_b3}
{\bkmkend classCXtEventLoop_b3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set new fallback resource list.\par
{{{\b \par
{\b Bug: }}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid  May want to do a copy in instead of pointer copy.\par
} \par
\par
Definition at line 407 of file CXtEventLoop.h.\par
\par
References m_ppcFallbackResources.}
{\xe \v setOptionCount\:CXtEventLoop}
{\xe \v CXtEventLoop\:setOptionCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CXtEventLoop::setOptionCount (unsigned int {\i nCount}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCXtEventLoop_b5}
{\bkmkend classCXtEventLoop_b5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set the number of items in the option list.\par
\par
Definition at line 415 of file CXtEventLoop.h.\par
\par
References m_nOptionCount.}
{\xe \v setOptionTable\:CXtEventLoop}
{\xe \v CXtEventLoop\:setOptionTable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CXtEventLoop::setOptionTable (XrmOptionDescRec * {\i pTable}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCXtEventLoop_b2}
{\bkmkend classCXtEventLoop_b2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set a new option table pointer.\par
\par
Definition at line 402 of file CXtEventLoop.h.\par
\par
References m_pOptionTable.}
{\xe \v setTopLevel\:CXtEventLoop}
{\xe \v CXtEventLoop\:setTopLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CXtEventLoop::setTopLevel (const Widget {\i am_TopLevel}){\f2  [inline, protected]}}
}\par
{\bkmkstart classCXtEventLoop_b0}
{\bkmkend classCXtEventLoop_b0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Set the value of the top level widget:.\par
\par
Definition at line 393 of file CXtEventLoop.h.\par
\par
References m_TopLevel.}
{\xe \v SetupApplicationResources\:CXtEventLoop}
{\xe \v CXtEventLoop\:SetupApplicationResources}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CXtEventLoop::SetupApplicationResources (Widget {\i TopLevel}){\f2  [protected, virtual]}}
}\par
{\bkmkstart classCXtEventLoop_b7}
{\bkmkend classCXtEventLoop_b7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Called from operator() to process the resource database. Since the resource database requires definitions which are application specific but is not actually  required, the default behavior is to do nothing.\par
Normal applications will override this member toset  up resource definition structures, invoke XtGetApplicationResrouces() to retrieve the actual values from the resource database and validity check them.\par
\\ \par
\par
Definition at line 386 of file CXtEventLoop.cpp.\par
\par
Referenced by operator()().}
{\xe \v SetupWidgetTree\:CXtEventLoop}
{\xe \v CXtEventLoop\:SetupWidgetTree}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void CXtEventLoop::SetupWidgetTree (Widget {\i TopLevel}){\f2  [protected, virtual]}}
}\par
{\bkmkstart classCXtEventLoop_b8}
{\bkmkend classCXtEventLoop_b8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
operator() calls this function to set up the initial widget tree.\par
This is completely application specific. Most applications will require a widget tree in addition to the shell widget produced by XtAppInitialize(). This member should be overridden to produce this tree. \par
\par
Definition at line 401 of file CXtEventLoop.cpp.\par
\par
Referenced by operator()().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Member Data Documentation\par
\pard\plain 
{\xe \v m_AppContext\:CXtEventLoop}
{\xe \v CXtEventLoop\:m_AppContext}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XtAppContext CXtEventLoop::m_AppContext{\f2  [private]}}
}\par
{\bkmkstart classCXtEventLoop_o1}
{\bkmkend classCXtEventLoop_o1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Xt application context.\par
\par
Definition at line 336 of file CXtEventLoop.h.\par
\par
Referenced by getAppContext(), InitializeApplication(), operator()(), and setAppContext().}
{\xe \v m_fExit\:CXtEventLoop}
{\xe \v CXtEventLoop\:m_fExit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
bool CXtEventLoop::m_fExit{\f2  [private]}}
}\par
{\bkmkstart classCXtEventLoop_o6}
{\bkmkend classCXtEventLoop_o6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
TRUE when supposed to exit.\par
\par
Definition at line 342 of file CXtEventLoop.h.\par
\par
Referenced by exit(), and operator()().}
{\xe \v m_nOptionCount\:CXtEventLoop}
{\xe \v CXtEventLoop\:m_nOptionCount}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
unsigned int CXtEventLoop::m_nOptionCount{\f2  [private]}}
}\par
{\bkmkstart classCXtEventLoop_o3}
{\bkmkend classCXtEventLoop_o3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Number of options.\par
\par
Definition at line 339 of file CXtEventLoop.h.\par
\par
Referenced by getOptionCount(), InitializeApplication(), and setOptionCount().}
{\xe \v m_pOptionTable\:CXtEventLoop}
{\xe \v CXtEventLoop\:m_pOptionTable}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XrmOptionDescRec* CXtEventLoop::m_pOptionTable{\f2  [private]}}
}\par
{\bkmkstart classCXtEventLoop_o2}
{\bkmkend classCXtEventLoop_o2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Command line option table (optional).\par
\par
Definition at line 338 of file CXtEventLoop.h.\par
\par
Referenced by getOptionTable(), InitializeApplication(), and setOptionTable().}
{\xe \v m_ppcFallbackResources\:CXtEventLoop}
{\xe \v CXtEventLoop\:m_ppcFallbackResources}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char** CXtEventLoop::m_ppcFallbackResources{\f2  [private]}}
}\par
{\bkmkstart classCXtEventLoop_o4}
{\bkmkend classCXtEventLoop_o4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Application fall back resourcelist.\par
\par
Definition at line 340 of file CXtEventLoop.h.\par
\par
Referenced by getFallbackResources(), InitializeApplication(), and setFallbackResources().}
{\xe \v m_sClass\:CXtEventLoop}
{\xe \v CXtEventLoop\:m_sClass}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
string CXtEventLoop::m_sClass{\f2  [private]}}
}\par
{\bkmkstart classCXtEventLoop_o5}
{\bkmkend classCXtEventLoop_o5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Application class.\par
\par
Definition at line 341 of file CXtEventLoop.h.\par
\par
Referenced by getApplicationClass(), InitializeApplication(), and setApplicationClass().}
{\xe \v m_TopLevel\:CXtEventLoop}
{\xe \v CXtEventLoop\:m_TopLevel}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
Widget CXtEventLoop::m_TopLevel{\f2  [private]}}
}\par
{\bkmkstart classCXtEventLoop_o0}
{\bkmkend classCXtEventLoop_o0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
m_TopLevel is the top level of the application's widget hierarchy. in order to use the Xm++ library it will be necessary to retrieve this and instantiate Widget object from it. \par
\par
Definition at line 335 of file CXtEventLoop.h.\par
\par
Referenced by getTopLevel(), InitializeApplication(), operator()(), and setTopLevel().}
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
The documentation for this class was generated from the following files:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CXtEventLoop.h}\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CXtEventLoop.cpp}\par
}}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Spectrodaq External Event Framework File Documentation{\tc \v File Documentation}
\par \pard\plain 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
BufferEvent.oxy File Reference\par \pard\plain 
{\tc\tcl2 \v BufferEvent.oxy}
{\xe \v BufferEvent.oxy}
{\bkmkstart BufferEvent_8oxy}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid \par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CAlarmLogger.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CAlarmLogger.cpp}
{\xe \v CAlarmLogger.cpp}
{\bkmkstart CAlarmLogger_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CAlarmLogger.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <pwd.h>}\par
{\f2 #include <sys/types.h>}\par
{\f2 #include <CDuplicateNameException.h>}\par
{\f2 #include <CNoSuchObjectException.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CAlarmLogger.cpp}
{\xe \v CAlarmLogger.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CAlarmLogger_8cpp_a0}
{\bkmkend CAlarmLogger_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CAlarmLogger.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CAlarmLogger.h File Reference\par \pard\plain 
{\tc\tcl2 \v CAlarmLogger.h}
{\xe \v CAlarmLogger.h}
{\bkmkstart CAlarmLogger_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CSocket.h>}\par
{\f2 #include <spectrodaq.h>}\par
{\f2 #include <SpectroFramework.h>}\par
{\f2 #include <sys/time.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Namespaces\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
namespace {\b std}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CAlarmLogger}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CApplicationRegistry.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CApplicationRegistry.cpp}
{\xe \v CApplicationRegistry.cpp}
{\bkmkstart CApplicationRegistry_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CApplicationRegistry.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CApplicationRegistry.cpp}
{\xe \v CApplicationRegistry.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CApplicationRegistry_8cpp_a0}
{\bkmkend CApplicationRegistry_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CApplicationRegistry.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CApplicationRegistry.h File Reference\par \pard\plain 
{\tc\tcl2 \v CApplicationRegistry.h}
{\xe \v CApplicationRegistry.h}
{\bkmkstart CApplicationRegistry_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CClassifiedObjectRegistry.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CApplicationRegistry}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CApplicationSerializer.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CApplicationSerializer.cpp}
{\xe \v CApplicationSerializer.cpp}
{\bkmkstart CApplicationSerializer_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CApplicationSerializer.h"}\par
{\f2 #include <assert.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NULL}\~ 0\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v NULL\:CApplicationSerializer.cpp}
{\xe \v CApplicationSerializer.cpp\:NULL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NULL\~ 0}
}\par
{\bkmkstart CApplicationSerializer_8cpp_a0}
{\bkmkend CApplicationSerializer_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 285 of file CApplicationSerializer.cpp.\par
\par
Referenced by CApplicationSerializer::CApplicationSerializer(), and CApplicationSerializer::~CApplicationSerializer().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CApplicationSerializer.cpp}
{\xe \v CApplicationSerializer.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CApplicationSerializer_8cpp_a1}
{\bkmkend CApplicationSerializer_8cpp_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CApplicationSerializer.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CApplicationSerializer.h File Reference\par \pard\plain 
{\tc\tcl2 \v CApplicationSerializer.h}
{\xe \v CApplicationSerializer.h}
{\bkmkstart CApplicationSerializer_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CThreadRecursiveMutex.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CApplicationSerializer}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CArrayBinding.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CArrayBinding.cpp}
{\xe \v CArrayBinding.cpp}
{\bkmkstart CArrayBinding_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CArrayBinding.h>}\par
{\f2 #include <TCLVariable.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <stdlib.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <fstream.h>}\par
\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CArrayBinding.h File Reference\par \pard\plain 
{\tc\tcl2 \v CArrayBinding.h}
{\xe \v CArrayBinding.h}
{\bkmkstart CArrayBinding_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <TCLInterpreter.h>}\par
{\f2 #include "CArrayBinding.cpp"}\par
{\f2 #include <CBinding.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CArrayBinding}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CAssocArrayBinding.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CAssocArrayBinding.cpp}
{\xe \v CAssocArrayBinding.cpp}
{\bkmkstart CAssocArrayBinding_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CAssocArrayBinding.h>}\par
{\f2 #include <tcl.h>}\par
{\f2 #include <TCLList.h>}\par
{\f2 #include <TCLException.h>}\par
{\f2 #include <TCLInterpreter.h>}\par
{\f2 #include <vector>}\par
{\f2 #include <iostream.h>}\par
{\f2 #include <fstream.h>}\par
{\f2 #include <stdlib.h>}\par
\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CAssocArrayBinding.h File Reference\par \pard\plain 
{\tc\tcl2 \v CAssocArrayBinding.h}
{\xe \v CAssocArrayBinding.h}
{\bkmkstart CAssocArrayBinding_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <TCLInterpreter.h>}\par
{\f2 #include "CAssocArrayBinding.cpp"}\par
{\f2 #include <CBinding.h>}\par
{\f2 #include <map>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CAssocArrayBinding}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CBinding.h File Reference\par \pard\plain 
{\tc\tcl2 \v CBinding.h}
{\xe \v CBinding.h}
{\bkmkstart CBinding_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <TCLInterpreter.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <CTypeFreeBinding.h>}\par
{\f2 #include <typeinfo>}\par
{\f2 #include <string>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CBinding}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CBufferEvent.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CBufferEvent.cpp}
{\xe \v CBufferEvent.cpp}
{\bkmkstart CBufferEvent_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CBufferEvent.h"}\par
{\f2 #include <stdio.h>}\par
\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
\par
\\class {\b CBufferEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferEvent \\*MERGEFORMAT}{\fldrslt pagenum}}}) abstract template Provides an ABC for building application level objects to react to SpectroDaq Buffers. This is an abstract, templated class which is templated by the type of buffer whch can be received. Note that depending on how this is constructed,, The object can handle alarm events instead of data buffers.\par
\par
Definition in file {\b CBufferEvent.cpp}.\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CBufferEvent.h File Reference\par \pard\plain 
{\tc\tcl2 \v CBufferEvent.h}
{\xe \v CBufferEvent.h}
{\bkmkstart CBufferEvent_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CEvent.h"}\par
{\f2 #include <CBufferMonitor.h>}\par
{\f2 #include <CBufferReactor.h>}\par
{\f2 #include "CBufferEvent.cpp"}\par
{\f2 #include <spectrodaq.h>}\par
{\f2 #include <CApplicationSerializer.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b AddLinkRequest}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i Form of request to add a link to the link manager.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CBufferEvent}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i \\class: CBufferEvent \\file: {\b CBufferEvent.h}.}\par
\par}
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CGenericBufferReactor}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CBufferMonitor.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CBufferMonitor.cpp}
{\xe \v CBufferMonitor.cpp}
{\bkmkstart CBufferMonitor_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CBufferMonitor.h>}\par
\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CBufferMonitor.h File Reference\par \pard\plain 
{\tc\tcl2 \v CBufferMonitor.h}
{\xe \v CBufferMonitor.h}
{\bkmkstart CBufferMonitor_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CClassifiedObjectRegistry.h>}\par
{\f2 #include <CNoSuchLinkException.h>}\par
{\f2 #include <CLinkFailedException.h>}\par
{\f2 #include <spectrodaq.h>}\par
{\f2 #include <CBufferMonitor.cpp>}\par
{\f2 #include "CEventMonitor.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CBufferMonitor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b LinkInfo}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MatchAll}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b MatchURL}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef list< struct {\b LinkInfo} >::iterator {\b LinkIterator}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b CBufferMonitor}< Byte > {\b CByteBufferMonitor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b CBufferMonitor}< Word > {\b CWordBufferMonitor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b CBufferMonitor}< DWord > {\b CLongBufferMonitor}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v CByteBufferMonitor\:CBufferMonitor.h}
{\xe \v CBufferMonitor.h\:CByteBufferMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b CBufferMonitor}<Byte> CByteBufferMonitor}
}\par
{\bkmkstart CBufferMonitor_8h_a1}
{\bkmkend CBufferMonitor_8h_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 483 of file CBufferMonitor.h.\par
}
{\xe \v CLongBufferMonitor\:CBufferMonitor.h}
{\xe \v CBufferMonitor.h\:CLongBufferMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b CBufferMonitor}<DWord> CLongBufferMonitor}
}\par
{\bkmkstart CBufferMonitor_8h_a3}
{\bkmkend CBufferMonitor_8h_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 485 of file CBufferMonitor.h.\par
}
{\xe \v CWordBufferMonitor\:CBufferMonitor.h}
{\xe \v CBufferMonitor.h\:CWordBufferMonitor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b CBufferMonitor}<Word> CWordBufferMonitor}
}\par
{\bkmkstart CBufferMonitor_8h_a2}
{\bkmkend CBufferMonitor_8h_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 484 of file CBufferMonitor.h.\par
}
{\xe \v LinkIterator\:CBufferMonitor.h}
{\xe \v CBufferMonitor.h\:LinkIterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef list<struct {\b LinkInfo}>::iterator LinkIterator}
}\par
{\bkmkstart CBufferMonitor_8h_a0}
{\bkmkend CBufferMonitor_8h_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 339 of file CBufferMonitor.h.\par
\par
Referenced by CBufferMonitor< T >::DescribeSelf(), CBufferMonitor< T >::FindLink(), CBufferEvent< T >::ProcessDelQueue(), and CBufferMonitor< T >::RemoveLink().}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CBufferReactor.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CBufferReactor.cpp}
{\xe \v CBufferReactor.cpp}
{\bkmkstart CBufferReactor_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CBufferReactor.h"}\par
{\f2 #include <spectrodaq.h>}\par
{\f2 #include <CEventMonitor.h>}\par
{\f2 #include <CBufferMonitor.h>}\par
{\f2 #include <CIncompatibleMonitor.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <typeinfo>}\par
\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CBufferReactor.h File Reference\par \pard\plain 
{\tc\tcl2 \v CBufferReactor.h}
{\xe \v CBufferReactor.h}
{\bkmkstart CBufferReactor_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CReactor.h"}\par
{\f2 #include <spectrodaq.h>}\par
{\f2 #include <CBufferReactor.cpp>}\par
{\f2 #include <CBufferMonitor.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CBufferReactor}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b CBufferReactor}< Byte > {\b CByteBufferReactor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b CBufferReactor}< Word > {\b CWordBufferReactor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b CBufferReactor}< DWord > {\b CLongBufferReactor}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v CByteBufferReactor\:CBufferReactor.h}
{\xe \v CBufferReactor.h\:CByteBufferReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b CBufferReactor}<Byte> CByteBufferReactor}
}\par
{\bkmkstart CBufferReactor_8h_a0}
{\bkmkend CBufferReactor_8h_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 361 of file CBufferReactor.h.\par
}
{\xe \v CLongBufferReactor\:CBufferReactor.h}
{\xe \v CBufferReactor.h\:CLongBufferReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b CBufferReactor}<DWord> CLongBufferReactor}
}\par
{\bkmkstart CBufferReactor_8h_a2}
{\bkmkend CBufferReactor_8h_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 363 of file CBufferReactor.h.\par
}
{\xe \v CWordBufferReactor\:CBufferReactor.h}
{\xe \v CBufferReactor.h\:CWordBufferReactor}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b CBufferReactor}<Word> CWordBufferReactor}
}\par
{\bkmkstart CBufferReactor_8h_a1}
{\bkmkend CBufferReactor_8h_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 362 of file CBufferReactor.h.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CChangedPredicate.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CChangedPredicate.cpp}
{\xe \v CChangedPredicate.cpp}
{\bkmkstart CChangedPredicate_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CChangedPredicate.h>}\par
\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CChangedPredicate.h File Reference\par \pard\plain 
{\tc\tcl2 \v CChangedPredicate.h}
{\xe \v CChangedPredicate.h}
{\bkmkstart CChangedPredicate_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CPointerPredicate.h"}\par
{\f2 #include <CChangedPredicate.cpp>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CChangedPredicate}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CClassifiedObjectRegistry.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CClassifiedObjectRegistry.cpp}
{\xe \v CClassifiedObjectRegistry.cpp}
{\bkmkstart CClassifiedObjectRegistry_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CClassifiedObjectRegistry.h"}\par
{\f2 #include "CDuplicateNameException.h"}\par
{\f2 #include "CNoSuchObjectException.h"}\par
{\f2 #include <string>}\par
{\f2 #include <map>}\par
{\f2 #include <list>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CClassifiedObjectRegistry.cpp}
{\xe \v CClassifiedObjectRegistry.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CClassifiedObjectRegistry_8cpp_a0}
{\bkmkend CClassifiedObjectRegistry_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CClassifiedObjectRegistry.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CClassifiedObjectRegistry.h File Reference\par \pard\plain 
{\tc\tcl2 \v CClassifiedObjectRegistry.h}
{\xe \v CClassifiedObjectRegistry.h}
{\bkmkstart CClassifiedObjectRegistry_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CNamedObject.h"}\par
{\f2 #include "CObjectRegistry.h"}\par
{\f2 #include "CRefptr.h"}\par
{\f2 #include <list>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CClassifiedObjectRegistry}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef map< string, {\b CObjectRegistry} >::iterator {\b RegistryIterator}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef list< {\b CNamedObject} * > {\b ObjectList}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v ObjectList\:CClassifiedObjectRegistry.h}
{\xe \v CClassifiedObjectRegistry.h\:ObjectList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef list<{\b CNamedObject}*> ObjectList}
}\par
{\bkmkstart CClassifiedObjectRegistry_8h_a1}
{\bkmkend CClassifiedObjectRegistry_8h_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 322 of file CClassifiedObjectRegistry.h.\par
\par
Referenced by CClassifiedObjectRegistry::Find().}
{\xe \v RegistryIterator\:CClassifiedObjectRegistry.h}
{\xe \v CClassifiedObjectRegistry.h\:RegistryIterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef map<string, {\b CObjectRegistry}>::iterator RegistryIterator}
}\par
{\bkmkstart CClassifiedObjectRegistry_8h_a0}
{\bkmkend CClassifiedObjectRegistry_8h_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
ObjectRegistry.h:\par
This file defines the {\b CClassifiedObjectRegistry} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCClassifiedObjectRegistry \\*MERGEFORMAT}{\fldrslt pagenum}}}) class.\par
Author: Jason Venema NSCL Michigan State University East Lansing, MI 48824-1321 mailto:{\f2 venemaja@msu.edu} \par
\par
Definition at line 321 of file CClassifiedObjectRegistry.h.\par
\par
Referenced by CClassifiedObjectRegistry::Add(), CClassifiedObjectRegistry::DescribeSelf(), CClassifiedObjectRegistry::Find(), and CClassifiedObjectRegistry::Remove().}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CConfigurationManager.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CConfigurationManager.cpp}
{\xe \v CConfigurationManager.cpp}
{\bkmkstart CConfigurationManager_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CConfigurationManager.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <sys/types.h>}\par
{\f2 #include <sys/stat.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include <ErrnoException.h>}\par
{\f2 #include <TCLException.h>}\par
{\f2 #include <time.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <algorithm>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CCommit}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CDumpBinding}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CInitBinding}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CShutdownBinding}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char {\b PathSep} = '/'\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CConfigurationManager.cpp}
{\xe \v CConfigurationManager.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CConfigurationManager_8cpp_a0}
{\bkmkend CConfigurationManager_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CConfigurationManager.cpp.\par
}
{\xe \v PathSep\:CConfigurationManager.cpp}
{\xe \v CConfigurationManager.cpp\:PathSep}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char PathSep = '/'{\f2  [static]}}
}\par
{\bkmkstart CConfigurationManager_8cpp_a1}
{\bkmkend CConfigurationManager_8cpp_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 303 of file CConfigurationManager.cpp.\par
\par
Referenced by CConfigurationManager::Read1stConfigFile(), and CConfigurationManager::ReadAllConfigFiles().}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CConfigurationManager.h File Reference\par \pard\plain 
{\tc\tcl2 \v CConfigurationManager.h}
{\xe \v CConfigurationManager.h}
{\bkmkstart CConfigurationManager_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CTypeFreeBinding.h>}\par
{\f2 #include <list>}\par
{\f2 #include <vector>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CConfigurationManager}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CDAQTCLProcessor.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CDAQTCLProcessor.cpp}
{\xe \v CDAQTCLProcessor.cpp}
{\bkmkstart CDAQTCLProcessor_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CDAQTCLProcessor.h"}\par
{\f2 #include "CApplicationSerializer.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CDAQTCLProcessor.cpp}
{\xe \v CDAQTCLProcessor.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CDAQTCLProcessor_8cpp_a0}
{\bkmkend CDAQTCLProcessor_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CDAQTCLProcessor.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CDAQTCLProcessor.h File Reference\par \pard\plain 
{\tc\tcl2 \v CDAQTCLProcessor.h}
{\xe \v CDAQTCLProcessor.h}
{\bkmkstart CDAQTCLProcessor_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TCLProcessor.h"}\par
{\f2 #include <string>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CDAQTCLProcessor}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CDuplicateNameException.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CDuplicateNameException.cpp}
{\xe \v CDuplicateNameException.cpp}
{\bkmkstart CDuplicateNameException_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CDuplicateNameException.h"}\par
{\f2 #include <string.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CDuplicateNameException.cpp}
{\xe \v CDuplicateNameException.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CDuplicateNameException_8cpp_a0}
{\bkmkend CDuplicateNameException_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CDuplicateNameException.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CDuplicateNameException.h File Reference\par \pard\plain 
{\tc\tcl2 \v CDuplicateNameException.h}
{\xe \v CDuplicateNameException.h}
{\bkmkstart CDuplicateNameException_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <histotypes.h>}\par
{\f2 #include "Exception.h"}\par
{\f2 #include <string>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CDuplicateNameException}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CDuplicateSingleton.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CDuplicateSingleton.cpp}
{\xe \v CDuplicateSingleton.cpp}
{\bkmkstart CDuplicateSingleton_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CDuplicateSingleton.h"}\par
{\f2 #include <string.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CDuplicateSingleton.cpp}
{\xe \v CDuplicateSingleton.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CDuplicateSingleton_8cpp_a0}
{\bkmkend CDuplicateSingleton_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CDuplicateSingleton.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CDuplicateSingleton.h File Reference\par \pard\plain 
{\tc\tcl2 \v CDuplicateSingleton.h}
{\xe \v CDuplicateSingleton.h}
{\bkmkstart CDuplicateSingleton_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <histotypes.h>}\par
{\f2 #include "Exception.h"}\par
{\f2 #include <string>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CDuplicateSingleton}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CErrnoException.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CErrnoException.cpp}
{\xe \v CErrnoException.cpp}
{\bkmkstart CErrnoException_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CErrnoException.h"}\par
{\f2 #include <errno.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CErrnoException.cpp}
{\xe \v CErrnoException.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright{\f2  [static]}}
}\par
{\bkmkstart CErrnoException_8cpp_a0}
{\bkmkend CErrnoException_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \par
"CErrnoException.cpp: Copyright 1999 NSCL, All rights reserved\\n"\par
}
Encapsulates exceptions which are thrown due to bad errno values. \par
\par
Definition at line 304 of file CErrnoException.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CErrnoException.h File Reference\par \pard\plain 
{\tc\tcl2 \v CErrnoException.h}
{\xe \v CErrnoException.h}
{\bkmkstart CErrnoException_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CException.h"}\par
{\f2 #include <histotypes.h>}\par
{\f2 #include <errno.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CErrnoException}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CEvent.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CEvent.cpp}
{\xe \v CEvent.cpp}
{\bkmkstart CEvent_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CEvent.h"}\par
{\f2 #include <CEventMonitor.h>}\par
{\f2 #include <CApplicationRegistry.h>}\par
{\f2 #include <CApplicationSerializer.h>}\par
{\f2 #include <CReactor.h>}\par
{\f2 #include <spectrodaq.h>}\par
{\f2 #include <unistd.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b StartEventThread}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const string {\b RegistryName} = "Events"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const unsigned long {\b StartupDelayuSec} = 100000\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
\par
\\class {\b CEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent \\*MERGEFORMAT}{\fldrslt pagenum}}})  Encapsulates event handling. Events consist of an event monitor which is responsible for determining when an event fires and a reactor which provides application specific handling of the event.  When enabled, the event will schedule a thread m_EventThread to process the event. The event thread contains code to repeatedly calll the monitor's operator(), lock the global mutex and call the reactor's operator(). The reactors provided with  classes derived from this are generally standardized to invoke Subclass virtual function which are specific to the event being managed..\par
\par
Definition in file {\b CEvent.cpp}.{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CEvent.cpp}
{\xe \v CEvent.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CEvent_8cpp_a0}
{\bkmkend CEvent_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CEvent.cpp.\par
}
{\xe \v RegistryName\:CEvent.cpp}
{\xe \v CEvent.cpp\:RegistryName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const string RegistryName = "Events"{\f2  [static]}}
}\par
{\bkmkstart CEvent_8cpp_a1}
{\bkmkend CEvent_8cpp_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 305 of file CEvent.cpp.\par
\par
Referenced by CEvent::CEvent().}
{\xe \v StartupDelayuSec\:CEvent.cpp}
{\xe \v CEvent.cpp\:StartupDelayuSec}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const unsigned long StartupDelayuSec = 100000{\f2  [static]}}
}\par
{\bkmkstart CEvent_8cpp_a2}
{\bkmkend CEvent_8cpp_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 306 of file CEvent.cpp.\par
\par
Referenced by StartEventThread::operator()().}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CEvent.h File Reference\par \pard\plain 
{\tc\tcl2 \v CEvent.h}
{\xe \v CEvent.h}
{\bkmkstart CEvent_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <spectrodaq.h>}\par
{\f2 #include "CRegisteredObject.h"}\par
{\f2 #include <CEventMonitor.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CEvent}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CEventLoop.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CEventLoop.cpp}
{\xe \v CEventLoop.cpp}
{\bkmkstart CEventLoop_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CEventLoop.h"}\par
{\f2 #include "CDuplicateSingleton.h"}\par
{\f2 #include "CNoSuchObjectException.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
\par
\\class {\b CEventLoop} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEventLoop \\*MERGEFORMAT}{\fldrslt pagenum}}}) abstract  Encapsulates within a thread an application library which  runs it's own event loop. Examples are Xt and Tcl/Tk. These systems include their own mechanisms for detecting and dispatching events to application and framework specific code.\par
Attempting to instantiate more than one instance of an event  loop derived object results in a CDuplicateSingelton exception. Event loop derived processes implement operator() to  initiate an event loop how they are used depends on the iindividual framework. Each of these event loops is supposed to ensure that event dispatching to application level code is synchronized through the application's mutex. It is legal to synchronize all such events or an "appropriate subset".\par
\par
Definition in file {\b CEventLoop.cpp}.{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CEventLoop.cpp}
{\xe \v CEventLoop.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CEventLoop_8cpp_a0}
{\bkmkend CEventLoop_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CEventLoop.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CEventLoop.h File Reference\par \pard\plain 
{\tc\tcl2 \v CEventLoop.h}
{\xe \v CEventLoop.h}
{\bkmkstart CEventLoop_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <spectrodaq.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CEventLoop}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CEventMonitor.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CEventMonitor.cpp}
{\xe \v CEventMonitor.cpp}
{\bkmkstart CEventMonitor_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CEventMonitor.h"}\par
{\f2 #include <CApplicationRegistry.h>}\par
{\f2 #include <stdio.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const string {\b RegistryName} = "Monitors"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
\par
CEventmonitor is the abstract base class for Event Monitors. An Event monitor provides event specific logic for waiting for external program events. operator() is expected to wait for an event to occur and return to indicate if the event  in fact did occur.\par
Author: Jason Venema NSCL Michigan State University East Lansing, MI 48824-1321 mailto:{\f2 venemaja@msu.edu}\par
\par
Definition in file {\b CEventMonitor.cpp}.{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CEventMonitor.cpp}
{\xe \v CEventMonitor.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CEventMonitor_8cpp_a0}
{\bkmkend CEventMonitor_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CEventMonitor.cpp.\par
}
{\xe \v RegistryName\:CEventMonitor.cpp}
{\xe \v CEventMonitor.cpp\:RegistryName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const string RegistryName = "Monitors"{\f2  [static]}}
}\par
{\bkmkstart CEventMonitor_8cpp_a1}
{\bkmkend CEventMonitor_8cpp_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 299 of file CEventMonitor.cpp.\par
\par
Referenced by CEventMonitor::CEventMonitor(), and CEventMonitor::~CEventMonitor().}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CEventMonitor.h File Reference\par \pard\plain 
{\tc\tcl2 \v CEventMonitor.h}
{\xe \v CEventMonitor.h}
{\bkmkstart CEventMonitor_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <sys/time.h>}\par
{\f2 #include <climits>}\par
{\f2 #include <CRegisteredObject.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CEventMonitor}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b FOREVER} = INT_MAX\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b COS_ALLBITS} = 0xffffffff\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b COS_MAXBUFTAG} = 0x00ffffff\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v COS_ALLBITS\:CEventMonitor.h}
{\xe \v CEventMonitor.h\:COS_ALLBITS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int COS_ALLBITS = 0xffffffff{\f2  [static]}}
}\par
{\bkmkstart CEventMonitor_8h_a1}
{\bkmkend CEventMonitor_8h_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 313 of file CEventMonitor.h.\par
}
{\xe \v COS_MAXBUFTAG\:CEventMonitor.h}
{\xe \v CEventMonitor.h\:COS_MAXBUFTAG}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int COS_MAXBUFTAG = 0x00ffffff{\f2  [static]}}
}\par
{\bkmkstart CEventMonitor_8h_a2}
{\bkmkend CEventMonitor_8h_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 314 of file CEventMonitor.h.\par
}
{\xe \v FOREVER\:CEventMonitor.h}
{\xe \v CEventMonitor.h\:FOREVER}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int FOREVER = INT_MAX{\f2  [static]}}
}\par
{\bkmkstart CEventMonitor_8h_a0}
{\bkmkend CEventMonitor_8h_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Author: Jason Venema NSCL Michigan State University East Lansing, MI 48824-1321 mailto:{\f2 venemaja@msu.edu} \par
\par
Definition at line 312 of file CEventMonitor.h.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CException.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CException.cpp}
{\xe \v CException.cpp}
{\bkmkstart CException_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CException.h"}\par
{\f2 #include <string.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CException.cpp}
{\xe \v CException.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright{\f2  [static]}}
}\par
{\bkmkstart CException_8cpp_a0}
{\bkmkend CException_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \par
"CException.cpp: Copyright 1999 NSCL, All rights reserved\\n"\par
}
Definition at line 306 of file CException.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CException.h File Reference\par \pard\plain 
{\tc\tcl2 \v CException.h}
{\xe \v CException.h}
{\bkmkstart CException_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <histotypes.h>}\par
{\f2 #include <string>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CException}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CFdMonitor.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CFdMonitor.cpp}
{\xe \v CFdMonitor.cpp}
{\bkmkstart CFdMonitor_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CFdMonitor.h"}\par
{\f2 #include <stdio.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
\par
\\class {\b CFdMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFdMonitor \\*MERGEFORMAT}{\fldrslt pagenum}}}) Monitors activity on a file descriptor. A file descriptior can be monitored for the logical or of any of the following conditions: Readable Writable Exception\par
Monitoring is done via the select(2) system service. Note that this can yield some unexpected results. For example, in some operating systems, tape drives are never considered readable without blocking.\par
Author: Jason Venema NSCL Michigan State University East Lansing, MI 48824-1321 mailto:{\f2 venemaja@msu.edu}\par
\par
Definition in file {\b CFdMonitor.cpp}.{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CFdMonitor.cpp}
{\xe \v CFdMonitor.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CFdMonitor_8cpp_a0}
{\bkmkend CFdMonitor_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CFdMonitor.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CFdMonitor.h File Reference\par \pard\plain 
{\tc\tcl2 \v CFdMonitor.h}
{\xe \v CFdMonitor.h}
{\bkmkstart CFdMonitor_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <sys/time.h>}\par
{\f2 #include <sys/types.h>}\par
{\f2 #include <sys/select.h>}\par
{\f2 #include "CEventMonitor.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CFdMonitor}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CFdReactor.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CFdReactor.cpp}
{\xe \v CFdReactor.cpp}
{\bkmkstart CFdReactor_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CFdReactor.h"}\par
{\f2 #include "CFdMonitor.h"}\par
{\f2 #include <string>}\par
{\f2 #include <CIncompatibleMonitor.h>}\par
{\f2 #include <typeinfo>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CFdReactor.cpp}
{\xe \v CFdReactor.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CFdReactor_8cpp_a0}
{\bkmkend CFdReactor_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CFdReactor.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CFdReactor.h File Reference\par \pard\plain 
{\tc\tcl2 \v CFdReactor.h}
{\xe \v CFdReactor.h}
{\bkmkstart CFdReactor_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CReactor.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CFdReactor}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CFileEvent.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CFileEvent.cpp}
{\xe \v CFileEvent.cpp}
{\bkmkstart CFileEvent_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CFileEvent.h>}\par
{\f2 #include <CApplicationSerializer.h>}\par
{\f2 #include <iostream.h>}\par
{\f2 #include <fstream.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <ErrnoException.h>}\par
{\f2 #include <stdio.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CFileEvent.cpp}
{\xe \v CFileEvent.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CFileEvent_8cpp_a0}
{\bkmkend CFileEvent_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CFileEvent.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CFileEvent.h File Reference\par \pard\plain 
{\tc\tcl2 \v CFileEvent.h}
{\xe \v CFileEvent.h}
{\bkmkstart CFileEvent_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <sys/types.h>}\par
{\f2 #include <sys/stat.h>}\par
{\f2 #include <fcntl.h>}\par
{\f2 #include "CEvent.h"}\par
{\f2 #include <CFdReactor.h>}\par
{\f2 #include <CFdMonitor.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CFileEvent}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CFileEventReactor}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b __CRT_FCTNL_H}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i \\class: {\b CFileEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFileEvent \\*MERGEFORMAT}{\fldrslt pagenum}}}) \\file: {\b CFileEvent.h}.}\par
\par}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v __CRT_FCTNL_H\:CFileEvent.h}
{\xe \v CFileEvent.h\:__CRT_FCTNL_H}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define __CRT_FCTNL_H}
}\par
{\bkmkstart CFileEvent_8h_a0}
{\bkmkend CFileEvent_8h_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\\class: {\b CFileEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFileEvent \\*MERGEFORMAT}{\fldrslt pagenum}}}) \\file: {\b CFileEvent.h}.\par
\par
Definition at line 322 of file CFileEvent.h.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CIncompatibleMonitor.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CIncompatibleMonitor.cpp}
{\xe \v CIncompatibleMonitor.cpp}
{\bkmkstart CIncompatibleMonitor_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CIncompatibleMonitor.h>}\par
{\f2 #include <CEventMonitor.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CIncompatibleMonitor.cpp}
{\xe \v CIncompatibleMonitor.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CIncompatibleMonitor_8cpp_a0}
{\bkmkend CIncompatibleMonitor_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CIncompatibleMonitor.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CIncompatibleMonitor.h File Reference\par \pard\plain 
{\tc\tcl2 \v CIncompatibleMonitor.h}
{\xe \v CIncompatibleMonitor.h}
{\bkmkstart CIncompatibleMonitor_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <Exception.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CIncompatibleMonitor}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CInterpreterStartup.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CInterpreterStartup.cpp}
{\xe \v CInterpreterStartup.cpp}
{\bkmkstart CInterpreterStartup_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CInterpreterStartup.h"}\par
{\f2 #include "TCLInterpreter.h"}\par
{\f2 #include "CTCLSynchronizeCommand.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CInterpreterStartup.cpp}
{\xe \v CInterpreterStartup.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CInterpreterStartup_8cpp_a0}
{\bkmkend CInterpreterStartup_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CInterpreterStartup.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CInterpreterStartup.h File Reference\par \pard\plain 
{\tc\tcl2 \v CInterpreterStartup.h}
{\xe \v CInterpreterStartup.h}
{\bkmkstart CInterpreterStartup_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CEventLoop.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CInterpreterStartup}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CLinkFailedException.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CLinkFailedException.cpp}
{\xe \v CLinkFailedException.cpp}
{\bkmkstart CLinkFailedException_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CLinkFailedException.h"}\par
{\f2 #include <string.h>}\par
{\f2 #include <stdio.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CLinkFailedException.cpp}
{\xe \v CLinkFailedException.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CLinkFailedException_8cpp_a0}
{\bkmkend CLinkFailedException_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CLinkFailedException.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CLinkFailedException.h File Reference\par \pard\plain 
{\tc\tcl2 \v CLinkFailedException.h}
{\xe \v CLinkFailedException.h}
{\bkmkstart CLinkFailedException_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Exception.h"}\par
{\f2 #include <histotypes.h>}\par
{\f2 #include <string>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CLinkFailedException}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CLocationEvent.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CLocationEvent.cpp}
{\xe \v CLocationEvent.cpp}
{\bkmkstart CLocationEvent_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CLocationEvent.h>}\par
\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CLocationEvent.h File Reference\par \pard\plain 
{\tc\tcl2 \v CLocationEvent.h}
{\xe \v CLocationEvent.h}
{\bkmkstart CLocationEvent_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CLocationMonitor.h>}\par
{\f2 #include <CLocationReactor.h>}\par
{\f2 #include "CLocationEvent.cpp"}\par
{\f2 #include "CEvent.h"}\par
{\f2 #include <CPointerPredicate.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CGenericLocationReactor}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CLocationEvent}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CLocationMonitor.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CLocationMonitor.cpp}
{\xe \v CLocationMonitor.cpp}
{\bkmkstart CLocationMonitor_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CLocationMonitor.h>}\par
{\f2 #include "CMaskedValuePredicate.h"}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <iostream.h>}\par
{\f2 #include "CChangedPredicate.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const int {\b INCREMENTS} = 1000\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
\par
\\class {\b CLocationMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCLocationMonitor \\*MERGEFORMAT}{\fldrslt pagenum}}}) Encapsulates a location monitor.  The location monitor watches a volatile memory location  to satisfy some predicate function object. Predicates are objects from classes which implement: bool operator()(T value) T is a templated variable of the class. Such objects are function objects. The  Event is fired when the predicate returns TRUE.\par
Author: Jason Venema NSCL Michigan State University East Lansing, MI 48824-1321 mailto:{\f2 venemaja@msu.edu}\par
\par
Definition in file {\b CLocationMonitor.cpp}.{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v INCREMENTS\:CLocationMonitor.cpp}
{\xe \v CLocationMonitor.cpp\:INCREMENTS}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const int INCREMENTS = 1000{\f2  [static]}}
}\par
{\bkmkstart CLocationMonitor_8cpp_a0}
{\bkmkend CLocationMonitor_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 294 of file CLocationMonitor.cpp.\par
\par
Referenced by CLocationMonitor< T >::operator()().}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ClocationMonitor.h File Reference\par \pard\plain 
{\tc\tcl2 \v ClocationMonitor.h}
{\xe \v ClocationMonitor.h}
{\bkmkstart ClocationMonitor_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid \par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CLocationMonitor.h File Reference\par \pard\plain 
{\tc\tcl2 \v CLocationMonitor.h}
{\xe \v CLocationMonitor.h}
{\bkmkstart CLocationMonitor_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <sys/time.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <CLocationMonitor.cpp>}\par
{\f2 #include "CEventMonitor.h"}\par
{\f2 #include "CPointerPredicate.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CLocationMonitor}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CLocationReactor.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CLocationReactor.cpp}
{\xe \v CLocationReactor.cpp}
{\bkmkstart CLocationReactor_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CLocationReactor.h"}\par
{\f2 #include <CEventMonitor.h>}\par
{\f2 #include <CLocationMonitor.h>}\par
{\f2 #include <CIncompatibleMonitor.h>}\par
{\f2 #include <typeinfo>}\par
\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CLocationReactor.h File Reference\par \pard\plain 
{\tc\tcl2 \v CLocationReactor.h}
{\xe \v CLocationReactor.h}
{\bkmkstart CLocationReactor_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CLocationReactor.cpp>}\par
{\f2 #include "CReactor.h"}\par
{\f2 #include <CLocationMonitor.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CLocationReactor}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CLogger.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CLogger.cpp}
{\xe \v CLogger.cpp}
{\bkmkstart CLogger_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CLogger.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <pwd.h>}\par
{\f2 #include <sys/types.h>}\par
{\f2 #include <CDuplicateNameException.h>}\par
{\f2 #include <CNoSuchObjectException.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b PORT}\~ string("2702")\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v PORT\:CLogger.cpp}
{\xe \v CLogger.cpp\:PORT}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define PORT\~ string("2702")}
}\par
{\bkmkstart CLogger_8cpp_a0}
{\bkmkend CLogger_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 300 of file CLogger.cpp.\par
\par
Referenced by CLogger::Log().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CLogger.cpp}
{\xe \v CLogger.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CLogger_8cpp_a1}
{\bkmkend CLogger_8cpp_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CLogger.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CLogger.h File Reference\par \pard\plain 
{\tc\tcl2 \v CLogger.h}
{\xe \v CLogger.h}
{\bkmkstart CLogger_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CSocket.h>}\par
{\f2 #include <list>}\par
{\f2 #include <spectrodaq.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <SpectroFramework.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CLogger}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef list< string >::iterator {\b HostListIterator}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v HostListIterator\:CLogger.h}
{\xe \v CLogger.h\:HostListIterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef list<string>::iterator HostListIterator}
}\par
{\bkmkstart CLogger_8h_a0}
{\bkmkend CLogger_8h_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 324 of file CLogger.h.\par
\par
Referenced by CLogger::AddHost(), and CLogger::RemoveHost().}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CMaskedValuePredicate.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CMaskedValuePredicate.cpp}
{\xe \v CMaskedValuePredicate.cpp}
{\bkmkstart CMaskedValuePredicate_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CMaskedValuePredicate.h>}\par
\par
}
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
\par
\\class {\b CMaskedValuePredicate} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCMaskedValuePredicate \\*MERGEFORMAT}{\fldrslt pagenum}}}) template Does a comparison with a value given a set of significant bits. Note that one of the constructors makes all bits significant, effectively making this a match of value.\par
Author: Jason Venema NSCL Michigan State University East Lansing, MI 48824-1321 mailto:{\f2 venemaja@msu.edu}\par
\par
Definition in file {\b CMaskedValuePredicate.cpp}.\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CMaskedValuePredicate.h File Reference\par \pard\plain 
{\tc\tcl2 \v CMaskedValuePredicate.h}
{\xe \v CMaskedValuePredicate.h}
{\bkmkstart CMaskedValuePredicate_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CMaskedValuePredicate.cpp>}\par
{\f2 #include "CPointerPredicate.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CMaskedValuePredicate}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CNamedObject.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CNamedObject.cpp}
{\xe \v CNamedObject.cpp}
{\bkmkstart CNamedObject_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CNamedObject.h"}\par
{\f2 #include <string>}\par
{\f2 #include <typeinfo>}\par
{\f2 #include <stdio.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CNamedObject.cpp}
{\xe \v CNamedObject.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CNamedObject_8cpp_a0}
{\bkmkend CNamedObject_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CNamedObject.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CNamedObject.h File Reference\par \pard\plain 
{\tc\tcl2 \v CNamedObject.h}
{\xe \v CNamedObject.h}
{\bkmkstart CNamedObject_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <typeinfo>}\par
{\f2 #include <string>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CNamedObject}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CNoSuchLinkException.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CNoSuchLinkException.cpp}
{\xe \v CNoSuchLinkException.cpp}
{\bkmkstart CNoSuchLinkException_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CNoSuchLinkException.h"}\par
{\f2 #include <string.h>}\par
{\f2 #include <stdio.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CNoSuchLinkException.cpp}
{\xe \v CNoSuchLinkException.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CNoSuchLinkException_8cpp_a0}
{\bkmkend CNoSuchLinkException_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CNoSuchLinkException.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CNoSuchLinkException.h File Reference\par \pard\plain 
{\tc\tcl2 \v CNoSuchLinkException.h}
{\xe \v CNoSuchLinkException.h}
{\bkmkstart CNoSuchLinkException_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "Exception.h"}\par
{\f2 #include <histotypes.h>}\par
{\f2 #include <string>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CNoSuchLinkException}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CNoSuchObjectException.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CNoSuchObjectException.cpp}
{\xe \v CNoSuchObjectException.cpp}
{\bkmkstart CNoSuchObjectException_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CNoSuchObjectException.h"}\par
{\f2 #include <string.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CNoSuchObjectException.cpp}
{\xe \v CNoSuchObjectException.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CNoSuchObjectException_8cpp_a0}
{\bkmkend CNoSuchObjectException_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CNoSuchObjectException.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CNoSuchObjectException.h File Reference\par \pard\plain 
{\tc\tcl2 \v CNoSuchObjectException.h}
{\xe \v CNoSuchObjectException.h}
{\bkmkstart CNoSuchObjectException_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <histotypes.h>}\par
{\f2 #include "Exception.h"}\par
{\f2 #include <string>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CNoSuchObjectException}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CObjectRegistry.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CObjectRegistry.cpp}
{\xe \v CObjectRegistry.cpp}
{\bkmkstart CObjectRegistry_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CObjectRegistry.h"}\par
{\f2 #include "CDuplicateNameException.h"}\par
{\f2 #include "CNoSuchObjectException.h"}\par
{\f2 #include <string>}\par
{\f2 #include <map>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CObjectRegistry.cpp}
{\xe \v CObjectRegistry.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CObjectRegistry_8cpp_a0}
{\bkmkend CObjectRegistry_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CObjectRegistry.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CObjectRegistry.h File Reference\par \pard\plain 
{\tc\tcl2 \v CObjectRegistry.h}
{\xe \v CObjectRegistry.h}
{\bkmkstart CObjectRegistry_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CNamedObject.h"}\par
{\f2 #include <map>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CObjectRegistry}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef map< string, {\b CNamedObject} * >::iterator {\b ObjectIterator}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v ObjectIterator\:CObjectRegistry.h}
{\xe \v CObjectRegistry.h\:ObjectIterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef map<string, {\b CNamedObject}*>::iterator ObjectIterator}
}\par
{\bkmkstart CObjectRegistry_8h_a0}
{\bkmkend CObjectRegistry_8h_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
ObjectRegistry.h:\par
This file defines the {\b CObjectRegistry} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCObjectRegistry \\*MERGEFORMAT}{\fldrslt pagenum}}}) class.\par
Author: Jason Venema NSCL Michigan State University East Lansing, MI 48824-1321 mailto:{\f2 venemaja@msu.edu} \par
\par
Definition at line 308 of file CObjectRegistry.h.\par
\par
Referenced by CObjectRegistry::DescribeSelf(), CObjectRegistry::Find(), and CClassifiedObjectRegistry::Find().}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
configsys.oxy File Reference\par \pard\plain 
{\tc\tcl2 \v configsys.oxy}
{\xe \v configsys.oxy}
{\bkmkstart configsys_8oxy}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid \par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CPointerPredicate.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CPointerPredicate.cpp}
{\xe \v CPointerPredicate.cpp}
{\bkmkstart CPointerPredicate_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CPointerPredicate.h"}\par
\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CPointerPredicate.h File Reference\par \pard\plain 
{\tc\tcl2 \v CPointerPredicate.h}
{\xe \v CPointerPredicate.h}
{\bkmkstart CPointerPredicate_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CPointerPredicate.cpp>}\par
{\f2 #include "CRegisteredObject.h"}\par
{\f2 #include <CApplicationRegistry.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CPointerPredicate}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const string {\b RegistryName} = "PointerPredicates"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v RegistryName\:CPointerPredicate.h}
{\xe \v CPointerPredicate.h\:RegistryName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const string RegistryName = "PointerPredicates"{\f2  [static]}}
}\par
{\bkmkstart CPointerPredicate_8h_a0}
{\bkmkend CPointerPredicate_8h_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\\class: {\b CPointerPredicate} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCPointerPredicate \\*MERGEFORMAT}{\fldrslt pagenum}}})\par
Encapsulates standard predicates for location monitors. Location monitor predicates are template classes on a type T They must implement the function: bool operator()(T nCurrent)\par
The function returns TRUE if nCurrent satisfies whatever condition  the predicate is established on the location.\par
Author: Jason Venema NSCL Michigan State University East Lansing, MI 48824-1321 mailto: {\f2 venemaja@msu.edu} \par
\par
Definition at line 308 of file CPointerPredicate.h.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CRangeError.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CRangeError.cpp}
{\xe \v CRangeError.cpp}
{\bkmkstart CRangeError_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CRangeError.h"}\par
{\f2 #include <stdio.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CRangeError.cpp}
{\xe \v CRangeError.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright{\f2  [static]}}
}\par
{\bkmkstart CRangeError_8cpp_a0}
{\bkmkend CRangeError_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \par
"CRangeError.cpp: Copyright 1999 NSCL, All rights reserved\\n"\par
}
Definition at line 303 of file CRangeError.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CRangeError.h File Reference\par \pard\plain 
{\tc\tcl2 \v CRangeError.h}
{\xe \v CRangeError.h}
{\bkmkstart CRangeError_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CException.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CRangeError}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CReactor.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CReactor.cpp}
{\xe \v CReactor.cpp}
{\bkmkstart CReactor_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CReactor.h"}\par
{\f2 #include <CEventMonitor.h>}\par
{\f2 #include <CApplicationRegistry.h>}\par
{\f2 #include <RangeError.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const string {\b RegistryName} = "Reactors"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CReactor.cpp}
{\xe \v CReactor.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CReactor_8cpp_a0}
{\bkmkend CReactor_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CReactor.cpp.\par
}
{\xe \v RegistryName\:CReactor.cpp}
{\xe \v CReactor.cpp\:RegistryName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const string RegistryName = "Reactors"{\f2  [static]}}
}\par
{\bkmkstart CReactor_8cpp_a1}
{\bkmkend CReactor_8cpp_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 309 of file CReactor.cpp.\par
\par
Referenced by CReactor::CReactor(), and CReactor::~CReactor().}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CReactor.h File Reference\par \pard\plain 
{\tc\tcl2 \v CReactor.h}
{\xe \v CReactor.h}
{\bkmkstart CReactor_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CRegisteredObject.h"}\par
{\f2 #include <CEventMonitor.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CReactor}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CRefptr.h File Reference\par \pard\plain 
{\tc\tcl2 \v CRefptr.h}
{\xe \v CRefptr.h}
{\bkmkstart CRefptr_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid \par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CRefcountedPtr}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CReferenceCounted}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CRegisteredObject.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CRegisteredObject.cpp}
{\xe \v CRegisteredObject.cpp}
{\bkmkstart CRegisteredObject_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CRegisteredObject.h"}\par
{\f2 #include "CDuplicateNameException.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CRegisteredObject.cpp}
{\xe \v CRegisteredObject.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CRegisteredObject_8cpp_a0}
{\bkmkend CRegisteredObject_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CRegisteredObject.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CRegisteredObject.h File Reference\par \pard\plain 
{\tc\tcl2 \v CRegisteredObject.h}
{\xe \v CRegisteredObject.h}
{\bkmkstart CRegisteredObject_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CNamedObject.h"}\par
{\f2 #include "CClassifiedObjectRegistry.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CRegisteredObject}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CServerConnectionEvent.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CServerConnectionEvent.cpp}
{\xe \v CServerConnectionEvent.cpp}
{\bkmkstart CServerConnectionEvent_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CServerConnectionEvent.h>}\par
{\f2 #include <CApplicationSerializer.h>}\par
{\f2 #include <sys/types.h>}\par
{\f2 #include <sys/socket.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <assert.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CServerConnectionEvent.cpp}
{\xe \v CServerConnectionEvent.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CServerConnectionEvent_8cpp_a0}
{\bkmkend CServerConnectionEvent_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CServerConnectionEvent.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CServerConnectionEvent.h File Reference\par \pard\plain 
{\tc\tcl2 \v CServerConnectionEvent.h}
{\xe \v CServerConnectionEvent.h}
{\bkmkstart CServerConnectionEvent_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CFileEvent.h"}\par
{\f2 #include "CSocket.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CServerConnectionEvent}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i \\class: CServerConnectionEvent \\file: {\b CServerConnectionEvent.h}.}\par
\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CServerInstance.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CServerInstance.cpp}
{\xe \v CServerInstance.cpp}
{\bkmkstart CServerInstance_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CServerInstance.h>}\par
{\f2 #include <CTCPConnectionLost.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CServerInstance.cpp}
{\xe \v CServerInstance.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CServerInstance_8cpp_a0}
{\bkmkend CServerInstance_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CServerInstance.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CServerInstance.h File Reference\par \pard\plain 
{\tc\tcl2 \v CServerInstance.h}
{\xe \v CServerInstance.h}
{\bkmkstart CServerInstance_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream.h>}\par
{\f2 #include <CFileEvent.h>}\par
{\f2 #include <CSocket.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CServerInstance}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CServerMonitor.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CServerMonitor.cpp}
{\xe \v CServerMonitor.cpp}
{\bkmkstart CServerMonitor_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CServerMonitor.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
\par
\\class {\b CServerMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCServerMonitor \\*MERGEFORMAT}{\fldrslt pagenum}}})  Monitors a TCP/IP socket for connection requests. When a connection request is available, returns. Note that it is up to the reactor to actually accept the connection request. ServerMonitors can have monitors which are descended from CFdMoniitors\par
\par
Definition in file {\b CServerMonitor.cpp}.{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CServerMonitor.cpp}
{\xe \v CServerMonitor.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CServerMonitor_8cpp_a0}
{\bkmkend CServerMonitor_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CServerMonitor.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CServerMonitor.h File Reference\par \pard\plain 
{\tc\tcl2 \v CServerMonitor.h}
{\xe \v CServerMonitor.h}
{\bkmkstart CServerMonitor_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CFdMonitor.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CServerMonitor}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i \\class: CServerMonitor \\file: {\b CServerMonitor.h}.}\par
\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CSocket.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CSocket.cpp}
{\xe \v CSocket.cpp}
{\bkmkstart CSocket_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CSocket.h"}\par
{\f2 #include <CApplicationSerializer.h>}\par
{\f2 #include <CTCPNoSuchHost.h>}\par
{\f2 #include <CTCPNoSuchService.h>}\par
{\f2 #include <CTCPBadSocketState.h>}\par
{\f2 #include <CTCPConnectionFailed.h>}\par
{\f2 #include <ErrnoException.h>}\par
{\f2 #include <CTCPConnectionLost.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <sys/types.h>}\par
{\f2 #include <sys/socket.h>}\par
{\f2 #include <sys/time.h>}\par
{\f2 #include <netinet/in.h>}\par
{\f2 #include <arpa/inet.h>}\par
{\f2 #include <vector>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b FALSE}\~ 0\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v FALSE\:CSocket.cpp}
{\xe \v CSocket.cpp\:FALSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define FALSE\~ 0}
}\par
{\bkmkstart CSocket_8cpp_a0}
{\bkmkend CSocket_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{{{\b \par
{\b Bug: }}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid  Perhaps global syncronization of (3) calls should be conditionalized so that this module can be used in a non spectrodaq environment too. \par
} \par
\par
Definition at line 343 of file CSocket.cpp.\par
\par
Referenced by CXtEventLoop::CXtEventLoop(), CSocket::isDebug(), CSocket::isNotRoutable(), and CSocket::isOOBInline().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CSocket.cpp}
{\xe \v CSocket.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CSocket_8cpp_a1}
{\bkmkend CSocket_8cpp_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CSocket.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CSocket.h File Reference\par \pard\plain 
{\tc\tcl2 \v CSocket.h}
{\xe \v CSocket.h}
{\bkmkstart CSocket_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <string>}\par
{\f2 #include <map>}\par
{\f2 #include <netinet/in.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CSocket}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TRUE}\~ 1\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v TRUE\:CSocket.h}
{\xe \v CSocket.h\:TRUE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TRUE\~ 1}
}\par
{\bkmkstart CSocket_8h_a0}
{\bkmkend CSocket_8h_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 311 of file CSocket.h.\par
\par
Referenced by CSocket::Debug(), CXtEventLoop::exit(), CSocket::isDebug(), CSocket::isNotRoutable(), and CSocket::isOOBInline().}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CStreamIOError.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CStreamIOError.cpp}
{\xe \v CStreamIOError.cpp}
{\bkmkstart CStreamIOError_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CStreamIOError.h"}\par
{\f2 #include <string.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b pCopyrightNotice}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b pErrorMessages} []\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CStreamIOError.cpp}
{\xe \v CStreamIOError.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CStreamIOError_8cpp_a0}
{\bkmkend CStreamIOError_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CStreamIOError.cpp.\par
}
{\xe \v pCopyrightNotice\:CStreamIOError.cpp}
{\xe \v CStreamIOError.cpp\:pCopyrightNotice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* pCopyrightNotice{\f2  [static]}}
}\par
{\bkmkstart CStreamIOError_8cpp_a1}
{\bkmkend CStreamIOError_8cpp_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \par
"(C) Copyright 1999 NSCL, All rights reserved StreamIOError.cpp \\n"\par
}
Definition at line 301 of file CStreamIOError.cpp.\par
}
{\xe \v pErrorMessages\:CStreamIOError.cpp}
{\xe \v CStreamIOError.cpp\:pErrorMessages}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* pErrorMessages[]{\f2  [static]}}
}\par
{\bkmkstart CStreamIOError_8cpp_a2}
{\bkmkend CStreamIOError_8cpp_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \par
\{\par
  "End of file encountered (prematurely) ",\par
  "Bad bit set in ios:: ",\par
  "Fail bit set in ios:: "\par
\}\par
}
Definition at line 304 of file CStreamIOError.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CStreamIOError.h File Reference\par \pard\plain 
{\tc\tcl2 \v CStreamIOError.h}
{\xe \v CStreamIOError.h}
{\bkmkstart CStreamIOError_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CException.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CStreamIOError}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCLInterpreterStartup.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CTCLInterpreterStartup.cpp}
{\xe \v CTCLInterpreterStartup.cpp}
{\bkmkstart CTCLInterpreterStartup_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CTCLInterpreterStartup.h"}\par
{\f2 #include "TCLInterpreter.h"}\par
{\f2 #include <tcl.h>}\par
{\f2 #include <assert.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NULL}\~ 0\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b dbgmsg} (const char *msg)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v NULL\:CTCLInterpreterStartup.cpp}
{\xe \v CTCLInterpreterStartup.cpp\:NULL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NULL\~ 0}
}\par
{\bkmkstart CTCLInterpreterStartup_8cpp_a0}
{\bkmkend CTCLInterpreterStartup_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 303 of file CTCLInterpreterStartup.cpp.\par
\par
Referenced by CTCLInterpreterStartup::operator()(), and CTCLInterpreterStartup::Tcl_Init().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v dbgmsg\:CTCLInterpreterStartup.cpp}
{\xe \v CTCLInterpreterStartup.cpp\:dbgmsg}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void dbgmsg (const char * {\i msg}){\f2  [inline, static]}}
}\par
{\bkmkstart CTCLInterpreterStartup_8cpp_a2}
{\bkmkend CTCLInterpreterStartup_8cpp_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Starts up a TCL interpreter. This is suitable for applications which do not require or cannot use a GUI. \par
\par
Definition at line 294 of file CTCLInterpreterStartup.cpp.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CTCLInterpreterStartup.cpp}
{\xe \v CTCLInterpreterStartup.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CTCLInterpreterStartup_8cpp_a1}
{\bkmkend CTCLInterpreterStartup_8cpp_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CTCLInterpreterStartup.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCLInterpreterStartup.h File Reference\par \pard\plain 
{\tc\tcl2 \v CTCLInterpreterStartup.h}
{\xe \v CTCLInterpreterStartup.h}
{\bkmkstart CTCLInterpreterStartup_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <tcl.h>}\par
{\f2 #include "CInterpreterStartup.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTCLInterpreterStartup}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b __CTCoLINTERPRETERSTARTUP_H}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v __CTCoLINTERPRETERSTARTUP_H\:CTCLInterpreterStartup.h}
{\xe \v CTCLInterpreterStartup.h\:__CTCoLINTERPRETERSTARTUP_H}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define __CTCoLINTERPRETERSTARTUP_H}
}\par
{\bkmkstart CTCLInterpreterStartup_8h_a0}
{\bkmkend CTCLInterpreterStartup_8h_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 288 of file CTCLInterpreterStartup.h.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCLSynchronizeCommand.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CTCLSynchronizeCommand.cpp}
{\xe \v CTCLSynchronizeCommand.cpp}
{\bkmkstart CTCLSynchronizeCommand_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CTCLSynchronizeCommand.h"}\par
{\f2 #include <TCLException.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
\par
\\class {\b CTCLSynchronizeCommand} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCLSynchronizeCommand \\*MERGEFORMAT}{\fldrslt pagenum}}}) {\b CTCLSynchronizeCommand.h} Implements a Tcl command extension sync \{script\}\par
The script parameter is simply evaluated. Since this class is derived from {\b CDAQTCLProcessor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDAQTCLProcessor \\*MERGEFORMAT}{\fldrslt pagenum}}}), however the script is executed syncrhonized to the application's global mutex.\par
\par
Definition in file {\b CTCLSynchronizeCommand.cpp}.{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CTCLSynchronizeCommand.cpp}
{\xe \v CTCLSynchronizeCommand.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CTCLSynchronizeCommand_8cpp_a0}
{\bkmkend CTCLSynchronizeCommand_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CTCLSynchronizeCommand.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCLSynchronizeCommand.h File Reference\par \pard\plain 
{\tc\tcl2 \v CTCLSynchronizeCommand.h}
{\xe \v CTCLSynchronizeCommand.h}
{\bkmkstart CTCLSynchronizeCommand_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CDAQTCLProcessor.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTCLSynchronizeCommand}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCPBadSocketState.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CTCPBadSocketState.cpp}
{\xe \v CTCPBadSocketState.cpp}
{\bkmkstart CTCPBadSocketState_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CTCPBadSocketState.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = Copyright= "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CTCPBadSocketState.cpp}
{\xe \v CTCPBadSocketState.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = Copyright= "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CTCPBadSocketState_8cpp_a0}
{\bkmkend CTCPBadSocketState_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CTCPBadSocketState.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCPBadSocketState.h File Reference\par \pard\plain 
{\tc\tcl2 \v CTCPBadSocketState.h}
{\xe \v CTCPBadSocketState.h}
{\bkmkstart CTCPBadSocketState_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <vector>}\par
{\f2 #include <Exception.h>}\par
{\f2 #include <CSocket.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTCPBadSocketState}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCPConnectionFailed.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CTCPConnectionFailed.cpp}
{\xe \v CTCPConnectionFailed.cpp}
{\bkmkstart CTCPConnectionFailed_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CTCPConnectionFailed.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CTCPConnectionFailed.cpp}
{\xe \v CTCPConnectionFailed.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CTCPConnectionFailed_8cpp_a0}
{\bkmkend CTCPConnectionFailed_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CTCPConnectionFailed.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCPConnectionFailed.h File Reference\par \pard\plain 
{\tc\tcl2 \v CTCPConnectionFailed.h}
{\xe \v CTCPConnectionFailed.h}
{\bkmkstart CTCPConnectionFailed_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <ErrnoException.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTCPConnectionFailed}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCPConnectionLost.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CTCPConnectionLost.cpp}
{\xe \v CTCPConnectionLost.cpp}
{\bkmkstart CTCPConnectionLost_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CTCPConnectionLost.h>}\par
{\f2 #include <CSocket.h>}\par
{\f2 #include <sys/socket.h>}\par
{\f2 #include <netinet/in.h>}\par
{\f2 #include <arpa/inet.h>}\par
{\f2 #include <netdb.h>}\par
{\f2 #include <CApplicationSerializer.h>}\par
{\f2 #include <stdio.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CTCPConnectionLost.cpp}
{\xe \v CTCPConnectionLost.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CTCPConnectionLost_8cpp_a0}
{\bkmkend CTCPConnectionLost_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CTCPConnectionLost.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCPConnectionLost.h File Reference\par \pard\plain 
{\tc\tcl2 \v CTCPConnectionLost.h}
{\xe \v CTCPConnectionLost.h}
{\bkmkstart CTCPConnectionLost_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <ErrnoException.h>}\par
{\f2 #include <string>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTCPConnectionLost}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCPNoSuchHost.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CTCPNoSuchHost.cpp}
{\xe \v CTCPNoSuchHost.cpp}
{\bkmkstart CTCPNoSuchHost_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CTCPNoSuchHost.h>}\par
{\f2 #include <netdb.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CTCPNoSuchHost.cpp}
{\xe \v CTCPNoSuchHost.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CTCPNoSuchHost_8cpp_a0}
{\bkmkend CTCPNoSuchHost_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CTCPNoSuchHost.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCPNoSuchHost.h File Reference\par \pard\plain 
{\tc\tcl2 \v CTCPNoSuchHost.h}
{\xe \v CTCPNoSuchHost.h}
{\bkmkstart CTCPNoSuchHost_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <Exception.h>}\par
{\f2 #include <string>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTCPNoSuchHost}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCPNoSuchService.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CTCPNoSuchService.cpp}
{\xe \v CTCPNoSuchService.cpp}
{\bkmkstart CTCPNoSuchService_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CTCPNoSuchService.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CTCPNoSuchService.cpp}
{\xe \v CTCPNoSuchService.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CTCPNoSuchService_8cpp_a0}
{\bkmkend CTCPNoSuchService_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CTCPNoSuchService.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTCPNoSuchService.h File Reference\par \pard\plain 
{\tc\tcl2 \v CTCPNoSuchService.h}
{\xe \v CTCPNoSuchService.h}
{\bkmkstart CTCPNoSuchService_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "ErrnoException.h"}\par
{\f2 #include <string>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTCPNoSuchService}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CThreadRecursiveMutex.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CThreadRecursiveMutex.cpp}
{\xe \v CThreadRecursiveMutex.cpp}
{\bkmkstart CThreadRecursiveMutex_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CThreadRecursiveMutex.h"}\par
{\f2 #include <spectrodaq.h>}\par
{\f2 #include <errno.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
  Provides a mutex which can be locked in a nested manner by a thread. The "nested ness' is managed through the m_nLockLevel and the  m_OwningThread member. Atomicity of the otherwise non-atomic  function is handled by bracketing calls with locks of the mutexe's own m_MonitorMutex\par
\par
Definition in file {\b CThreadRecursiveMutex.cpp}.{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CThreadRecursiveMutex.cpp}
{\xe \v CThreadRecursiveMutex.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CThreadRecursiveMutex_8cpp_a0}
{\bkmkend CThreadRecursiveMutex_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CThreadRecursiveMutex.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CThreadRecursiveMutex.h File Reference\par \pard\plain 
{\tc\tcl2 \v CThreadRecursiveMutex.h}
{\xe \v CThreadRecursiveMutex.h}
{\bkmkstart CThreadRecursiveMutex_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <spectrodaq.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CThreadRecursiveMutex}\par
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid {\i CThreadRecursiveMutex {\b CThreadRecursiveMutex.h}.}\par
\par}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTimerEvent.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CTimerEvent.cpp}
{\xe \v CTimerEvent.cpp}
{\bkmkstart CTimerEvent_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CTimerEvent.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CTimerEvent.cpp}
{\xe \v CTimerEvent.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CTimerEvent_8cpp_a0}
{\bkmkend CTimerEvent_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CTimerEvent.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTimerEvent.h File Reference\par \pard\plain 
{\tc\tcl2 \v CTimerEvent.h}
{\xe \v CTimerEvent.h}
{\bkmkstart CTimerEvent_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CTimerMonitor.h>}\par
{\f2 #include <CEvent.h>}\par
{\f2 #include <CReactor.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTimerEvent}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTimerGenericReactor}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b __CTIMEREVENT_H}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v __CTIMEREVENT_H\:CTimerEvent.h}
{\xe \v CTimerEvent.h\:__CTIMEREVENT_H}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define __CTIMEREVENT_H}
}\par
{\bkmkstart CTimerEvent_8h_a0}
{\bkmkend CTimerEvent_8h_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 286 of file CTimerEvent.h.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTimerMonitor.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CTimerMonitor.cpp}
{\xe \v CTimerMonitor.cpp}
{\bkmkstart CTimerMonitor_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CTimerMonitor.h"}\par
{\f2 #include <unistd.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
\par
\\class {\b CTimerMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTimerMonitor \\*MERGEFORMAT}{\fldrslt pagenum}}})\par
Encapsulates an event monitor for timers. Timers can be either repeating or oneshot. A oneshot timer willl fire once after a delay and  then refuse to fire until it's time is reset.\par
Repeating timers essentially reset their time after each instance of an event.\par
Author: Jason Venema NSCL Michigan State University East Lansing, MI 48824-1321 mailto: {\f2 venemaja@msu.edu}\par
\par
Definition in file {\b CTimerMonitor.cpp}.{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CTimerMonitor.cpp}
{\xe \v CTimerMonitor.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CTimerMonitor_8cpp_a0}
{\bkmkend CTimerMonitor_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CTimerMonitor.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTimerMonitor.h File Reference\par \pard\plain 
{\tc\tcl2 \v CTimerMonitor.h}
{\xe \v CTimerMonitor.h}
{\bkmkstart CTimerMonitor_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <spectrodaq.h>}\par
{\f2 #include "CEventMonitor.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTimerMonitor}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
  \\class: {\b CTimerMonitor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTimerMonitor \\*MERGEFORMAT}{\fldrslt pagenum}}})\par
Author: Jason Venema NSCL Michigan State University East Lansing, MI 48824-1321 mailto: {\f2 venemaja@msu.edu}\par
\par
Definition in file {\b CTimerMonitor.h}.\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTKInterpreterStartup.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CTKInterpreterStartup.cpp}
{\xe \v CTKInterpreterStartup.cpp}
{\bkmkstart CTKInterpreterStartup_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CTKInterpreterStartup.h"}\par
{\f2 #include <TCLInterpreter.h>}\par
{\f2 #include <tk.h>}\par
{\f2 #include <assert.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CTKInterpreterStartup.cpp}
{\xe \v CTKInterpreterStartup.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CTKInterpreterStartup_8cpp_a0}
{\bkmkend CTKInterpreterStartup_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CTKInterpreterStartup.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTKInterpreterStartup.h File Reference\par \pard\plain 
{\tc\tcl2 \v CTKInterpreterStartup.h}
{\xe \v CTKInterpreterStartup.h}
{\bkmkstart CTKInterpreterStartup_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <tk.h>}\par
{\f2 #include "CInterpreterStartup.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTKInterpreterStartup}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CTypeFreeBinding.h File Reference\par \pard\plain 
{\tc\tcl2 \v CTypeFreeBinding.h}
{\xe \v CTypeFreeBinding.h}
{\bkmkstart CTypeFreeBinding_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <TCLInterpreter.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTypeFreeBinding}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CVariableBinding.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CVariableBinding.cpp}
{\xe \v CVariableBinding.cpp}
{\bkmkstart CVariableBinding_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <CVariableBinding.h>}\par
{\f2 #include <TCLString.h>}\par
{\f2 #include <iostream.h>}\par
{\f2 #include <fstream.h>}\par
\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CVariableBinding.h File Reference\par \pard\plain 
{\tc\tcl2 \v CVariableBinding.h}
{\xe \v CVariableBinding.h}
{\bkmkstart CVariableBinding_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <TCLInterpreter.h>}\par
{\f2 #include <CVariableBinding.cpp>}\par
{\f2 #include <CBinding.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CVariableBinding}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CXtEventLoop.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v CXtEventLoop.cpp}
{\xe \v CXtEventLoop.cpp}
{\bkmkstart CXtEventLoop_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "CXtEventLoop.h"}\par
{\f2 #include "CApplicationSerializer.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Detailed Description\par
\pard\plain 
\par
\\class {\b CXtEventLoop} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCXtEventLoop \\*MERGEFORMAT}{\fldrslt pagenum}}})  Encapsulates an occurance of an Xt event loop.  The main loop synchronizes the event loop thread with the application each pass through the  xt event loop e.g. the event loop looks like:\par
while(1) \{ XtGetEvent() LockMutex() XtDispatchEvent(); UnlockMutex(); yield(); // Let someone else run. \}\par
This implies that work procedures and timer procs are also synchonrized to the application. Note that this synchronization can be costly if there are work procedures continuously active.\par
\par
Definition in file {\b CXtEventLoop.cpp}.{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:CXtEventLoop.cpp}
{\xe \v CXtEventLoop.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart CXtEventLoop_8cpp_a0}
{\bkmkend CXtEventLoop_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file CXtEventLoop.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
CXtEventLoop.h File Reference\par \pard\plain 
{\tc\tcl2 \v CXtEventLoop.h}
{\xe \v CXtEventLoop.h}
{\bkmkstart CXtEventLoop_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <Xm/Xm.h>}\par
{\f2 #include "CEventLoop.h"}\par
{\f2 #include <string>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CXtEventLoop}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
EventDriven.oxy File Reference\par \pard\plain 
{\tc\tcl2 \v EventDriven.oxy}
{\xe \v EventDriven.oxy}
{\bkmkstart EventDriven_8oxy}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid \par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
FdMonitorTest.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v FdMonitorTest.cpp}
{\xe \v FdMonitorTest.cpp}
{\bkmkstart FdMonitorTest_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream.h>}\par
{\f2 #include "CNamedObject.h"}\par
{\f2 #include "CObjectRegistry.h"}\par
{\f2 #include "CClassifiedObjectRegistry.h"}\par
{\f2 #include "CRegisteredObject.h"}\par
{\f2 #include "CFdMonitor.h"}\par
{\f2 #include "CDuplicateNameException.h"}\par
{\f2 #include "CNoSuchObjectException.h"}\par
{\f2 #include <assert.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} ()\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:FdMonitorTest.cpp}
{\xe \v FdMonitorTest.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main ()}
}\par
{\bkmkstart FdMonitorTest_8cpp_a1}
{\bkmkend FdMonitorTest_8cpp_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 290 of file FdMonitorTest.cpp.\par
\par
References CFdMonitor::DescribeSelf(), CEventMonitor::Error, CFdMonitor::getConditionMask(), CFdMonitor::MonitorExceptions(), CFdMonitor::MonitorReadable(), CFdMonitor::MonitorWritable(), CEventMonitor::Occurred, CEventMonitor::setTimeout(), and CEventMonitor::TimedOut.}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:FdMonitorTest.cpp}
{\xe \v FdMonitorTest.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart FdMonitorTest_8cpp_a0}
{\bkmkend FdMonitorTest_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file FdMonitorTest.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
FileEvents.oxy File Reference\par \pard\plain 
{\tc\tcl2 \v FileEvents.oxy}
{\xe \v FileEvents.oxy}
{\bkmkstart FileEvents_8oxy}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid \par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
histotypes.h File Reference\par \pard\plain 
{\tc\tcl2 \v histotypes.h}
{\xe \v histotypes.h}
{\bkmkstart histotypes_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <iostream.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <string>}\par
{\f2 #include <math.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Time_t}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b kACTIONSIZE}\~ 1024\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef int {\b Int_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned int {\b UInt_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef short {\b Short_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned short {\b UShort_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef long {\b Long_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned long {\b ULong_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef float {\b Float_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef double {\b DFloat_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef char {\b Char_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef unsigned char {\b UChar_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef char * {\b Textsz_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b UInt_t} {\b Size_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef void * {\b Address_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b UChar_t} {\b Bool_t}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef * {\b pTime_t}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Address_t} {\b kpNULL} = ({\b Address_t})0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Bool_t} {\b kfTRUE} = 0xff\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b Bool_t} {\b kfFALSE} = 0\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UInt_t} {\b kn1K} = 1024\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UInt_t} {\b kn1M} = {\b kn1K}*{\b kn1K}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const {\b UInt_t} {\b knDefaultBufferSize} = {\b kn1K}*8\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v kACTIONSIZE\:histotypes.h}
{\xe \v histotypes.h\:kACTIONSIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define kACTIONSIZE\~ 1024}
}\par
{\bkmkstart histotypes_8h_a0}
{\bkmkend histotypes_8h_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 337 of file histotypes.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v Address_t\:histotypes.h}
{\xe \v histotypes.h\:Address_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef void* Address_t}
}\par
{\bkmkstart histotypes_8h_a13}
{\bkmkend histotypes_8h_a13}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 332 of file histotypes.h.\par
}
{\xe \v Bool_t\:histotypes.h}
{\xe \v histotypes.h\:Bool_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b UChar_t} Bool_t}
}\par
{\bkmkstart histotypes_8h_a15}
{\bkmkend histotypes_8h_a15}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 340 of file histotypes.h.\par
\par
Referenced by CTCLVariable::CTCLVariable(), CTCLInterpreter::ExprBoolean(), CTCLTimer::IsSet(), CTCLVariable::IsTracing(), CTCLString::Match(), CTCLProcessor::ParseBoolean(), CTCLInterpreter::RecordAndEval(), CTCLTimer::setSet(), and CTCLVariable::setTracing().}
{\xe \v Char_t\:histotypes.h}
{\xe \v histotypes.h\:Char_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef char Char_t}
}\par
{\bkmkstart histotypes_8h_a9}
{\bkmkend histotypes_8h_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 326 of file histotypes.h.\par
}
{\xe \v DFloat_t\:histotypes.h}
{\xe \v histotypes.h\:DFloat_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef double DFloat_t}
}\par
{\bkmkstart histotypes_8h_a8}
{\bkmkend histotypes_8h_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 322 of file histotypes.h.\par
\par
Referenced by CTCLInterpreter::ExprDouble().}
{\xe \v Float_t\:histotypes.h}
{\xe \v histotypes.h\:Float_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef float Float_t}
}\par
{\bkmkstart histotypes_8h_a7}
{\bkmkend histotypes_8h_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 321 of file histotypes.h.\par
}
{\xe \v Int_t\:histotypes.h}
{\xe \v histotypes.h\:Int_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef int Int_t}
}\par
{\bkmkstart histotypes_8h_a1}
{\bkmkend histotypes_8h_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 312 of file histotypes.h.\par
\par
Referenced by CTCLString::Append(), CAlarmLogger::CAlarmLogger(), CRangeError::CRangeError(), CTCLException::CTCLException(), CTCLInterpreter::DetachProcess(), CTCLHashTable< T >::Enter(), CTCLInterpreter::ExprBoolean(), CTCLInterpreter::ExprDouble(), CErrnoException::getErrno(), CRangeError::getHigh(), CRangeError::getLow(), CTCLException::getReason(), CRangeError::getRequested(), CTCLString::isCommand(), CTCLString::Match(), CStreamIOError::ReasonCode(), CErrnoException::setErrno(), CRangeError::setHigh(), CRangeError::setLow(), CTCLException::setReason(), CRangeError::setRequested(), and CTCLInterpreter::SignalId().}
{\xe \v Long_t\:histotypes.h}
{\xe \v histotypes.h\:Long_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef long Long_t}
}\par
{\bkmkstart histotypes_8h_a5}
{\bkmkend histotypes_8h_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 318 of file histotypes.h.\par
\par
Referenced by CTCLInterpreter::ExprLong().}
{\xe \v pTime_t\:histotypes.h}
{\xe \v histotypes.h\:pTime_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef   * pTime_t}
}\par
{\bkmkstart histotypes_8h_a18}
{\bkmkend histotypes_8h_a18}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v Short_t\:histotypes.h}
{\xe \v histotypes.h\:Short_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef short Short_t}
}\par
{\bkmkstart histotypes_8h_a3}
{\bkmkend histotypes_8h_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 315 of file histotypes.h.\par
}
{\xe \v Size_t\:histotypes.h}
{\xe \v histotypes.h\:Size_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b UInt_t} Size_t}
}\par
{\bkmkstart histotypes_8h_a12}
{\bkmkend histotypes_8h_a12}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 330 of file histotypes.h.\par
}
{\xe \v Textsz_t\:histotypes.h}
{\xe \v histotypes.h\:Textsz_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef char* Textsz_t}
}\par
{\bkmkstart histotypes_8h_a11}
{\bkmkend histotypes_8h_a11}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 329 of file histotypes.h.\par
}
{\xe \v UChar_t\:histotypes.h}
{\xe \v histotypes.h\:UChar_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned char UChar_t}
}\par
{\bkmkstart histotypes_8h_a10}
{\bkmkend histotypes_8h_a10}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 327 of file histotypes.h.\par
}
{\xe \v UInt_t\:histotypes.h}
{\xe \v histotypes.h\:UInt_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned int UInt_t}
}\par
{\bkmkstart histotypes_8h_a2}
{\bkmkend histotypes_8h_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 313 of file histotypes.h.\par
\par
Referenced by CTCLFileHandler::CTCLFileHandler(), CTCLTimer::CTCLTimer(), CTCLInterpreter::DetachProcess(), CTCLFileHandler::getFid(), CTCLTimer::getMsec(), CTCLTimer::Set(), CTCLFileHandler::setFid(), CTCLTimer::setMsec(), CTCLInterpreter::SignalId(), CTCLInterpreter::SignalMsg(), and CTCLString::Truncate().}
{\xe \v ULong_t\:histotypes.h}
{\xe \v histotypes.h\:ULong_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned long ULong_t}
}\par
{\bkmkstart histotypes_8h_a6}
{\bkmkend histotypes_8h_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 319 of file histotypes.h.\par
}
{\xe \v UShort_t\:histotypes.h}
{\xe \v histotypes.h\:UShort_t}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef unsigned short UShort_t}
}\par
{\bkmkstart histotypes_8h_a4}
{\bkmkend histotypes_8h_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 316 of file histotypes.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v kfFALSE\:histotypes.h}
{\xe \v histotypes.h\:kfFALSE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Bool_t} kfFALSE = 0{\f2  [static]}}
}\par
{\bkmkstart histotypes_8h_a17}
{\bkmkend histotypes_8h_a17}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 342 of file histotypes.h.\par
}
{\xe \v kfTRUE\:histotypes.h}
{\xe \v histotypes.h\:kfTRUE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Bool_t} kfTRUE = 0xff{\f2  [static]}}
}\par
{\bkmkstart histotypes_8h_a16}
{\bkmkend histotypes_8h_a16}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 341 of file histotypes.h.\par
}
{\xe \v kn1K\:histotypes.h}
{\xe \v histotypes.h\:kn1K}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UInt_t} kn1K = 1024{\f2  [static]}}
}\par
{\bkmkstart histotypes_8h_a19}
{\bkmkend histotypes_8h_a19}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 350 of file histotypes.h.\par
}
{\xe \v kn1M\:histotypes.h}
{\xe \v histotypes.h\:kn1M}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UInt_t} kn1M = {\b kn1K}*{\b kn1K}{\f2  [static]}}
}\par
{\bkmkstart histotypes_8h_a20}
{\bkmkend histotypes_8h_a20}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 351 of file histotypes.h.\par
}
{\xe \v knDefaultBufferSize\:histotypes.h}
{\xe \v histotypes.h\:knDefaultBufferSize}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b UInt_t} knDefaultBufferSize = {\b kn1K}*8{\f2  [static]}}
}\par
{\bkmkstart histotypes_8h_a21}
{\bkmkend histotypes_8h_a21}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 355 of file histotypes.h.\par
}
{\xe \v kpNULL\:histotypes.h}
{\xe \v histotypes.h\:kpNULL}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const {\b Address_t} kpNULL = ({\b Address_t})0{\f2  [static]}}
}\par
{\bkmkstart histotypes_8h_a14}
{\bkmkend histotypes_8h_a14}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 334 of file histotypes.h.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
locationmonitor.oxy File Reference\par \pard\plain 
{\tc\tcl2 \v locationmonitor.oxy}
{\xe \v locationmonitor.oxy}
{\bkmkstart locationmonitor_8oxy}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid \par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
maindocs.oxy File Reference\par \pard\plain 
{\tc\tcl2 \v maindocs.oxy}
{\xe \v maindocs.oxy}
{\bkmkstart maindocs_8oxy}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid \par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Registration.oxy File Reference\par \pard\plain 
{\tc\tcl2 \v Registration.oxy}
{\xe \v Registration.oxy}
{\bkmkstart Registration_8oxy}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid \par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
ServerEvent.oxy File Reference\par \pard\plain 
{\tc\tcl2 \v ServerEvent.oxy}
{\xe \v ServerEvent.oxy}
{\bkmkstart ServerEvent_8oxy}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid \par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SocketEvents.oxy File Reference\par \pard\plain 
{\tc\tcl2 \v SocketEvents.oxy}
{\xe \v SocketEvents.oxy}
{\bkmkstart SocketEvents_8oxy}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid \par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
SpectroFramework.h File Reference\par \pard\plain 
{\tc\tcl2 \v SpectroFramework.h}
{\xe \v SpectroFramework.h}
{\bkmkstart SpectroFramework_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <histotypes.h>}\par
{\f2 #include <CApplicationRegistry.h>}\par
{\f2 #include <CApplicationSerializer.h>}\par
{\f2 #include <CBufferEvent.h>}\par
{\f2 #include <CBufferMonitor.h>}\par
{\f2 #include <CBufferReactor.h>}\par
{\f2 #include <CChangedPredicate.h>}\par
{\f2 #include <CClassifiedObjectRegistry.h>}\par
{\f2 #include <CDAQTCLProcessor.h>}\par
{\f2 #include <CDuplicateNameException.h>}\par
{\f2 #include <CDuplicateSingleton.h>}\par
{\f2 #include <ErrnoException.h>}\par
{\f2 #include <CEvent.h>}\par
{\f2 #include <CEventLoop.h>}\par
{\f2 #include <CEventMonitor.h>}\par
{\f2 #include <Exception.h>}\par
{\f2 #include <CFdMonitor.h>}\par
{\f2 #include <CFdReactor.h>}\par
{\f2 #include <CFileEvent.h>}\par
{\f2 #include <CIncompatibleMonitor.h>}\par
{\f2 #include <CInterpreterStartup.h>}\par
{\f2 #include <CLinkFailedException.h>}\par
{\f2 #include <CLocationEvent.h>}\par
{\f2 #include <CLocationMonitor.h>}\par
{\f2 #include <CLocationReactor.h>}\par
{\f2 #include <CMaskedValuePredicate.h>}\par
{\f2 #include <CNamedObject.h>}\par
{\f2 #include <CNoSuchLinkException.h>}\par
{\f2 #include <CNoSuchObjectException.h>}\par
{\f2 #include <CObjectRegistry.h>}\par
{\f2 #include <CPointerPredicate.h>}\par
{\f2 #include <RangeError.h>}\par
{\f2 #include <CReactor.h>}\par
{\f2 #include <CRefptr.h>}\par
{\f2 #include <CRegisteredObject.h>}\par
{\f2 #include <CServerConnectionEvent.h>}\par
{\f2 #include <CServerInstance.h>}\par
{\f2 #include <CSocket.h>}\par
{\f2 #include <StreamIOError.h>}\par
{\f2 #include <CTCLInterpreterStartup.h>}\par
{\f2 #include <CTCLSynchronizeCommand.h>}\par
{\f2 #include <CTCPBadSocketState.h>}\par
{\f2 #include <CTCPConnectionFailed.h>}\par
{\f2 #include <CTCPConnectionLost.h>}\par
{\f2 #include <CTCPNoSuchHost.h>}\par
{\f2 #include <CTCPNoSuchService.h>}\par
{\f2 #include <CTKInterpreterStartup.h>}\par
{\f2 #include <CThreadRecursiveMutex.h>}\par
{\f2 #include <CTimerEvent.h>}\par
{\f2 #include <CTimerMonitor.h>}\par
{\f2 #include <CXtEventLoop.h>}\par
{\f2 #include <ClocationMonitor.h>}\par
{\f2 #include <SpectroFramework.h>}\par
{\f2 #include <TCLApplication.h>}\par
{\f2 #include <TCLCommandPackage.h>}\par
{\f2 #include <TCLException.h>}\par
{\f2 #include <TCLFileHandler.h>}\par
{\f2 #include <TCLHashTable.h>}\par
{\f2 #include <TCLHashTableItem.h>}\par
{\f2 #include <TCLHashTableIterator.h>}\par
{\f2 #include <TCLIdleProcess.h>}\par
{\f2 #include <TCLInterpreter.h>}\par
{\f2 #include <TCLInterpreterObject.h>}\par
{\f2 #include <TCLList.h>}\par
{\f2 #include <TCLObject.h>}\par
{\f2 #include <TCLPackagedCommand.h>}\par
{\f2 #include <TCLProcessor.h>}\par
{\f2 #include <TCLResult.h>}\par
{\f2 #include <TCLString.h>}\par
{\f2 #include <TCLTimer.h>}\par
{\f2 #include <TCLVariable.h>}\par
{\f2 #include <XMCallback.h>}\par
{\f2 #include <XMDialogs.h>}\par
{\f2 #include <XMLabel.h>}\par
{\f2 #include <XMList.h>}\par
{\f2 #include <XMManagers.h>}\par
{\f2 #include <XMMenubar.h>}\par
{\f2 #include <XMMenus.h>}\par
{\f2 #include <XMPushbutton.h>}\par
{\f2 #include <XMScale.h>}\par
{\f2 #include <XMSeparators.h>}\par
{\f2 #include <XMShell.h>}\par
{\f2 #include <XMText.h>}\par
{\f2 #include <XMWidget.h>}\par
{\f2 #include <XMWlist.h>}\par
{\f2 #include <CTypeFreeBinding.h>}\par
{\f2 #include <CBinding.h>}\par
{\f2 #include <CVariableBinding.h>}\par
{\f2 #include <CArrayBinding.h>}\par
{\f2 #include <CAssocArrayBinding.h>}\par
{\f2 #include <CConfigurationManager.h>}\par
\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Subclassing.oxy File Reference\par \pard\plain 
{\tc\tcl2 \v Subclassing.oxy}
{\xe \v Subclassing.oxy}
{\bkmkstart Subclassing_8oxy}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid \par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
Synchronization.oxy File Reference\par \pard\plain 
{\tc\tcl2 \v Synchronization.oxy}
{\xe \v Synchronization.oxy}
{\bkmkstart Synchronization_8oxy}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid \par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLApplication.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v TCLApplication.cpp}
{\xe \v TCLApplication.cpp}
{\bkmkstart TCLApplication_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TCLApplication.h"}\par
{\f2 #include "TCLInterpreter.h"}\par
{\f2 #include <histotypes.h>}\par
{\f2 #include <assert.h>}\par
{\f2 #include <tcl.h>}\par
{\f2 #include <tk.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b main} (int argc, char **argv)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
int {\b Tcl_AppInit} (Tcl_Interp *interp)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b pCopyright}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLApplication} * {\b gpTCLApplication}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b CTCLInterpreter} * {\b gpTCLInterpreter}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v main\:TCLApplication.cpp}
{\xe \v TCLApplication.cpp\:main}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int main (int {\i argc}, char ** {\i argv})}
}\par
{\bkmkstart TCLApplication_8cpp_a4}
{\bkmkend TCLApplication_8cpp_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 350 of file TCLApplication.cpp.\par
\par
References Tcl_AppInit().}
{\xe \v Tcl_AppInit\:TCLApplication.cpp}
{\xe \v TCLApplication.cpp\:Tcl_AppInit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
int Tcl_AppInit (Tcl_Interp * {\i interp})}
}\par
{\bkmkstart TCLApplication_8cpp_a5}
{\bkmkend TCLApplication_8cpp_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 358 of file TCLApplication.cpp.\par
\par
References CTCLInterpreterObject::Bind().\par
Referenced by CTCLApplication::CTCLApplication(), and main().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:TCLApplication.cpp}
{\xe \v TCLApplication.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart TCLApplication_8cpp_a0}
{\bkmkend TCLApplication_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file TCLApplication.cpp.\par
}
{\xe \v gpTCLApplication\:TCLApplication.cpp}
{\xe \v TCLApplication.cpp\:gpTCLApplication}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CTCLApplication}* gpTCLApplication}
}\par
{\bkmkstart TCLApplication_8cpp_a2}
{\bkmkend TCLApplication_8cpp_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 318 of file TCLApplication.cpp.\par
}
{\xe \v gpTCLInterpreter\:TCLApplication.cpp}
{\xe \v TCLApplication.cpp\:gpTCLInterpreter}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b CTCLInterpreter}* gpTCLInterpreter}
}\par
{\bkmkstart TCLApplication_8cpp_a3}
{\bkmkend TCLApplication_8cpp_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 320 of file TCLApplication.cpp.\par
}
{\xe \v pCopyright\:TCLApplication.cpp}
{\xe \v TCLApplication.cpp\:pCopyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* pCopyright{\f2  [static]}}
}\par
{\bkmkstart TCLApplication_8cpp_a1}
{\bkmkend TCLApplication_8cpp_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \par
"TCLApplication.cpp - (c) Copyright NSCL 1999, all rights reserved\\n"\par
}
Definition at line 312 of file TCLApplication.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLApplication.h File Reference\par \pard\plain 
{\tc\tcl2 \v TCLApplication.h}
{\xe \v TCLApplication.h}
{\bkmkstart TCLApplication_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TCLInterpreterObject.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTCLApplication}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLCommandPackage.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v TCLCommandPackage.cpp}
{\xe \v TCLCommandPackage.cpp}
{\bkmkstart TCLCommandPackage_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TCLCommandPackage.h"}\par
{\f2 #include <assert.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:TCLCommandPackage.cpp}
{\xe \v TCLCommandPackage.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright{\f2  [static]}}
}\par
{\bkmkstart TCLCommandPackage_8cpp_a0}
{\bkmkend TCLCommandPackage_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \par
"CTCLCommandPackage.cpp: Copyright 1999 NSCL, All rights reserved\\n"\par
}
Definition at line 311 of file TCLCommandPackage.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLCommandPackage.h File Reference\par \pard\plain 
{\tc\tcl2 \v TCLCommandPackage.h}
{\xe \v TCLCommandPackage.h}
{\bkmkstart TCLCommandPackage_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TCLInterpreterObject.h"}\par
{\f2 #include "TCLInterpreter.h"}\par
{\f2 #include "TCLProcessor.h"}\par
{\f2 #include <histotypes.h>}\par
{\f2 #include <list>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTCLCommandPackage}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef std::list< {\b CTCLProcessor} * > {\b CommandList}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef CommandList::iterator {\b CommandListIterator}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v CommandList\:TCLCommandPackage.h}
{\xe \v TCLCommandPackage.h\:CommandList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef std::list<{\b CTCLProcessor}*> CommandList}
}\par
{\bkmkstart TCLCommandPackage_8h_a0}
{\bkmkend TCLCommandPackage_8h_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 325 of file TCLCommandPackage.h.\par
\par
Referenced by CTCLCommandPackage::AddProcessors(), CTCLCommandPackage::getCommandList(), and CTCLCommandPackage::setCommandList().}
{\xe \v CommandListIterator\:TCLCommandPackage.h}
{\xe \v TCLCommandPackage.h\:CommandListIterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef CommandList::iterator CommandListIterator}
}\par
{\bkmkstart TCLCommandPackage_8h_a1}
{\bkmkend TCLCommandPackage_8h_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 326 of file TCLCommandPackage.h.\par
\par
Referenced by CTCLCommandPackage::begin(), CTCLCommandPackage::end(), CTCLCommandPackage::Register(), and CTCLCommandPackage::Unregister().}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLException.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v TCLException.cpp}
{\xe \v TCLException.cpp}
{\bkmkstart TCLException_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TCLException.h"}\par
{\f2 #include "TCLInterpreter.h"}\par
{\f2 #include <tcl.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:TCLException.cpp}
{\xe \v TCLException.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright{\f2  [static]}}
}\par
{\bkmkstart TCLException_8cpp_a0}
{\bkmkend TCLException_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \par
"CTCLException.cpp: Copyright 1999 NSCL, All rights reserved\\n"\par
}
Definition at line 300 of file TCLException.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLException.h File Reference\par \pard\plain 
{\tc\tcl2 \v TCLException.h}
{\xe \v TCLException.h}
{\bkmkstart TCLException_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TCLInterpreterObject.h"}\par
{\f2 #include "TCLResult.h"}\par
{\f2 #include "CException.h"}\par
{\f2 #include <histotypes.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTCLException}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLFileHandler.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v TCLFileHandler.cpp}
{\xe \v TCLFileHandler.cpp}
{\bkmkstart TCLFileHandler_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TCLFileHandler.h"}\par
{\f2 #include <tcl.h>}\par
{\f2 #include <tk.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:TCLFileHandler.cpp}
{\xe \v TCLFileHandler.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright{\f2  [static]}}
}\par
{\bkmkstart TCLFileHandler_8cpp_a0}
{\bkmkend TCLFileHandler_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  Copyright = \par
"CTCLFileHandler.cpp: Copyright 1999 NSCL, All rights reserved\\n"\par
}
Definition at line 307 of file TCLFileHandler.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLFileHandler.h File Reference\par \pard\plain 
{\tc\tcl2 \v TCLFileHandler.h}
{\xe \v TCLFileHandler.h}
{\bkmkstart TCLFileHandler_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TCLInterpreterObject.h"}\par
{\f2 #include <histotypes.h>}\par
{\f2 #include <unistd.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <fstream.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTCLFileHandler}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLGuests.oxy File Reference\par \pard\plain 
{\tc\tcl2 \v TCLGuests.oxy}
{\xe \v TCLGuests.oxy}
{\bkmkstart TCLGuests_8oxy}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid \par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLHashTable.h File Reference\par \pard\plain 
{\tc\tcl2 \v TCLHashTable.h}
{\xe \v TCLHashTable.h}
{\bkmkstart TCLHashTable_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TCLHashTableItem.h"}\par
{\f2 #include "TCLHashTableIterator.h"}\par
{\f2 #include <histotypes.h>}\par
{\f2 #include <assert.h>}\par
{\f2 #include <string>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTCLHashTable}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLHashTableItem.h File Reference\par \pard\plain 
{\tc\tcl2 \v TCLHashTableItem.h}
{\xe \v TCLHashTableItem.h}
{\bkmkstart TCLHashTableItem_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid \par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTCLHashTableItem}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLHashTableIterator.h File Reference\par \pard\plain 
{\tc\tcl2 \v TCLHashTableIterator.h}
{\xe \v TCLHashTableIterator.h}
{\bkmkstart TCLHashTableIterator_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TCLHashTableItem.h"}\par
{\f2 #include <tcl.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTCLHashTableIterator}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLIdleProcess.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v TCLIdleProcess.cpp}
{\xe \v TCLIdleProcess.cpp}
{\bkmkstart TCLIdleProcess_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TCLIdleProcess.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b Copyright}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:TCLIdleProcess.cpp}
{\xe \v TCLIdleProcess.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* Copyright{\f2  [static]}}
}\par
{\bkmkstart TCLIdleProcess_8cpp_a0}
{\bkmkend TCLIdleProcess_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid \par
"TCLIdleProcess.cpp - (c) Copyright NSCL 1999, All rights reserved\\n"\par
}
Definition at line 301 of file TCLIdleProcess.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLIdleProcess.h File Reference\par \pard\plain 
{\tc\tcl2 \v TCLIdleProcess.h}
{\xe \v TCLIdleProcess.h}
{\bkmkstart TCLIdleProcess_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TCLTimer.h"}\par
{\f2 #include <histotypes.h>}\par
{\f2 #include <tk.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTCLIdleProcess}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLInterpreter.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v TCLInterpreter.cpp}
{\xe \v TCLInterpreter.cpp}
{\bkmkstart TCLInterpreter_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TCLInterpreter.h"}\par
{\f2 #include "TCLException.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:TCLInterpreter.cpp}
{\xe \v TCLInterpreter.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart TCLInterpreter_8cpp_a0}
{\bkmkend TCLInterpreter_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file TCLInterpreter.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLInterpreter.h File Reference\par \pard\plain 
{\tc\tcl2 \v TCLInterpreter.h}
{\xe \v TCLInterpreter.h}
{\bkmkstart TCLInterpreter_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <string>}\par
{\f2 #include <vector>}\par
{\f2 #include "TCLString.h"}\par
{\f2 #include <histotypes.h>}\par
{\f2 #include <tcl.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTCLInterpreter}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLInterpreterObject.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v TCLInterpreterObject.cpp}
{\xe \v TCLInterpreterObject.cpp}
{\bkmkstart TCLInterpreterObject_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TCLInterpreterObject.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:TCLInterpreterObject.cpp}
{\xe \v TCLInterpreterObject.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright{\f2  [static]}}
}\par
{\bkmkstart TCLInterpreterObject_8cpp_a0}
{\bkmkend TCLInterpreterObject_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \par
"CTCLInterpreterObject.cpp: Copyright 1999 NSCL, All rights reserved\\n"\par
}
Definition at line 305 of file TCLInterpreterObject.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLInterpreterObject.h File Reference\par \pard\plain 
{\tc\tcl2 \v TCLInterpreterObject.h}
{\xe \v TCLInterpreterObject.h}
{\bkmkstart TCLInterpreterObject_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <tcl.h>}\par
{\f2 #include <histotypes.h>}\par
{\f2 #include <assert.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTCLInterpreterObject}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLList.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v TCLList.cpp}
{\xe \v TCLList.cpp}
{\bkmkstart TCLList_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TCLList.h"}\par
{\f2 #include "TCLInterpreter.h"}\par
{\f2 #include <string.h>}\par
{\f2 #include <assert.h>}\par
{\f2 #include <malloc.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:TCLList.cpp}
{\xe \v TCLList.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright{\f2  [static]}}
}\par
{\bkmkstart TCLList_8cpp_a0}
{\bkmkend TCLList_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  Copyright = \par
"CTCLList.cpp: Copyright 1999 NSCL, All rights reserved\\n"\par
}
Definition at line 306 of file TCLList.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLList.h File Reference\par \pard\plain 
{\tc\tcl2 \v TCLList.h}
{\xe \v TCLList.h}
{\bkmkstart TCLList_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TCLInterpreterObject.h"}\par
{\f2 #include <string>}\par
{\f2 #include <vector>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTCLList}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef vector< std::string > {\b StringArray}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef StringArray::iterator {\b StringArrayIterator}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v StringArray\:TCLList.h}
{\xe \v TCLList.h\:StringArray}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef vector<std::string> StringArray}
}\par
{\bkmkstart TCLList_8h_a0}
{\bkmkend TCLList_8h_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 310 of file TCLList.h.\par
\par
Referenced by CAssocArrayBinding< T >::Commit(), CTCLList::Merge(), and CTCLList::Split().}
{\xe \v StringArrayIterator\:TCLList.h}
{\xe \v TCLList.h\:StringArrayIterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef StringArray::iterator StringArrayIterator}
}\par
{\bkmkstart TCLList_8h_a1}
{\bkmkend TCLList_8h_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 311 of file TCLList.h.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLObject.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v TCLObject.cpp}
{\xe \v TCLObject.cpp}
{\bkmkstart TCLObject_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TCLObject.h"}\par
{\f2 #include "TCLInterpreter.h"}\par
{\f2 #include "TCLList.h"}\par
{\f2 #include "TCLException.h"}\par
{\f2 #include <string.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b pCopyrightNotice}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:TCLObject.cpp}
{\xe \v TCLObject.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart TCLObject_8cpp_a0}
{\bkmkend TCLObject_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file TCLObject.cpp.\par
}
{\xe \v pCopyrightNotice\:TCLObject.cpp}
{\xe \v TCLObject.cpp\:pCopyrightNotice}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* pCopyrightNotice{\f2  [static]}}
}\par
{\bkmkstart TCLObject_8cpp_a1}
{\bkmkend TCLObject_8cpp_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \par
"(C) Copyright 1999 NSCL, All rights reserved TCLObject.cpp \\n"\par
}
Definition at line 296 of file TCLObject.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLObject.h File Reference\par \pard\plain 
{\tc\tcl2 \v TCLObject.h}
{\xe \v TCLObject.h}
{\bkmkstart TCLObject_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TCLInterpreterObject.h"}\par
{\f2 #include "TCLList.h"}\par
{\f2 #include <tcl.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTCLObject}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLPackagedCommand.h File Reference\par \pard\plain 
{\tc\tcl2 \v TCLPackagedCommand.h}
{\xe \v TCLPackagedCommand.h}
{\bkmkstart TCLPackagedCommand_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TCLCommandPackage.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTCLPackagedCommand}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLProcessor.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v TCLProcessor.cpp}
{\xe \v TCLProcessor.cpp}
{\bkmkstart TCLProcessor_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TCLProcessor.h"}\par
{\f2 #include "TCLException.h"}\par
{\f2 #include "TCLResult.h"}\par
{\f2 #include <tcl.h>}\par
{\f2 #include <assert.h>}\par
{\f2 #include <vector>}\par
{\f2 #include <string>}\par
{\f2 #include <string.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:TCLProcessor.cpp}
{\xe \v TCLProcessor.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright{\f2  [static]}}
}\par
{\bkmkstart TCLProcessor_8cpp_a0}
{\bkmkend TCLProcessor_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  Copyright = \par
"CTCLProcessor.cpp: Copyright 1999 NSCL, All rights reserved\\n"\par
}
Definition at line 318 of file TCLProcessor.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLProcessor.h File Reference\par \pard\plain 
{\tc\tcl2 \v TCLProcessor.h}
{\xe \v TCLProcessor.h}
{\bkmkstart TCLProcessor_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TCLInterpreter.h"}\par
{\f2 #include "TCLResult.h"}\par
{\f2 #include "TCLInterpreterObject.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTCLProcessor}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef vector< {\b CTCLInterpreter} * > {\b TCLInterpreterList}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef TCLInterpreterList::iterator {\b TCLInterpreterIterator}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v TCLInterpreterIterator\:TCLProcessor.h}
{\xe \v TCLProcessor.h\:TCLInterpreterIterator}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef TCLInterpreterList::iterator TCLInterpreterIterator}
}\par
{\bkmkstart TCLProcessor_8h_a1}
{\bkmkend TCLProcessor_8h_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 319 of file TCLProcessor.h.\par
\par
Referenced by CTCLProcessor::begin(), CTCLProcessor::DeleteRelay(), CTCLProcessor::end(), and CTCLProcessor::EvalRelay().}
{\xe \v TCLInterpreterList\:TCLProcessor.h}
{\xe \v TCLProcessor.h\:TCLInterpreterList}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef vector<{\b CTCLInterpreter}*> TCLInterpreterList}
}\par
{\bkmkstart TCLProcessor_8h_a0}
{\bkmkend TCLProcessor_8h_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 318 of file TCLProcessor.h.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLResult.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v TCLResult.cpp}
{\xe \v TCLResult.cpp}
{\bkmkstart TCLResult_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TCLResult.h"}\par
{\f2 #include "TCLString.h"}\par
{\f2 #include "TCLInterpreter.h"}\par
{\f2 #include <tcl.h>}\par
{\f2 #include <histotypes.h>}\par
{\f2 #include <assert.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:TCLResult.cpp}
{\xe \v TCLResult.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright{\f2  [static]}}
}\par
{\bkmkstart TCLResult_8cpp_a0}
{\bkmkend TCLResult_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \par
"CTCLResult.cpp: Copyright 1999 NSCL, All rights reserved\\n"\par
}
Definition at line 308 of file TCLResult.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLResult.h File Reference\par \pard\plain 
{\tc\tcl2 \v TCLResult.h}
{\xe \v TCLResult.h}
{\bkmkstart TCLResult_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TCLString.h"}\par
{\f2 #include "TCLInterpreterObject.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTCLResult}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLString.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v TCLString.cpp}
{\xe \v TCLString.cpp}
{\bkmkstart TCLString_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TCLString.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:TCLString.cpp}
{\xe \v TCLString.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright{\f2  [static]}}
}\par
{\bkmkstart TCLString_8cpp_a0}
{\bkmkend TCLString_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  Copyright = \par
"CTCLString.cpp: Copyright 1999 NSCL, All rights reserved\\n"\par
}
Definition at line 304 of file TCLString.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLString.h File Reference\par \pard\plain 
{\tc\tcl2 \v TCLString.h}
{\xe \v TCLString.h}
{\bkmkstart TCLString_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <tcl.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <histotypes.h>}\par
{\f2 #include <string>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTCLString}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLTimer.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v TCLTimer.cpp}
{\xe \v TCLTimer.cpp}
{\bkmkstart TCLTimer_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TCLTimer.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:TCLTimer.cpp}
{\xe \v TCLTimer.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright{\f2  [static]}}
}\par
{\bkmkstart TCLTimer_8cpp_a0}
{\bkmkend TCLTimer_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  Copyright = \par
"CTCLTimer.cpp: Copyright 1999 NSCL, All rights reserved\\n"\par
}
Definition at line 308 of file TCLTimer.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLTimer.h File Reference\par \pard\plain 
{\tc\tcl2 \v TCLTimer.h}
{\xe \v TCLTimer.h}
{\bkmkstart TCLTimer_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TCLInterpreterObject.h"}\par
{\f2 #include <tcl.h>}\par
{\f2 #include <tk.h>}\par
{\f2 #include <histotypes.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTCLTimer}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b _TCL_TK_H}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v _TCL_TK_H\:TCLTimer.h}
{\xe \v TCLTimer.h\:_TCL_TK_H}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define _TCL_TK_H}
}\par
{\bkmkstart TCLTimer_8h_a0}
{\bkmkend TCLTimer_8h_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 307 of file TCLTimer.h.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLVariable.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v TCLVariable.cpp}
{\xe \v TCLVariable.cpp}
{\bkmkstart TCLVariable_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TCLVariable.h"}\par
{\f2 #include "TCLInterpreter.h"}\par
{\f2 #include <tcl.h>}\par
{\f2 #include <histotypes.h>}\par
{\f2 #include <assert.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:TCLVariable.cpp}
{\xe \v TCLVariable.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright{\f2  [static]}}
}\par
{\bkmkstart TCLVariable_8cpp_a0}
{\bkmkend TCLVariable_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  Copyright = \par
"CTCLVariable.cpp: Copyright 1999 NSCL, All rights reserved\\n"\par
}
Definition at line 307 of file TCLVariable.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TCLVariable.h File Reference\par \pard\plain 
{\tc\tcl2 \v TCLVariable.h}
{\xe \v TCLVariable.h}
{\bkmkstart TCLVariable_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "TCLInterpreterObject.h"}\par
{\f2 #include <histotypes.h>}\par
{\f2 #include <string>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b CTCLVariable}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
tcpip.oxy File Reference\par \pard\plain 
{\tc\tcl2 \v tcpip.oxy}
{\xe \v tcpip.oxy}
{\bkmkstart tcpip_8oxy}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid \par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
TimerEventTest.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v TimerEventTest.cpp}
{\xe \v TimerEventTest.cpp}
{\bkmkstart TimerEventTest_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid \par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:TimerEventTest.cpp}
{\xe \v TimerEventTest.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart TimerEventTest_8cpp_a0}
{\bkmkend TimerEventTest_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file TimerEventTest.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMCallback.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v XMCallback.cpp}
{\xe \v XMCallback.cpp}
{\bkmkstart XMCallback_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <errno.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include "XMWidget.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b exit} (int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b XMDispatchCallback} (Widget w, XtPointer cbd, XtPointer reason)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Callback_data} * {\b XMAddCallback} ({\b XMWidget} *object, String reason, void(*proc)({\b XMWidget} *, XtPointer, XtPointer), XtPointer data)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b XMRemoveCallback} ({\b Callback_data} *cbd)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b XMUnmanageChild} ({\b XMWidget} *wid, XtPointer client_data, XtPointer callback_data)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b XMDestroyWidget} ({\b XMWidget} *w, XtPointer cd, XtPointer cb)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b sccsversion} = "@(#){\b XMCallback}.cc 8.2 1/26/98 "\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v exit\:XMCallback.cpp}
{\xe \v XMCallback.cpp\:exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void exit (int)}
}\par
{\bkmkstart XMCallback_8cpp_a2}
{\bkmkend XMCallback_8cpp_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v XMAddCallback\:XMCallback.cpp}
{\xe \v XMCallback.cpp\:XMAddCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Callback_data}* XMAddCallback ({\b XMWidget} * {\i object}, String {\i reason}, void(* {\i proc})({\b XMWidget} *, XtPointer, XtPointer), XtPointer {\i data})}
}\par
{\bkmkstart XMCallback_8cpp_a4}
{\bkmkend XMCallback_8cpp_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 359 of file XMCallback.cpp.\par
\par
References Callback_data::client_data, exit(), Callback_data::function, XMWidget::getid(), Callback_data::object, Callback_data::reason, and XMDispatchCallback().\par
Referenced by XMWidget::AddCallback().}
{\xe \v XMDestroyWidget\:XMCallback.cpp}
{\xe \v XMCallback.cpp\:XMDestroyWidget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMDestroyWidget ({\b XMWidget} * {\i w}, XtPointer {\i cd}, XtPointer {\i cb})}
}\par
{\bkmkstart XMCallback_8cpp_a7}
{\bkmkend XMCallback_8cpp_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 438 of file XMCallback.cpp.\par
}
{\xe \v XMDispatchCallback\:XMCallback.cpp}
{\xe \v XMCallback.cpp\:XMDispatchCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMDispatchCallback (Widget {\i w}, XtPointer {\i cbd}, XtPointer {\i reason}){\f2  [static]}}
}\par
{\bkmkstart XMCallback_8cpp_a3}
{\bkmkend XMCallback_8cpp_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 335 of file XMCallback.cpp.\par
\par
References Callback_data::client_data, Callback_data::function, and Callback_data::object.\par
Referenced by XMAddCallback(), and XMRemoveCallback().}
{\xe \v XMRemoveCallback\:XMCallback.cpp}
{\xe \v XMCallback.cpp\:XMRemoveCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMRemoveCallback ({\b Callback_data} * {\i cbd})}
}\par
{\bkmkstart XMCallback_8cpp_a5}
{\bkmkend XMCallback_8cpp_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 396 of file XMCallback.cpp.\par
\par
References XMWidget::getid(), Callback_data::object, Callback_data::reason, and XMDispatchCallback().}
{\xe \v XMUnmanageChild\:XMCallback.cpp}
{\xe \v XMCallback.cpp\:XMUnmanageChild}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMUnmanageChild ({\b XMWidget} * {\i wid}, XtPointer {\i client_data}, XtPointer {\i callback_data})}
}\par
{\bkmkstart XMCallback_8cpp_a6}
{\bkmkend XMCallback_8cpp_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Functional Description: XMUnmanageChild - A callback that can be specified to unmanage a child widget. Formal Parameters: {\b XMWidget} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classXMWidget \\*MERGEFORMAT}{\fldrslt pagenum}}}) *wid: Widget of callback. XtPointer client_data, callback_data: Ignored data pointers. \par
\par
Definition at line 422 of file XMCallback.cpp.\par
\par
References XMWidget::UnManage().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:XMCallback.cpp}
{\xe \v XMCallback.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart XMCallback_8cpp_a0}
{\bkmkend XMCallback_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file XMCallback.cpp.\par
}
{\xe \v sccsversion\:XMCallback.cpp}
{\xe \v XMCallback.cpp\:sccsversion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* sccsversion = "@(#){\b XMCallback}.cc 8.2 1/26/98 "{\f2  [static]}}
}\par
{\bkmkstart XMCallback_8cpp_a1}
{\bkmkend XMCallback_8cpp_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 303 of file XMCallback.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMcallback.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v XMcallback.cpp}
{\xe \v XMcallback.cpp}
{\bkmkstart XMcallback_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <errno.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include "XMWidget.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b exit} (int)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b XMDispatchCallback} (Widget w, XtPointer cbd, XtPointer reason)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
{\b Callback_data} * {\b XMAddCallback} ({\b XMWidget} *object, String reason, void(*proc)({\b XMWidget} *, XtPointer, XtPointer), XtPointer data)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b XMRemoveCallback} ({\b Callback_data} *cbd)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b XMUnmanageChild} ({\b XMWidget} *wid, XtPointer client_data, XtPointer callback_data)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b XMDestroyWidget} ({\b XMWidget} *w, XtPointer cd, XtPointer cb)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b sccsversion} = "@(#)XMcallback.cc 8.1 6/23/95 "\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v exit\:XMcallback.cpp}
{\xe \v XMcallback.cpp\:exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void exit (int)}
}\par
{\bkmkstart XMcallback_8cpp_a2}
{\bkmkend XMcallback_8cpp_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\xe \v XMAddCallback\:XMcallback.cpp}
{\xe \v XMcallback.cpp\:XMAddCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
{\b Callback_data}* XMAddCallback ({\b XMWidget} * {\i object}, String {\i reason}, void(* {\i proc})({\b XMWidget} *, XtPointer, XtPointer), XtPointer {\i data})}
}\par
{\bkmkstart XMcallback_8cpp_a4}
{\bkmkend XMcallback_8cpp_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 359 of file XMcallback.cpp.\par
\par
References Callback_data::client_data, exit(), Callback_data::function, XMWidget::getid(), Callback_data::object, Callback_data::reason, and XMDispatchCallback().}
{\xe \v XMDestroyWidget\:XMcallback.cpp}
{\xe \v XMcallback.cpp\:XMDestroyWidget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMDestroyWidget ({\b XMWidget} * {\i w}, XtPointer {\i cd}, XtPointer {\i cb})}
}\par
{\bkmkstart XMcallback_8cpp_a7}
{\bkmkend XMcallback_8cpp_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 438 of file XMcallback.cpp.\par
}
{\xe \v XMDispatchCallback\:XMcallback.cpp}
{\xe \v XMcallback.cpp\:XMDispatchCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMDispatchCallback (Widget {\i w}, XtPointer {\i cbd}, XtPointer {\i reason}){\f2  [static]}}
}\par
{\bkmkstart XMcallback_8cpp_a3}
{\bkmkend XMcallback_8cpp_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 335 of file XMcallback.cpp.\par
\par
References Callback_data::client_data, Callback_data::function, and Callback_data::object.\par
Referenced by XMAddCallback(), and XMRemoveCallback().}
{\xe \v XMRemoveCallback\:XMcallback.cpp}
{\xe \v XMcallback.cpp\:XMRemoveCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMRemoveCallback ({\b Callback_data} * {\i cbd})}
}\par
{\bkmkstart XMcallback_8cpp_a5}
{\bkmkend XMcallback_8cpp_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 396 of file XMcallback.cpp.\par
\par
References XMWidget::getid(), Callback_data::object, Callback_data::reason, and XMDispatchCallback().}
{\xe \v XMUnmanageChild\:XMcallback.cpp}
{\xe \v XMcallback.cpp\:XMUnmanageChild}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMUnmanageChild ({\b XMWidget} * {\i wid}, XtPointer {\i client_data}, XtPointer {\i callback_data})}
}\par
{\bkmkstart XMcallback_8cpp_a6}
{\bkmkend XMcallback_8cpp_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Functional Description: XMUnmanageChild - A callback that can be specified to unmanage a child widget. Formal Parameters: {\b XMWidget} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classXMWidget \\*MERGEFORMAT}{\fldrslt pagenum}}}) *wid: Widget of callback. XtPointer client_data, callback_data: Ignored data pointers. \par
\par
Definition at line 422 of file XMcallback.cpp.\par
\par
References XMWidget::UnManage().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:XMcallback.cpp}
{\xe \v XMcallback.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart XMcallback_8cpp_a0}
{\bkmkend XMcallback_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file XMcallback.cpp.\par
}
{\xe \v sccsversion\:XMcallback.cpp}
{\xe \v XMcallback.cpp\:sccsversion}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* sccsversion = "@(#)XMcallback.cc 8.1 6/23/95 "{\f2  [static]}}
}\par
{\bkmkstart XMcallback_8cpp_a1}
{\bkmkend XMcallback_8cpp_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 303 of file XMcallback.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMCallback.h File Reference\par \pard\plain 
{\tc\tcl2 \v XMCallback.h}
{\xe \v XMCallback.h}
{\bkmkstart XMCallback_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "XMWidget.h"}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <string.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XMCallback}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b TEMP_TYPEDEF}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v TEMP_TYPEDEF\:XMCallback.h}
{\xe \v XMCallback.h\:TEMP_TYPEDEF}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define TEMP_TYPEDEF}
}\par
{\bkmkstart XMCallback_8h_a0}
{\bkmkend XMCallback_8h_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 312 of file XMCallback.h.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMDialogs.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v XMDialogs.cpp}
{\xe \v XMDialogs.cpp}
{\bkmkstart XMDialogs_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "XMDialogs.h"}\par
{\f2 #include <Xm/MwmUtil.h>}\par
{\f2 #include <Xm/DialogS.h>}\par
{\f2 #include <Xm/FileSB.h>}\par
{\f2 #include <X11/Shell.h>}\par
{\f2 #include <stdio.h>}\par
{\f2 #include <assert.h>}\par
{\f2 #include <string.h>}\par
{\f2 #include <ctype.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b StripNonPrinting} (char *out, char *in)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b SetupBorders} (Widget id)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b sccsinfo} = "@(#)XMDialogs.cc 8.2 9/10/96 \\n"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b prompter_help} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b SelectionDefaultHelp} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b FileSelectorHelp} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b custom_help} []\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v SetupBorders\:XMDialogs.cpp}
{\xe \v XMDialogs.cpp\:SetupBorders}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void SetupBorders (Widget {\i id}){\f2  [static]}}
}\par
{\bkmkstart XMDialogs_8cpp_a7}
{\bkmkend XMDialogs_8cpp_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 342 of file XMDialogs.cpp.\par
}
{\xe \v StripNonPrinting\:XMDialogs.cpp}
{\xe \v XMDialogs.cpp\:StripNonPrinting}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void StripNonPrinting (char * {\i out}, char * {\i in}){\f2  [static]}}
}\par
{\bkmkstart XMDialogs_8cpp_a6}
{\bkmkend XMDialogs_8cpp_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 324 of file XMDialogs.cpp.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:XMDialogs.cpp}
{\xe \v XMDialogs.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart XMDialogs_8cpp_a0}
{\bkmkend XMDialogs_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file XMDialogs.cpp.\par
}
{\xe \v custom_help\:XMDialogs.cpp}
{\xe \v XMDialogs.cpp\:custom_help}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* custom_help[]{\f2  [static]}}
}\par
{\bkmkstart XMDialogs_8cpp_a5}
{\bkmkend XMDialogs_8cpp_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
  "  This is a custom dialog box which was created by a programmer that was\\n",\par
  "too lazy to supply detailed help text about what the dialog does.  Since\\n",\par
  "the work area of the dialog box could be almost anything, I cannot be\\n",\par
  "much of a help about what to do there.  What I can say, however is that\\n",\par
  "after you've done what you need to do in the work area, you should select\\n",\par
  "one of the following buttons from the action area:\\n\\n",\par
  "    Ok     - Generally accepts what ever you've done and removes the\\n",\par
  "             dialog box assuming everything was done properly\\n",\par
  "    Apply  - Generally the same as Ok, but leaves the dialog box up.\\n",\par
  "    Cancel - Generally takes no action, but dismisses the dialog box\\n",\par
  "    Help   - Causes this helpful message to appear.\\n\\n",\par
  "NOTE:  If you know who wrote this program, then bother the hell out of \\n",\par
  "       that person to replace this help text with something more specific\\n",\par
  "       to the application\\n",\par
  NULL\par
\}\par
}
Definition at line 1520 of file XMDialogs.cpp.\par
}
{\xe \v FileSelectorHelp\:XMDialogs.cpp}
{\xe \v XMDialogs.cpp\:FileSelectorHelp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* FileSelectorHelp[]{\f2  [static]}}
}\par
{\bkmkstart XMDialogs_8cpp_a4}
{\bkmkend XMDialogs_8cpp_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 1176 of file XMDialogs.cpp.\par
}
{\xe \v prompter_help\:XMDialogs.cpp}
{\xe \v XMDialogs.cpp\:prompter_help}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* prompter_help[]{\f2  [static]}}
}\par
{\bkmkstart XMDialogs_8cpp_a2}
{\bkmkend XMDialogs_8cpp_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
  "You are being prompted for some text.  Type the text in the text window.\\n",\par
  " When you have edited the text to look like what you want click:  \\n\\n",\par
  "   Ok    - To accept the text and remove the dialog.\\n",\par
  "   Apply - To accept the text and leave the dialog displayed \\n",\par
  "   Cancel- To cancel dismiss the dialog without accepting the text\\n",\par
  "   Help  - To display this message\\n",\par
  NULL\par
\}\par
}
Definition at line 610 of file XMDialogs.cpp.\par
}
{\xe \v sccsinfo\:XMDialogs.cpp}
{\xe \v XMDialogs.cpp\:sccsinfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* sccsinfo = "@(#)XMDialogs.cc 8.2 9/10/96 \\n"{\f2  [static]}}
}\par
{\bkmkstart XMDialogs_8cpp_a1}
{\bkmkend XMDialogs_8cpp_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 296 of file XMDialogs.cpp.\par
}
{\xe \v SelectionDefaultHelp\:XMDialogs.cpp}
{\xe \v XMDialogs.cpp\:SelectionDefaultHelp}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* SelectionDefaultHelp[]{\f2  [static]}}
}\par
{\bkmkstart XMDialogs_8cpp_a3}
{\bkmkend XMDialogs_8cpp_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{\par
  "  You are being asked to select an item from the list of choices\\n",\par
  "in the list box part of the widget.  You can select an item either by\\n",\par
  "clicking on it with the mouse or by typing it into the text input\\n",\par
  "area below the list box.  Once you have made your selection, you should\\n",\par
  "click a button in the action area at the bottom of the dialog where: \\n\\n",\par
  "    Ok          - Will accept your choice and dismiss the dialog\\n",\par
  "    Apply       - Will accept your choice and leave the dialog displayed\\n",\par
  "    Cancel      - Will dismiss the dialog without any action\\n",\par
  "    Help        - Will display this text\\n",\par
  NULL\par
\}\par
}
Definition at line 917 of file XMDialogs.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMDialogs.h File Reference\par \pard\plain 
{\tc\tcl2 \v XMDialogs.h}
{\xe \v XMDialogs.h}
{\bkmkstart XMDialogs_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <X11/StringDefs.h>}\par
{\f2 #include <Xm/MessageB.h>}\par
{\f2 #include <Xm/SelectioB.h>}\par
{\f2 #include <Xm/FileSB.h>}\par
{\f2 #include "XMWidget.h"}\par
{\f2 #include "XMPushbutton.h"}\par
{\f2 #include "XMManagers.h"}\par
{\f2 #include "XMCallback.h"}\par
\par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMHelp.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v XMHelp.cpp}
{\xe \v XMHelp.cpp}
{\bkmkstart XMHelp_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <Xm/Xm.h>}\par
{\f2 #include "XMDialogs.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
XMInformationDialog * {\b XM_help} (char *name, {\b XMWidget} *parent, char **help_text)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b XM_display_help} ({\b XMWidget} *caller, XtPointer client_data, XtPointer reason)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b sccsinfo} = "@(#)helpmenu.cc 8.9 10/19/98 \\n"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b About} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b aboutname} = "{\b About}"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
XM_help_client_data {\b XM_About} = \{ {\b aboutname}, NULL, {\b About} \}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b Help} []\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b overname} = "Help_Overview"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
XM_help_client_data {\b XM_Help_Overview} = \{{\b overname}, NULL, {\b Help} \}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v XM_display_help\:XMHelp.cpp}
{\xe \v XMHelp.cpp\:XM_display_help}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XM_display_help ({\b XMWidget} * {\i caller}, XtPointer {\i client_data}, XtPointer {\i reason})}
}\par
{\bkmkstart XMHelp_8cpp_a9}
{\bkmkend XMHelp_8cpp_a9}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 464 of file XMHelp.cpp.\par
\par
References XM_help().}
{\xe \v XM_help\:XMHelp.cpp}
{\xe \v XMHelp.cpp\:XM_help}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XMInformationDialog* XM_help (char * {\i name}, {\b XMWidget} * {\i parent}, char ** {\i help_text})}
}\par
{\bkmkstart XMHelp_8cpp_a8}
{\bkmkend XMHelp_8cpp_a8}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Functional Description: XM_help - This function builds a help dialog object and returns it to the caller. The help dialog is built up from a list of string pointers. The Help dialog will be managed at the time we exit. The caller can do whatever it wants with the dialog including recycling it for later use or allowing it to be destroyed.  A Help dialog will be an information dialog with a single button labelled "Dismiss". The "Dismiss" button, when pressed, by default will just pop down the dialog. To alter this behavior, the caller must invoke the AddOkCallback method on the returned dialog to string a callback onto the Dismiss button. Formal Parameters: char *name: Name of the dialog. {\b XMWidget} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classXMWidget \\*MERGEFORMAT}{\fldrslt pagenum}}}) *parent: Parent widget for the help dialog. char **help_text: A NULL terminated list of character string pointers which will be used to construct the help message string. Returns: XMInformationDialog * - Pointer to the created information dialog. NULL - If failed. \par
\par
Definition at line 397 of file XMHelp.cpp.\par
\par
References XMWidget::getid().\par
Referenced by XM_display_help().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v About\:XMHelp.cpp}
{\xe \v XMHelp.cpp\:About}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* About[]{\f2  [static]}}
}\par
{\bkmkstart XMHelp_8cpp_a2}
{\bkmkend XMHelp_8cpp_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{ "Xamine -- The NSCL X/Motif histogram display program\\n",\par
      "               Author: Ron Fox\\n",\par
      "                       NSCL\\n",\par
      "                       Michigan State University\\n",\par
      "                       East Lansing, MI 48824-1321\\n",\par
      "                       fox@foxsun.nscl.msu.edu\\n",\par
      "               Copyright (c) NSCL, 1995,1996,1997,1998 All rights reserved\\n",\par
      "\\n",\par
      "               Version: Xamine - X2.0-003\\n",\par
      "               O/S support for:   VAX/VMS\\n",\par
      "                                  AXP/VMS\\n",\par
      "                                  Ultrix 4.x\\n",\par
      "                                  SunOS 4.1.x\\n",\par
      "                                  OSF/1 AXP\\n",\par
      "                                  Linux with Lesstif\\n",\par
      "               Recent enhancements:\\n",\par
      "                    June 24, 1997:\\n"\par
      "                      Added support for client supplied peak markers\\n",\par
      "                    July 13, 1998:\\n",\par
      "                      Fixed problems doing graphics to deleted pixmaps\\n",\par
      "                      Fixed problems producing corrupt default files\\n",\par
      "                    July 23, 1998:\\n",\par
      "                      Completed port to Linux with Lesstif\\n",\par
      "                    October 19, 1998\\n",\par
      "                      Fixed error in points prompter on client buttons\\n",\par
        NULL\par
    \}\par
}
Definition at line 319 of file XMHelp.cpp.\par
}
{\xe \v aboutname\:XMHelp.cpp}
{\xe \v XMHelp.cpp\:aboutname}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* aboutname = "{\b About}"{\f2  [static]}}
}\par
{\bkmkstart XMHelp_8cpp_a3}
{\bkmkend XMHelp_8cpp_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 346 of file XMHelp.cpp.\par
}
{\xe \v Copyright\:XMHelp.cpp}
{\xe \v XMHelp.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart XMHelp_8cpp_a0}
{\bkmkend XMHelp_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file XMHelp.cpp.\par
}
{\xe \v Help\:XMHelp.cpp}
{\xe \v XMHelp.cpp\:Help}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* Help[]{\f2  [static]}}
}\par
{\bkmkstart XMHelp_8cpp_a5}
{\bkmkend XMHelp_8cpp_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{\b Initial value:}{
\par
\pard\plain \s41\li360\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid  \{ "Xamine is the NSCL X/Motif histogram display program\\n\\n",\par
      "   The highlighted pane is the \\"selected\\" pane. All operations\\n",\par
      " that require a pane are performed on that pane. To get a feel\\n",\par
      " for the functionality of the program, explore the menu bar at the \\n",\par
      " top of the set of panes. Where appropriate, dialogs that result\\n",\par
      " from selecting menu buttons, or buttons on the quick select button\\n",\par
      " bar below the pane region include context sensitive documentation.\\n",\par
      " By exploring these options and reading the associated help where\\n",\par
      " the consequences of your actions are not clear, you can get a hands\\n",\par
      " on introduction to Xamine.\\n",\par
    "\\n   For more information about the program, refer to the Xamine paper\\n",\par
      " documentation\\n",\par
      NULL\par
      \}\par
}
Definition at line 351 of file XMHelp.cpp.\par
}
{\xe \v overname\:XMHelp.cpp}
{\xe \v XMHelp.cpp\:overname}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* overname = "Help_Overview"{\f2  [static]}}
}\par
{\bkmkstart XMHelp_8cpp_a6}
{\bkmkend XMHelp_8cpp_a6}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 366 of file XMHelp.cpp.\par
}
{\xe \v sccsinfo\:XMHelp.cpp}
{\xe \v XMHelp.cpp\:sccsinfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* sccsinfo = "@(#)helpmenu.cc 8.9 10/19/98 \\n"{\f2  [static]}}
}\par
{\bkmkstart XMHelp_8cpp_a1}
{\bkmkend XMHelp_8cpp_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 298 of file XMHelp.cpp.\par
}
{\xe \v XM_About\:XMHelp.cpp}
{\xe \v XMHelp.cpp\:XM_About}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XM_help_client_data XM_About = \{ {\b aboutname}, NULL, {\b About} \}}
}\par
{\bkmkstart XMHelp_8cpp_a4}
{\bkmkend XMHelp_8cpp_a4}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 348 of file XMHelp.cpp.\par
}
{\xe \v XM_Help_Overview\:XMHelp.cpp}
{\xe \v XMHelp.cpp\:XM_Help_Overview}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
XM_help_client_data XM_Help_Overview = \{{\b overname}, NULL, {\b Help} \}}
}\par
{\bkmkstart XMHelp_8cpp_a7}
{\bkmkend XMHelp_8cpp_a7}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 367 of file XMHelp.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMLabel.h File Reference\par \pard\plain 
{\tc\tcl2 \v XMLabel.h}
{\xe \v XMLabel.h}
{\bkmkstart XMLabel_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <Xm/Label.h>}\par
{\f2 #include "XMWidget.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XMLabel}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMList.h File Reference\par \pard\plain 
{\tc\tcl2 \v XMList.h}
{\xe \v XMList.h}
{\bkmkstart XMList_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "XMWidget.h"}\par
{\f2 #include <Xm/List.h>}\par
{\f2 #include <Xm/ScrolledW.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XMList}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XMListBaseClass}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XMScrolledList}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMManagers.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v XMManagers.cpp}
{\xe \v XMManagers.cpp}
{\bkmkstart XMManagers_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "XMManagers.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b sscsinfo} = "@(#)XMManagers.cc 8.1 6/23/95 \\n"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:XMManagers.cpp}
{\xe \v XMManagers.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart XMManagers_8cpp_a0}
{\bkmkend XMManagers_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file XMManagers.cpp.\par
}
{\xe \v sscsinfo\:XMManagers.cpp}
{\xe \v XMManagers.cpp\:sscsinfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* sscsinfo = "@(#)XMManagers.cc 8.1 6/23/95 \\n"{\f2  [static]}}
}\par
{\bkmkstart XMManagers_8cpp_a1}
{\bkmkend XMManagers_8cpp_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 290 of file XMManagers.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMManagers.h File Reference\par \pard\plain 
{\tc\tcl2 \v XMManagers.h}
{\xe \v XMManagers.h}
{\bkmkstart XMManagers_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <Xm/BulletinB.h>}\par
{\f2 #include <Xm/Form.h>}\par
{\f2 #include <Xm/RowColumn.h>}\par
{\f2 #include <Xm/PanedW.h>}\par
{\f2 #include <Xm/MainW.h>}\par
{\f2 #include <Xm/Frame.h>}\par
{\f2 #include "XMWidget.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XMBulletinBoard}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XMForm}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XMFrame}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XMMainWindow}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XMManager}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XMPanedWindow}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XMRowColumn}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMMenubar.h File Reference\par \pard\plain 
{\tc\tcl2 \v XMMenubar.h}
{\xe \v XMMenubar.h}
{\bkmkstart XMMenubar_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid \par
}
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMMenus.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v XMMenus.cpp}
{\xe \v XMMenus.cpp}
{\bkmkstart XMMenus_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <Xm/Separator.h>}\par
{\f2 #include "XMMenus.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef {\b XMPulldown} * {\b pdpointer}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b exit} (int)\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v pdpointer\:XMMenus.cpp}
{\xe \v XMMenus.cpp\:pdpointer}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef {\b XMPulldown}* pdpointer}
}\par
{\bkmkstart XMMenus_8cpp_a1}
{\bkmkend XMMenus_8cpp_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 717 of file XMMenus.cpp.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v exit\:XMMenus.cpp}
{\xe \v XMMenus.cpp\:exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void exit (int)}
}\par
{\bkmkstart XMMenus_8cpp_a2}
{\bkmkend XMMenus_8cpp_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:XMMenus.cpp}
{\xe \v XMMenus.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart XMMenus_8cpp_a0}
{\bkmkend XMMenus_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file XMMenus.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMMenus.h File Reference\par \pard\plain 
{\tc\tcl2 \v XMMenus.h}
{\xe \v XMMenus.h}
{\bkmkstart XMMenus_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "XMWidget.h"}\par
{\f2 #include "XMPushbutton.h"}\par
{\f2 #include <Xm/RowColumn.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XMMenuBar}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b XMMenuItem}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XMPulldown}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumerations\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
enum {\b XMMenuEntryType} \{ {\b Unused}, 
{\b Separator}, 
{\b Button}, 
{\b ToggleButton}, 
{\b Submenu}
 \}\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Enumeration Type Documentation\par
\pard\plain 
{\xe \v XMMenuEntryType\:XMMenus.h}
{\xe \v XMMenus.h\:XMMenuEntryType}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
enum XMMenuEntryType}
}\par
{\bkmkstart XMMenus_8h_a5}
{\bkmkend XMMenus_8h_a5}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
{{{\b \par
Enumeration values:}}\par
\pard\plain \s62\li720\widctlpar\ql\adjustright \fs20\cgrid {\xe \v Unused\:XMMenus.h}
{\xe \v XMMenus.h\:Unused}
{\b {\i {\i Unused}{\bkmkstart XMMenus_8h_a5a0}
{\bkmkend XMMenus_8h_a5a0}
}}  \par
{\xe \v Separator\:XMMenus.h}
{\xe \v XMMenus.h\:Separator}
{\b {\i {\i Separator}{\bkmkstart XMMenus_8h_a5a1}
{\bkmkend XMMenus_8h_a5a1}
}}  \par
{\xe \v Button\:XMMenus.h}
{\xe \v XMMenus.h\:Button}
{\b {\i {\i Button}{\bkmkstart XMMenus_8h_a5a2}
{\bkmkend XMMenus_8h_a5a2}
}}  \par
{\xe \v ToggleButton\:XMMenus.h}
{\xe \v XMMenus.h\:ToggleButton}
{\b {\i {\i ToggleButton}{\bkmkstart XMMenus_8h_a5a3}
{\bkmkend XMMenus_8h_a5a3}
}}  \par
{\xe \v Submenu\:XMMenus.h}
{\xe \v XMMenus.h\:Submenu}
{\b {\i {\i Submenu}{\bkmkstart XMMenus_8h_a5a4}
{\bkmkend XMMenus_8h_a5a4}
}}  \par
}
\par
Definition at line 305 of file XMMenus.h.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMPushbutton.h File Reference\par \pard\plain 
{\tc\tcl2 \v XMPushbutton.h}
{\xe \v XMPushbutton.h}
{\bkmkstart XMPushbutton_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <Xm/PushB.h>}\par
{\f2 #include <Xm/CascadeB.h>}\par
{\f2 #include <Xm/ToggleB.h>}\par
{\f2 #include <Xm/ArrowB.h>}\par
{\f2 #include "XMWidget.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XMArrowButton}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XMButton}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XMCascadeButton}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XMPushButton}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XMToggleButton}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMScale.h File Reference\par \pard\plain 
{\tc\tcl2 \v XMScale.h}
{\xe \v XMScale.h}
{\bkmkstart XMScale_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <Xm/Scale.h>}\par
{\f2 #include "XMWidget.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XMScale}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMSeparators.h File Reference\par \pard\plain 
{\tc\tcl2 \v XMSeparators.h}
{\xe \v XMSeparators.h}
{\bkmkstart XMSeparators_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <Xm/Separator.h>}\par
{\f2 #include "XMWidget.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XMHorizontalSeparator}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XMSeparator}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XMVerticalSeparator}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMShell.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v XMShell.cpp}
{\xe \v XMShell.cpp}
{\bkmkstart XMShell_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "XMShell.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b NINHRESOURCES}\~ 6\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b sccsinfo} = "@(#)XMShell.cc 8.1 6/23/95 "\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v NINHRESOURCES\:XMShell.cpp}
{\xe \v XMShell.cpp\:NINHRESOURCES}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define NINHRESOURCES\~ 6}
}\par
{\bkmkstart XMShell_8cpp_a0}
{\bkmkend XMShell_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:XMShell.cpp}
{\xe \v XMShell.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart XMShell_8cpp_a1}
{\bkmkend XMShell_8cpp_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file XMShell.cpp.\par
}
{\xe \v sccsinfo\:XMShell.cpp}
{\xe \v XMShell.cpp\:sccsinfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* sccsinfo = "@(#)XMShell.cc 8.1 6/23/95 "{\f2  [static]}}
}\par
{\bkmkstart XMShell_8cpp_a2}
{\bkmkend XMShell_8cpp_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 293 of file XMShell.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMShell.h File Reference\par \pard\plain 
{\tc\tcl2 \v XMShell.h}
{\xe \v XMShell.h}
{\bkmkstart XMShell_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <Xm/Xm.h>}\par
{\f2 #include <X11/Shell.h>}\par
{\f2 #include "XMWidget.h"}\par
{\f2 #include "XMCallback.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Shell}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b TopLevelShell}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMText.h File Reference\par \pard\plain 
{\tc\tcl2 \v XMText.h}
{\xe \v XMText.h}
{\bkmkstart XMText_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include "XMWidget.h"}\par
{\f2 #include <Xm/Text.h>}\par
{\f2 #include <Xm/TextF.h>}\par
{\f2 #include <string.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XMScrolledText}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XMText}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XMTextField}\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMWidget.h File Reference\par \pard\plain 
{\tc\tcl2 \v XMWidget.h}
{\xe \v XMWidget.h}
{\bkmkstart XMWidget_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <X11/Intrinsic.h>}\par
{\f2 #include <X11/StringDefs.h>}\par
{\f2 #include <Xm/Xm.h>}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
struct {\b Callback_data}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XMApplication}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XMManagedWidget}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XMWidget}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedefs\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
typedef char {\b XMWidgetName} [32]\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b XMRemoveCallback} ({\b Callback_data} *cb)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b XMUnmanageChild} ({\b XMWidget} *, XtPointer, XtPointer)\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b XMDestroyWidget} ({\b XMWidget} *, XtPointer, XtPointer)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Typedef Documentation\par
\pard\plain 
{\xe \v XMWidgetName\:XMWidget.h}
{\xe \v XMWidget.h\:XMWidgetName}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
typedef char XMWidgetName[32]}
}\par
{\bkmkstart XMWidget_8h_a0}
{\bkmkend XMWidget_8h_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 309 of file XMWidget.h.\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v XMDestroyWidget\:XMWidget.h}
{\xe \v XMWidget.h\:XMDestroyWidget}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMDestroyWidget ({\b XMWidget} *, XtPointer, XtPointer)}
}\par
{\bkmkstart XMWidget_8h_a3}
{\bkmkend XMWidget_8h_a3}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 438 of file XMCallback.cpp.\par
}
{\xe \v XMRemoveCallback\:XMWidget.h}
{\xe \v XMWidget.h\:XMRemoveCallback}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMRemoveCallback ({\b Callback_data} * {\i cb})}
}\par
{\bkmkstart XMWidget_8h_a1}
{\bkmkend XMWidget_8h_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 396 of file XMCallback.cpp.\par
\par
References XMWidget::getid(), Callback_data::object, Callback_data::reason, and XMDispatchCallback().}
{\xe \v XMUnmanageChild\:XMWidget.h}
{\xe \v XMWidget.h\:XMUnmanageChild}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void XMUnmanageChild ({\b XMWidget} * {\i wid}, XtPointer {\i client_data}, XtPointer {\i callback_data})}
}\par
{\bkmkstart XMWidget_8h_a2}
{\bkmkend XMWidget_8h_a2}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
Functional Description: XMUnmanageChild - A callback that can be specified to unmanage a child widget. Formal Parameters: {\b XMWidget} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classXMWidget \\*MERGEFORMAT}{\fldrslt pagenum}}}) *wid: Widget of callback. XtPointer client_data, callback_data: Ignored data pointers. \par
\par
Definition at line 422 of file XMCallback.cpp.\par
\par
References XMWidget::UnManage().}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMWlist.cpp File Reference\par \pard\plain 
{\tc\tcl2 \v XMWlist.cpp}
{\xe \v XMWlist.cpp}
{\bkmkstart XMWlist_8cpp}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include "XMWlist.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variables\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
const char * {\b Copyright} = "(C) Copyright Michigan State University 2002, All rights reserved"\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
char * {\b sccsinfo} = "@(#)XMWlist.cc 8.1 6/23/95 "\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Variable Documentation\par
\pard\plain 
{\xe \v Copyright\:XMWlist.cpp}
{\xe \v XMWlist.cpp\:Copyright}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
const char* Copyright = "(C) Copyright Michigan State University 2002, All rights reserved"{\f2  [static]}}
}\par
{\bkmkstart XMWlist_8cpp_a0}
{\bkmkend XMWlist_8cpp_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 278 of file XMWlist.cpp.\par
}
{\xe \v sccsinfo\:XMWlist.cpp}
{\xe \v XMWlist.cpp\:sccsinfo}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
char* sccsinfo = "@(#)XMWlist.cc 8.1 6/23/95 "{\f2  [static]}}
}\par
{\bkmkstart XMWlist_8cpp_a1}
{\bkmkend XMWlist_8cpp_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 290 of file XMWlist.cpp.\par
}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XMWlist.h File Reference\par \pard\plain 
{\tc\tcl2 \v XMWlist.h}
{\xe \v XMWlist.h}
{\bkmkstart XMWlist_8h}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid {\f2 #include <stdio.h>}\par
{\f2 #include <errno.h>}\par
{\f2 #include "XMWidget.h"}\par
{\f2 #include "XMPushbutton.h"}\par
\par
}
}
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Compounds\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b Generic_List}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XMButtonList}\par
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
class {\b XMWidgetList}\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Defines\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
#define {\b LIST_DEFAULT_SIZE}\~ 100\par
}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Functions\par
\pard\plain 

{
\pard\plain \s80\fi-360\li360\widctlpar\jclisttab\tx360{\*\pn \pnlvlbody\ilvl0\ls1\pnrnot0\pndec }\ls1\adjustright \fs20\cgrid 
void {\b exit} (int code)\par
}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Define Documentation\par
\pard\plain 
{\xe \v LIST_DEFAULT_SIZE\:XMWlist.h}
{\xe \v XMWlist.h\:LIST_DEFAULT_SIZE}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
#define LIST_DEFAULT_SIZE\~ 100}
}\par
{\bkmkstart XMWlist_8h_a0}
{\bkmkend XMWlist_8h_a0}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Definition at line 308 of file XMWlist.h.\par
\par
Referenced by Generic_List< XMWidget >::Generic_List(), and XMWidgetList::XMWidgetList().}
{\pard\widctlpar\brdrb\brdrs\brdrw5\brsp20 \adjustright \par}
\par
\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid 
Function Documentation\par
\pard\plain 
{\xe \v exit\:XMWlist.h}
{\xe \v XMWlist.h\:exit}
\pard\plain \s4\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs20\cgrid {
{\b 
void exit (int {\i code})}
}\par
{\bkmkstart XMWlist_8h_a1}
{\bkmkend XMWlist_8h_a1}
{
\pard\plain \s51\li360\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid 
\par
Referenced by XMMenuBar::AddHelpPulldown(), XMPulldown::AddMenuButton(), XMPulldown::AddMenuToggleButton(), XMMenuBar::AddPulldown(), XMPulldown::AddSeparator(), XMPulldown::AddSubmenu(), XMPulldown::BuildMenu(), XMPulldown::FindMenuItem(), Generic_List< XMWidget >::Generic_List(), XMMenuBar::mbCreate(), and XMAddCallback().}
\par \pard\plain 

\pard\plain \sect\sbkpage
\s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid 
XtGuests.oxy File Reference\par \pard\plain 
{\tc\tcl2 \v XtGuests.oxy}
{\xe \v XtGuests.oxy}
{\bkmkstart XtGuests_8oxy}
{\bkmkend }
{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s18\widctlpar\fs22\cgrid \par
}
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
Spectrodaq External Event Framework Page Documentation{\tc \v Page Documentation}
\par \pard\plain 
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v Buffer arrival events}
Buffer arrival events\par
{\bkmkstart BufferEvent}
{\bkmkend BufferEvent}
}{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
The main function of the Spectrodaq server is to provide buffers of data, as requested from producers of data. The {\b CBufferEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferEvent \\*MERGEFORMAT}{\fldrslt pagenum}}}) class provides the hook to respond to buffers received asyncrhonously. Each BufferEvent class  can respond to buffers from a disjoint set of sources (links in Spectrodaq terminology).\par
In order to understand buffer data sources it is necessary to understand the folowing spectrodaq concepts:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Link - A link is a virtual connection to a spectrodaq server in the local system or in some remote system. The link is specified by a URL of the form: TCP://hostname:2602/ where:{
\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
1.\tab hostname specifies the host on which the server lives e.g. localhost for buffers produced on the local system.\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
2.\tab 2602 is the TCP/IP port number on which the server by default listens for connection requests.\par
}\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Selectivity - A link can be selective of the buffers it receives in two ways:{
\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
1.\tab Reliability - For programs which need not see all data, the application can specify that it wants to receive data  "Unreliably" The application will then only recieve the fraction of the data it can analyze.\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
2.\tab Type selection; Buffers are tagged with a longword which can be thought of as representative of their data type. A link has associated with it a tag and a mask. Links will only accept buffers where (buffer.tag & link.mask) ==  link.tag In addition, buffers which receive data along a link also have tags and masks. Once the link has received the data it is only sent to the receiving buffer after similar selection logic.\par
}}With that understanding we can now look in more detail at the {\b CBufferEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferEvent \\*MERGEFORMAT}{\fldrslt pagenum}}}) class and how to use it. To respond to spectrodaq buffers you must:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Write a subclas to {\b CBufferEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferEvent \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The {\b OnBuffer} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferEvent_a10 \\*MERGEFORMAT}{\fldrslt pagenum}}}) must be overridden with experiment specific code to process buffers received by the object.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
One or more instances (depending on application needs) of the class must be instantiated by the running application.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The instances must be started by calling their  {\b Enable()} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent_a11 \\*MERGEFORMAT}{\fldrslt pagenum}}}) member.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Select the buffer mask and tag using:{
\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
1.\tab {\b setBufferTag} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferEvent_a12 \\*MERGEFORMAT}{\fldrslt pagenum}}}) and\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
2.\tab {\b setBufferMask} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferEvent_a13 \\*MERGEFORMAT}{\fldrslt pagenum}}})\par
}\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Create links for every data source desired by calling {\b AddLink().} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCBufferEvent_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}})\par
}In the example below, a buffer event is created which listens for, and receives all buffers from the local host. When a buffer is received, the first 64 words (16 bit integers) are dumped to stdout in hex notation with just enough header text to allow us to separate the buffers.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid #include <spectrodaq.h>\par
#include <SpectroFramework.h>\par
#include <iostream.h>\par
\par
typedef CBufferEvent<Word> WordBufferEvent;\par
typedef Pointer<DAQBuffer<Word>,Word> WordPointer;\par
\par
\par
static const int WordsToDump = 64;\par
static const int WordsPerLine= 16;\par
class MyBuffers : public WordBufferEvent\par
\{\par
  ostream& m_rOutfile;\par
public:\par
  MyBuffers(const char* pName, ostream& routfile);\par
  virtual void OnBuffer(WordPointer& pBuffer);\par
\};\par
\par
MyBuffers::MyBuffers(const char* pname, ostream& routfile) :\par
  WordBufferEvent(pname),\par
  m_rOutfile(routfile)\par
\{\}\par
\par
void\par
MyBuffers::OnBuffer(WordPointer& pBuffer)\par
\{\par
  m_rOutfile << "---------------------- buffer -----------------";\par
  m_rOutfile << hex;\par
  for(int i =0; i < WordsToDump; i++) \{\par
    if( (i% WordsPerLine) == 0) \{\par
      cout << endl;\par
    \}\par
    cout << *pBuffer << " ";\par
    ++pBuffer;\par
  \}\par
  m_rOutfile << endl;\par
\par
  m_rOutfile << dec;\par
\}\par
\par
class MyApp : public DAQROCNode\par
\{\par
protected:\par
  int operator() (int argc, char** argv);\par
\par
\};\par
MyApp theApplication;\par
\par
int\par
MyApp::operator()(int argc, char** argv)\par
\{\par
  MyBuffers Receiver("BuferReceiver", cout);\par
  Receiver.setBufferTag(0);\par
  Receiver.setBufferMask(0);\par
  \par
  Receiver.AddLink("TCP://localhost:2602/", 0, 0);   // Relieable, all events\par
  Receiver.Enable();\par
  \par
  DAQThreadId id = Receiver.getThreadId();\par
  \par
  Join(id);\par
\}\par
\par
\par
}
\par
}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v Configuration subsystem}
Configuration subsystem\par
{\bkmkstart configsys}
{\bkmkend configsys}
}{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
In many cases, applications require configuration information to run correctly. For example, a readout program may need to load a set of ADC thresholds in order to manage those ADC's correctly. The application framework provides  for configuration information to be read via Tcl startup scripts.\par
Configuration data can be directly bound to:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Single C/C++ variables or member data.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Slices of C/C++ arrays.\par
}In addition, associative arrays (based on the STL Map class) can be created, and initialized via these scripts. The framwoerk provides a wide variety of  configuration policies including:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Read single script.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Read first specified script in directory path list.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Read all specified scripts in a directory path list.\par
}Once configuration requirments for an application have been determined:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Create a binding for each variable, array slice, or associative array needed for the configuration.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Register these bindings with a CConfigurationManger object.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Request the CCConfiguration manager object process configuration files.\par
}Configuration scripts can be written using the entire Tcl language. Variable bindings are allowed for data of type:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Integer (int)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Double precision (double)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Boolean (bool)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
String (char*) Each of the configuration classes is templated to support configuration for any of these types. The Configuration bindings classes are:\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CVariableBinding} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCVariableBinding \\*MERGEFORMAT}{\fldrslt pagenum}}}) - Allows you to bind a single variable to a Tcl variable in the configuraiton script.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CArrayBinding} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCArrayBinding \\*MERGEFORMAT}{\fldrslt pagenum}}}) - Allows you to bind a slice of an array to a Tcl array with integer indices in the configuration script.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CAssocArrayBinding} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCAssocArrayBinding \\*MERGEFORMAT}{\fldrslt pagenum}}}) - Allows you to create and configue an associative array with string indices.\par
}The example below creates all of these bindings, and manages them via a  {\b CConfigurationManager} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCConfigurationManager \\*MERGEFORMAT}{\fldrslt pagenum}}}) object\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid //\par
// Tests the configuration system.\par
#include <spectrodaq.h>\par
#include <SpectroFramework.h>\par
#include <iostream.h>\par
#include <fstream.h>\par
#include <vector>\par
#include <string>\par
#include <stdlib.h>\par
\par
\par
class MyApp : public DAQROCNode\par
\{\par
  // Single configuration variables.\par
\par
  int    m_nSingle;\par
  double m_fSingle;\par
  bool   m_bSingle;\par
  char*  m_pSingle;\par
\par
  // Array bindings\par
\par
  int    m_nArray[100];\par
  double m_fArray[100];\par
  bool   m_bArray[100];\par
  char*  m_pArray[100];\par
\par
  // pointers to associative array bindings:\par
  //\par
  CAssocArrayBinding<int>*    m_pnAssoc;\par
  CAssocArrayBinding<double>* m_pfAssoc;\par
  CAssocArrayBinding<bool>*   m_pbAssoc;\par
  CAssocArrayBinding<char*>*  m_ppAssoc;  \par
protected:\par
  int operator()(int argc, char** argv);\par
  void DumpConfig(CConfigurationManager& rMgr, const char* dumpfile);\par
\};\par
\par
MyApp theApplication;\par
\par
int\par
MyApp::operator()(int argc, char** pargv)\par
\{\par
  // Bindings for single variables:\par
\par
  cout << "Binding single variables" << endl;\par
  CVariableBinding<int>    nSingle(m_nSingle, "Integer", 0);\par
  CVariableBinding<double> fSingle(m_fSingle,  "Float" , 3.14159);\par
  CVariableBinding<bool>   bSingle(m_bSingle,  "Bool"  , false);\par
  CVariableBinding<char*>  pSingle(m_pSingle,  string("Char"), \par
                                   (char*)NULL);\par
\par
  // Bindings for arrays:\par
\par
  cout << "Binding array slices" << endl;\par
\par
  CArrayBinding<int>    nArray(m_nArray, 0, 99, "IArray");\par
  CArrayBinding<double> fArray(m_fArray, 50,99, "FArray");\par
  CArrayBinding<bool>   bArray(m_bArray, 0, 49, "BArray");\par
  CArrayBinding<char*>  cArray(m_pArray, 25,75, string("SArray"));\par
\par
  // Build a bound associative array:\par
\par
  cout << "Creating associative arrays" << endl;\par
\par
  CAssocArrayBinding<int>    nAssoc("IAssoc");\par
  CAssocArrayBinding<double> fAssoc("FAssoc");\par
  CAssocArrayBinding<bool>   bAssoc("BAssoc");\par
  CAssocArrayBinding<char*>  cAssoc(string("CAssoc"));\par
  m_pnAssoc = &nAssoc;\par
  m_pfAssoc = &fAssoc;\par
  m_pbAssoc = &bAssoc;\par
  m_ppAssoc = &cAssoc;\par
\par
  // Setup the configuration object:\par
\par
  cout << "Creating configuration manager and loading in bindings:" << endl;\par
  CConfigurationManager configurer;\par
\par
  configurer.AddBinding(nSingle);\par
  configurer.AddBinding(fSingle);\par
  configurer.AddBinding(bSingle);\par
  configurer.AddBinding(pSingle);\par
\par
  list<CTypeFreeBinding*> bindlist;\par
  bindlist.push_back(&nArray);\par
  bindlist.push_back(&fArray);\par
  bindlist.push_back(&bArray);\par
  bindlist.push_back(&cArray);\par
  configurer.AddBinding(bindlist);\par
  configurer.AddBinding(nAssoc);\par
  configurer.AddBinding(fAssoc);\par
  configurer.AddBinding(bAssoc);\par
  configurer.AddBinding(cAssoc);\par
\par
  //  Configure from a single file:\par
\par
  cout << "Reading single config file" << endl;\par
\par
  configurer.ReadConfigFile("config.tcl");\par
 \par
  DumpConfig(configurer, "SingleFile");\par
\par
  // Configure from first file in path list... should get same result.\par
\par
  cout << "Reading 1st config file in pathlist" << endl;\par
\par
  vector<string> Pathlist;\par
  Pathlist.push_back(string("."));\par
  Pathlist.push_back(string(getenv("HOME")));\par
  Pathlist.push_back(string(".."));\par
  configurer.Read1stConfigFile(Pathlist, "config.tcl");\par
  DumpConfig(configurer, "FirstFile");\par
\par
  // Configure from multiple files in path list\par
\par
  cout << "Reading all config files in pathlist." << endl;\par
\par
  configurer.ReadAllConfigFiles(Pathlist, "config.tcl");\par
  DumpConfig(configurer, "AllFiles");\par
\par
\par
\}\par
//\par
\par
void\par
MyApp::DumpConfig(CConfigurationManager& rMgr, const char* dumpfile)\par
\{\par
  // Make the filenames:\par
\par
  string dumpname(dumpfile);\par
  string listname(dumpfile);\par
  dumpname += ".tcl";\par
  listname += ".txt";\par
  \par
  // Do the config dump:\par
\par
  rMgr.WriteConfigFile(dumpname);\par
\par
  ofstream txtfile(listname.c_str());\par
  txtfile << "----------------------- single variables --------------\\n";\par
  txtfile << "m_nSingle = " << m_nSingle;\par
  txtfile << " m_fSingel = " << m_fSingle;\par
  txtfile << " m_bSingle = " << m_bSingle;\par
  txtfile << " m_pSingle = " << (m_pSingle ? m_pSingle : "null") << endl;\par
\par
  txtfile << "-------------------------- Array variables -------------\\n";\par
  txtfile << "index  int     double   bool     string\\n";\par
  for(int i = 0; i < 100; i++) \{\par
    txtfile << i << m_nArray[i] << " " << m_fArray[i] << " " << m_bArray[i] << " " ;\par
    txtfile << (m_pArray[i] ? m_pArray[i] : "(null)") << endl;\par
\par
  \}\par
  txtfile << "----------------------- nAssoc (integer assoc array) ----\\n";\par
  txtfile << "Index           Value\\n";\par
  map<string,int>::iterator i = m_pnAssoc->begin();\par
  while(i != m_pnAssoc->end()) \{\par
    txtfile << i->first  << " " << i->second << endl;\par
    i++;\par
  \}\par
  txtfile << "----------------------fAssoc (double assoc array) ------\\n";\par
  txtfile << "Index           Value\\n";\par
  map<string,double>::iterator f = m_pfAssoc->begin();\par
  while(f != m_pfAssoc->end()) \{\par
    txtfile << f->first << " " << f->second << endl;\par
    f++;\par
  \}\par
  txtfile << "---------------------------bAssoc (Bool assoc array)-----\\n";\par
  txtfile << "Index           Value\\n";\par
  map<string,bool>::iterator b = m_pbAssoc->begin();\par
  while(b != m_pbAssoc->end()) \{\par
    txtfile << b->first << " " << b->second << endl;\par
    b++;\par
  \}\par
  txtfile << "---------------------------cAssoc (char* assoc array) ------\\n";\par
  txtfile << "Index           Value\\n";\par
  map<string,char*>::iterator c = m_ppAssoc->begin();\par
  while(c != m_ppAssoc->end()) \{\par
    txtfile << c->first << " " << c->second << endl;\par
    c++;                        \par
  \}\par
\par
\par
  \par
  \par
\}\par
\par
}
\par
}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v Event Driven Programming model}
Event Driven Programming model\par
{\bkmkstart EventDriven}
{\bkmkend EventDriven}
}{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v What is event driven software.}
What is event driven software.\par
{\bkmkstart WhatisEventDriven}
{\bkmkend WhatisEventDriven}
}\par
A simple way to understand the event driven programming model is to compare  and contrast it with the the traditional model. In the traditional model the  programmer:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Writes a main program.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Explicitly controls a main loop which looks for stuff to do and then does it.\par
}In the event driven model, the programmer:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Writes application initialization code which, among other things,  requests the receipt of events of interest from the outside world.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Writes handlers for the events and reigsters a correspondence betwen events and their handlers.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Turns control over to a library event loop which waits for the desired events and dispatches control to their handlers as required.\par
}Event driven software is a win whenever:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The event loop is sufficiently complex that you'd like to re-use it from application to application.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
You want to decouple the user interface from the functionality of the software.\par
}Both of these criteria are true for the spectrodaq framework.\par
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v Event management and the spectrodaq framework}
Event management and the spectrodaq framework\par
{\bkmkstart FWKEventManagement}
{\bkmkend FWKEventManagement}
}\par
In the spectrodaq event framework, event handlers are member functions of classes descended from the {\b CEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent \\*MERGEFORMAT}{\fldrslt pagenum}}}) class. Thus events are handled as follows:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The appropriate {\b CEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent \\*MERGEFORMAT}{\fldrslt pagenum}}}) subclass is subclassed and its event handlers are  overridden with application specific code.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
One or more instance's of this event handler are created (e.g. via new).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
An Event handler's {\b CEvent::Enable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent_a11 \\*MERGEFORMAT}{\fldrslt pagenum}}}) member function is called to start the handlers private thread and event loop. See the general   concepts page for more information about the event classes.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
As the event thread detects events, the overridden handler function is  called triggering the application specific behavior.\par
}The example below shows this process: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid #include <iostream.h>\par
#include <stdio.h>\par
#include <spectrodaq.h>\par
#include <SpectroFramework.h>\par
\par
class Echo : public CFileEvent\par
\{\par
public:\par
  Echo(int fd, const char* pName);\par
  virtual void OnReadable(istream& rin);\par
\};\par
\par
Echo::Echo(int fd, const char* pName):\par
  CFileEvent(fd, pName)\par
\{\par
  AppendClassInfo();\par
\}\par
\par
void\par
Echo::OnReadable(istream& rin)\par
\{\par
  CFileEvent::OnReadable(rin);\par
  string word;\par
  rin >> word;\par
  cout << word << endl;\par
\}\par
\par
class MyApp : public DAQROCNode\par
\{\par
protected:\par
  virtual int operator()(int argc, char** argv);\par
\};\par
\par
int\par
MyApp::operator()(int argc, char** argv)\par
\{\par
  Echo echo(fileno(stdin), "EchoProcessor");\par
\par
  echo.Enable();\par
  DAQThreadId id = echo.getThreadId();\par
\par
  Join(id);                     // Wait for echo to exit.\par
\}\par
\par
\par
MyApp theapp;\par
\par
}
The Echo class subclasses {\b CFileEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFileEvent \\*MERGEFORMAT}{\fldrslt pagenum}}}) which is an event handler that watches  for events on a file descriptor. Overriding OnReadable supplies application specific behavior for a file descriptor when the file becomes readable. The line in MyApp::operator() which reads: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid         Echo echo(fileno(stdin), "EchoProcessor");\par
\par
}
 creates an instance of this event to listen for and react to input on stdin. and the call to echo.Enable() starts the thread.\par
When the event thread detecs input on stdin, it calls Echo::OnReadable which proceses the input in an application specific manner.\par
\par
}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v Reacting to file events.}
Reacting to file events.\par
{\bkmkstart FileEvents}
{\bkmkend FileEvents}
}{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
The class {\b CFileEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFileEvent \\*MERGEFORMAT}{\fldrslt pagenum}}}) allows an application to react asynchronously to events on a file. To use a {\b CFileEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFileEvent \\*MERGEFORMAT}{\fldrslt pagenum}}}) you will need to:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Decide which of the following conditions you need to supply  application code for:{
\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
1.\tab Readbility (may be significant on e.g. \par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
2.\tab Writability (may be significant e.g. pipes).\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
3.\tab Exceptional conditions (e.g. pipe broken).\par
}\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Write a subclass of CFile event which supplies the appropriate application specific functionality for any or all of the functions:{
\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
1.\tab {\b OnReadable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFileEvent_a15 \\*MERGEFORMAT}{\fldrslt pagenum}}}) which is called when the file descriptor becomes readable.\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
2.\tab {\b OnWritable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFileEvent_a16 \\*MERGEFORMAT}{\fldrslt pagenum}}}) which  is called when the file descriptor becomes writable.\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
3.\tab {\b OnException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFileEvent_a17 \\*MERGEFORMAT}{\fldrslt pagenum}}}) which is called when the file descriptor has an exceptional condition pending.\par
}\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
During application execution create and enable an instance of this class.\par
}In the example below, a file event is created to monitor stdin. When input is available on stdin, the first word of the line is echoed back on stdout.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid #include <iostream.h>\par
#include <stdio.h>\par
#include <spectrodaq.h>\par
#include <SpectroFramework.h>\par
\par
class Echo : public CFileEvent\par
\{\par
public:\par
  Echo(int fd, const char* pName);\par
  virtual void OnReadable(istream& rin);\par
\};\par
\par
Echo::Echo(int fd, const char* pName):\par
  CFileEvent(fd, pName)\par
\{\par
  AppendClassInfo();\par
\}\par
\par
void\par
Echo::OnReadable(istream& rin)\par
\{\par
  CFileEvent::OnReadable(rin);\par
  string word;\par
  rin >> word;\par
  cout << word << endl;\par
\}\par
\par
class MyApp : public DAQROCNode\par
\{\par
protected:\par
  virtual int operator()(int argc, char** argv);\par
\};\par
\par
int\par
MyApp::operator()(int argc, char** argv)\par
\{\par
  Echo echo(fileno(stdin), "EchoProcessor");\par
\par
  echo.Enable();\par
  DAQThreadId id = echo.getThreadId();\par
\par
  Join(id);                     // Wait for echo to exit.\par
\}\par
\par
\par
MyApp theapp;\par
\par
}
\par
}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v Location monitors.}
Location monitors.\par
{\bkmkstart LocationMonitors}
{\bkmkend LocationMonitors}
}{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
A location monitor watches a volatile memory location and, with low latency, dispatches to application code whenever a significant change in the monitored location occurs. A typical use of a location monitor would be to spin while monitoring a hardware register for changes indicating an event trigger.\par
The application framework encapsulates location monitors in a templated class: {\b CLocationEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCLocationEvent \\*MERGEFORMAT}{\fldrslt pagenum}}}). The implementation of this event is a thread which spins tightly on the location.\par
For each pass through the the main loop of {\b CLocationEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCLocationEvent \\*MERGEFORMAT}{\fldrslt pagenum}}}), the location is  tested for significant change. If a significant change ocured, the OnEvent member is called ({\b CLocationEvent::OnEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent_b2 \\*MERGEFORMAT}{\fldrslt pagenum}}})).\par
The concept of "significant change" is captured by associating a  {\b CPointerPredicate} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCPointerPredicate \\*MERGEFORMAT}{\fldrslt pagenum}}}) derived class with each location monitor. Predicates are  function like objects (they are objects from classes which implement  operator()), whose function call operator returns a boolean given the current value of the monitored location. The predicate determines if the change was significate from the application's standpoint and if so returns TRUE, otherwise FALSE.\par
The following pre-defined predicates exist:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CChangedPredicate} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCChangedPredicate \\*MERGEFORMAT}{\fldrslt pagenum}}}) - The location's value this pass through the loop is  different than the prior pass.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CMaskedValuePredicate} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCMaskedValuePredicate \\*MERGEFORMAT}{\fldrslt pagenum}}}) - does a bitwise and of the location with a mask and compares the result to a value, equality indicates significance.\par
}The example below is somewhat artificial. A location monitor is created to monitor an ordinary program memory location, using the {\b CChangedPredicate} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCChangedPredicate \\*MERGEFORMAT}{\fldrslt pagenum}}}) to  determine significant change. The main program accepts input from stdin, and modifies the location each time input is received.\par
The location monitor responds to the change by printing out the value of the location.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid #include <spectrodaq.h>\par
#include <SpectroFramework.h>\par
\par
#include <iostream.h>\par
\par
volatile long location = 0;     // Location monitored.\par
\par
typedef CLocationEvent<long> LongMonitor;\par
typedef CPointerPredicate<long> LongPred;\par
typedef CChangedPredicate<long> LongChanged;\par
\par
class MyLocation : public LongMonitor\par
\{\par
public:\par
  MyLocation(const char* pName, LongPred& pred, long* pLoc); //  Constructor.\par
  virtual void OnLocationChanged(long newval);\par
\par
\};\par
\par
MyLocation::MyLocation(const char* pName, LongPred& pred,  long* pLoc) :\par
  LongMonitor(pName, pLoc,  pred)\par
\{\par
\}\par
void\par
MyLocation::OnLocationChanged(long newval)\par
\{\par
  cout << "Location changed. New value is: " << newval <<endl;\par
\}\par
\par
\par
class MyApp : public DAQROCNode\par
\{\par
protected:\par
  int operator()(int argc, char** argv);\par
\};\par
\par
MyApp theApp;\par
\par
int\par
MyApp::operator()(int argc, char** argv)\par
\{\par
  LongChanged predicate(location);\par
  MyLocation LocMonitor("TriggeronChanged", predicate, (long*)&location);\par
\par
  LocMonitor.Enable();\par
\par
  cout << " Location event: " << LocMonitor.DescribeSelf() << endl;\par
  cout << "Started\\n";\par
\par
  string input;\par
  while(1) \{\par
    cin >> input;               //  Block until input...\par
    location++;                 // Update location.\par
  \}\par
\}\par
\par
}
\par
}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v TCL/Tk Guest event loops.}
TCL/Tk Guest event loops.\par
{\bkmkstart TCLGuests}
{\bkmkend TCLGuests}
}{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
The framework allows you to include either a TCL (non GUI script engine) or Tk (GUI based script engine) in your application. To do this you must:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Design the set of command extensions your application needs.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Write subclasses of {\b CDAQTCLProcessor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDAQTCLProcessor \\*MERGEFORMAT}{\fldrslt pagenum}}}) which implement these commands.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Write a subclass of either {\b CTCLInterpreterStartup} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCLInterpreterStartup \\*MERGEFORMAT}{\fldrslt pagenum}}}) (non GUI script engine) or CTKInterpreterstartup (GUI script engine) which instantiates your command extensions and registers them with the interpreter.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Instantiate your extension of the C*Interpreterstartup class to create and start an interpreter.\par
}{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v Writing CDAQTCLProcessor extensions.}
Writing CDAQTCLProcessor extensions.\par
{\bkmkstart TclCommandProcessors}
{\bkmkend TclCommandProcessors}
}\par
It is important that user written extensions to the Tcl/Tk command interpreter. This is done automatically by deriving your command extensions from  {\b CDAQTCLProcessor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDAQTCLProcessor \\*MERGEFORMAT}{\fldrslt pagenum}}}). There are two member functions which must be written:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The constructor which determines the command keyword (or name).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The function call operator (operator()), which gets control when the  command keyword has been recognized by the Tcl/Tk interpreter.\par
}See {\b CDAQTCLProcessor::CDAQTCLProcessor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDAQTCLProcessor_a0 \\*MERGEFORMAT}{\fldrslt pagenum}}}) for the call signature of the base class constructor. The parameters are: {{{\b \par
Parameters: }}\par
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\b {\i Command}}  - A specification of the command (char* or string&). \par
{\b {\i pInterp}}  - A pointer to the interpreter object.\par
}The function call operator (operator()) is called when the command  registered by an object has been recognized. The parameters of this function are: {{{\b \par
Parameters: }}\par
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\b {\i rInterpreter}}  - A reference to the {\b interpreter  	object} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCLInterpreter \\*MERGEFORMAT}{\fldrslt pagenum}}}) which invoked this command. The interpreter provides several facilities including subscriptexecution support, and parameter parsing utilities. \par
{\b {\i rResult}}  - A refereince to the interpreter's {\b result 	object.} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCLResult \\*MERGEFORMAT}{\fldrslt pagenum}}}) The result object is used to return information from the command to the invoking script. In the event of an error, the error message associated with the error should be returned in the result object. \par
{\b {\i argc}}  - The number of words in the command (after the interpreter's round of substitutions). \par
{\b {\i argv}}  - A pointer to a list of pointers to the characters strings which represent the words of the command. Note that the 'first' of these is the command itself.\par
}The function call operator must return an int which is one of:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
TCL_OK - The command completed successfully and script execution can continue\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
TCL_ERROR - The command failed, script execution should terminate unless the command was invoked within a catch command.\par
}{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v Writing the interpreter startup functions}
Writing the interpreter startup functions\par
{\bkmkstart TclInterpreters}
{\bkmkend TclInterpreters}
}\par
This section describes the member functions you may need to override when  deriving your command interpreter startup class (subclass of either {\b CTCLInterpreterStartup} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCLInterpreterStartup \\*MERGEFORMAT}{\fldrslt pagenum}}}) or {\b CTKInterpreterStartup} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTKInterpreterStartup \\*MERGEFORMAT}{\fldrslt pagenum}}})). The functions you may need to write are:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b OnInitialize} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCInterpreterStartup_b0 \\*MERGEFORMAT}{\fldrslt pagenum}}}) which is called to allow you a chance to process command line parameters and do other pre-interpreter startup initializations.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b which is called after the   Tcl/Tk interpreter has been created and initialized and is intended to be   the member in which you instantiate and register your command extensions.  \\section OnInitialize  	OnInitialize()} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCInterpreterStartup_b1 \\*MERGEFORMAT}{\fldrslt pagenum}}}) member function.\par
}This member function is called prior to the creation and initialization of the interpreter object. The parameters passed to this member are: {{{\b \par
Parameters: }}\par
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\b {\i argc}}  - Number of command line parameters with which to invoke the interpreter. \par
{\b {\i argv}}  - char** pointer to the list of pointers to the parameter strings.\par
}{\pard\plain \s3\sb240\sa60\keepn\widctlpar\adjustright \b\f1\cgrid {\tc\tcl3 \v The}
The\par
{\bkmkstart RegisterExtensions}
{\bkmkend RegisterExtensions}
} {\b RegisterExtensions()} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCInterpreterStartup_b1 \\*MERGEFORMAT}{\fldrslt pagenum}}}) member function.\par
Once the interpreter has been created and initialized, the framework calls RegisterExtensions with no parameters. The interpreter can be retrieved via {\b getInterpreter().} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCInterpreterStartup_a2 \\*MERGEFORMAT}{\fldrslt pagenum}}}) In this function you should provide code to make instances of your command processors and register them with the interpreter. A normal tactic is to use new to  instantiate a processor, save the processor's pointer as member data which is deleted' by the destructor.\par
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v Example application.}
Example application.\par
{\bkmkstart TclExample}
{\bkmkend TclExample}
}\par
The sample application in this section shows how to create a Tcl interpreter as a guest event loop. A simple Echo command is added which simply takes  command parameters and places them in the result.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid //\par
// Test program for the CTCLInterpreterStartup.\par
//   We start up a TCL interpreter in its own thread\par
//   and register the Echo command extension as a synchronized\par
//   extension.\par
//   The program should also understand the sync command.\par
//\par
\par
#include <spectrodaq.h>\par
#include <iostream.h>\par
#include <CTCLInterpreterStartup.h>\par
\par
\par
#include <CDAQTCLProcessor.h>\par
\par
\par
\par
class TCLExtension : public CDAQTCLProcessor\par
\{\par
\par
public:\par
  TCLExtension(CTCLInterpreter* pInterp);\par
  virtual int  operator() (CTCLInterpreter &rInterpreter, CTCLResult &rResult, \par
                           int nArguments, char *pArguments[]);\par
\par
\};\par
\par
\par
TCLExtension::TCLExtension(CTCLInterpreter* pInterp) :\par
  CDAQTCLProcessor("Echo", pInterp)\par
\{\par
\}\par
\par
int\par
TCLExtension::operator() (CTCLInterpreter &rInterpreter, CTCLResult &rResult, \par
                          int nArguments, char *pArguments[])\par
\{\par
  for(int i = 1; i < nArguments; i++) \{\par
    rResult.AppendElement(pArguments[i]);\par
  \}\par
  return TCL_OK;\par
\}\par
\par
\par
\par
\par
class MyInterpThread : public CTCLInterpreterStartup\par
\{\par
  TCLExtension* m_pCommand;\par
protected:\par
  virtual void  RegisterExtensions () \{\par
    cerr << "Registering extensions\\n";\par
    cerr.flush();\par
    m_pCommand = new TCLExtension(getInterpreter());\par
    m_pCommand->Register();\par
    cerr << "Registering base class extensions\\n";\par
    cerr.flush();\par
    CTCLInterpreterStartup::RegisterExtensions();\par
    cerr << "Returning to TCL Main loop\\n";\par
    cerr.flush();\par
  \}\par
\};\par
\par
class App : public DAQROCNode\par
\{\par
  virtual int  operator() (int argc, char **argv) \{\par
    MyInterpThread Tcl;\par
    DAQThreadId tid = daq_dispatcher.Dispatch(Tcl);\par
\par
    DAQStatus stat;\par
    Join(tid, &stat);\par
    cerr << "Tcl interpreter exited" << stat.GetStatusCode() << endl;\par
    return 0;\par
  \}\par
\par
\};\par
\par
App theApp;\par
\par
}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v example application}
example application\par
{\bkmkstart TkExample}
{\bkmkend TkExample}
}\par
This sample application is the same as the one shown in section TclExample, however a Tk interpreter is started up rather  than a Tcl interpreter. This provides the capability of a scripted GUI for the application.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid //\par
// Test program for the CTCLInterpreterStartup.\par
//   We start up a TCL interpreter in its own thread\par
//   and register the Echo command extension as a synchronized\par
//   extension.\par
//   The program should also understand the sync command.\par
//\par
\par
#include <spectrodaq.h>\par
#include <iostream.h>\par
#include <CTKInterpreterStartup.h>\par
\par
\par
#include <CDAQTCLProcessor.h>\par
\par
\par
\par
class TCLExtension : public CDAQTCLProcessor\par
\{\par
\par
public:\par
  TCLExtension(CTCLInterpreter* pInterp);\par
  virtual int  operator() (CTCLInterpreter &rInterpreter, CTCLResult &rResult, \par
                           int nArguments, char *pArguments[]);\par
\par
\};\par
\par
\par
TCLExtension::TCLExtension(CTCLInterpreter* pInterp) :\par
  CDAQTCLProcessor("Echo", pInterp)\par
\{\par
\}\par
\par
int\par
TCLExtension::operator() (CTCLInterpreter &rInterpreter, CTCLResult &rResult, \par
                          int nArguments, char *pArguments[])\par
\{\par
  for(int i = 1; i < nArguments; i++) \{\par
    rResult.AppendElement(pArguments[i]);\par
  \}\par
  return TCL_OK;\par
\}\par
\par
\par
\par
\par
class MyInterpThread : public CTKInterpreterStartup\par
\{\par
  TCLExtension* m_pCommand;\par
protected:\par
  virtual void  RegisterExtensions () \{\par
    cerr << "Registering extensions\\n";\par
    cerr.flush();\par
    m_pCommand = new TCLExtension(getInterpreter());\par
    m_pCommand->Register();\par
    cerr << "Registering base class extensions\\n";\par
    cerr.flush();\par
    CTKInterpreterStartup::RegisterExtensions();\par
    cerr << "Returning to TCL Main loop\\n";\par
    cerr.flush();\par
  \}\par
\};\par
\par
class App : public DAQROCNode\par
\{\par
  virtual int  operator() (int argc, char **argv) \{\par
    MyInterpThread Tcl;\par
    DAQThreadId tid = daq_dispatcher.Dispatch(Tcl);\par
\par
    DAQStatus stat;\par
    Join(tid, &stat);\par
    cerr << "Tcl interpreter exited" << stat.GetStatusCode() << endl;\par
    return 0;\par
  \}\par
\par
\};\par
\par
App theApp;\par
\par
}
\par
}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v Object Registries names and descriptions.}
Object Registries names and descriptions.\par
{\bkmkstart Registration}
{\bkmkend Registration}
}{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
The goal of the framework is to provide some capability of introspection to the application. Introspection allows programs to examine themselves, determine what objects are instantiated, and for what types as well as to get descriptive information about each object. For the spectrodaq client framework, introspection is achieved via:\par
{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Object registries (dictionaries of objects)\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Object class hierarchy positioning information\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Object description member functions.  For a simple application example see \\ref regExample "Registration Example" below.  \\section registries   The intent of object registries and the application registry is to allow a program to determine what set of objects from what general class types are currently instantiated, and to get pointers to a specific object, given its name, for later manipulation.  This registration of objects allows: - Objects to circularly reference each other for communication purposes - In the future: we will be able to provide support for Tcl/Tk commands   to list, create and manipulate objects by their names, allowing for   "programming free" configuration of software given that an appropriate   set of classes exists and is linked into the application.  Each application using an application framework contains a single instance of an \\link CApplicationRegistry application registry.  The static function {\b CApplicationRegistry::getInstance} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCApplicationRegistry_d0 \\*MERGEFORMAT}{\fldrslt pagenum}}}) retrieves a pointer to this registry.\par
}Application registries are a subclass of the {\b CClassifiedObjectRegistry} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCClassifiedObjectRegistry \\*MERGEFORMAT}{\fldrslt pagenum}}}) class. classified object registries contain several {\b CObjectRegistry} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCObjectRegistry \\*MERGEFORMAT}{\fldrslt pagenum}}}) objects. Each  of these object registries is a dictionary of classes for a particular type of object.\par
Most classes in the framework are descended from the {\b CRegisteredObject} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCRegisteredObject \\*MERGEFORMAT}{\fldrslt pagenum}}}) class. This class of object registers itself in the appropriate registry on  construction, and removes itself from the appropriate registry on destruction. Subclasses usually provide two types of constructors:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Anonymous object constructors - These constructors choose a unique but meaningless name for the object and register the object under that name in the appopriate object registry.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Named object constructors - These constructors allow you to choose a name for the object and register the object under that name in the appropriate object registry. If an object of the selected name already exists in the registry, a {\b CDuplicateNameException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDuplicateNameException \\*MERGEFORMAT}{\fldrslt pagenum}}}) will be thrown from the  constructor.\par
}The application registry can be searched for specific objects within a  specific registry or the registries themselves can be iterated through and  objects enumerated or searched for in each registry.\par
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v Object class hierarchy positioning information.}
Object class hierarchy positioning information.\par
{\bkmkstart Hierarchyinfo}
{\bkmkend Hierarchyinfo}
}\par
{\b CNamedObject} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNamedObject \\*MERGEFORMAT}{\fldrslt pagenum}}}) derived classes provide two member functions to support retrieving information about the place of the object in the class hierarchy. This is  intended to be descriptive information, rather than information which can be used from within a program. (To programmatically manipulate object types, it is better to use the C++ RTTI subsystem.):{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CNamedObject::AppendClassInfo} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNamedObject_b2 \\*MERGEFORMAT}{\fldrslt pagenum}}}) should be called from within the constructor of an application class. This member function, allows a string which describes the full class derivation to be built up.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
{\b CNamedObject::getClassPath} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNamedObject_a5 \\*MERGEFORMAT}{\fldrslt pagenum}}}) Can be called to return this class derivation string.\par
}{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v Object Description member functions.}
Object Description member functions.\par
{\bkmkstart SelfDescription}
{\bkmkend SelfDescription}
}\par
{\b CNamedObject} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNamedObject \\*MERGEFORMAT}{\fldrslt pagenum}}}) derived classes implement the member function  {\b DescribeSelf().} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCNamedObject_a8 \\*MERGEFORMAT}{\fldrslt pagenum}}}) DescribeSelf provides a human readable dump of the current state of an object. If you implement DescribeSelf() be sure to call your base class DescribeSelf so that the full state of the object can be produced.\par
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v Registration Example.}
Registration Example.\par
{\bkmkstart regExample}
{\bkmkend regExample}
}\par
The example in this section shows how to create objects which make full use of the introspective features of the class hierarchy. The example creates two Events, a {\b Timer event} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTimerEvent \\*MERGEFORMAT}{\fldrslt pagenum}}}) and a {\b file event.} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFileEvent \\*MERGEFORMAT}{\fldrslt pagenum}}})\par
The file event accepts numeric input on stdin, locates the timer event by name, describes it and schedules it to run in single shot mode after n seconds where n is just the number the user typed in. If a non-numeric value is entered, the application exits.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid #include <spectrodaq.h>\par
#include <SpectroFramework.h>\par
#include <iostream.h>\par
#include <unistd.h>\par
#include <stdlib.h>\par
#include <string>\par
\par
//\par
// Timer class intended to be 'remote controlled' by name.\par
//\par
class MyTimer : public CTimerEvent\par
\{\par
public:\par
  MyTimer(const char* pName);\par
  virtual void OnTimer();\par
  virtual string DescribeSelf();\par
\};\par
//  The constructor registers us, with the given name, however\par
//  since we won't be enabled, the initial timeout is 0 and we create\par
//  ourselves in norepeat mode.\par
//\par
MyTimer::MyTimer(const char* pName) :\par
  CTimerEvent(pName, 0, false)\par
\{\par
  AppendClassInfo();            // Add our place in class hierarchy.\par
\}\par
//  OnTimer is called when the timer does expire.. it just types out\par
//  "Timer fired" and it's description.\par
//\par
void\par
MyTimer::OnTimer()\par
\{\par
  cout << "A MyTimer object fired:" << endl;\par
  cout << DescribeSelf() << endl;\par
  cout << "------------------------------------------" << endl;\par
\}\par
string \par
MyTimer::DescribeSelf()\par
\{\par
  string result;\par
  result = "My timer object (one shot remote controlled timer).\\n";\par
  result += CTimerEvent::DescribeSelf();\par
\par
  return result;\par
\}\par
\par
\par
// Fd class to monitor stdin and remote control a timer based on numeric\par
// input.  Note that the thread exits if non-numeric input is received.\par
// \par
class Stdin : public CFileEvent\par
\{\par
  string m_TimerName;\par
public:\par
  Stdin(const char* pName, const string& rTimerName);\par
  virtual void OnReadable(istream &  rInput  );\par
  virtual string DescribeSelf();\par
protected:\par
  void         StartTimer(int nSeconds);\par
  CTimerEvent* LocateTimer();\par
\};\par
\par
// Constructor creates us on STDIN_FILENO registered as per name:\par
//\par
Stdin::Stdin(const char *pName, const string& rTimerName) : \par
  CFileEvent(STDIN_FILENO, string(pName)),\par
  m_TimerName(rTimerName)\par
\{\par
  AppendClassInfo();            // Add our place in class hierarchy.\par
\}\par
//\par
// OnReadable reads a number, locates and fires off the timer:\par
//\par
void\par
Stdin::OnReadable(istream& rInput)\par
\{\par
  char number[100];\par
  int  nsec;\par
\par
  rInput >> number;\par
  nsec = atoi(number);\par
\par
  if(nsec != 0) \{\par
    StartTimer(nsec);\par
  \}\par
  else \{\par
    setEnable(false);           // Disable ourselves.\par
  \}\par
\}\par
\par
// Describe ourself:\par
//\par
string\par
Stdin::DescribeSelf()\par
\{\par
  string result;\par
  result = " Stdin  object controlling the timer: ";\par
  result += m_TimerName;\par
  result += '\\n';\par
  result += CFileEvent::DescribeSelf();\par
\par
  return result;\par
\}\par
//\par
// Start timer locates the timer, sets its timeout and enables it:\par
//\par
void\par
Stdin::StartTimer(int nseconds)\par
\{\par
  nseconds = nseconds * 1000;   // Timer needs milliseconds, not seconds.\par
  CTimerEvent* pTimer = LocateTimer();\par
  if(pTimer) \{\par
    pTimer->SetTimeout(nseconds);\par
    pTimer->Enable();\par
  \}\par
  else \{\par
    cerr << "Stdin::StartTimer(): The timer " << m_TimerName;\par
    cerr << " Does not exist in: " << endl;\par
    cerr << DescribeSelf();\par
  \}\par
\}\par
//\par
//  Locates the named timer controlled by this StdIn object.\par
//\par
CTimerEvent*\par
Stdin::LocateTimer()\par
\{\par
  CClassifiedObjectRegistry* pRegistry = CApplicationRegistry::getInstance();\par
  try \{\par
    ObjectIterator p = pRegistry->Find(string("Events"), m_TimerName);\par
    return (CTimerEvent*)(p->second);\par
  \}\par
  catch (CNoSuchObjectException& rExcept) \{ // Timer not found.\par
    return (CTimerEvent*)NULL;\par
  \}\par
  \par
\}\par
\par
class MyApp : public DAQROCNode\par
\{\par
protected:\par
  int operator()(int argc, char** argv);\par
\};\par
\par
MyApp theApplication;\par
\par
int\par
MyApp::operator()(int argc, char** argv)\par
\{\par
  // Create and describe the timer, but don't enable it.. that's done\par
  // by StdIn's object.\par
\par
  MyTimer timer("A timer");\par
  cout << "Created a timer: " << timer.DescribeSelf() << endl;\par
\par
  // Create an Stdin which controls the timer:\par
\par
  Stdin TimerController("TimerControl", string("A timer"));\par
  cout << "Starting Stdin object: " << TimerController.DescribeSelf() << endl;\par
  TimerController.Enable();\par
\par
  DAQThreadId id = TimerController.getThreadId();\par
  Join(id);\par
  \par
\}\par
\par
}
\par
}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v Server accept events.}
Server accept events.\par
{\bkmkstart ServerEvent}
{\bkmkend ServerEvent}
}{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
Before reading this page, be sure you are familiar with {\b TCP/IP  client server programming.} ({\i p.{\field\fldedit {\*\fldinst PAGEREF TCPIP \\*MERGEFORMAT}{\fldrslt pagenum}}})  Server accept events allow a Spectrodaq application running under the framework to act as the listener part of a TCP/IP server.\par
To do this, the application writer must:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Subclass the class {\b CServerConnectionEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCServerConnectionEvent \\*MERGEFORMAT}{\fldrslt pagenum}}}) to provide application specific functionality for connection events (override {\b OnConnecition).} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCServerConnectionEvent_a12 \\*MERGEFORMAT}{\fldrslt pagenum}}})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Create an instance of this class in your application and configure it with the service on which to listen. Note that the service can either be a textual service name, as it appears in the /etc/services file, or it can be a port number.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Enable the event.\par
}When a connection to the service is requested by a client, the framework:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Creates a {\b CSocket} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCSocket \\*MERGEFORMAT}{\fldrslt pagenum}}}) which represents the connection along which client and server communicate. This {\b CSocket} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCSocket \\*MERGEFORMAT}{\fldrslt pagenum}}}) object is dynamically created and must be deleted when the connection to the client is shutdown.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Calls {\b OnConnection} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCServerConnectionEvent_a12 \\*MERGEFORMAT}{\fldrslt pagenum}}}). Normally the application will do the following:{
\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
1.\tab Optionally validate the connection request, shutting down and destroying the connection socket if necessary.\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
2.\tab Create a {\b CServerInstance} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCServerInstance \\*MERGEFORMAT}{\fldrslt pagenum}}}) derived object to carry out the dialog between the client and server for that client (see {\b Server       Instance Events} ({\i p.{\field\fldedit {\*\fldinst PAGEREF SocketEvents \\*MERGEFORMAT}{\fldrslt pagenum}}})).\par
}}In the example below, the program waits for connection requests on port 2048. When a connection arrives, it is honored by creating an echo server. The echo server simply echoes back lines to the client until the client breaks the connection. Deletion of exiting server instance threads is handled as follows:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
A timer event derived object called GrimReaper is instantiated and started.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
GrimReaper maintains an interlocked queue of {\b CEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCEvent \\*MERGEFORMAT}{\fldrslt pagenum}}}) object pointers for threads about to be deleted.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
When GrimReaper executes, it examines entries in the queue, ensures that they are indeed inactive, and if so, deletes them.\par
}{
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid #include <spectrodaq.h>\par
#include <SpectroFramework.h>\par
#include <list>\par
#include <string>\par
\par
\par
typedef list<CEvent*> EventList;\par
\par
// Reaper objects are timed events which delete dead process objects:\par
//\par
class Reaper : public CTimerEvent\par
\{\par
private:\par
  EventList m_DeletePending;\par
public:\par
  Reaper(const char* pName);\par
\par
  void QueueEvent(CEvent* pEvent);\par
  CEvent* DeQueueEvent();\par
\par
  virtual void OnTimer();\par
\};\par
// Implementation of Reaper:\par
\par
Reaper::Reaper(const char* pname) :\par
  CTimerEvent(pname, 1000, true) \{\}\par
\par
void \par
Reaper::QueueEvent(CEvent* pEvent)\par
\{\par
  CApplicationSerializer::getInstance()->Lock(); // Don't assume this is done\par
  m_DeletePending.push_back(pEvent);             // in an event context. \par
  CApplicationSerializer::getInstance()->UnLock();\par
\}\par
CEvent* \par
Reaper::DeQueueEvent()          // Returns NULL if empty queue or front not yet\par
\{                               // inactive... assumed to run locked.\par
  if(m_DeletePending.empty()) return (CEvent*)NULL;\par
\par
  CEvent* pItem = m_DeletePending.front();\par
  if(pItem->isActive()) \{\par
    m_DeletePending.pop_front();\par
    return pItem;\par
  \}\par
  else \{\par
    return (CEvent*)NULL;\par
  \}\par
\}\par
void \par
Reaper::OnTimer()\par
\{\par
  CEvent* pEvent;\par
  while(pEvent = DeQueueEvent()) \{\par
    delete pEvent;\par
  \}\par
\}\par
\par
// Server instance. Echoes client requests on client channel until\par
// client exits.. at exit time, disables self and enters the object\par
// on the delete pending queue of a reaper.\par
\par
class EchoServer : public CServerInstance\par
\{\par
  Reaper& m_GrimReaper;\par
public:\par
  EchoServer(CSocket* pSocket, Reaper& pReapme);\par
  void OnRequest(CSocket* pSocket);\par
\};\par
\par
EchoServer::EchoServer(CSocket* pSocket, Reaper& rReapme) :\par
  CServerInstance(pSocket),\par
  m_GrimReaper(rReapme) \{\}\par
\par
void\par
EchoServer::OnRequest(CSocket* pSocket) \{\par
  char buffer[1024];\par
  int nread = pSocket->Read(buffer, sizeof(buffer)-1);\par
  if(nread <= 0) \{              // Client exited or other error...\par
    Shutdown();                 // Shutdown our part of the connection.\par
    Disable();                  // Schedule thread exit and\par
    m_GrimReaper.QueueEvent(this); // Object deletion.\par
  \} else \{                      // Data available.\par
    pSocket->Write(buffer, nread);\par
  \}\par
\}\par
\par
\par
// Server listener.  Only new functionality is the OnConnection\par
// which creates a new server instance thread.\par
\par
class EchoListener : public CServerConnectionEvent\par
\{\par
  Reaper& m_GrimReaper;\par
public:\par
  EchoListener(const char* pName, const string& rservice, Reaper& rReaper);\par
  virtual void OnConnection(CSocket* pSocket);\par
\};\par
\par
EchoListener::EchoListener(const char* pName, const string& rservice,\par
                           Reaper& rReaper) :\par
  CServerConnectionEvent(pName, rservice),\par
  m_GrimReaper(rReaper)\par
\{\}\par
void\par
EchoListener::OnConnection(CSocket* pSocket)\par
\{\par
  EchoServer* pServer = new EchoServer(pSocket, m_GrimReaper);\par
  pServer->Enable();\par
\}\par
\par
\par
class MyApp : public DAQROCNode\par
\{\par
protected:\par
  int operator()(int argc, char** pargv);\par
\par
\};\par
int\par
MyApp::operator()(int argc, char** pargv)\par
\{\par
  Reaper theReaper("GrimReaper");\par
  theReaper.Enable();           // Start off the grim reaper.\par
\par
  EchoListener Listen("EchoListen", string("2048"), theReaper);\par
  Listen.Enable();\par
\par
  DAQThreadId id = Listen.getThreadId();\par
  Join(id);\par
  \par
\};\par
\par
MyApp theApplication;\par
}
\par
}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v Server Instance events.}
Server Instance events.\par
{\bkmkstart SocketEvents}
{\bkmkend SocketEvents}
}{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
The class CServerInstanceEvent is used to encapsulate a simple model of client server interaction. The model implemented is that following connection:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Clients make requests of the server by sending them a message.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Servers, perform the request and optionally send a reply message to the client.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Servers never initiate communication with the client without being prompted first by the client with a request message.\par
}This simple model is sufficient to encompass a wide variety of application level protocols. Under this model, you can think of a CServerInstanceEvent as a {\b CFileEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFileEvent \\*MERGEFORMAT}{\fldrslt pagenum}}}) which is only sensitized to readability, and which operates on a  socket rather than a file descriptor.\par
In general, a CServerInstanceEvent is created by the  {\b OnConnection member function of a CServerConnectionvent derived object.} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCServerConnectionEvent_a12 \\*MERGEFORMAT}{\fldrslt pagenum}}}) For more information, see {\b Server accept events.} ({\i p.{\field\fldedit {\*\fldinst PAGEREF ServerEvent \\*MERGEFORMAT}{\fldrslt pagenum}}})\par
The sample application below implements an echo server. The class to examine closely is the EchoServer class, its implementation and how it is constructed from the connection socket by the listener object (of type EchoListener). Note as well how the Reaper helper class and object is used to delete the resources associated with EchoServer objects which are no longer active.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid #include <spectrodaq.h>\par
#include <SpectroFramework.h>\par
#include <list>\par
#include <string>\par
\par
\par
typedef list<CEvent*> EventList;\par
\par
// Reaper objects are timed events which delete dead process objects:\par
//\par
class Reaper : public CTimerEvent\par
\{\par
private:\par
  EventList m_DeletePending;\par
public:\par
  Reaper(const char* pName);\par
\par
  void QueueEvent(CEvent* pEvent);\par
  CEvent* DeQueueEvent();\par
\par
  virtual void OnTimer();\par
\};\par
// Implementation of Reaper:\par
\par
Reaper::Reaper(const char* pname) :\par
  CTimerEvent(pname, 1000, true) \{\}\par
\par
void \par
Reaper::QueueEvent(CEvent* pEvent)\par
\{\par
  CApplicationSerializer::getInstance()->Lock(); // Don't assume this is done\par
  m_DeletePending.push_back(pEvent);             // in an event context. \par
  CApplicationSerializer::getInstance()->UnLock();\par
\}\par
CEvent* \par
Reaper::DeQueueEvent()          // Returns NULL if empty queue or front not yet\par
\{                               // inactive... assumed to run locked.\par
  if(m_DeletePending.empty()) return (CEvent*)NULL;\par
\par
  CEvent* pItem = m_DeletePending.front();\par
  if(pItem->isActive()) \{\par
    m_DeletePending.pop_front();\par
    return pItem;\par
  \}\par
  else \{\par
    return (CEvent*)NULL;\par
  \}\par
\}\par
void \par
Reaper::OnTimer()\par
\{\par
  CEvent* pEvent;\par
  while(pEvent = DeQueueEvent()) \{\par
    delete pEvent;\par
  \}\par
\}\par
\par
// Server instance. Echoes client requests on client channel until\par
// client exits.. at exit time, disables self and enters the object\par
// on the delete pending queue of a reaper.\par
\par
class EchoServer : public CServerInstance\par
\{\par
  Reaper& m_GrimReaper;\par
public:\par
  EchoServer(CSocket* pSocket, Reaper& pReapme);\par
  void OnRequest(CSocket* pSocket);\par
\};\par
\par
EchoServer::EchoServer(CSocket* pSocket, Reaper& rReapme) :\par
  CServerInstance(pSocket),\par
  m_GrimReaper(rReapme) \{\}\par
\par
void\par
EchoServer::OnRequest(CSocket* pSocket) \{\par
  char buffer[1024];\par
  int nread = pSocket->Read(buffer, sizeof(buffer)-1);\par
  if(nread <= 0) \{              // Client exited or other error...\par
    Shutdown();                 // Shutdown our part of the connection.\par
    Disable();                  // Schedule thread exit and\par
    m_GrimReaper.QueueEvent(this); // Object deletion.\par
  \} else \{                      // Data available.\par
    pSocket->Write(buffer, nread);\par
  \}\par
\}\par
\par
\par
// Server listener.  Only new functionality is the OnConnection\par
// which creates a new server instance thread.\par
\par
class EchoListener : public CServerConnectionEvent\par
\{\par
  Reaper& m_GrimReaper;\par
public:\par
  EchoListener(const char* pName, const string& rservice, Reaper& rReaper);\par
  virtual void OnConnection(CSocket* pSocket);\par
\};\par
\par
EchoListener::EchoListener(const char* pName, const string& rservice,\par
                           Reaper& rReaper) :\par
  CServerConnectionEvent(pName, rservice),\par
  m_GrimReaper(rReaper)\par
\{\}\par
void\par
EchoListener::OnConnection(CSocket* pSocket)\par
\{\par
  EchoServer* pServer = new EchoServer(pSocket, m_GrimReaper);\par
  pServer->Enable();\par
\}\par
\par
\par
class MyApp : public DAQROCNode\par
\{\par
protected:\par
  int operator()(int argc, char** pargv);\par
\par
\};\par
int\par
MyApp::operator()(int argc, char** pargv)\par
\{\par
  Reaper theReaper("GrimReaper");\par
  theReaper.Enable();           // Start off the grim reaper.\par
\par
  EchoListener Listen("EchoListen", string("2048"), theReaper);\par
  Listen.Enable();\par
\par
  DAQThreadId id = Listen.getThreadId();\par
  Join(id);\par
  \par
\};\par
\par
MyApp theApplication;\par
\par
}
\par
}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v Sub-classing in object frameworks}
Sub-classing in object frameworks\par
{\bkmkstart Subclassing}
{\bkmkend Subclassing}
}{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
Sub-classing is the basic mechanism which object frameworks provide the  programmer to supply application functionality. Application frameworks can be thought of as providing a complete program which does nothing. The  programmer selects classes to extend (via subclassing) and instantiates an appropriate set of objects to give the final program its functionality.\par
Subclassing to provide functionality consists of the following steps:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Derive a class from the base class in the framework.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Override some of the virtual member functions of the base class to  provide the functionality you desire. It is good practice to call the base class's member from within your function in case the base class performs useful default processing.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Create an object of your derived class.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Start the object 'running'.\par
}Consider for example the {\b CFileEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFileEvent \\*MERGEFORMAT}{\fldrslt pagenum}}}) class. This class provides a framework for handling events which occur as a result of a file descriptor becomming readable, writable or having an exceptional condition. (For user documentation of {\b CFileEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFileEvent \\*MERGEFORMAT}{\fldrslt pagenum}}}), see {\b the File Event handling class} ({\i p.{\field\fldedit {\*\fldinst PAGEREF FileEvents \\*MERGEFORMAT}{\fldrslt pagenum}}})):\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid #include <iostream.h>\par
#include <stdio.h>\par
#include <spectrodaq.h>\par
#include <SpectroFramework.h>\par
\par
class Echo : public CFileEvent\par
\{\par
public:\par
  Echo(int fd, const char* pName);\par
  virtual void OnReadable(istream& rin);\par
\};\par
\par
Echo::Echo(int fd, const char* pName):\par
  CFileEvent(fd, pName)\par
\{\par
  AppendClassInfo();\par
\}\par
\par
void\par
Echo::OnReadable(istream& rin)\par
\{\par
  CFileEvent::OnReadable(rin);\par
  string word;\par
  rin >> word;\par
  cout << word << endl;\par
\}\par
\par
class MyApp : public DAQROCNode\par
\{\par
protected:\par
  virtual int operator()(int argc, char** argv);\par
\};\par
\par
int\par
MyApp::operator()(int argc, char** argv)\par
\{\par
  Echo echo(fileno(stdin), "EchoProcessor");\par
\par
  echo.Enable();\par
  DAQThreadId id = echo.getThreadId();\par
\par
  Join(id);                     // Wait for echo to exit.\par
\}\par
\par
\par
MyApp theapp;\par
\par
}
The class declaration for Echo defines a new class derived from {\b CFileEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFileEvent \\*MERGEFORMAT}{\fldrslt pagenum}}}). In addition to implementing a constructor, this application specific class overrides {\b CFileEvent::OnReadable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFileEvent_a15 \\*MERGEFORMAT}{\fldrslt pagenum}}}). That member is called when the file descriptor represented by the object becomes readable.\par
The implementation of our override is to call the base class function ({\b CFileEvent::OnReadable} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCFileEvent_a15 \\*MERGEFORMAT}{\fldrslt pagenum}}})), and to read a string from the input file and echo it back to stdout (cout).\par
The application's operator() (entry point) creates an instance of echo monitoring stdin. It enables execution of the event object via a call to the object's Enable() member. Enable creates an independent thread of execution. The event serializes execution of the OnReadable member, and other user overridable members so that the programmer, for the most part, doe not need to worry about thread/thread synchronization (see {\b Synchronizing multiple threads of execution} ({\i p.{\field\fldedit {\*\fldinst PAGEREF Synchronization \\*MERGEFORMAT}{\fldrslt pagenum}}})).\par
Once the thread is started, it's thread Id is gotten and the main program  blocks until the Event thread exits (never).\par
\par
}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v Guest event loop synchronization}
Guest event loop synchronization\par
{\bkmkstart Synchronization}
{\bkmkend Synchronization}
}{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
The framework supports the existence of exactly one guest event loop.  The event loop supported are:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Tcl event loops.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Tk Event loops.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
X11/Xt event loops\par
}The first two synchronize differently than the X11/Xt event loops:\par
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v Tcl and Tk event loop synchronization}
Tcl and Tk event loop synchronization\par
{\bkmkstart TCLSynchronization}
{\bkmkend TCLSynchronization}
}\par
Most of the built in Tcl/Tk commands require no application synchronization.  For example, setting a variable is an essentially atomic action and in most cases does not involve interaction with other event threads. User command extensions are another matter however. It is assumed that user command  extensions may be used to control other event threads executing in the  framework. Therefore, user command extensions should be implemented as  derived classes from {\b CDAQTCLProcessor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDAQTCLProcessor \\*MERGEFORMAT}{\fldrslt pagenum}}}) rather than from {\b CTCLProcessor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCLProcessor \\*MERGEFORMAT}{\fldrslt pagenum}}}).\par
The {\b CDAQTCLProcessor} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDAQTCLProcessor \\*MERGEFORMAT}{\fldrslt pagenum}}}) jackets the call to operator() with a lock and unlock of the global serialization mutex. This forces the command's execution to be synchronized to the  application.\par
There may be some application specific scripts which require syncronization to the application (for example modification of related variables). The sync command can be added to the interpreter by instantiating and registering an instance of a {\b CTCLSynchronizeCommand} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCTCLSynchronizeCommand \\*MERGEFORMAT}{\fldrslt pagenum}}}). The sync command allows a script to be syncronized to the application. For example:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid sync \{                  ;# Synchronized script begins.\par
  set var1  $thing\par
  set var2 [Relationship $var1]\par
\}                       ;# Synchronized script ends.\par
\par
}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v X11/Xt Syncronization}
X11/Xt Syncronization\par
{\bkmkstart XTSynchronization}
{\bkmkend XTSynchronization}
}\par
The class {\b CXtEventLoop} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCXtEventLoop \\*MERGEFORMAT}{\fldrslt pagenum}}}) provides a base class for implementing X11/Xt event  loops in a synchronized manner. Since Xt operates by associating arbitrary application specific callbacks with events in the GUI, potentially and GUI event can trigger code which must be synchronized.\par
The {\b CXtEventLoop} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCXtEventLoop \\*MERGEFORMAT}{\fldrslt pagenum}}}) encapsulates an event loop which brackets the dispatch of a GUI event with synchronization calls. The main loop for examples looks like:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid            while(1) \{\par
              XtGetEvent()\par
              LockMutex()\par
              XtDispatchEvent();\par
              UnlockMutex();\par
             yield();                         // Let someone else run.\par
           \}\par
\par
}
The call to LockMutex() enters application synchronized code. After this call the GUI event is dispatched to its application specific callback via the call to XtDispatchEvent(). On return, UnlockMutex() marks the end of  syncronized execution.\par
\par
}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v TCP/IP client server programming}
TCP/IP client server programming\par
{\bkmkstart TCPIP}
{\bkmkend TCPIP}
}{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
Modern TCP/IP network aware programs generally divide into two roles; clients and servers.\par
Servers therefore have responsibilities:{
\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
1.\tab Listen for connection requests from new clients on a specified "service port."\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
2.\tab Respond to work requests by existing, connected clients.\par
}Client responsibilities are much simpler:{
\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
1.\tab Form a connection with a server\par
\pard\plain \s91\fi-360\li720\widctlpar\fs20\cgrid 
2.\tab Ask the server to do work, receive and analyze the server response.\par
}In the spectrodaq framework, clients and servers are represented by the {\b CSocket} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCSocket \\*MERGEFORMAT}{\fldrslt pagenum}}}) class. Sockets are used differently depending on whether or not the program is acting as a client or a server.\par
Server Sockets are wrapped in objects derived from the {\b CServerConnectionEvent} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCServerConnectionEvent \\*MERGEFORMAT}{\fldrslt pagenum}}})  class. This class allows the programmer to set up a thread to listen for  connection events on a socket which has been bound to listen for connection requests on a specified service or port. When connections arrive, the event calls {\b CServerConnectionEvent::OnConnection} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCServerConnectionEvent_a12 \\*MERGEFORMAT}{\fldrslt pagenum}}}) passing it a {\b CSocket} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCSocket \\*MERGEFORMAT}{\fldrslt pagenum}}}) which represents the connection to the client.\par
Application specific code can do whatever it wants at this time.  Normally, if the connection is valid, the application code will use the socket object to create a {\b CServerInstance} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCServerInstance \\*MERGEFORMAT}{\fldrslt pagenum}}}) derived object. {\b CServerInstance} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCServerInstance \\*MERGEFORMAT}{\fldrslt pagenum}}})  encapsulates a request response protocol in which the server passively waits for client requests, reacts and replies to them.\par
In {\b CServerInstance} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCServerInstance \\*MERGEFORMAT}{\fldrslt pagenum}}}) derived objects, {\b CServerInstance::OnRequest} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCServerInstance_a9 \\*MERGEFORMAT}{\fldrslt pagenum}}}) is called whenever the client has a new request for the server. The server can read the request from the socket passed to OnRequest, process it and return information to the client by writing it along the socket.\par
\par
}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v Xt/X11 event loops.}
Xt/X11 event loops.\par
{\bkmkstart XtGuests}
{\bkmkend XtGuests}
}{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid \par
Support for Xt/X11 event loops allows framework software to take advantage of the rich GUI functionality offered by Xwindows widget libraries such as the Athena widget library or Motif widgets. The Xt event loop is fully  synchronized with the application. The event loop structure looks like:\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid   while(!m_fExit) \{\par
    XEvent event;\par
\par
    XtAppNextEvent(m_AppContext, &event);\par
    pMutex->Lock(); \{           //--> Begin Critical region.\par
      XtDispatchEvent(&event);\par
    \}\par
    pMutex->UnLock();           //<-- End Critical region.\par
\par
  \}\par
\par
}
Xt event dispatch is bracketed by Lock and Unlock calls on the application  serialization mutex ensuring that all Xt Event processing is done synchronized to the application.\par
To include an Xt event loop in your application you must:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Create a subclass of the {\b CXtEventLoop} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCXtEventLoop \\*MERGEFORMAT}{\fldrslt pagenum}}}) class.\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Fill in the following member functions with application specific code:{
\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
1.\tab {\b InitializeApplication()} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCXtEventLoop_b6 \\*MERGEFORMAT}{\fldrslt pagenum}}}) (see {\b Application initialization.} (p.{\field\fldedit {\*\fldinst PAGEREF InitializeApplication \\*MERGEFORMAT}{\fldrslt pagenum}})
 below).\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
2.\tab {\b SetupApplicationResources()} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCXtEventLoop_b7 \\*MERGEFORMAT}{\fldrslt pagenum}}}) (see  {\b Setting up the application resource} (p.{\field\fldedit {\*\fldinst PAGEREF SetupApplicationResources \\*MERGEFORMAT}{\fldrslt pagenum}})
 below).\par
\pard\plain \s92\fi-360\li1080\widctlpar\fs20\cgrid 
3.\tab {\b SetupWidgetTree()} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCXtEventLoop_b8 \\*MERGEFORMAT}{\fldrslt pagenum}}}) (see {\b Setting up the application's initial widget tree.} (p.{\field\fldedit {\*\fldinst PAGEREF SetupWidgetTree \\*MERGEFORMAT}{\fldrslt pagenum}})
 below).\par
}\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Create an instance of the event loop in the application object\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
Schedule the event loop for execution.\par
}{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v Application initialization.}
Application initialization.\par
{\bkmkstart InitializeApplication}
{\bkmkend InitializeApplication}
} If the default application initialization is not sufficient, you can implement an override to this function. The default contents of the function are: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid Widget\par
CXtEventLoop::InitializeApplication(int& argc, char** argv)\par
\{\par
  m_TopLevel = XtAppInitialize(&m_AppContext,\par
                               m_sClass.c_str(),\par
                               m_pOptionTable,\par
                               m_nOptionCount,\par
                               &argc, argv,\par
                               m_ppcFallbackResources,\par
                               NULL, 0);\par
  return m_TopLevel;\par
\par
\}\par
\par
}
This initializes the Xt library, and produces the application top level widget. You can write your member to modify the class (m_sClass), the option table  (m_pOptionTable), and the application fallback resources  (m_ppcFallbackResources) prior to calling {\b CXtEventLoop::InitializeApplication} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCXtEventLoop_b6 \\*MERGEFORMAT}{\fldrslt pagenum}}})\par
You can also detect and process application specific "Command line parameters."\par
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v Setting up the application resource}
Setting up the application resource\par
{\bkmkstart SetupApplicationResources}
{\bkmkend SetupApplicationResources}
} database.\par
The attributes of widgets and classes of widgets are defined both by explicit properties at widget creation or modification time, and by a set of  defaults or "resources." The resources are loaded into a resource database from several sources:{\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
A set of 'fallback' resources can be loaded at Xt initialization time in {\b InitializeApplication().} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCXtEventLoop_b6 \\*MERGEFORMAT}{\fldrslt pagenum}}})\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
A set of default resources may be loaded into the Xt library in the function  described in this section ({\b SetupApplicationResources()} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCXtEventLoop_b7 \\*MERGEFORMAT}{\fldrslt pagenum}}})).\par
\pard\plain \s81\fi-360\li720\widctlpar\jclisttab\tx720{\*\pn \pnlvlbody\ilvl0\ls2\pnrnot0\pndec }\ls2\adjustright \fs20\cgrid 
The resources can be loaded in from files in the X11 resource directory and from resource specifications in a user application specific resource file.\par
}The function {\b SetupApplicationResources()} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCXtEventLoop_b7 \\*MERGEFORMAT}{\fldrslt pagenum}}}) provides a hook to allow default application resources to be loaded into the system. The call signature for this member is: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid void   SetupApplicationResources (Widget TopLevel);\par
\par
}
 Where: {{{\b \par
Parameters: }}\par
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\b {\i Toplevel}}  is the top level widget created in  {\b InitializeApplication()} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCXtEventLoop_b6 \\*MERGEFORMAT}{\fldrslt pagenum}}})\par
}The default behavior of this member is empty. For more information on X11 resources and the resource database, consult the relevant Xt and X11  programming documentation.\par
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v Setting up the application's initial widget tree.}
Setting up the application's initial widget tree.\par
{\bkmkstart SetupWidgetTree}
{\bkmkend SetupWidgetTree}
}\par
Xt applications consist of a hierachical set of GUI components called  "widgets." {\b SetupWidgetTree} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCXtEventLoop_b8 \\*MERGEFORMAT}{\fldrslt pagenum}}}) allows the initial set of widgets to be created.\par
The call signature of this member is: {
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid void \par
CXtEventLoop::SetupWidgetTree(Widget TopLevel)\par
\par
}
Where: {{{\b \par
Parameters: }}\par
\pard\plain \s61\li360\widctlpar\ql\adjustright \fs20\cgrid {\b {\i TopLevel}}  is the toplevel widget. All application widgets have this  widget as an ultimate parent.\par
}The default implementation of {\b SetupWidgetTree} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCXtEventLoop_b8 \\*MERGEFORMAT}{\fldrslt pagenum}}}) is empty. It is up to the application to determine its user interface\par
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v :}
:\par
{\bkmkstart Example}
{\bkmkend Example}
} The example below creates a single button which when clicked exits the Xt event loop.\par
{
\par
\pard\plain \s40\li0\widctlpar\adjustright \shading1000\cbpat8 \f2\fs16\cgrid //\par
// Tests the Xt event loop as a separate thread.\par
//\par
#include <spectrodaq.h>\par
#include <CXtEventLoop.h>\par
#include <XMPushbutton.h>\par
#include <iostream.h>\par
class CXMApplication : public CXtEventLoop\par
\{\par
  XMPushButton* m_pButton;\par
protected:\par
  virtual void SetupWidgetTree(Widget top)\par
  \{\par
    cerr << "Setting up widget tree\\n";\par
    cerr.flush();\par
    m_pButton = new XMPushButton("Exit",\par
                                 top,\par
                                 CXMApplication::Exit,\par
                                 (XtPointer)this);\par
    m_pButton->Manage();\par
    cerr << "Widget Tree set up.\\n";\par
    cerr.flush();\par
  \}\par
public:\par
  CXMApplication() :\par
    m_pButton(0)\par
  \{\par
    cerr << "Motif app constructed\\n";\par
    cerr.flush();\par
  \}\par
\par
private:\par
  static void  Exit(XMWidget* pMyWidget, XtPointer cd, XtPointer reason)\par
  \{\par
    CXMApplication* pMe = (CXMApplication*)cd;\par
    delete pMe->m_pButton;\par
    pMe->exit();\par
  \}\par
\par
\};\par
\par
class Main : public DAQROCNode\par
\{\par
  int operator()(int argc, char** argv)\par
  \{\par
    CXMApplication app;\par
    DAQThreadId   tid = daq_dispatcher.Dispatch(app);\par
    DAQStatus     stat;\par
\par
    Join(tid, &stat);\par
    cerr << "Motif gui thread exited: " << stat.GetStatusCode() << endl;\par
    return 0;\par
  \}\par
\};\par
\par
static Main myApp;\par
\par
}
\par
}
{\pard\plain \s2\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs28\kerning28\cgrid {\tc\tcl2 \v Bug List}
Bug List\par
{\bkmkstart bug}
{\bkmkend bug}
}{
\pard\plain \s17\sa60\sb30\widctlpar\qj \fs22\cgrid {
\pard\plain \s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \par
{\b {\bkmkstart classCBinding_BM_bug000005}
{\bkmkend BM_bug000005}
Member {\b CBinding::ItemToString}(T Item) }
\par
 Should invent a bad type exception and throw it. }\par
\par
{
\pard\plain \s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \par
{\b {\bkmkstart classCBinding_BM_bug000004}
{\bkmkend BM_bug000004}
Member {\b CBinding::VariableType}(T item) }
\par
Really should invent a bad type exception and throw it instead}\par
\par
{
\pard\plain \s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \par
{\b {\bkmkstart classCEventLoop_BM_bug000001}
{\bkmkend BM_bug000001}
Member {\b CEventLoop::~CEventLoop}() }
\par
There is no good way to enforce that {\b CDuplicateSingleton} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCDuplicateSingleton \\*MERGEFORMAT}{\fldrslt pagenum}}})'s don't result in spurious clears of the instance pointer.}\par
\par
{
\pard\plain \s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \par
{\b {\bkmkstart classCSocket_BM_bug000003}
{\bkmkend BM_bug000003}
Member {\b CSocket::Write}(void *pBuffer, size_t nBytes) }
\par
There's not a good way to handle failures on the second or later call to write(2). Since we'd like to indicate that part of the write completed before an error occured. The current assumption is that a followup write will produce the same error. Perhaps the best long term thing to do is to define a CTCPSocketIOError which will include as data the number of bytes written along with a {\b CErrnoException} ({\i p.{\field\fldedit {\*\fldinst PAGEREF classCErrnoException \\*MERGEFORMAT}{\fldrslt pagenum}}}) which describes why the write actually failed??}\par
\par
{
\pard\plain \s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \par
{\b {\bkmkstart classCXtEventLoop_BM_bug000006}
{\bkmkend BM_bug000006}
Member {\b CXtEventLoop::setFallbackResources}(char **resources) }
\par
 May want to do a copy in instead of pointer copy.}\par
\par
{
\pard\plain \s50\li0\sa60\sb30\qj\widctlpar\qj\adjustright \fs20\cgrid \par
{\b {\bkmkstart CSocket_8cpp_BM_bug000002}
{\bkmkend BM_bug000002}
Member {\b FALSE} }
\par
 Perhaps global syncronization of (3) calls should be conditionalized so that this module can be used in a non spectrodaq environment too. }\par
 \par
}

\pard\plain \sect\sbkpage
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid 
\s1\sb240\sa60\keepn\widctlpar\adjustright \b\f1\fs36\kerning36\cgrid Index\par 
\pard\plain 
{\tc \v Index}
{\field\fldedit {\*\fldinst INDEX \\c2 \\*MERGEFORMAT}{\fldrslt INDEX}}
}