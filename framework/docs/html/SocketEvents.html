<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Server Instance events.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.15 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><a name="SocketEvents"><h2>Server Instance events.</h2></a>

<p>
The class CServerInstanceEvent is used to encapsulate a simple model of client server interaction. The model implemented is that following connection:<ul>
<li>Clients make requests of the server by sending them a message.<li>Servers, perform the request and optionally send a reply message to the client.<li>Servers never initiate communication with the client without being prompted first by the client with a request message.</ul>
This simple model is sufficient to encompass a wide variety of application level protocols. Under this model, you can think of a CServerInstanceEvent as a <a class="el" href="classCFileEvent.html">CFileEvent</a> which is only sensitized to readability, and which operates on a  socket rather than a file descriptor.
<p>
In general, a CServerInstanceEvent is created by the  <a class="el" href="classCServerConnectionEvent.html#a12">OnConnection member function of a CServerConnectionvent derived object.</a> For more information, see <a class="el" href="ServerEvent.html">Server accept events.</a>
<p>
The sample application below implements an echo server. The class to examine closely is the EchoServer class, its implementation and how it is constructed from the connection socket by the listener object (of type EchoListener). Note as well how the Reaper helper class and object is used to delete the resources associated with EchoServer objects which are no longer active.
<p>
<div class="fragment"><pre><font class="preprocessor">#include &lt;spectrodaq.h&gt;</font>
<font class="preprocessor">#include &lt;<a class="code" href="SpectroFramework_8h.html">SpectroFramework.h</a>&gt;</font>
<font class="preprocessor">#include &lt;list&gt;</font>
<font class="preprocessor">#include &lt;string&gt;</font>


<font class="keyword">typedef</font> list&lt;CEvent*&gt; EventList;

<font class="comment">// Reaper objects are timed events which delete dead process objects:</font>
<font class="comment">//</font>
<font class="keyword">class </font>Reaper : <font class="keyword">public</font> <a class="code" href="classCTimerEvent.html">CTimerEvent</a>
{
<font class="keyword">private</font>:
  EventList m_DeletePending;
<font class="keyword">public</font>:
  Reaper(<font class="keyword">const</font> <font class="keywordtype">char</font>* pName);

  <font class="keywordtype">void</font> QueueEvent(<a class="code" href="classCEvent.html">CEvent</a>* pEvent);
  <a class="code" href="classCEvent.html">CEvent</a>* DeQueueEvent();

  <font class="keyword">virtual</font> <font class="keywordtype">void</font> <a class="code" href="classCTimerEvent.html#a10">OnTimer</a>();
};
<font class="comment">// Implementation of Reaper:</font>

Reaper::Reaper(<font class="keyword">const</font> <font class="keywordtype">char</font>* pname) :
  <a class="code" href="classCTimerEvent.html">CTimerEvent</a>(pname, 1000, true) {}

<font class="keywordtype">void</font> 
Reaper::QueueEvent(<a class="code" href="classCEvent.html">CEvent</a>* pEvent)
{
  <a class="code" href="classCApplicationSerializer.html#d0">CApplicationSerializer::getInstance</a>()-&gt;<a class="code" href="classCThreadRecursiveMutex.html#a6">Lock</a>(); <font class="comment">// Don't assume this is done</font>
  m_DeletePending.push_back(pEvent);             <font class="comment">// in an event context. </font>
  <a class="code" href="classCApplicationSerializer.html#d0">CApplicationSerializer::getInstance</a>()-&gt;<a class="code" href="classCThreadRecursiveMutex.html#a7">UnLock</a>();
}
<a class="code" href="classCEvent.html">CEvent</a>* 
Reaper::DeQueueEvent()          <font class="comment">// Returns NULL if empty queue or front not yet</font>
{                               <font class="comment">// inactive... assumed to run locked.</font>
  <font class="keywordflow">if</font>(m_DeletePending.empty()) <font class="keywordflow">return</font> (<a class="code" href="classCEvent.html">CEvent</a>*)NULL;

  <a class="code" href="classCEvent.html">CEvent</a>* pItem = m_DeletePending.front();
  <font class="keywordflow">if</font>(pItem-&gt;<a class="code" href="classCEvent.html#a5">isActive</a>()) {
    m_DeletePending.pop_front();
    <font class="keywordflow">return</font> pItem;
  }
  <font class="keywordflow">else</font> {
    <font class="keywordflow">return</font> (<a class="code" href="classCEvent.html">CEvent</a>*)NULL;
  }
}
<font class="keywordtype">void</font> 
<a class="code" href="classCTimerEvent.html#a10">Reaper::OnTimer</a>()
{
  <a class="code" href="classCEvent.html">CEvent</a>* pEvent;
  <font class="keywordflow">while</font>(pEvent = DeQueueEvent()) {
    <font class="keyword">delete</font> pEvent;
  }
}

<font class="comment">// Server instance. Echoes client requests on client channel until</font>
<font class="comment">// client exits.. at exit time, disables self and enters the object</font>
<font class="comment">// on the delete pending queue of a reaper.</font>

<font class="keyword">class </font>EchoServer : <font class="keyword">public</font> <a class="code" href="classCServerInstance.html">CServerInstance</a>
{
  Reaper&amp; m_GrimReaper;
<font class="keyword">public</font>:
  EchoServer(<a class="code" href="classCSocket.html">CSocket</a>* pSocket, Reaper&amp; pReapme);
  <font class="keywordtype">void</font> <a class="code" href="classCServerInstance.html#a9">OnRequest</a>(<a class="code" href="classCSocket.html">CSocket</a>* pSocket);
};

EchoServer::EchoServer(<a class="code" href="classCSocket.html">CSocket</a>* pSocket, Reaper&amp; rReapme) :
  <a class="code" href="classCServerInstance.html">CServerInstance</a>(pSocket),
  m_GrimReaper(rReapme) {}

<font class="keywordtype">void</font>
<a class="code" href="classCServerInstance.html#a9">EchoServer::OnRequest</a>(<a class="code" href="classCSocket.html">CSocket</a>* pSocket) {
  <font class="keywordtype">char</font> buffer[1024];
  <font class="keywordtype">int</font> nread = pSocket-&gt;<a class="code" href="classCSocket.html#a11">Read</a>(buffer, <font class="keyword">sizeof</font>(buffer)-1);
  <font class="keywordflow">if</font>(nread &lt;= 0) {              <font class="comment">// Client exited or other error...</font>
    Shutdown();                 <font class="comment">// Shutdown our part of the connection.</font>
    <a class="code" href="classXMButtonList.html#a1">Disable</a>();                  <font class="comment">// Schedule thread exit and</font>
    m_GrimReaper.QueueEvent(<font class="keyword">this</font>); <font class="comment">// Object deletion.</font>
  } <font class="keywordflow">else</font> {                      <font class="comment">// Data available.</font>
    pSocket-&gt;<a class="code" href="classCSocket.html#a12">Write</a>(buffer, nread);
  }
}


<font class="comment">// Server listener.  Only new functionality is the OnConnection</font>
<font class="comment">// which creates a new server instance thread.</font>

<font class="keyword">class </font>EchoListener : <font class="keyword">public</font> <a class="code" href="classCServerConnectionEvent.html">CServerConnectionEvent</a>
{
  Reaper&amp; m_GrimReaper;
<font class="keyword">public</font>:
  EchoListener(<font class="keyword">const</font> <font class="keywordtype">char</font>* pName, <font class="keyword">const</font> string&amp; rservice, Reaper&amp; rReaper);
  <font class="keyword">virtual</font> <font class="keywordtype">void</font> <a class="code" href="classCServerConnectionEvent.html#a12">OnConnection</a>(<a class="code" href="classCSocket.html">CSocket</a>* pSocket);
};

EchoListener::EchoListener(<font class="keyword">const</font> <font class="keywordtype">char</font>* pName, <font class="keyword">const</font> string&amp; rservice,
                           Reaper&amp; rReaper) :
  <a class="code" href="classCServerConnectionEvent.html">CServerConnectionEvent</a>(pName, rservice),
  m_GrimReaper(rReaper)
{}
<font class="keywordtype">void</font>
<a class="code" href="classCServerConnectionEvent.html#a12">EchoListener::OnConnection</a>(<a class="code" href="classCSocket.html">CSocket</a>* pSocket)
{
  EchoServer* pServer = <font class="keyword">new</font> EchoServer(pSocket, m_GrimReaper);
  pServer-&gt;Enable();
}


<font class="keyword">class </font>MyApp : <font class="keyword">public</font> DAQROCNode
{
<font class="keyword">protected</font>:
  <font class="keywordtype">int</font> operator()(<font class="keywordtype">int</font> argc, <font class="keywordtype">char</font>** pargv);

};
<font class="keywordtype">int</font>
MyApp::operator()(<font class="keywordtype">int</font> argc, <font class="keywordtype">char</font>** pargv)
{
  Reaper theReaper(<font class="stringliteral">"GrimReaper"</font>);
  theReaper.Enable();           <font class="comment">// Start off the grim reaper.</font>

  EchoListener Listen(<font class="stringliteral">"EchoListen"</font>, string(<font class="stringliteral">"2048"</font>), theReaper);
  Listen.Enable();

  DAQThreadId id = Listen.getThreadId();
  Join(id);
  
};

MyApp theApplication;
</pre></div>
<p>
<hr><address align="right"><small>Generated on Wed Feb 5 13:40:38 2003 for Spectrodaq External Event Framework by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.15 </small></address>
</body>
</html>
