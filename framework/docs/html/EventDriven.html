<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Event Driven Programming model</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.15 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><a name="EventDriven"><h2>Event Driven Programming model</h2></a>

<p>
<a name="WhatisEventDriven"><h2>What is event driven software.</h2></a>

<p>
A simple way to understand the event driven programming model is to compare  and contrast it with the the traditional model. In the traditional model the  programmer:<ul>
<li>Writes a main program.<li>Explicitly controls a main loop which looks for stuff to do and then does it.</ul>
In the event driven model, the programmer:<ul>
<li>Writes application initialization code which, among other things,  requests the receipt of events of interest from the outside world.<li>Writes handlers for the events and reigsters a correspondence betwen events and their handlers.<li>Turns control over to a library event loop which waits for the desired events and dispatches control to their handlers as required.</ul>
Event driven software is a win whenever:<ul>
<li>The event loop is sufficiently complex that you'd like to re-use it from application to application.<li>You want to decouple the user interface from the functionality of the software.</ul>
Both of these criteria are true for the spectrodaq framework.
<p>
<a name="FWKEventManagement"><h2>Event management and the spectrodaq framework</h2></a>

<p>
In the spectrodaq event framework, event handlers are member functions of classes descended from the <a class="el" href="classCEvent.html">CEvent</a> class. Thus events are handled as follows:<ul>
<li>The appropriate <a class="el" href="classCEvent.html">CEvent</a> subclass is subclassed and its event handlers are  overridden with application specific code.<li>One or more instance's of this event handler are created (e.g. via new).<li>An Event handler's <a class="el" href="classCEvent.html#a11">CEvent::Enable</a> member function is called to start the handlers private thread and event loop. See the general   concepts page for more information about the event classes.<li>As the event thread detects events, the overridden handler function is  called triggering the application specific behavior.</ul>
The example below shows this process: <div class="fragment"><pre><font class="preprocessor">#include &lt;iostream.h&gt;</font>
<font class="preprocessor">#include &lt;stdio.h&gt;</font>
<font class="preprocessor">#include &lt;spectrodaq.h&gt;</font>
<font class="preprocessor">#include &lt;<a class="code" href="SpectroFramework_8h.html">SpectroFramework.h</a>&gt;</font>

<font class="keyword">class </font>Echo : <font class="keyword">public</font> <a class="code" href="classCFileEvent.html">CFileEvent</a>
{
<font class="keyword">public</font>:
  Echo(<font class="keywordtype">int</font> fd, <font class="keyword">const</font> <font class="keywordtype">char</font>* pName);
  <font class="keyword">virtual</font> <font class="keywordtype">void</font> <a class="code" href="classCFileEvent.html#a15">OnReadable</a>(istream&amp; rin);
};

Echo::Echo(<font class="keywordtype">int</font> fd, <font class="keyword">const</font> <font class="keywordtype">char</font>* pName):
  <a class="code" href="classCFileEvent.html">CFileEvent</a>(fd, pName)
{
  AppendClassInfo();
}

<font class="keywordtype">void</font>
<a class="code" href="classCFileEvent.html#a15">Echo::OnReadable</a>(istream&amp; rin)
{
  <a class="code" href="classCFileEvent.html#a15">CFileEvent::OnReadable</a>(rin);
  string word;
  rin &gt;&gt; word;
  cout &lt;&lt; word &lt;&lt; endl;
}

<font class="keyword">class </font>MyApp : <font class="keyword">public</font> DAQROCNode
{
<font class="keyword">protected</font>:
  <font class="keyword">virtual</font> <font class="keywordtype">int</font> operator()(<font class="keywordtype">int</font> argc, <font class="keywordtype">char</font>** argv);
};

<font class="keywordtype">int</font>
MyApp::operator()(<font class="keywordtype">int</font> argc, <font class="keywordtype">char</font>** argv)
{
  Echo echo(fileno(stdin), <font class="stringliteral">"EchoProcessor"</font>);

  echo.Enable();
  DAQThreadId id = echo.getThreadId();

  Join(id);                     <font class="comment">// Wait for echo to exit.</font>
}


MyApp theapp;
</pre></div>
<p>
The Echo class subclasses <a class="el" href="classCFileEvent.html">CFileEvent</a> which is an event handler that watches  for events on a file descriptor. Overriding OnReadable supplies application specific behavior for a file descriptor when the file becomes readable. The line in MyApp::operator() which reads: <div class="fragment"><pre>        Echo echo(fileno(stdin), <font class="stringliteral">"EchoProcessor"</font>);
</pre></div> creates an instance of this event to listen for and react to input on stdin. and the call to echo.Enable() starts the thread.
<p>
When the event thread detecs input on stdin, it calls Echo::OnReadable which proceses the input in an application specific manner.
<p>
<hr><address align="right"><small>Generated on Tue Feb 4 12:35:49 2003 for Spectrodaq External Event Framework by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.15 </small></address>
</body>
</html>
