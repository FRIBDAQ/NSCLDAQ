<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Top&nbsp; Level of Named Objects</title>
</head>

<body>

<h1>Top&nbsp; Level of Named Objects:</h1>
<p>&nbsp;</p>
<p><map name="FPMap0">
<area href="#CNamedObject" shape="rect" coords="404, 10, 518, 95">
<area href="#CRegisteredObject" shape="rect" coords="402, 233, 536, 323">
<area href="#CClassifiedObjectRegistry" shape="rect" coords="734, 116, 927, 270">
<area href="#CEvent" shape="rect" coords="68, 474, 188, 583">
<area href="#CEventContainer" shape="rect" coords="232, 475, 355, 638">
<area href="#CReactor" shape="rect" coords="497, 470, 643, 557">
<area href="#CEventMonitor" shape="rect" coords="106, 785, 261, 878">
<area href="#CPointerPredicate" shape="rect" coords="365, 791, 501, 870">
<area href="#CApplication" shape="rect" coords="689, 783, 797, 871"></map><img border="0" src="images/NamedO1.gif" usemap="#FPMap0" width="933" height="906"></p>

<H1><A NAME = "CNamedObject">CNamedObject</A></H1>

<P> SuperClasses: </P>
<P> One to One associations: 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H3>m_sName</H3>
<P>Visibility: private</P>
<P>Type: string</p>
<P>
The name of this object, as assigned at creation time.
</P>
<H3>m_sClassPath</H3>
<P>Visibility: private</P>
<P>Type: string</p>
<P>
Class derivation as determined by at
construction time by recursing the
typeinfo tree.
</P>

<H2>Operations on  CNamedObject</H2>

<H3>virtual   DescribeSelf</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: string</p>
<P>Classification: Selector</p>
<P>Returns a string decribing what is known about 
the object.  In this case, the string is of the
form:</P>
<P>&nbsp;>>>>>>>>>>>>>>>>>>><<<<<<<<<<<<<<<<<<<</P>
<P>&nbsp;Object of type m_sClassPath named m_sName</P>
<H3>virtual   AppendClassInfo</H3>
<P>Visibility: protected</p>
<P>Parameters: </P>
<P>Return Type: void</p>
<P>Classification: Construction helper</p>
<P>Called down through the construction chain
to build up the m_sClassPath string.</P>

<HR>

<H1><A NAME = "CRegisteredObject">CRegisteredObject</A></H1>

<P> SuperClasses: *CNamedObject </P>
<P> One to One associations: CClassifiedObjectRegistry : m_Registry 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H2>Operations on  CRegisteredObject</H2>

<H3>  RegisterSelf</H3>
<P>Visibility: public</p>
<P>Parameters: const string& RegistryName</P>
<P>Return Type: void</p>
<P>Classification: Interactor</p>
<P>Registers this object in the appropriate object
registry.  Note: the object registry will throw
a DuplicateName exception if there is already
an object in our registry with that name.
If necesary, the registry is created.

Implicit parameters:
   m_Registry - a static member which is the collection
                       of object registries into which the object
                      will be registered.
   m_sName  - The name under which the object
                       will be registered.
</P>

<HR>

<H1><A NAME = "CClassifiedObjectRegistry">CClassifiedObjectRegistry</A></H1>

<P> SuperClasses: *CNamedObject </P>
<P> One to One associations: 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H2>Operations on  CClassifiedObjectRegistry</H2>

<H3>  CreateRegistry</H3>
<P>Visibility: public</p>
<P>Parameters: const string& RegistryName</P>
<P>Return Type: void</p>
<P>Classification: Mutator</p>
<P>Creates a new registry. It is not an error
to create a registry which already exists.
If this is attempted, it is a no-op.</P>
<H3>  DeleteRegistry</H3>
<P>Visibility: public</p>
<P>Parameters: const string& RegistryName</P>
<P>Return Type: void</p>
<P>Classification: Mutator</p>
<P>Delete an existing registry. Any registry entries
are destroyed, however the objects they point to
are not.
Attempts to destroy an nonexsitent registry
result in a NoSuchObject exception.</P>
<H3>virtual   Add</H3>
<P>Visibility: public</p>
<P>Parameters: const string& RegistryName, CNamedObject& rObject</P>
<P>Return Type: void</p>
<P>Classification: base class mutator.</p>
<P>Adds an item to a registry.
If the item already exists in that registry,
a DuplicateName exception is thrown.
If the registry does not exist a 
NoSuchObject exception is thrown.</P>
<H3>virtual   Remove</H3>
<P>Visibility: public</p>
<P>Parameters: const string& RegistryName, CNamedObject& Object</P>
<P>Return Type: void</p>
<P>Classification: base class mutator</p>
<P>The named object is removed from the designated registry.
If the object does not exist, or the registry does not exist,
a NoSuchObject exception is thrown. The name embedded
in the exception differentiates between these two cases.
</P>
<H3>  Find</H3>
<P>Visibility: public</p>
<P>Parameters: const string& RegistryName, const string& ObjectName</P>
<P>Return Type: ObjectRegistryIterator</p>
<P>Classification: Selector</p>
<P>Locates an object in a specific registry.
If the registry or object don't exist a
NoSuchObject exception is thrown.
</P>
<H3>  Find</H3>
<P>Visibility: public</p>
<P>Parameters: const string& ObjectName</P>
<P>Return Type: CRefcountedPtr<ObjectList></p>
<P>Classification: Sellector</p>
<P>Returns a referece counted pointer to
a dynamically allocated list of Objects which
match the name requested.
ObjectList is a typedef for:
list<CNamedObject*>
The list is drawn from all of the registries.
If no registries contain the requested name,
an empty list is returned.</P>
<H3>  beginregistry</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: RegistryIterator</p>
<P>Classification: Selector</p>
<P>Returns an iterator into the registries which
are contained by this object.  Note that iteratiing
will return registries... that is RegistryIterator is a
typedef for:

map<string,CObjectRegistry>::iterator</P>
<H3>  endregistry</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: RegistryIterator</p>
<P>Classification: Selector</p>
<P>Returns a registry iterator suitable for determining
when iteration has been completed
(e.g. while(p != coreg.endregistry()) {...
  p++;
}</P>
<H3>virtual   DescribeSelf</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: string</p>
<P>Classification: Selector</p>
<P>Descirbes self.  This produces a string of the form:
CNamedObject::DescibeSelf()
"  Registries defined: "  List of registries
"     Registry " <name>"  Contains:   <- for all registries.
          Registry::DescribeSelf</P>

<HR>

<H1><A NAME = "CEvent">CEvent</A></H1>

<P> SuperClasses: CRegisteredObject </P>
<P> One to One associations: *CThreadRecursiveMutex : m_Synchronizer 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : CEventMonitor : -- 
  CReactor : -- 
  CEventThread : -- 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H3>m_fEnabled</H3>
<P>Visibility: private</P>
<P>Type: bool</p>
<P>
TRUE if the event is enabled and actively monitoriing
FALSE if the event is disabled or disable pending.
</P>

<H2>Operations on  CEvent</H2>

<H3>  OnEvent</H3>
<P>Visibility: protected</p>
<P>Parameters: CEventMonitor::result why</P>
<P>Return Type: void</p>
<P>Classification: Callback</p>
<P>Locks the global mutex, invokes the
Reactor's operator() and unlocks the global mutex.</P>
<H3>  ReplaceMonitor</H3>
<P>Visibility: public</p>
<P>Parameters: CEventMonitor& rEvent</P>
<P>Return Type: void</p>
<P>Classification: Mutator.</p>
<P>Replaces the event monitor with a different
object.  This allows the event to reconfigure
itself at run time.  In theory base class
events can completely reconfigure what they
point to.  In practice, this member is called
by constructors of descendants to set up
the initial event systesm.

 Note that it is an error to call this when the
EventThread is active.  If this is done a
CAlreadyRunning exception will be thrown.
</P>
<H3>  ReplaceReactor</H3>
<P>Visibility: public</p>
<P>Parameters: CReactor& rReactor</P>
<P>Return Type: void</p>
<P>Classification: Mutator</p>
<P>Called to replace the current instance of the event reactor.
This is typically called at construction time by subclasess
to set up the actual event framework.  Event reactors
may be modified when the event thread is active.</P>
<H3>  Enable</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: void</p>
<P>Classification: Mutator.</p>
<P>The Event thread is started in a synchronized way.
If the event thread is already running, this is a noop.
</P>
<H3>  Disable</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: void</p>
<P>Classification: Mutator.</p>
<P>The event thread is stopped.  This member
returns when the stop has been requested,
but not necessarily halted.  If the
event thread has been halted or has a halt
pending, this is a No-Op.</P>
<H3>virtual   DescribeSelf</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: string</p>
<P>Classification: Selector</p>
<P>Returns a description of this.
1. CNamedObject::DescribeSelf
2. Values of m_fEnabled.
3. Describe self from:
   Event monitor
   Event reactor,
   

</P>

<HR>

<H1><A NAME = "CEventMonitor">CEventMonitor</A></H1>

<P> SuperClasses: CRegisteredObject </P>
<P> One to One associations: 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H3>m_tvTimeout</H3>
<P>Visibility: private</P>
<P>Type: timeval</p>
<P>
contains the timeout if timeouts are enabled else indeterminate.
</P>
<H3>m_fTimedWait</H3>
<P>Visibility: private</P>
<P>Type: bool</p>
<P>
if TRUE, waits for events are timed,
else they are determined by the timeout.
</P>

<H2>Operations on  CEventMonitor</H2>

<H3>virtual   operator()</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: CEventMonitor::result</p>
<P>Classification: Interface</p>
<P>Monitor for the occurance of an event.
Concrete classes must implement this.
Return values are from the enum:

CEventMonitor::result:

Occured   - The event happened.
TimedOut -  The event monitor supports timeouts
                    and the timeout fired.
Error         -  An error condition was encountered
                   waiting for the event.
</P>
<H3>virtual   isReactorCompatible</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: bool</p>
<P>Classification: Interface</p>
<P>Determines if a reactor can be applied to
an event monitor.  That is if a reactor is of
a type which can successfully interact with
an event monitor.  This must be implemented
by the concrete classes themselves.</P>
<H3>virtual   setTimeout</H3>
<P>Visibility: public</p>
<P>Parameters: int nTimeout=FOREVER</P>
<P>Return Type: void</p>
<P>Classification: mutator</p>
<P>Sets the timeout.  The length of the timeout is
determined by the parameter in ms..  Special values:

0   - Poll (return instantly).
FOREVER - Block until event.
</P>

<HR>

<H1><A NAME = "CEventContainer">CEventContainer</A></H1>

<P> SuperClasses: CRegisteredObject </P>
<P> One to One associations: 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H2>Operations on  CEventContainer</H2>

<H3>  AddEvent</H3>
<P>Visibility: public</p>
<P>Parameters: CEvent& rEvent</P>
<P>Return Type: CEventContainer::iterator</p>
<P>Classification: mutator</p>
<P>Adds an event to the container.
The state of the event is not changed.
It is up to the caller to enable/disable the
event.  In most physics applications,
events remain enabled once created
in any event.
Exception to this: servers.</P>
<H3>  RemoveEvent</H3>
<P>Visibility: public</p>
<P>Parameters: const string& rName</P>
<P>Return Type: void</p>
<P>Classification: Mutator</p>
<P>Removes an event given it's name.
If the event does not exist in the container,
throws CNoSuchObject.</P>
<H3>  RemoveEvent</H3>
<P>Visibility: public</p>
<P>Parameters: CEventContainer::iter p</P>
<P>Return Type: void</p>
<P>Classification: Mutator.</p>
<P>Removes an event from the container
given an iterator.  If the iterator is end()
CNoSuchObject is thrown.</P>
<H3>  FindEvent</H3>
<P>Visibility: public</p>
<P>Parameters: const string& rName</P>
<P>Return Type: CEventContainer::iterator</p>
<P>Classification: Selector.</p>
<P>Locates an event given it's name.
If the event is not found, endEvents() is
returned.</P>
<H3>  FindEvent</H3>
<P>Visibility: public</p>
<P>Parameters: EventMatchPredicate Predicate</P>
<P>Return Type: CEventContainer::iterator</p>
<P>Classification: Selector</p>
<P>Returns an event iterator which points to
a selected event.  The event is the first one
in iteration order to match an EventMatchPredicate
EventMatchPredicates are function objects which
implement: 
bool operator()(CEvent& rEvent)

If no event causes the predicate to return TRUE,
endEvents() is returned.</P>
<H3>  beginEvents</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: CEventContainer::iterator</p>
<P>Classification: </p>
<P>Returns an iterator pointing towards the 
'first' item in m_Events.</P>
<H3>  endEvents</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: CEventContainer::iterator</p>
<P>Classification: Selector</p>
<P>Returns an iterator suitable for 
ending iteration through the
container e.g.:
CEventContainer::iterator p = cont.beginEvents();
for(;p!= cont.endEvents(); p++) {
   // do stuff on *p.
}</P>
<H3>  EnableEvents</H3>
<P>Visibility: public</p>
<P>Parameters: EventMatchPredicate pred=MatchAll</P>
<P>Return Type: void</p>
<P>Classification: Mutator</p>
<P>Enables execution of all 
events which match the predicate.</P>
<H3>  DisableEvents</H3>
<P>Visibility: public</p>
<P>Parameters: EventMatchPredicate pred=MatchAll</P>
<P>Return Type: void</p>
<P>Classification: mutator</p>
<P>Disables all events which match the predicate.</P>
<H3>virtual   DescribeSelf</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: string&</p>
<P>Classification: Selector</p>
<P>Returns a string which defines the event container.  
The container describes all events it
contains.</P>

<HR>

<H1><A NAME = "CPointerPredicate">CPointerPredicate</A></H1>

<P> SuperClasses: CRegisteredObject </P>
<P> One to One associations: 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H2>Operations on  CPointerPredicate</H2>

<H3>virtual   operator()</H3>
<P>Visibility: public</p>
<P>Parameters: T newValue</P>
<P>Return Type: bool</p>
<P>Classification: </p>
<P>Called to evaluate a value by a 
location  monitor.</P>

<HR>

<H1><A NAME = "CReactor">CReactor</A></H1>

<P> SuperClasses: CRegisteredObject </P>
<P> One to One associations: 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H2>Operations on  CReactor</H2>

<H3>virtual   operator()</H3>
<P>Visibility: public</p>
<P>Parameters: CEventMonitor& rMonitor, CEventMonitor::result Reason</P>
<P>Return Type: void</p>
<P>Classification: Interface Definition</p>
<P>This method is called in response ot an event
from an event monitor on which this reactor
has been established.  The Reactor provides 
application specific procesing of the event.</P>
<H3>virtual   isMonitorCompatible</H3>
<P>Visibility: public</p>
<P>Parameters: CEventMonirtor& rMonitor</P>
<P>Return Type: BOOL</p>
<P>Classification: interface.</p>
<P>Determines if the monitor passed in
is compatible with us.   Base class
default functionality is to return TRUE.</P>

<HR>

<H1><A NAME = "CApplication">CApplication</A></H1>

<P> SuperClasses: CRegisteredObject </P>
<P> One to One associations: CClassifiedObjectRegistry : m_ObjectRegistry 
  *CEventContainer : -- 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H3>m_Instance</H3>
<P>Visibility: private</P>
<P>Type: CApplication*</p>
<P>
Static member data:
If an application instance has been created,
this points to it, otherwise it is null.
</P>

<H2>Operations on  CApplication</H2>

<H3> static  GetInstance</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: CApplication*</p>
<P>Classification: Selector</p>
<P>Returns the application instance.
(m_Instance).</P>
<H3>virtual   DescribeSelf</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: string</p>
<P>Classification: Selector</p>
<P>Describes the application.
This is done by calling CNamedObject::DescribeSelf
then dumping the event container and the object registry in that
order.
</P>

<HR>

<p>Last Modified: <!--webbot bot="Timestamp" startspan S-Type="EDITED"
S-Format="%A, %B %d, %Y" -->Tuesday, August 07, 2001<!--webbot bot="Timestamp"
I-CheckSum="50518" endspan -->
 <a href="mailto:fox@nscl.msu.edu">Ron Fox</a></p>

</body>

</html>
