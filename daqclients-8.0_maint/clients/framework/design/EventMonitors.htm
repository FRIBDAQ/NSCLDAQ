<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Event Monitor Class Hierarchy</title>
</head>

<body>

<h1>Event Monitor Class Hierarchy</h1>
<p><map name="FPMap0">
<area href="#CEventMonitor" shape="rect" coords="432, 20, 577, 112">
<area href="#CFdMonitor" shape="rect" coords="71, 260, 220, 386">
<area href="#CServerMonitor" shape="rect" coords="71, 564, 189, 649">
<area href="#CBufferMonitor" shape="rect" coords="272, 252, 418, 450">
<area href="#CAlarmMonitor" shape="rect" coords="281, 697, 374, 774">
<area href="#CTimerMonitor" shape="rect" coords="684, 243, 830, 353">
<area href="#CLocationMonitor" shape="rect" coords="890, 252, 1044, 373">
<area href="#CPointerPredicate" shape="rect" coords="428, 789, 572, 863">
<area href="#CChangedPredicate" shape="rect" coords="279, 995, 430, 1094">
<area href="#CMaskedValuePredicate" shape="rect" coords="572, 992, 734, 1091"></map><img border="0" src="images/EventM2.gif" usemap="#FPMap0" width="1056" height="1122"></p>

<H1><A NAME = "CEventMonitor">CEventMonitor</A></H1>

<P> SuperClasses: CRegisteredObject </P>
<P> One to One associations: 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H3>m_tvTimeout</H3>
<P>Visibility: private</P>
<P>Type: timeval</p>
<P>
contains the timeout if timeouts are enabled else indeterminate.
</P>
<H3>m_fTimedWait</H3>
<P>Visibility: private</P>
<P>Type: bool</p>
<P>
if TRUE, waits for events are timed,
else they are determined by the timeout.
</P>

<H2>Operations on  CEventMonitor</H2>

<H3>virtual   operator()</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: CEventMonitor::result</p>
<P>Classification: Interface</p>
<P>Monitor for the occurance of an event.
Concrete classes must implement this.
Return values are from the enum:

CEventMonitor::result:

Occured   - The event happened.
TimedOut -  The event monitor supports timeouts
                    and the timeout fired.
Error         -  An error condition was encountered
                   waiting for the event.
</P>
<H3>virtual   isReactorCompatible</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: bool</p>
<P>Classification: Interface</p>
<P>Determines if a reactor can be applied to
an event monitor.  That is if a reactor is of
a type which can successfully interact with
an event monitor.  This must be implemented
by the concrete classes themselves.</P>
<H3>virtual   setTimeout</H3>
<P>Visibility: public</p>
<P>Parameters: int nTimeout=FOREVER</P>
<P>Return Type: void</p>
<P>Classification: mutator</p>
<P>Sets the timeout.  The length of the timeout is
determined by the parameter in ms..  Special values:

0   - Poll (return instantly).
FOREVER - Block until event.
</P>

<HR>

<H1><A NAME = "CFdMonitor">CFdMonitor</A></H1>

<P> SuperClasses: CEventMonitor </P>
<P> One to One associations: 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H3>m_nFd</H3>
<P>Visibility: private</P>
<P>Type: int</p>
<P>
File descriptor which will be monitored by the 
monitor.
</P>
<H3>m_nConditionMask</H3>
<P>Visibility: private</P>
<P>Type: UInt_t</p>
<P>
Conditions which will be monitored by the 
monitor for the file descriptor.  This will
be a mask of the bits:
FD_READABLE
FD_WRITABLE
FD_EXCEPTION

These bits are defined
as members of the public bit-field strructure:
CFdMonitor::FdConditions

</P>
<H3>m_fLastEventMask</H3>
<P>Visibility: private</P>
<P>Type: int</p>
<P>
Mask of the last set of events to be detected on a 
file.  This is calculated from the select() service, and
does not necessarily reflect the actual state. e.g.
if an fd is readable and writable, but only readability
was monitored, this mask will contain FD_READABLE
not FD_READABLE | FD_WRITABLE
</P>

<H2>Operations on  CFdMonitor</H2>

<H3>  MonitorReadable</H3>
<P>Visibility: public</p>
<P>Parameters: bool fReadable=TRUE</P>
<P>Return Type: void</p>
<P>Classification: Mutator</p>
<P>Sets or clears the FD_READABLE bit in 
m_nConditionMask.</P>
<H3>  MonitorWritable</H3>
<P>Visibility: public</p>
<P>Parameters: bool  fWritable=TRUE</P>
<P>Return Type: void</p>
<P>Classification: Mutator</p>
<P>Sets or clears the FD_WRITABLE bit in the
m_nConditionMask attribute.</P>
<H3>  MonitorExceptions</H3>
<P>Visibility: public</p>
<P>Parameters: bool fException=TRUE</P>
<P>Return Type: void</p>
<P>Classification: Mutator</p>
<P>Sets or clears  the FD_EXCEPTION bit
in m_nConditionMask.</P>
<H3>virtual   operator()</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: void</p>
<P>Classification: Interface Implementation</p>
<P>Implements a wait for a single file descriptor event
as described in the mask.  Returns one of:
Occured   - one of the masked conditions occured.
TimedOut - Timeout was enabled and none of the
                  conditions occured within the timeout.
Error         - An error condition ocurred.
</P>
<H3>virtual   DescribeSelf</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: string</p>
<P>Classification: Behavioral override.</p>
<P>Returns a string which describes the state of the monitor:

CEventMonitor::DescribeSlef()
    File descriptor = $m_nFd
    Conditions      = <Decoded condition>
    Timeout          = Enabled  at $m_tvTimeout ms | Disabled 
</P>
<H3>virtual   isReactorCompatible</H3>
<P>Visibility: public</p>
<P>Parameters: CReactor& rReactor</P>
<P>Return Type: bool</p>
<P>Classification: interface implementation</p>
<P>Indicates if the passed reactor is compatible with the monitor.  This will be the
case if the reactor is dynamcially castable to a CLocationReactor type.</P>

<HR>

<H1><A NAME = "CServerMonitor">CServerMonitor</A></H1>

<P> SuperClasses: CFdMonitor </P>
<P> One to One associations: 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H3>m_Socket</H3>
<P>Visibility: private</P>
<P>Type: CSocket&</p>
<P>
Socket object which represents the 
server listen socket.
</P>

<H2>Operations on  CServerMonitor</H2>

<H3>  operator()</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: void</p>
<P>Classification: </p>
<P></P>
<H3>virtual   DescribeSelf</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: string</p>
<P>Classification: selector</p>
<P>Describes self as a file descriptor
which has a socket that has a state.
</P>

<HR>

<H1><A NAME = "CBufferMonitor">CBufferMonitor</A></H1>

<P> SuperClasses: CEventMonitor </P>
<P> One to One associations: 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H3>m_Buffer</H3>
<P>Visibility: private</P>
<P>Type: DAQBuffer<T></p>
<P>
Contains the buffer which is to be managed by this 
monitor.  All data received is received into this buffer.
</P>
<H3>m_lLinks</H3>
<P>Visibility: private</P>
<P>Type: list<CBufferMonitor::LinkInfo></p>
<P>
Contains a list of LinkInfo data structures 
which describe the current set of links.
For each link the following is maintained:
int Tag      - The tag associated with the link.
int Mask    - The mask associated with the link.
string URL - The URL defining the source system.
int linkid     - The id which identifies the link to the
                    spectrodaq link manager object.
</P>

<H2>Operations on  CBufferMonitor</H2>

<H3>virtual   operator()</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: CEventMonitor::result</p>
<P>Classification: override.</p>
<P>Waits for a buffer to be recieved.  Returns 
one of the following:
Occured   - A buffer was received into m_Buffer.
TimedOut - Timeouts were enabled and no buffer
                   was received during the timeout
                   interval (See m_fTimedWait and
                   m_tvTimeout in base class).
</P>
<H3>virtual   AddLink</H3>
<P>Visibility: public</p>
<P>Parameters: const string& URL, int tag=COS_ALLBITS, int mask=COS_ALLBITS, bool fReliable=TRUE</P>
<P>Return Type: int</p>
<P>Classification: mutator</p>
<P>Adds a link to the link manager.  Note that links
are somewhat independent of buffers.  A link
Buffers are accepted along links, the tag and
mask of each link and buffer combine to determine
what data is receieved into the buffer.  However if
these conditions overlap, it is possible to get some
strange results as for each buffer accepted by the link
at >most< one buffer is allowed to receive it.

The link is inserted in the m_lLinks list of links.
The linkid (from the SpectroDaq link manager) is returned.
On failure, CLinkFailed is thrown.


</P>
<H3>  RemoveLink</H3>
<P>Visibility: public</p>
<P>Parameters: int linkid</P>
<P>Return Type: void</p>
<P>Classification: mutator</p>
<P>If the specified link exists, it is removed from the link list and
deleted from the SpectroDaq link manager.
If the link does not exist, then CNoSuchLink is thrown.
</P>
<H3>  RemoveLink</H3>
<P>Visibility: public</p>
<P>Parameters: LinkIterator link</P>
<P>Return Type: void</p>
<P>Classification: mutator</p>
<P>Removes a link given the iterator to
it's link structure in the link list.
If the iterator is end() then
CNoSuchLink is thrown.</P>
<H3>  FindLink</H3>
<P>Visibility: public</p>
<P>Parameters: LinkMatchPredicate& rPredicate, LinkIterator startat</P>
<P>Return Type: LinkIterator</p>
<P>Classification: Selector (Templated)</p>
<P>Locates the first link which satisfies a 
given predicate.  Predefined predicates
include:
MatchURL  - Matches a URL only.
MatchAll      - Matches URL, tag and mask.

A LinkMatchPredicate is a function object
implementing:
bool operator()(LinkInfo)
  which returns TRUE if the link satisfies
the predicate.

Returns:
  An iterator 'pointing' to the first match or
end() if there are no matches.</P>
<H3>  beginLinks</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: LinkIterator</p>
<P>Classification: Selector</p>
<P>Returns an iterator to the beginning of the 
links list.</P>
<H3>  endLinks</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: LinkIterator</p>
<P>Classification: selector</p>
<P>Returns an iterator suitable for
determining end of iteration
through the link list e.g.:
LinkIterator p;
for(p = o.beginLinks(); p != o.endLinks(); o++) {
...
}</P>
<H3>  getBufferPointer</H3>
<P>Visibility: public</p>
<P>Parameters: offset_t nOffset=0</P>
<P>Return Type: DAQBufferPointer<T></p>
<P>Classification: Selector (Templatized).</p>
<P>Returns a pointer to the daq buffer.</P>
<H3>  SetBufferTag</H3>
<P>Visibility: public</p>
<P>Parameters: int tag=COS_ALLBITS</P>
<P>Return Type: void</p>
<P>Classification: Mutator.</p>
<P>Sets the tag matched on receives into the buffer.
For each link/buffer pair, tags are used to determine
which buffers routed through SpectroDaq will be
received by a link or buffer.  The logic is that
at each stage, the routed buffer's tag is anded with
the receiving entity's mask.  If this is equal to the
receiving entity's tag, the buffer is accepted.
So, for a given link (link.mask, link.tag), and
our buffer (buffer.mask, buffer.tag):
A routed buffer rbuffer.tag is received when:

((rbuffer.tag & link.mask) == link.tag) &&
((rbuffer.tag & buffer.mask) == buffer.tag)
</P>
<H3>  SetBufferMask</H3>
<P>Visibility: public</p>
<P>Parameters: int nMask</P>
<P>Return Type: void</p>
<P>Classification: Mutator.</p>
<P>Sets the receive mask associated with the buffer.
See SetBufferTag for an explanation of tags and masks
and how they interact with link tags and masks and the tag
of the incomming buffer to determine receipt.</P>
<H3>  DescribeSelf</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: string</p>
<P>Classification: Selector</p>
<P>Produces a desciprtion string of the object.  This includes
1. Calling CEventManager::DescribeSelf()
2. Putting out the tag and mask of the buffer.
3. Listing the links and their information.</P>
<H3>  isReactorCompatible</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: bool</p>
<P>Classification: RealityCheck.</p>
<P>Determines if the reactor passed in is descended from
a CBufferReactor.  If not, returns FALSE, if so 
Returns TRUE.
</P>

<HR>

<H1><A NAME = "CAlarmMonitor">CAlarmMonitor</A></H1>

<P> SuperClasses: CBufferMonitor </P>
<P> One to One associations: 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H2>Operations on  CAlarmMonitor</H2>

<H3>virtual   AddLink</H3>
<P>Visibility: public</p>
<P>Parameters: const string& URL, int tag=COS_ALLBITS, int mask=COS_ALLBITS, bool fReliable=TRUE</P>
<P>Return Type: int</p>
<P>Classification: Mutator</p>
<P>Adds an alarm link to the link list.
The link id is returned.  On failure
CLinkFailed is thrown.</P>

<HR>

<H1><A NAME = "CTimerMonitor">CTimerMonitor</A></H1>

<P> SuperClasses: CEventMonitor </P>
<P> One to One associations: 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H3>m_fOneShot</H3>
<P>Visibility: private</P>
<P>Type: bool</p>
<P>
This flags indicates whether or not the timer is a
One-shot timer or a Recurring timer.
</P>
<H3>m_fFired</H3>
<P>Visibility: private</P>
<P>Type: bool</p>
<P>
If m_fOneShot is true, this flag is used
to indicate whether or not the timer has fired
already.
</P>

<H2>Operations on  CTimerMonitor</H2>

<H3>virtual   operator()</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: CEventMonitor::results</p>
<P>Classification: Override behavior</p>
<P>Waits for the timer as follows:
1. If m_fOneshot is false, this function blocks
    for m_tvTimeout time, then returns Occured
2. If m_fOneshot is true, but m_fFired is false,
    blocks for m_tvTimeout, sets m_fFired and
    returns Occured
3. If m_fOneshot and m_fFired are both true,
    returns TimedOut
</P>
<H3>  Repeat</H3>
<P>Visibility: public</p>
<P>Parameters: bool fReapeat=TRUE</P>
<P>Return Type: void</p>
<P>Classification: mutator.</p>
<P>Sets m_fOneshot to the value of its
parameter.</P>
<H3>virtual   setTimeout</H3>
<P>Visibility: public</p>
<P>Parameters: int nTimeout=FOREVER</P>
<P>Return Type: void</p>
<P>Classification: Mutator.</p>
<P>  Calls CEventMonitor::setTimeout and
clears m_fFired.
  The wait flag FOREVER results in a
MAXINT being passed to CEventMonitor::setTimeout
</P>
<H3>virtual   DescribeSelf</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: string</p>
<P>Classification: selector</p>
<P>Produces a string describing the object:
1. Calls CEventMonitor::DecribeSelf
2. Dumps the state of the oneshot and timed flags.
</P>
<H3>virtual   isReactorCompatible</H3>
<P>Visibility: public</p>
<P>Parameters: CReactor& rReactor</P>
<P>Return Type: bool</p>
<P>Classification: errorchecking</p>
<P>Determines if the Reactor passed in is derived from CReactor (TRUE).
</P>

<HR>

<H1><A NAME = "CLocationMonitor">CLocationMonitor</A></H1>

<P> SuperClasses: CEventMonitor </P>
<P> One to One associations: *CPointerPredicate : m_Predicate 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H3>m_pTLocation</H3>
<P>Visibility: private</P>
<P>Type: volatile T*</p>
<P>
Points to the location monitored. This location is
assumed to be changing asynchronously to the 
execution of the thread which monitors the location.
Note that the pointer can point to any type which can be
accepted by the predicate.   For the predefined predicates:
CChangedPredicate:        Requiires operator== be implemented fo rT
                                                        CopyConstruction
CMaksedValuePredicate Requires:   operator&,
                                                          operator==
                                                          Copy construction:
CisValuePredicate Require:     opreator==
                                                CopyConstruction
</P>

<H2>Operations on  CLocationMonitor</H2>

<H3>  ChangePredicate</H3>
<P>Visibility: public</p>
<P>Parameters: LocationMonPred& newloc</P>
<P>Return Type: void</p>
<P>Classification: Mutator.</p>
<P>Associates a new predicate with the 
location monitor.</P>
<H3>virtual   operator()</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: CEventMonitor::results</p>
<P>Classification: behavior override.</p>
<P>Reads the current value of the location and passes it to the predicate.
Returns:
1. Occured - if the predicate returned TRUE
2. TimedOut - if the wait time for this event timedout.
3. Error         - If the predicate threw an exception.</P>
<H3>  ChangeLocation</H3>
<P>Visibility: public</p>
<P>Parameters: T* pNewLocation</P>
<P>Return Type: void</p>
<P>Classification: Mutator</p>
<P>Changes the location monitored.</P>
<H3>virtual   DescribeSelf</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: string</p>
<P>Classification: Selector</p>
<P>Returns a string which describes the monitor.  Inlcudes:
1. CEventMonitor::DescribeSelf
2. Dumps of thte pointer value,
3.  m_Predicate.DescribeSelf()
</P>
<H3>virtual   isReactorCompatible</H3>
<P>Visibility: public</p>
<P>Parameters: CReactor& rReactor</P>
<P>Return Type: bool</p>
<P>Classification: Override.</p>
<P>Returns TRUE if the Reactor passed in is a 
valid reactor for location monitors (is an object
descended from CLocationReactor.</P>

<HR>

<H1><A NAME = "CPointerPredicate">CPointerPredicate</A></H1>

<P> SuperClasses: CRegisteredObject </P>
<P> One to One associations: 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H2>Operations on  CPointerPredicate</H2>

<H3>virtual   operator()</H3>
<P>Visibility: public</p>
<P>Parameters: T newValue</P>
<P>Return Type: bool</p>
<P>Classification: </p>
<P>Called to evaluate a value by a 
location  monitor.</P>

<HR>

<H1><A NAME = "CChangedPredicate">CChangedPredicate</A></H1>

<P> SuperClasses: *CPointerPredicate </P>
<P> One to One associations: 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H3>m_TOldValue</H3>
<P>Visibility: private</P>
<P>Type: T</p>
<P>

</P>

<H2>Operations on  CChangedPredicate</H2>

<H3>virtual   operator()</H3>
<P>Visibility: public</p>
<P>Parameters: T nValue</P>
<P>Return Type: bool</p>
<P>Classification: override.</p>
<P>Returns TRUE if the current value is different from the prior value.</P>
<H3>virtual   DescribeSelf</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: string</p>
<P>Classification: Override.</p>
<P>Describes self as:
CPointerPredicate::DescribeSelf()
Value to compare with.
</P>

<HR>

<H1><A NAME = "CMaskedValuePredicate">CMaskedValuePredicate</A></H1>

<P> SuperClasses: *CPointerPredicate </P>
<P> One to One associations: 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H3>m_TMask</H3>
<P>Visibility: private</P>
<P>Type: T</p>
<P>

</P>
<H3>m_TValue</H3>
<P>Visibility: private</P>
<P>Type: T</p>
<P>

</P>

<H2>Operations on  CMaskedValuePredicate</H2>

<H3>virtual   operator()</H3>
<P>Visibility: public</p>
<P>Parameters: T nValue</P>
<P>Return Type: bool</p>
<P>Classification: Override</p>
<P>Returns TRUE if nVal & m_TMask == m_TValue</P>
<H3>virtual   DescribeSelf</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: string</p>
<P>Classification: Override.</p>
<P>Returns a string which describes this object:
1. CPointerPredicate::DescribeSellf
2. Values of mask and value.

Note that T must implement an operator <<</P>

<HR>

<p>Last Modified: <!--webbot bot="Timestamp" startspan S-Type="EDITED"
S-Format="%A, %B %d, %Y" -->Tuesday, August 07, 2001<!--webbot bot="Timestamp"
I-CheckSum="50518" endspan -->
 <a href="mailto:fox@nscl.msu.edu">Ron Fox</a></p>

</body>

</html>
