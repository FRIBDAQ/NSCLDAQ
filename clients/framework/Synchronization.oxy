/*!
	\page Synchronization Guest event loop synchronization

The framework supports the existence of exactly one guest event loop. 
The event loop supported are:
- Tcl event loops.
- Tk Event loops.
- X11/Xt event loops

The first two synchronize differently than the X11/Xt event loops:

\section TCLSynchronization Tcl and Tk event loop synchronization

Most of the built in Tcl/Tk commands require no application synchronization. 
For example, setting a variable is an essentially atomic action and in most
cases does not involve interaction with other event threads.  User command
extensions are another matter however.  It is assumed that user command 
extensions may be used to control other event threads executing in the 
framework.  Therefore, user command extensions should be implemented as 
derived classes from CDAQTCLProcessor rather than from CTCLProcessor.  

The CDAQTCLProcessor jackets the call to CDAQTCLProcessor::operator()
 with a lock and unlock of the global serialization
mutex.  This forces the command's execution to be synchronized to the 
application.

There may be some application specific scripts which require syncronization
to the application (for example modification of related variables).  The
sync command can be added to the interpreter by instantiating and registering
an instance of a CTCLSynchronizeCommand.  The sync command allows a script
to be syncronized to the application. For example:

\code
sync {			;# Synchronized script begins.
  set var1  $thing
  set var2 [Relationship $var1]
}                       ;# Synchronized script ends.
\endcode

\section XTSynchronization X11/Xt Syncronization

The class CXtEventLoop provides a base class for implementing X11/Xt event 
loops in a synchronized manner.  Since Xt operates by associating arbitrary
application specific callbacks with events in the GUI, potentially and GUI
event can trigger code which must be synchronized.   

The CXtEventLoop encapsulates an event loop which brackets the dispatch of
a GUI event with synchronization calls.  The main loop for examples looks like:

\code
           while(1) {
              XtGetEvent()
              LockMutex()
              XtDispatchEvent();
              UnlockMutex();
             yield();                         // Let someone else run.
           }
 
\endcode

The call to LockMutex() enters application synchronized code.  After this call
the GUI event is dispatched to its application specific callback via the
call to  XtDispatchEvent().  On return, UnlockMutex() marks the end of 
syncronized execution.
*/