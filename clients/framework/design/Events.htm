<html>

<head>
<meta http-equiv="Content-Language" content="en-us">
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="GENERATOR" content="Microsoft FrontPage 4.0">
<meta name="ProgId" content="FrontPage.Editor.Document">
<title>Event Convenience Classes</title>
</head>

<body>

<h1>Event Convenience Classes:</h1>
<p>&nbsp;</p>
<p><map name="FPMap0">
<area href="#CThreadRecursiveMutex" shape="rect" coords="87, 86, 253, 202">
<area href="#CEventMonitor" shape="rect" coords="767, 20, 912, 109">
<area href="#CReactor" shape="rect" coords="625, 211, 787, 298">
<area href="#CEventThread" shape="rect" coords="770, 343, 867, 420">
<area href="#CEvent" shape="rect" coords="347, 305, 464, 444">
<area href="#CEventContainer" shape="rect" coords="78, 606, 198, 767">
<area href="#CEventContainer" shape="rect" coords="240, 554, 348, 634">
<area href="#CFileEvent" shape="rect" coords="382, 555, 470, 632">
<area href="#CBufferEvent" shape="rect" coords="519, 553, 612, 633">
<area href="#CServerConnectionEvent" shape="rect" coords="661, 554, 810, 632">
<area href="#CServerInstance" shape="rect" coords="594, 757, 717, 849">
<area href="#CSocket" shape="rect" coords="807, 713, 944, 1061">
<area href="#CClassifiedObjectRegistry" shape="rect" coords="371, 1001, 565, 1147">
<area href="#CApplication" shape="rect" coords="92, 1043, 197, 1121"></map><img border="0" src="images/Events4.gif" usemap="#FPMap0" width="1041" height="1195"></p>

<H1><A NAME = "CThreadRecursiveMutex">CThreadRecursiveMutex</A></H1>

<P> SuperClasses: </P>
<P> One to One associations: 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H3>m_tOwningThread</H3>
<P>Visibility: private</P>
<P>Type: daqthread_t</p>
<P>
This value is only valid if m_LockLevel > 0.
</P>
<H3>m_nLockLevel</H3>
<P>Visibility: private</P>
<P>Type: unsigned</p>
<P>
Each time a thread locks a mutex, the lock level increments actual final unlocking 
only occurs when the m_nLockLevel goes to zero.
</P>
<H3>m_MonitorMutex</H3>
<P>Visibility: private</P>
<P>Type: DAQThreadMutex</p>
<P>
member is used to force otherwise non-atomic members to execute atomically
with respect to the mutex represented by this object.
</P>

<H2>Operations on  CThreadRecursiveMutex</H2>

<H3>virtual   Lock</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: int</p>
<P>Classification: Override.</p>
<P>Locks the mutex.  Returns zero on success,
otherwise, errno has the reason for the failure.</P>
<H3>virtual   UnLock</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: int</p>
<P>Classification: Override</p>
<P>Unlocks a locked mutex.  If the mutex is already locked by us,
the lock level is decremented.  The mutex is not actually released
until the lock level goes to zero.  If we don't own the mutex, and
error results.
Returns zero on success,
otherwise, errno has the reason for the failure.</P>
<H3>virtual   TryLock</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: int</p>
<P>Classification: Override</p>
<P>Tries to lock the mutex. 
 If the mutex is owned by the running thread
the lock succeeds and the lock level is incremented.
If the lock level is zero, then trylock is done on the
base class and the result is returned.  On success, the
lock level is incremented.
Returns 0 on success, otherwise, errno has reason for
failure.</P>
<H3>virtual   isLocked</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: int</p>
<P>Classification: Override.</p>
<P>Returns non zero if someone, anyone (even self()) owns the mutex.
Note that the mutex is considered owned if the lock level is 
nonzero.  This should even be faster than the base class 
implementation.</P>

<HR>

<H1><A NAME = "CEvent">CEvent</A></H1>

<P> SuperClasses: CRegisteredObject </P>
<P> One to One associations: *CThreadRecursiveMutex : m_Synchronizer 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : CEventMonitor : -- 
  CReactor : -- 
  CEventThread : -- 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H3>m_fEnabled</H3>
<P>Visibility: private</P>
<P>Type: bool</p>
<P>
TRUE if the event is enabled and actively monitoriing
FALSE if the event is disabled or disable pending.
</P>

<H2>Operations on  CEvent</H2>

<H3>  OnEvent</H3>
<P>Visibility: protected</p>
<P>Parameters: CEventMonitor::result why</P>
<P>Return Type: void</p>
<P>Classification: Callback</p>
<P>Locks the global mutex, invokes the
Reactor's operator() and unlocks the global mutex.</P>
<H3>  ReplaceMonitor</H3>
<P>Visibility: public</p>
<P>Parameters: CEventMonitor& rEvent</P>
<P>Return Type: void</p>
<P>Classification: Mutator.</p>
<P>Replaces the event monitor with a different
object.  This allows the event to reconfigure
itself at run time.  In theory base class
events can completely reconfigure what they
point to.  In practice, this member is called
by constructors of descendants to set up
the initial event systesm.

 Note that it is an error to call this when the
EventThread is active.  If this is done a
CAlreadyRunning exception will be thrown.
</P>
<H3>  ReplaceReactor</H3>
<P>Visibility: public</p>
<P>Parameters: CReactor& rReactor</P>
<P>Return Type: void</p>
<P>Classification: Mutator</p>
<P>Called to replace the current instance of the event reactor.
This is typically called at construction time by subclasess
to set up the actual event framework.  Event reactors
may be modified when the event thread is active.</P>
<H3>  Enable</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: void</p>
<P>Classification: Mutator.</p>
<P>The Event thread is started in a synchronized way.
If the event thread is already running, this is a noop.
</P>
<H3>  Disable</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: void</p>
<P>Classification: Mutator.</p>
<P>The event thread is stopped.  This member
returns when the stop has been requested,
but not necessarily halted.  If the
event thread has been halted or has a halt
pending, this is a No-Op.</P>
<H3>virtual   DescribeSelf</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: string</p>
<P>Classification: Selector</p>
<P>Returns a description of this.
1. CNamedObject::DescribeSelf
2. Values of m_fEnabled.
3. Describe self from:
   Event monitor
   Event reactor,
   

</P>

<HR>

<H1><A NAME = "CEventMonitor">CEventMonitor</A></H1>

<P> SuperClasses: CRegisteredObject </P>
<P> One to One associations: 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H3>m_tvTimeout</H3>
<P>Visibility: private</P>
<P>Type: timeval</p>
<P>
contains the timeout if timeouts are enabled else indeterminate.
</P>
<H3>m_fTimedWait</H3>
<P>Visibility: private</P>
<P>Type: bool</p>
<P>
if TRUE, waits for events are timed,
else they are determined by the timeout.
</P>

<H2>Operations on  CEventMonitor</H2>

<H3>virtual   operator()</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: CEventMonitor::result</p>
<P>Classification: Interface</p>
<P>Monitor for the occurance of an event.
Concrete classes must implement this.
Return values are from the enum:

CEventMonitor::result:

Occured   - The event happened.
TimedOut -  The event monitor supports timeouts
                    and the timeout fired.
Error         -  An error condition was encountered
                   waiting for the event.
</P>
<H3>virtual   isReactorCompatible</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: bool</p>
<P>Classification: Interface</p>
<P>Determines if a reactor can be applied to
an event monitor.  That is if a reactor is of
a type which can successfully interact with
an event monitor.  This must be implemented
by the concrete classes themselves.</P>
<H3>virtual   setTimeout</H3>
<P>Visibility: public</p>
<P>Parameters: int nTimeout=FOREVER</P>
<P>Return Type: void</p>
<P>Classification: mutator</p>
<P>Sets the timeout.  The length of the timeout is
determined by the parameter in ms..  Special values:

0   - Poll (return instantly).
FOREVER - Block until event.
</P>

<HR>

<H1><A NAME = "CReactor">CReactor</A></H1>

<P> SuperClasses: CRegisteredObject </P>
<P> One to One associations: 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H2>Operations on  CReactor</H2>

<H3>virtual   operator()</H3>
<P>Visibility: public</p>
<P>Parameters: CEventMonitor& rMonitor, CEventMonitor::result Reason</P>
<P>Return Type: void</p>
<P>Classification: Interface Definition</p>
<P>This method is called in response ot an event
from an event monitor on which this reactor
has been established.  The Reactor provides 
application specific procesing of the event.</P>
<H3>virtual   isMonitorCompatible</H3>
<P>Visibility: public</p>
<P>Parameters: CEventMonirtor& rMonitor</P>
<P>Return Type: BOOL</p>
<P>Classification: interface.</p>
<P>Determines if the monitor passed in
is compatible with us.   Base class
default functionality is to return TRUE.</P>

<HR>

<H1><A NAME = "CEventThread">CEventThread</A></H1>

<P> SuperClasses: </P>
<P> One to One associations: *CEvent : -- 
  CEventMonitor : -- 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H3>m_fStopSoon</H3>
<P>Visibility: private</P>
<P>Type: BOOL</p>
<P>
When set, at the next opportunity, the 
event thread will exit.  Note that the
thread object will not be destroyed.

</P>
<H3>m_fRunning</H3>
<P>Visibility: private</P>
<P>Type: BOOL</p>
<P>
TRUE if the thread is already running
FALSE otherwise.
</P>

<H2>Operations on  CEventThread</H2>

<H3>  Start</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: void</p>
<P>Classification: Mutator.</p>
<P>Schedules the event thread for
execution. Note that if the thread is
already executing , this will
throw a CAlreadyRunning exception.</P>
<H3>  Stop</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: void</p>
<P>Classification: Mutator.</p>
<P>Requests the thread to stop execution
by setting m_fStopSoon  The
thread will exit as soon as it can
notice that it should.  If an event fires
with m_fStopSoon set, it will not be dispatched.
If the thread is not running, then this member throws:

CNotRunning</P>

<HR>

<H1><A NAME = "CEventContainer">CEventContainer</A></H1>

<P> SuperClasses: CRegisteredObject </P>
<P> One to One associations: 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H2>Operations on  CEventContainer</H2>

<H3>  AddEvent</H3>
<P>Visibility: public</p>
<P>Parameters: CEvent& rEvent</P>
<P>Return Type: CEventContainer::iterator</p>
<P>Classification: mutator</p>
<P>Adds an event to the container.
The state of the event is not changed.
It is up to the caller to enable/disable the
event.  In most physics applications,
events remain enabled once created
in any event.
Exception to this: servers.</P>
<H3>  RemoveEvent</H3>
<P>Visibility: public</p>
<P>Parameters: const string& rName</P>
<P>Return Type: void</p>
<P>Classification: Mutator</p>
<P>Removes an event given it's name.
If the event does not exist in the container,
throws CNoSuchObject.</P>
<H3>  RemoveEvent</H3>
<P>Visibility: public</p>
<P>Parameters: CEventContainer::iter p</P>
<P>Return Type: void</p>
<P>Classification: Mutator.</p>
<P>Removes an event from the container
given an iterator.  If the iterator is end()
CNoSuchObject is thrown.</P>
<H3>  FindEvent</H3>
<P>Visibility: public</p>
<P>Parameters: const string& rName</P>
<P>Return Type: CEventContainer::iterator</p>
<P>Classification: Selector.</p>
<P>Locates an event given it's name.
If the event is not found, endEvents() is
returned.</P>
<H3>  FindEvent</H3>
<P>Visibility: public</p>
<P>Parameters: EventMatchPredicate Predicate</P>
<P>Return Type: CEventContainer::iterator</p>
<P>Classification: Selector</p>
<P>Returns an event iterator which points to
a selected event.  The event is the first one
in iteration order to match an EventMatchPredicate
EventMatchPredicates are function objects which
implement: 
bool operator()(CEvent& rEvent)

If no event causes the predicate to return TRUE,
endEvents() is returned.</P>
<H3>  beginEvents</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: CEventContainer::iterator</p>
<P>Classification: </p>
<P>Returns an iterator pointing towards the 
'first' item in m_Events.</P>
<H3>  endEvents</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: CEventContainer::iterator</p>
<P>Classification: Selector</p>
<P>Returns an iterator suitable for 
ending iteration through the
container e.g.:
CEventContainer::iterator p = cont.beginEvents();
for(;p!= cont.endEvents(); p++) {
   // do stuff on *p.
}</P>
<H3>  EnableEvents</H3>
<P>Visibility: public</p>
<P>Parameters: EventMatchPredicate pred=MatchAll</P>
<P>Return Type: void</p>
<P>Classification: Mutator</p>
<P>Enables execution of all 
events which match the predicate.</P>
<H3>  DisableEvents</H3>
<P>Visibility: public</p>
<P>Parameters: EventMatchPredicate pred=MatchAll</P>
<P>Return Type: void</p>
<P>Classification: mutator</p>
<P>Disables all events which match the predicate.</P>
<H3>virtual   DescribeSelf</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: string&</p>
<P>Classification: Selector</p>
<P>Returns a string which defines the event container.  
The container describes all events it
contains.</P>

<HR>

<H1><A NAME = "CApplication">CApplication</A></H1>

<P> SuperClasses: CRegisteredObject </P>
<P> One to One associations: CClassifiedObjectRegistry : m_ObjectRegistry 
  *CEventContainer : -- 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H3>m_Instance</H3>
<P>Visibility: private</P>
<P>Type: CApplication*</p>
<P>
Static member data:
If an application instance has been created,
this points to it, otherwise it is null.
</P>

<H2>Operations on  CApplication</H2>

<H3> static  GetInstance</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: CApplication*</p>
<P>Classification: Selector</p>
<P>Returns the application instance.
(m_Instance).</P>
<H3>virtual   DescribeSelf</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: string</p>
<P>Classification: Selector</p>
<P>Describes the application.
This is done by calling CNamedObject::DescribeSelf
then dumping the event container and the object registry in that
order.
</P>

<HR>

<H1><A NAME = "CLocationEvent">CLocationEvent</A></H1>

<P> SuperClasses: *CEvent </P>
<P> One to One associations: 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H2>Operations on  CLocationEvent</H2>

<H3>virtual   operator()</H3>
<P>Visibility: public</p>
<P>Parameters: CEventMonitor::result why, T& CurrentValue</P>
<P>Return Type: void</p>
<P>Classification: Interface.</p>
<P>Called in response to a location monitor event.
</P>

<HR>

<H1><A NAME = "CFileEvent">CFileEvent</A></H1>

<P> SuperClasses: *CEvent </P>
<P> One to One associations: 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H2>Operations on  CFileEvent</H2>

<H3>virtual   operator()</H3>
<P>Visibility: public</p>
<P>Parameters: CEventMonitor::result why, int fd, int EventMask</P>
<P>Return Type: void</p>
<P>Classification: Interface</p>
<P>Provides an interface for application
specific processing of file events.
The EventMask describes the state of
the fd and consists of a mask of zero or more:

FD_READABLE  - File descriptor can be read
FD_WRITABLE  - File descriptor can be written
FD_EXCEPTION - File descriptor has an exceptional
                              condition set.

</P>

<HR>

<H1><A NAME = "CBufferEvent">CBufferEvent</A></H1>

<P> SuperClasses: *CEvent </P>
<P> One to One associations: 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H2>Operations on  CBufferEvent</H2>

<H3>virtual   operator()</H3>
<P>Visibility: public</p>
<P>Parameters: CEventMonitor::result why, CDAQBuffer& rBuffer</P>
<P>Return Type: void</p>
<P>Classification: interface</p>
<P>Provides an interface on which to supply application
specific behavior when a Spectrodaq buffer is 
received.  </P>

<HR>

<H1><A NAME = "CServerConnectionEvent">CServerConnectionEvent</A></H1>

<P> SuperClasses: *CEvent </P>
<P> One to One associations: CSocket : m_ConnectionSocket 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H3>m_ReferenceInstance</H3>
<P>Visibility: private</P>
<P>Type: CServerInstance</p>
<P>
This member is cloned to produce a server instance
executing on a connection.
</P>

<H2>Operations on  CServerConnectionEvent</H2>

<H3>virtual   operator()</H3>
<P>Visibility: public</p>
<P>Parameters: CEventMonitor::result why, CSocket& Listener, CSocket* Server</P>
<P>Return Type: bool</p>
<P>Classification: Default functionality.</p>
<P>operator() is supposed to determine if a 
connection request to the server should be
honored.  The default functionality is to return
TRUE indicating that all connection requests are
valid.</P>

<HR>

<H1><A NAME = "CServerInstance">CServerInstance</A></H1>

<P> SuperClasses: CFileEvent </P>
<P> One to One associations: CSocket : m_ServerSocket 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H2>Operations on  CServerInstance</H2>

<H3>virtual   OnStartup</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: BOOL</p>
<P>Classification: Iniitializer</p>
<P>Called after a particular instance has
been created to provide application
specific post connection functionality.
If FALSE is returned, this is considered a
late rejection of the connection (perhaps
as a result of an invalid username/password
interaction on the socket).
  Default functionality is a no-op returning TRUE.
</P>
<H3>virtual   clone</H3>
<P>Visibility: public</p>
<P>Parameters: CSocket& rSocket</P>
<P>Return Type: CServerInstance*</p>
<P>Classification: Interface:virtual construction</p>
<P>Provides an interface for cloning the 
reference instance and associating it
with a server socket.  Returns a pointer
to a new server instance of this type
</P>

<HR>

<H1><A NAME = "CClassifiedObjectRegistry">CClassifiedObjectRegistry</A></H1>

<P> SuperClasses: </P>
<P> One to One associations: 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H2>Operations on  CClassifiedObjectRegistry</H2>

<H3>  CreateRegistry</H3>
<P>Visibility: public</p>
<P>Parameters: const string& RegistryName</P>
<P>Return Type: void</p>
<P>Classification: Mutator</p>
<P>Creates a new registry. It is not an error
to create a registry which already exists.
If this is attempted, it is a no-op.</P>
<H3>  DeleteRegistry</H3>
<P>Visibility: public</p>
<P>Parameters: const string& RegistryName</P>
<P>Return Type: void</p>
<P>Classification: Mutator</p>
<P>Delete an existing registry. Any registry entries
are destroyed, however the objects they point to
are not.
Attempts to destroy an nonexsitent registry
result in a NoSuchObject exception.</P>
<H3>virtual   Add</H3>
<P>Visibility: public</p>
<P>Parameters: const string& RegistryName, CNamedObject& rObject</P>
<P>Return Type: void</p>
<P>Classification: base class mutator.</p>
<P>Adds an item to a registry.
If the item already exists in that registry,
a DuplicateName exception is thrown.
If the registry does not exist a 
NoSuchObject exception is thrown.</P>
<H3>virtual   Remove</H3>
<P>Visibility: public</p>
<P>Parameters: const string& RegistryName, CNamedObject& Object</P>
<P>Return Type: void</p>
<P>Classification: base class mutator</p>
<P>The named object is removed from the designated registry.
If the object does not exist, or the registry does not exist,
a NoSuchObject exception is thrown. The name embedded
in the exception differentiates between these two cases.
</P>
<H3>  Find</H3>
<P>Visibility: public</p>
<P>Parameters: const string& RegistryName, const string& ObjectName</P>
<P>Return Type: ObjectRegistryIterator</p>
<P>Classification: Selector</p>
<P>Locates an object in a specific registry.
If the registry or object don't exist a
NoSuchObject exception is thrown.
</P>
<H3>  Find</H3>
<P>Visibility: public</p>
<P>Parameters: const string& ObjectName</P>
<P>Return Type: CRefcountedPtr<ObjectList></p>
<P>Classification: Sellector</p>
<P>Returns a referece counted pointer to
a dynamically allocated list of Objects which
match the name requested.
ObjectList is a typedef for:
list<CNamedObject*>
The list is drawn from all of the registries.
If no registries contain the requested name,
an empty list is returned.</P>
<H3>  beginregistry</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: RegistryIterator</p>
<P>Classification: Selector</p>
<P>Returns an iterator into the registries which
are contained by this object.  Note that iteratiing
will return registries... that is RegistryIterator is a
typedef for:

map<string,CObjectRegistry>::iterator</P>
<H3>  endregistry</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: RegistryIterator</p>
<P>Classification: Selector</p>
<P>Returns a registry iterator suitable for determining
when iteration has been completed
(e.g. while(p != coreg.endregistry()) {...
  p++;
}</P>
<H3>virtual   DescribeSelf</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: string</p>
<P>Classification: Selector</p>
<P>Descirbes self.  This produces a string of the form:

CNamedObject::DescibeSelf()
"  Registries defined: "  List of registries
"     Registry " <name>"  Contains:   <- for all registries.
          Registry::DescribeSelf</P>

<HR>

<H1><A NAME = "CSocket">CSocket</A></H1>

<P> SuperClasses: </P>
<P> One to One associations: 
</P>
<P> One to Many associations:  
</P>
<P> Aggregate classes (1:1)  : 
</P>
<P> Aggregate classes (1:*)  : 

</P>

<H2>Class Attributes</H2>

<H3>m_Fd</H3>
<P>Visibility: private</P>
<P>Type: int</p>
<P>
A CSocket is create by construction.
This member variable contains the
file descriptor associated with the socket.

</P>
<H3>m_State</H3>
<P>Visibility: private</P>
<P>Type: CSocket::State</p>
<P>
Describes the current state of the socket.
This is taken from the enum:
CSocket::State and can be:
Disconnected  - The socket is not connected to anything.
Bound              - The socket is a server socket which is
                           not connected, but has been bound to
                           a service port.
Listening           - The socket is a server port which is
                            listening and can therefore accept
                            connections
Connected        - The socket is either a client or a 
                            server instance and is connected
                            to it's counterpart.

</P>

<H2>Operations on  CSocket</H2>

<H3>  Connect</H3>
<P>Visibility: public</p>
<P>Parameters: const string& host, const string& service</P>
<P>Return Type: void</p>
<P>Classification: Connection Control</p>
<P>Indicates that the socket will be used
as a client socket and attempts to connect it
to a server. 
The address of the server can be
passed in either in IP address or
IP name textual format.  Similarly,
the port can be passed in as a textual
port name (in /etc/services) or a port number.

Exceptions which can be thrown:
CTCPBadSocketState -- m_State was not Disconnected
CTCPNoSuchHost       - Host not in DNS or nonexistent.
CTCPNoSuchService  - Named service does not translate.
CTCPConnectionFailed- Connection refused by remote host.


On Success m_State --> Connected</P>
<H3>  Bind</H3>
<P>Visibility: public</p>
<P>Parameters: const string& service</P>
<P>Return Type: void</p>
<P>Classification: ConnectionControl</p>
<P>Indicates that the socket will be used
as a server listener socket, and binds it
to a service port.  The service can be
provided either as a numerical string
or as a string translated via getservbyname().

The following exceptions can be thrown:

CTCPBadSocketState   - m_State != Disconnected
CTCPNoSuchService    - getservbyname() failed and
                                        service string was not numeric.

On success, m_State --> Bound</P>
<H3>  Listen</H3>
<P>Visibility: public</p>
<P>Parameters: unsigned int nBacklog=5</P>
<P>Return Type: void</p>
<P>Classification: Connection Control</p>
<P>Indicates that the specified server 
listener socket is ready to listen
for connections. 

The Following exceptions can be 
thrown:

CTCPBadSocketState - m_State != Bound

On success, m_State --> Listening</P>
<H3>  Accept</H3>
<P>Visibility: public</p>
<P>Parameters: string& client</P>
<P>Return Type: CSocket* </p>
<P>Classification: Connection Control</p>
<P>This member function can be called on 
a server socket.  The calling thread is blocked
until a connection request is received.  At that
time, the connection is accepted (granted),
and a new CSocket is created in the Connected
state.  The new CSocket represents a Server
Instance socket, communication along that
socket can take place immediately and will
represent communication with the client.

Exceptions which can be thrown:
CTCPBadSocketState -- m_State != Listening

Side effects:

The client parameter is 
written with a string representing the
hostname of the client or the IP address
if the hostname can not be determined.

The socket created is created via new, therefore 
it is the responsibility of the caller to delete it.</P>
<H3>  Shutdown</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: void</p>
<P>Classification: Connection Control</p>
<P>  Shuts down a connection to a remote system.
Unlike shutdown(2) this function does not support
selectively shutting down reads or writes.  Both are
unconditionally shutdown.
  Note that the destructor will automatically call Shutdown
if necessary.

Exceptions:
CTCPBadSocketState  -- m_State != Connected.</P>
<H3>  Read</H3>
<P>Visibility: public</p>
<P>Parameters: void* pBuffer, size_t nBytes</P>
<P>Return Type: int</p>
<P>Classification: IO initiator</p>
<P>Performs a read on the socket.  The read will transfer
all of the bytes currently waiting in the socket buffers
or block until data is avaialble.  The return valiue will
be the number of bytes transferred.  If the connection
is lost, CTCPConnectionLost will be thrown.</P>
<H3>  Write</H3>
<P>Visibility: public</p>
<P>Parameters: void* pBuffer, size_t nBytes</P>
<P>Return Type: int</p>
<P>Classification: IO Initiator.</p>
<P>Writes data to the socket.  Note that
this member will block as needed until
all data has been queued to the socket buffers.
This may require multiple write(2) function calls
if the amount of data to be written is larger than
the socket's blocking factor.  Note that if the connection
is lost during the write, CTCPConnectionLost will be thrown.</P>
<H3>  getPeer</H3>
<P>Visibility: public</p>
<P>Parameters: int& short, string& peer</P>
<P>Return Type: void</p>
<P>Classification: Selector.</p>
<P>Returns information about who a socket
is connected to.  If the socket is not
connected, CTCPBadSocketState is thrown.
If possible, the peername parameter is returned
as a string containing the DNS name of the
peer. If the DNS lookup fails, the IP address
is converted into dotted form.</P>
<H3>  OOBInline</H3>
<P>Visibility: public</p>
<P>Parameters: bool State=TRUE</P>
<P>Return Type: void</p>
<P>Classification: Configuration</p>
<P>Allows Out Of Band (OOB) data to be inserted in line with buffered data.
OOB data is data with a higher delivery priority than 'normal data'. If this
flag is not set, then by default OOB data must be read through normal
socket interface functions by specifying it in the recv flags parameter.
If this flag is set, oob data is queue at the front of the data to be read
with the Read member.
  If the socket is not connected, then the CTCPBadSocketState exception
is thrown.</P>
<H3>  isOOBInline</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: bool</p>
<P>Classification: Options</p>
<P>Returns TRUE if OOBinline is set
FALSE otherwise.  Note that the underlying
socket state is inquired, not some saved internal
state.
  If not connected, CTCPBadSocketState is returned.</P>
<H3>  setRcvLowWaterMark</H3>
<P>Visibility: public</p>
<P>Parameters: size_t nBytes</P>
<P>Return Type: void</p>
<P>Classification: Configuration</p>
<P>Sets the Receive low water mark for the socket.
This is the number of bytes received by the
protocol before any is made available to the
user.  Note that some systems do not allow 
this to be changed.  It is not an error at this
level to attempt to do so, however you will need to 
call getRcvlowWaterMark to be sure the change was
actually made.

Throws CTCPBadSocketState if not connected.</P>
<H3>  getRcvLowWaterMark</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: size_t</p>
<P>Classification: </p>
<P>Returns the size of the current receive low water mark.
See setRcvLowWaterMark for information about what this
parameter does.  Note that the value returned is inquired from
the socket rather than stored in internal state.</P>
<H3>  setSndLowWaterMark</H3>
<P>Visibility: public</p>
<P>Parameters: size_t nBytes</P>
<P>Return Type: void</p>
<P>Classification: configuration</p>
<P>Sets the new value of the Send Low water mark.
This controls the number of bytes which must be written
before transferring data to the protocol layers for transmission.
Note that some systems don't allow this value to be changed.
It is not an error to attempt to change this value on those systems,
however you should use getSndLowWaterMark to determine the
actual value negotiated by the system,</P>
<H3>  getSndLowWaterMark</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: size_t</p>
<P>Classification: Configuration</p>
<P>Return the value of the current Send Low Water Mark
Set setSndLowWaterMarrk for more information.</P>
<H3>  setRcvTimeout</H3>
<P>Visibility: public</p>
<P>Parameters: unsigned int nMs</P>
<P>Return Type: void</p>
<P>Classification: Configuration</p>
<P>Set the protocol receive timeouts.  Note that in some systems,
these are not settable.  However it is not an error to attempt to do so.</P>
<H3>  getRcvTimeout</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: unsigned int</p>
<P>Classification: Configuration</p>
<P>Retrieve the protocol receive timeout.</P>
<H3>  setSndTimeout</H3>
<P>Visibility: public</p>
<P>Parameters: unsigned int nMs</P>
<P>Return Type: void</p>
<P>Classification: Configuration</p>
<P>Set the number of milliseconds in the send timeout.
Some systems may not allow this to be set, however it is not
an error to try.</P>
<H3>  getSndTimeout</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: unsigned int</p>
<P>Classification: Configuration</p>
<P>Returns the current send timeout in ms.

</P>
<H3>  Debug</H3>
<P>Visibility: public</p>
<P>Parameters: bool fState=TRUE</P>
<P>Return Type: void</p>
<P>Classification: Configuration</p>
<P>Attempts to turn on Socket debugging.
To support this. The user must have effective
UID = 0.  If the socket is not connected,
the CTCPBadSocketState exception is thrown.
If there are other errors (e.g. because the user
doesn't have eff UID=0), then the appropriate
CErrnoException object is thrown.</P>
<H3>  isDebug</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: bool</p>
<P>Classification: Configuration</p>
<P>Returns TRUE if socket debugging is
turned on and False otherwise.  If the socket
is not connected, CTCPBadSocketState is
thrown.</P>
<H3>  SetNotRoutable</H3>
<P>Visibility: public</p>
<P>Parameters: bool fRoutable=TRUE</P>
<P>Return Type: void</p>
<P>Classification: Configuration</p>
<P>Allows the caller to control the routability of messages
sent on the socket.  If set, messages will not
be sent through a gateway.
Note:
 The socket need not be connected. Presumably,
if this flag is set prior to Connect on a client socket
the client will be unable to connect outside the local
subnet, and if set prior to Bind for a server, the server will
be unable to accept connections from outside the subnet.
</P>
<H3>  isNotRoutable</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: bool</p>
<P>Classification: Configuration</p>
<P>Returns the state of the routability flag.</P>
<H3>  setSndBufSize</H3>
<P>Visibility: public</p>
<P>Parameters: size_t nBufferSize</P>
<P>Return Type: void</p>
<P>Classification: Configuration</p>
<P>Sets the socket send buffer size.  This 
has to do with how many bytes can be 
sent in a single write(2) service call. Messages
larger than that must be segmented into multiple
write(2) calls.  Note howerver that 
CTCPSocket::Write automatically handles
any necessary segmentation.
  If the socket is not connected, throws:
CTCPBadSocketState

</P>
<H3>  getSndBufSize</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: size_t</p>
<P>Classification: Configuration</p>
<P>Returns the number of bytes that can be
written in a single write(2) call.
</P>
<H3>  setRcvBufSize</H3>
<P>Visibility: public</p>
<P>Parameters: size_t nBytes</P>
<P>Return Type: void</p>
<P>Classification: Configuration</p>
<P>Sets the maximum number of bytes which can be received in a single
read(2) operation.  Note that CTCPSocket::Read does >NOT< 
automatically segment or else you may block when you'd like
to believe that a message has been received.

If the socket is not connected, throws CTCPBadSocketState
</P>
<H3>  getRcvBufSize</H3>
<P>Visibility: public</p>
<P>Parameters: </P>
<P>Return Type: size_t</p>
<P>Classification: Configuration</p>
<P>Returns the maximum number of bytes which can be 
recieved in a single read(2) call.</P>
<H3>  setLinger</H3>
<P>Visibility: public</p>
<P>Parameters: bool lOn, int nLingerSeconds</P>
<P>Return Type: void</p>
<P>Classification: Configuration</p>
<P>Sets the socket linger parameters.  Linger properties
govern the way a shutdown, operates.  Note that
object destruction which requires a shutdown implicitly
turns off linger.  
  If linger is enabled, then the close will block until
all pending data has been successfully sent or until the
linger timerout is exceeded.  If the socket is not
connected, throws a CTCPBadState exception.

</P>
<H3>  getLinger</H3>
<P>Visibility: public</p>
<P>Parameters: bool& isLingering, int& nLingerSeconds</P>
<P>Return Type: void</p>
<P>Classification: Configuration</p>
<P>Retrieve the linger parameters.</P>

<HR>

</body>

</html>
