

\begin{Desc}
\item[Author: ]\par
Ron Fox , Eric Kasten (Spectrodaq) , Jason Venema\end{Desc}
\section{Introduction}\label{Intro}


This documentation describes an application framework which simplifies the process of writing clients to spectrodaq, the NSCL data acquisition and distribution system. This set of web pages provides general documenation as well as reference information for this class library.

\section{Getting Started}\label{Starting}


To write programs under the client application framework you will need to know:\begin{enumerate}
\item 
How to {\bf subclass the DAQROCNode class.} {\rm (p.\,\pageref{Writing})}\item 
How to  {\bf Write a Makefile} {\rm (p.\,\pageref{Makefile})}  to build your program.\end{enumerate}
\subsection{Writing a subclass of DAQROCNode}\label{Writing}


DAQROCNode (DAQ Readout Controller Node) is the base class from which all spectrodaq clients are derived.  

\footnotesize\begin{verbatim}#include <iostream.h>
#include <spectrodaq.h>
#include <SpectroFramework.h>

class MyClass : public DAQROCNode
{
protected:
  int operator()(int argc, char** pargv);
};

int
MyClass::operator()(int argc, char** pargv)
{
  cout << "Hello World." << endl;
}

MyClass theApp;
\end{verbatim}\normalsize 
 is a minimal sample Spectrodaq client which uses the framework.

This example includes the following headers:\begin{CompactItemize}
\item 
$<$spectrodaq.h$>$ - header which defines the spectrodaq client interface classes.\item 
$<${\bf Spectro\-Framework.h}$>$ - header which defines the classes in the application framwork.\item 
$<$iostream.h$>$ - Which defines classes in the C++ I/O subsystem.\end{CompactItemize}
The bulk of the program is the definition of a class: My\-Class which extends DAQROCNode, definining and implementing the operator() member function. This member function is called when Spectrodaq has initialized and is ready to run application code. The implementation of that function simply puts the message \char`\"{}Hello World\char`\"{} to stdout.

The final line of the example declares an instance of My\-Class. This instance is the application object which will actually be run by spectrodaq.

This example shows the general pattern which you must follow to write Spectrodaq clients:\begin{CompactItemize}
\item 
Include the necessary headers ($<$spectrodaq.h$>$ $<${\bf Spectro\-Framework.h}$>$ at a minimum.\item 
Write a subclass to DAQROCNode which defines the behavior of your application. The entry point to the program will be the operator() member function which has the same signature as the main function. be sure not to provide an implementation of {\bf main}() {\rm (p.\,\pageref{FdMonitorTest_8cpp_a1})} as that's provided by the spectrodaq client libraries.\item 
Declare an instance of this class to provide spectrodaq with an application object to run.\end{CompactItemize}
\subsection{Writing a Makefile for framework programs.}\label{Makefile}


Writing a Makefile to build your application requires:\begin{CompactItemize}
\item 
Obtaining the compilation and link flags needed by spectrodaq.\item 
Listing the dependencies between modules, and build rules needed to get from indenendent to dependent half of these dependencies.\end{CompactItemize}
For the example in  {\bf the previous section} {\rm (p.\,\pageref{Writing})}, the resulting Makefile might look like 

\footnotesize\begin{verbatim}SPECTRO_FLAGS=$(shell /opt/spectrodaq/bin/spectrodaq-conf --cflags)
SPECTRO_LDFLAGS=$(shell /opt/spectrodaq/bin/spectrodaq-conf --libs)

CXXFLAGS=$(SPECTRO_FLAGS) -I/opt/daq/Include -I/usr/X11/include
LDFLAGS = $(SPECTRO_LDFLAGS) -L /opt/daq/Lib -L/usr/X11/lib \
         -lEventFramework -ltk -ltcl -lm -lXm -lXt

minimal: minimal.o
        g++ -o minimal $< $(LDFLAGS)

minimal.o: minimal.cpp
        g++ -c $< $(CXXFLAGS) -ltcl 
\end{verbatim}\normalsize 
 The first four macro definitions group together the compilation and load flags needed by spectrodaq and the  framework into two macros CXXFLAGS (compile flags), and LDFLAGS (loader  flags).

Two dependencies describe how to build the object from the source, and the executable from the object. Note that it may also be wise to  include the -ggdb flag in LDFLAGS so that you can use the gdb debugger.

\section{General concepts.}\label{Concepts}


The following is a list of general concepts which are used by the event framework and should be understood.

\begin{CompactItemize}
\item 
{\bf Subclassing  a base class to extend or provide functionality.} {\rm (p.\,\pageref{Subclassing})}\item 
{\bf Object registries} {\rm (p.\,\pageref{Registration})} and object naming.\item 
{\bf Event driven programming.} {\rm (p.\,\pageref{EventDriven})}\item 
{\bf TCP/IP client/server programming} {\rm (p.\,\pageref{TCPIP})}  with sockets.\item 
The events which are understood by the application framework:\begin{enumerate}
\item 
{\bf Location monitors:} {\rm (p.\,\pageref{LocationMonitors})} Low latency monitoring of a volatile memory location.\item 
{\bf File descriptor events:} {\rm (p.\,\pageref{FileEvents})} Events which occur when a file descriptor is readable or writable or has some other special condition (exception) pending.\item 
{\bf Spectrodaq Buffer Events} {\rm (p.\,\pageref{BufferEvent})} Events which occur when a spectrodaq makes a buffer available to the application along a link.\item 
{\bf Server accept events:} {\rm (p.\,\pageref{ServerEvent})} Events which occur when a TCP/IP server receives a connection request from a client.\item 
{\bf Server Instance events:} {\rm (p.\,\pageref{SocketEvents})} Events which occur when an instance of a TCP/IP server connected to an active client receives a request from the client.\end{enumerate}
\item 
Guest event loops including:\begin{enumerate}
\item 
{\bf Synchronization of guest event loops} {\rm (p.\,\pageref{Synchronization})} with other framework code.\item 
{\bf Tcl/Tk guest event loops} {\rm (p.\,\pageref{TCLGuests})}\item 
{\bf X11/Xt guest event loops} {\rm (p.\,\pageref{XtGuests})}\end{enumerate}
\item 
{\bf The Configuration subsystem.} {\rm (p.\,\pageref{configsys})}\end{CompactItemize}
