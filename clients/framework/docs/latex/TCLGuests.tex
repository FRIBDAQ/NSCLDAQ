\section{TCL/Tk Guest event loops.}\label{TCLGuests}


The framework allows you to include either a TCL (non GUI script engine) or Tk (GUI based script engine) in your application. To do this you must:\begin{CompactItemize}
\item 
Design the set of command extensions your application needs.\item 
Write subclasses of {\bf CDAQTCLProcessor} {\rm (p.\,\pageref{classCDAQTCLProcessor})} which implement these commands.\item 
Write a subclass of either {\bf CTCLInterpreter\-Startup} {\rm (p.\,\pageref{classCTCLInterpreterStartup})} (non GUI script engine) or CTKInterpreterstartup (GUI script engine) which instantiates your command extensions and registers them with the interpreter.\item 
Instantiate your extension of the C$\ast$Interpreterstartup class to create and start an interpreter.\end{CompactItemize}
\section{Writing CDAQTCLProcessor extensions.}\label{TclCommandProcessors}


It is important that user written extensions to the Tcl/Tk command interpreter. This is done automatically by deriving your command extensions from  {\bf CDAQTCLProcessor} {\rm (p.\,\pageref{classCDAQTCLProcessor})}. There are two member functions which must be written:\begin{CompactItemize}
\item 
The constructor which determines the command keyword (or name).\item 
The function call operator (operator()), which gets control when the  command keyword has been recognized by the Tcl/Tk interpreter.\end{CompactItemize}
See {\bf CDAQTCLProcessor::CDAQTCLProcessor} {\rm (p.\,\pageref{classCDAQTCLProcessor_a0})} for the call signature of the base class constructor. The parameters are: \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
Command}]- A specification of the command (char$\ast$ or string\&). \item[{\em 
p\-Interp}]- A pointer to the interpreter object.\end{description}
\end{Desc}
The function call operator (operator()) is called when the command  registered by an object has been recognized. The parameters of this function are: \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
r\-Interpreter}]- A reference to the {\bf interpreter  	object} {\rm (p.\,\pageref{classCTCLInterpreter})} which invoked this command. The interpreter provides several facilities including subscriptexecution support, and parameter parsing utilities. \item[{\em 
r\-Result}]- A refereince to the interpreter's {\bf result 	object.} {\rm (p.\,\pageref{classCTCLResult})} The result object is used to return information from the command to the invoking script. In the event of an error, the error message associated with the error should be returned in the result object. \item[{\em 
argc}]- The number of words in the command (after the interpreter's round of substitutions). \item[{\em 
argv}]- A pointer to a list of pointers to the characters strings which represent the words of the command. Note that the 'first' of these is the command itself.\end{description}
\end{Desc}
The function call operator must return an int which is one of:\begin{CompactItemize}
\item 
TCL\_\-OK - The command completed successfully and script execution can continue\item 
TCL\_\-ERROR - The command failed, script execution should terminate unless the command was invoked within a catch command.\end{CompactItemize}
\section{Writing the interpreter startup functions}\label{TclInterpreters}


This section describes the member functions you may need to override when  deriving your command interpreter startup class (subclass of either {\bf CTCLInterpreter\-Startup} {\rm (p.\,\pageref{classCTCLInterpreterStartup})} or {\bf CTKInterpreter\-Startup} {\rm (p.\,\pageref{classCTKInterpreterStartup})}). The functions you may need to write are:\begin{CompactItemize}
\item 
{\bf On\-Initialize} {\rm (p.\,\pageref{classCInterpreterStartup_b0})} which is called to allow you a chance to process command line parameters and do other pre-interpreter startup initializations.\item 
{\bf which is called after the   Tcl/Tk interpreter has been created and initialized and is intended to be   the member in which you instantiate and register your command extensions.  $\backslash$section On\-Initialize  	On\-Initialize()} {\rm (p.\,\pageref{classCInterpreterStartup_b1})} member function.\end{CompactItemize}
This member function is called prior to the creation and initialization of the interpreter object. The parameters passed to this member are: \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
argc}]- Number of command line parameters with which to invoke the interpreter. \item[{\em 
argv}]- char$\ast$$\ast$ pointer to the list of pointers to the parameter strings.\end{description}
\end{Desc}
\subsection{The}\label{RegisterExtensions}
 {\bf Register\-Extensions()} {\rm (p.\,\pageref{classCInterpreterStartup_b1})} member function.

Once the interpreter has been created and initialized, the framework calls Register\-Extensions with no parameters. The interpreter can be retrieved via {\bf get\-Interpreter().} {\rm (p.\,\pageref{classCInterpreterStartup_a2})} In this function you should provide code to make instances of your command processors and register them with the interpreter. A normal tactic is to use new to  instantiate a processor, save the processor's pointer as member data which is deleted' by the destructor.

\section{Example application.}\label{TclExample}


The sample application in this section shows how to create a Tcl interpreter as a guest event loop. A simple Echo command is added which simply takes  command parameters and places them in the result.



\footnotesize\begin{verbatim}//
// Test program for the CTCLInterpreterStartup.
//   We start up a TCL interpreter in its own thread
//   and register the Echo command extension as a synchronized
//   extension.
//   The program should also understand the sync command.
//

#include <spectrodaq.h>
#include <iostream.h>
#include <CTCLInterpreterStartup.h>


#include <CDAQTCLProcessor.h>



class TCLExtension : public CDAQTCLProcessor
{

public:
  TCLExtension(CTCLInterpreter* pInterp);
  virtual int  operator() (CTCLInterpreter &rInterpreter, CTCLResult &rResult, 
                           int nArguments, char *pArguments[]);

};


TCLExtension::TCLExtension(CTCLInterpreter* pInterp) :
  CDAQTCLProcessor("Echo", pInterp)
{
}

int
TCLExtension::operator() (CTCLInterpreter &rInterpreter, CTCLResult &rResult, 
                          int nArguments, char *pArguments[])
{
  for(int i = 1; i < nArguments; i++) {
    rResult.AppendElement(pArguments[i]);
  }
  return TCL_OK;
}




class MyInterpThread : public CTCLInterpreterStartup
{
  TCLExtension* m_pCommand;
protected:
  virtual void  RegisterExtensions () {
    cerr << "Registering extensions\n";
    cerr.flush();
    m_pCommand = new TCLExtension(getInterpreter());
    m_pCommand->Register();
    cerr << "Registering base class extensions\n";
    cerr.flush();
    CTCLInterpreterStartup::RegisterExtensions();
    cerr << "Returning to TCL Main loop\n";
    cerr.flush();
  }
};

class App : public DAQROCNode
{
  virtual int  operator() (int argc, char **argv) {
    MyInterpThread Tcl;
    DAQThreadId tid = daq_dispatcher.Dispatch(Tcl);

    DAQStatus stat;
    Join(tid, &stat);
    cerr << "Tcl interpreter exited" << stat.GetStatusCode() << endl;
    return 0;
  }

};

App theApp;
\end{verbatim}\normalsize 


\section{example application}\label{TkExample}


This sample application is the same as the one shown in section Tcl\-Example, however a Tk interpreter is started up rather  than a Tcl interpreter. This provides the capability of a scripted GUI for the application.



\footnotesize\begin{verbatim}//
// Test program for the CTCLInterpreterStartup.
//   We start up a TCL interpreter in its own thread
//   and register the Echo command extension as a synchronized
//   extension.
//   The program should also understand the sync command.
//

#include <spectrodaq.h>
#include <iostream.h>
#include <CTKInterpreterStartup.h>


#include <CDAQTCLProcessor.h>



class TCLExtension : public CDAQTCLProcessor
{

public:
  TCLExtension(CTCLInterpreter* pInterp);
  virtual int  operator() (CTCLInterpreter &rInterpreter, CTCLResult &rResult, 
                           int nArguments, char *pArguments[]);

};


TCLExtension::TCLExtension(CTCLInterpreter* pInterp) :
  CDAQTCLProcessor("Echo", pInterp)
{
}

int
TCLExtension::operator() (CTCLInterpreter &rInterpreter, CTCLResult &rResult, 
                          int nArguments, char *pArguments[])
{
  for(int i = 1; i < nArguments; i++) {
    rResult.AppendElement(pArguments[i]);
  }
  return TCL_OK;
}




class MyInterpThread : public CTKInterpreterStartup
{
  TCLExtension* m_pCommand;
protected:
  virtual void  RegisterExtensions () {
    cerr << "Registering extensions\n";
    cerr.flush();
    m_pCommand = new TCLExtension(getInterpreter());
    m_pCommand->Register();
    cerr << "Registering base class extensions\n";
    cerr.flush();
    CTKInterpreterStartup::RegisterExtensions();
    cerr << "Returning to TCL Main loop\n";
    cerr.flush();
  }
};

class App : public DAQROCNode
{
  virtual int  operator() (int argc, char **argv) {
    MyInterpThread Tcl;
    DAQThreadId tid = daq_dispatcher.Dispatch(Tcl);

    DAQStatus stat;
    Join(tid, &stat);
    cerr << "Tcl interpreter exited" << stat.GetStatusCode() << endl;
    return 0;
  }

};

App theApp;
\end{verbatim}\normalsize 


