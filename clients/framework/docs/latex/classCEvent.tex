\section{CEvent  Class Reference}
\label{classCEvent}\index{CEvent@{CEvent}}
{\tt \#include $<$CEvent.h$>$}

Inheritance diagram for CEvent::\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=4.26829cm]{classCEvent}
\end{center}
\end{figure}
\subsection*{Public Methods}
\begin{CompactItemize}
\item 
{\bf CEvent} ({\bf CEvent\-Monitor} \&r\-Monitor, {\bf CReactor} \&r\-Reactor, bool Inform\-Timeouts=false, int n\-Timeout\-Ms=500)
\item 
{\bf CEvent} (const char $\ast$p\-Name, {\bf CEvent\-Monitor} \&r\-Monitor, {\bf CReactor} \&r\-Reactor, bool Inform\-Timeouts=false, int n\-Timeout\-Ms=500)
\item 
{\bf CEvent} (const string \&r\-Name, {\bf CEvent\-Monitor} \&r\-Monitor, {\bf CReactor} \&r\-Reactor, bool Inform\-Timeouts=false, int n\-Timeout\-Ms=500)
\item 
virtual {\bf $\sim$CEvent} ()
\item 
bool {\bf is\-Enabled} () const
\begin{CompactList}\small\item\em Return TRUE if the thread is enabled if not thread halt is pending.\item\end{CompactList}\item 
bool {\bf is\-Active} () const
\begin{CompactList}\small\item\em Return TRUE if the thread is running (active) (small timing hole).\item\end{CompactList}\item 
bool {\bf get\-Inform\-Timeout} () const
\begin{CompactList}\small\item\em Return TRUE if Reactor also catches timeouts.\item\end{CompactList}\item 
int {\bf get\-Ms\-Reactivity} () const
\begin{CompactList}\small\item\em Return the reactivity of the event to programmatic stimulus.\item\end{CompactList}\item 
{\bf CEvent\-Monitor} \& {\bf get\-Monitor} ()
\begin{CompactList}\small\item\em Allow manipulation of the event monitor:.\item\end{CompactList}\item 
{\bf CReactor} \& {\bf get\-Reactor} ()
\begin{CompactList}\small\item\em Allow manipulation of the event reactor:.\item\end{CompactList}\item 
DAQThread\-Id {\bf get\-Thread\-Id} () const
\begin{CompactList}\small\item\em Allow external manipulation of the thread:.\item\end{CompactList}\item 
void {\bf Enable} ()
\item 
void {\bf Disable} ()
\item 
void {\bf set\-Reactivity} (int n\-Ms)
\item 
void {\bf set\-Enable} (bool f\-Enable)
\item 
void {\bf React\-To\-Timeouts} (bool f\-React=true)
\item 
virtual string {\bf Describe\-Self} ()
\end{CompactItemize}
\subsection*{Protected Methods}
\begin{CompactItemize}
\item 
void {\bf set\-Active} (bool f\-Active)
\begin{CompactList}\small\item\em Set state of active flag.. implies thread is running.\item\end{CompactList}\item 
void {\bf set\-Tid} (const DAQThread\-Id Tid)
\begin{CompactList}\small\item\em Set Thread ID: implies you know a lot about the system.\item\end{CompactList}\item 
virtual void {\bf On\-Event} ({\bf CEvent\-Monitor::result} why)
\item 
void {\bf Schedule} ()
\item 
virtual int {\bf operator()} (int nargs, char $\ast$$\ast$pp\-Args)
\item 
virtual void {\bf Process\-Queues} ()
\item 
DAQStatus {\bf Join\-This} ()
\end{CompactItemize}
\subsection*{Private Methods}
\begin{CompactItemize}
\item 
{\bf CEvent} (const CEvent \&a\-CEvent)
\begin{CompactList}\small\item\em Copy Constructor - not allowed.\item\end{CompactList}\item 
CEvent \& {\bf operator=} (const CEvent \&a\-CEvent)
\begin{CompactList}\small\item\em Operator= Assignment Operator - not allowed.\item\end{CompactList}\item 
int {\bf operator==} (const CEvent \&a\-CEvent) const
\begin{CompactList}\small\item\em Operator== Equality Operator no point.\item\end{CompactList}\end{CompactItemize}
\subsection*{Private Attributes}
\begin{CompactItemize}
\item 
bool {\bf m\_\-f\-Enabled}
\begin{CompactList}\small\item\em Event enabled flag.\item\end{CompactList}\item 
bool {\bf m\_\-f\-Active}
\begin{CompactList}\small\item\em True if thread is active.\item\end{CompactList}\item 
bool {\bf m\_\-Inform\-Timeouts}
\begin{CompactList}\small\item\em Pass timeouts on to reactor.\item\end{CompactList}\item 
int {\bf m\_\-n\-Ms\-Reactivity}
\begin{CompactList}\small\item\em Reactivity to external events.\item\end{CompactList}\item 
{\bf CEvent\-Monitor} \& {\bf m\_\-r\-Monitor}
\begin{CompactList}\small\item\em Monitor which polls for event.\item\end{CompactList}\item 
{\bf CReactor} \& {\bf m\_\-r\-Reactor}
\begin{CompactList}\small\item\em Reactor to the event when it fires.\item\end{CompactList}\item 
DAQThread\-Id {\bf m\_\-Tid}
\begin{CompactList}\small\item\em spectrodaq thread identifier.\item\end{CompactList}\end{CompactItemize}


\subsection{Detailed Description}
Encapsulates event handling. Events consist of an event monitor which is responsible for determining when an event fires and a reactor which provides application specific handling of the event.  When enabled, the event will schedule a thread m\_\-Event\-Thread to process the event. The event thread contains code to repeatedly calll the monitor's operator(), lock the global mutex and call the reactor's operator(). The reactors provided with  classes derived from this are generally standardized to invoke Subclass virtual function which are specific to the event being managed.. 



Definition at line 331 of file CEvent.h.

\subsection{Constructor \& Destructor Documentation}
\index{CEvent@{CEvent}!CEvent@{CEvent}}
\index{CEvent@{CEvent}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}CEvent::CEvent ({\bf CEvent\-Monitor} \& {\em r\-Monitor}, {\bf CReactor} \& {\em r\-Reactor}, bool {\em Inform\-Timeouts} = false, int {\em n\-Timeout\-Ms} = 500)}\label{classCEvent_a0}


Construct an \char`\"{}anonymous\char`\"{} event object. Anonymous event objects have names like Event\-Thread(unique\_\-index). All Event objects will be registered in the \char`\"{}Event\char`\"{} registry of the application's global  object classified registry.\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
r\-Monitor}]- The monitor which notices events. \item[{\em 
r\-Reactor}]- The reactor which does stuff when an event fires. \item[{\em 
Inform\-Timeouts}][false] - Optional parameter which, if true, allows the Reactor to be called when the monitor times out. \item[{\em 
Enabled}][true] - Optional parameter which when true indicates that the constructor should begin execution of the Event monitoring thread. If false, a call to the Enable member is required to start execution. \item[{\em 
n\-Timeout\-Ms}]- The timeout in ms for the Event monitor. Timeouts are an essential part of the event thread. The thread can only react to externally generated attempts to Disable it after the Monitor returns. The timeout in ms therefore is a measure of the  reactiveness of the event to programmatic stimulus from other threads. For 'permanent' events, use a timeout of -1 which will cause the monitor to be configured to run without a timeout. NOTE:\begin{CompactItemize}
\item 
The Event runs as a separate thread in the process. Destruction implies an attempt to kill the thread and join with it and may therefore be a time consuming process if the thread is active with a long or  nonexistent timeout.\item 
All calls to the reactor are synchronized with the application  global mutex. \end{CompactItemize}
\end{description}
\end{Desc}


Definition at line 358 of file CEvent.cpp.

References CNamed\-Object::Append\-Class\-Info(), and Registry\-Name.\index{CEvent@{CEvent}!CEvent@{CEvent}}
\index{CEvent@{CEvent}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}CEvent::CEvent (const char $\ast$ {\em p\-Name}, {\bf CEvent\-Monitor} \& {\em r\-Monitor}, {\bf CReactor} \& {\em r\-Reactor}, bool {\em Inform\-Timeouts} = false, int {\em n\-Timeout\-Ms} = 500)}\label{classCEvent_a1}


Construct a named event object. See the previous overload of {\bf CEvent::CEvent} {\rm (p.\,\pageref{classCEvent_a0})} for most of the descriptive information. However:\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
p\-Name}]- the name of the event object.\end{description}
\end{Desc}
Throws:\begin{CompactItemize}
\item 
{\bf CDuplicate\-Name\-Exception} {\rm (p.\,\pageref{classCDuplicateNameException})} if there is already an Event derived object with this name. \end{CompactItemize}


Definition at line 384 of file CEvent.cpp.

References CNamed\-Object::Append\-Class\-Info(), and Registry\-Name.\index{CEvent@{CEvent}!CEvent@{CEvent}}
\index{CEvent@{CEvent}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}CEvent::CEvent (const string \& {\em r\-Name}, {\bf CEvent\-Monitor} \& {\em r\-Monitor}, {\bf CReactor} \& {\em r\-Reactor}, bool {\em Inform\-Timeouts} = false, int {\em n\-Timeout\-Ms} = 500)}\label{classCEvent_a2}


Construct a named event object. See the previous overloads of  {\bf CEvent::CEvent} {\rm (p.\,\pageref{classCEvent_a0})}, however:\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
r\-Name}]- STL String name of event.\end{description}
\end{Desc}
Throws:\begin{CompactItemize}
\item 
{\bf CDuplicate\-Name\-Exception} {\rm (p.\,\pageref{classCDuplicateNameException})} if there is already an Event derived object with this name. \end{CompactItemize}


Definition at line 410 of file CEvent.cpp.

References CNamed\-Object::Append\-Class\-Info(), and Registry\-Name.\index{CEvent@{CEvent}!~CEvent@{$\sim$CEvent}}
\index{~CEvent@{$\sim$CEvent}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}CEvent::$\sim$CEvent ()\hspace{0.3cm}{\tt  [virtual]}}\label{classCEvent_a3}


Destroys an instance of ourselves. This implies that our thread will exit. In general the destructor will not be called from this thread. 

Definition at line 431 of file CEvent.cpp.

References Disable().\index{CEvent@{CEvent}!CEvent@{CEvent}}
\index{CEvent@{CEvent}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}CEvent::CEvent (const CEvent \& {\em a\-CEvent})\hspace{0.3cm}{\tt  [private]}}\label{classCEvent_c0}


Copy Constructor - not allowed.



\subsection{Member Function Documentation}
\index{CEvent@{CEvent}!DescribeSelf@{DescribeSelf}}
\index{DescribeSelf@{DescribeSelf}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}string CEvent::Describe\-Self ()\hspace{0.3cm}{\tt  [virtual]}}\label{classCEvent_a16}


Produce a string describing this : 

Reimplemented from {\bf CNamed\-Object} {\rm (p.\,\pageref{classCNamedObject_a8})}.

Reimplemented in {\bf CBuffer\-Event$<$ T $>$} {\rm (p.\,\pageref{classCBufferEvent_a14})}, {\bf CFile\-Event} {\rm (p.\,\pageref{classCFileEvent_a19})}, {\bf CLocation\-Event$<$ T $>$} {\rm (p.\,\pageref{classCLocationEvent_a10})}, {\bf CServer\-Connection\-Event} {\rm (p.\,\pageref{classCServerConnectionEvent_a14})}, {\bf CServer\-Instance} {\rm (p.\,\pageref{classCServerInstance_a11})}, {\bf CTimer\-Event} {\rm (p.\,\pageref{classCTimerEvent_a12})}, and {\bf CBuffer\-Event$<$ U $>$} {\rm (p.\,\pageref{classCBufferEvent_a14})}.

Definition at line 534 of file CEvent.cpp.

References CNamed\-Object::Describe\-Self(), m\_\-f\-Active, m\_\-f\-Enabled, m\_\-n\-Ms\-Reactivity, m\_\-r\-Monitor, and m\_\-r\-Reactor.

Referenced by CTimer\-Event::Describe\-Self(), CServer\-Instance::Describe\-Self(), CServer\-Connection\-Event::Describe\-Self(), CLocation\-Event$<$ T $>$::Describe\-Self(), CFile\-Event::Describe\-Self(), and CBuffer\-Event$<$ T $>$::Describe\-Self().\index{CEvent@{CEvent}!Disable@{Disable}}
\index{Disable@{Disable}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CEvent::Disable ()}\label{classCEvent_a12}


Disable execution of the event. A join is done with the event to ensure that it actually exits. There are two cases:\begin{CompactItemize}
\item 
m\_\-f\-Active == true - The thread is active m\_\-f\-Enabled is set false, after some time, the thread will actually exit. We join with it to ensure that by the time Disable is exited, the thread has exited too.\item 
m\_\-f\-Active == false - The thread is not active, we can just return.\end{CompactItemize}
\begin{Desc}
\item[Note: ]\par
If the calling thread owns the global serialization mutex, it will be temporarily released. If this were not done, the Join could  deadlock the initiating thread and the thread being killed:\begin{CompactItemize}
\item 
The initiating thread will wait on the event thread to die, while holding the serialization mutex.\item 
The Event thread will wait on the serialization mutex before it can notice that it has been asked to exit. \end{CompactItemize}
\end{Desc}


Definition at line 479 of file CEvent.cpp.

References CApplication\-Serializer::get\-Instance(), CThread\-Recursive\-Mutex::get\-Lock\-Level(), CThread\-Recursive\-Mutex::get\-Owning\-Thread(), CThread\-Recursive\-Mutex::Lock(), m\_\-f\-Enabled, m\_\-Tid, and CThread\-Recursive\-Mutex::Un\-Lock\-Completely().

Referenced by $\sim$CEvent().\index{CEvent@{CEvent}!Enable@{Enable}}
\index{Enable@{Enable}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CEvent::Enable ()}\label{classCEvent_a11}


Enable execution of the event. This is intended to be called from outside the Event thread. This allows us to directly schedule the object as a thread, rather than going through the rigmarole required by {\bf CEvent::Schedule} {\rm (p.\,\pageref{classCEvent_b3})}

\begin{CompactItemize}
\item 
Enabling an active thread is a no-op.\item 
The enable state is a flag, not a counter, so only a single disable is required to kill the thread regardless of the number of Enable calls. \end{CompactItemize}


Reimplemented in {\bf CTimer\-Event} {\rm (p.\,\pageref{classCTimerEvent_a7})}.

Definition at line 449 of file CEvent.cpp.

References CApplication\-Serializer::get\-Instance(), CThread\-Recursive\-Mutex::Lock(), m\_\-f\-Enabled, m\_\-Tid, and CThread\-Recursive\-Mutex::Un\-Lock().

Referenced by CTimer\-Event::Enable().\index{CEvent@{CEvent}!getInformTimeout@{getInformTimeout}}
\index{getInformTimeout@{getInformTimeout}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool CEvent::get\-Inform\-Timeout () const\hspace{0.3cm}{\tt  [inline]}}\label{classCEvent_a6}


Return TRUE if Reactor also catches timeouts.



Definition at line 390 of file CEvent.h.

References m\_\-Inform\-Timeouts.\index{CEvent@{CEvent}!getMonitor@{getMonitor}}
\index{getMonitor@{getMonitor}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf CEvent\-Monitor}\& CEvent::get\-Monitor ()\hspace{0.3cm}{\tt  [inline]}}\label{classCEvent_a8}


Allow manipulation of the event monitor:.



Reimplemented in {\bf CBuffer\-Event$<$ T $>$} {\rm (p.\,\pageref{classCBufferEvent_a6})}, {\bf CLocation\-Event$<$ T $>$} {\rm (p.\,\pageref{classCLocationEvent_a4})}, {\bf CTimer\-Event} {\rm (p.\,\pageref{classCTimerEvent_a4})}, and {\bf CBuffer\-Event$<$ U $>$} {\rm (p.\,\pageref{classCBufferEvent_a6})}.

Definition at line 398 of file CEvent.h.

Referenced by CFile\-Event::Monitor\-Exceptions(), CFile\-Event::Monitor\-Readable(), CFile\-Event::Monitor\-Writable(), and CFile\-Event::$\sim$CFile\-Event().\index{CEvent@{CEvent}!getMsReactivity@{getMsReactivity}}
\index{getMsReactivity@{getMsReactivity}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int CEvent::get\-Ms\-Reactivity () const\hspace{0.3cm}{\tt  [inline]}}\label{classCEvent_a7}


Return the reactivity of the event to programmatic stimulus.



Definition at line 394 of file CEvent.h.

References m\_\-n\-Ms\-Reactivity.\index{CEvent@{CEvent}!getReactor@{getReactor}}
\index{getReactor@{getReactor}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf CReactor}\& CEvent::get\-Reactor ()\hspace{0.3cm}{\tt  [inline]}}\label{classCEvent_a9}


Allow manipulation of the event reactor:.



Reimplemented in {\bf CBuffer\-Event$<$ T $>$} {\rm (p.\,\pageref{classCBufferEvent_a7})}, {\bf CLocation\-Event$<$ T $>$} {\rm (p.\,\pageref{classCLocationEvent_a5})}, {\bf CTimer\-Event} {\rm (p.\,\pageref{classCTimerEvent_a5})}, and {\bf CBuffer\-Event$<$ U $>$} {\rm (p.\,\pageref{classCBufferEvent_a7})}.

Definition at line 402 of file CEvent.h.

Referenced by CFile\-Event::$\sim$CFile\-Event().\index{CEvent@{CEvent}!getThreadId@{getThreadId}}
\index{getThreadId@{getThreadId}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}DAQThread\-Id CEvent::get\-Thread\-Id () const\hspace{0.3cm}{\tt  [inline]}}\label{classCEvent_a10}


Allow external manipulation of the thread:.



Definition at line 406 of file CEvent.h.

References m\_\-Tid.\index{CEvent@{CEvent}!isActive@{isActive}}
\index{isActive@{isActive}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool CEvent::is\-Active () const\hspace{0.3cm}{\tt  [inline]}}\label{classCEvent_a5}


Return TRUE if the thread is running (active) (small timing hole).



Definition at line 386 of file CEvent.h.

References m\_\-f\-Active.\index{CEvent@{CEvent}!isEnabled@{isEnabled}}
\index{isEnabled@{isEnabled}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool CEvent::is\-Enabled () const\hspace{0.3cm}{\tt  [inline]}}\label{classCEvent_a4}


Return TRUE if the thread is enabled if not thread halt is pending.



Definition at line 382 of file CEvent.h.

References m\_\-f\-Enabled.\index{CEvent@{CEvent}!JoinThis@{JoinThis}}
\index{JoinThis@{JoinThis}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}DAQStatus CEvent::Join\-This ()\hspace{0.3cm}{\tt  [protected]}}\label{classCEvent_b6}


Does a join on the current object. The assumption is that at some time this object exists as a thread and will exit to be joined before restarting. 

Definition at line 638 of file CEvent.cpp.

References m\_\-Tid.\index{CEvent@{CEvent}!OnEvent@{OnEvent}}
\index{OnEvent@{OnEvent}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CEvent::On\-Event ({\bf CEvent\-Monitor::result} {\em why})\hspace{0.3cm}{\tt  [protected, virtual]}}\label{classCEvent_b2}


Called when the event monitor indicates that an event has occured. The default action (overridable) is to: 1. Lock the global serialization mutex. 2. Call the Event reactor's operator() member function. 3. Unlock the global serialization mutex.\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
why}]- Indicates what condition the monitor signalled. \end{description}
\end{Desc}


Definition at line 565 of file CEvent.cpp.

References CApplication\-Serializer::get\-Instance(), CThread\-Recursive\-Mutex::Lock(), m\_\-Inform\-Timeouts, m\_\-r\-Monitor, m\_\-r\-Reactor, Process\-Queues(), CEvent\-Monitor::result, CEvent\-Monitor::Timed\-Out, and CThread\-Recursive\-Mutex::Un\-Lock().

Referenced by operator()().\index{CEvent@{CEvent}!operator()@{operator()}}
\index{operator()@{operator()}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int CEvent::operator() (int {\em nargs}, char $\ast$$\ast$ {\em pp\-Args})\hspace{0.3cm}{\tt  [protected, virtual]}}\label{classCEvent_b4}


This is the Event thread's entry point when scheduled. \begin{CompactItemize}
\item 
Reap the scheduler thread.\item 
Delete the scheduler object which started us.\item 
Enter the main event loop of polling the monitor and dipatching to the  reactor.\end{CompactItemize}
\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
nargs}]- Number of parameters. \item[{\em 
ppargs}]- Pointer to the arguments. In this case it's just a pointer to the dispatching thread's object. \end{description}
\end{Desc}


Reimplemented in {\bf CLocation\-Event$<$ T $>$} {\rm (p.\,\pageref{classCLocationEvent_b0})}.

Definition at line 616 of file CEvent.cpp.

References m\_\-f\-Active, m\_\-n\-Ms\-Reactivity, m\_\-r\-Monitor, m\_\-Tid, On\-Event(), and CEvent\-Monitor::set\-Timeout().

Referenced by CLocation\-Event$<$ T $>$::operator()().\index{CEvent@{CEvent}!operator=@{operator=}}
\index{operator=@{operator=}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}CEvent\& CEvent::operator= (const CEvent \& {\em a\-CEvent})\hspace{0.3cm}{\tt  [private]}}\label{classCEvent_c1}


Operator= Assignment Operator - not allowed.

\index{CEvent@{CEvent}!operator==@{operator==}}
\index{operator==@{operator==}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int CEvent::operator== (const CEvent \& {\em a\-CEvent}) const\hspace{0.3cm}{\tt  [private]}}\label{classCEvent_c2}


Operator== Equality Operator no point.

\index{CEvent@{CEvent}!ProcessQueues@{ProcessQueues}}
\index{ProcessQueues@{ProcessQueues}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CEvent::Process\-Queues ()\hspace{0.3cm}{\tt  [protected, virtual]}}\label{classCEvent_b5}


Called periodically in event thread context to process any  inter thread communication primitives which may require action at event context. 

Reimplemented in {\bf CBuffer\-Event$<$ T $>$} {\rm (p.\,\pageref{classCBufferEvent_b0})}, and {\bf CBuffer\-Event$<$ U $>$} {\rm (p.\,\pageref{classCBufferEvent_b0})}.

Definition at line 650 of file CEvent.cpp.

Referenced by On\-Event().\index{CEvent@{CEvent}!ReactToTimeouts@{ReactToTimeouts}}
\index{ReactToTimeouts@{ReactToTimeouts}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CEvent::React\-To\-Timeouts (bool {\em f\-React} = true)}\label{classCEvent_a15}


Determines whether or not Monitor timeouts will cause a reactor to be fired. Timeouts are used regardless in order to sense the dropping of the m\_\-f\-Enabled flag. However if a timeout occurs and  m\_\-f\-Inform\-Timeouts is false, the Reactor will not be called.\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
f\-React}][true] - true if reactivity is desired... \end{description}
\end{Desc}


Definition at line 526 of file CEvent.cpp.

References m\_\-Inform\-Timeouts.\index{CEvent@{CEvent}!Schedule@{Schedule}}
\index{Schedule@{Schedule}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CEvent::Schedule ()\hspace{0.3cm}{\tt  [protected]}}\label{classCEvent_b3}


Called to schedule this process. Eric feels that it is not safe to just start this process off directly, e.g. from the constructor, because execution may start while the constructor is still executing either at this or a  lower level of the class hierarchy if this is a class derived from CEvent. Therefore we do the following tricky startup:

\begin{CompactItemize}
\item 
Create a new thread (Event\-Startup\-Thread).\item 
Schedule that thread this is a parameter.\item 
The thread will wait for some period of ms. which hopefully will ensure that the constructors have all exited.\item 
The thread will start this object as a thread, passing itself to our operator()\item 
Our operator() will do a Join on the thread which started us up to reap it.\item 
Our operator() will enter the main event loop. \end{CompactItemize}


Definition at line 595 of file CEvent.cpp.

References m\_\-f\-Enabled.\index{CEvent@{CEvent}!setActive@{setActive}}
\index{setActive@{setActive}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CEvent::set\-Active (bool {\em f\-Active})\hspace{0.3cm}{\tt  [inline, protected]}}\label{classCEvent_b0}


Set state of active flag.. implies thread is running.



Definition at line 414 of file CEvent.h.

References m\_\-f\-Active.\index{CEvent@{CEvent}!setEnable@{setEnable}}
\index{setEnable@{setEnable}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CEvent::set\-Enable (bool {\em f\-Enable})\hspace{0.3cm}{\tt  [inline]}}\label{classCEvent_a14}




Definition at line 427 of file CEvent.h.

References m\_\-f\-Enabled.

Referenced by CTimer\-Event::Internal\-On\-Timer(), and CServer\-Instance::Shutdown().\index{CEvent@{CEvent}!setReactivity@{setReactivity}}
\index{setReactivity@{setReactivity}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CEvent::set\-Reactivity (int {\em n\-Ms})}\label{classCEvent_a13}


Changes the Monitor timeout. This will take effect after the next exit from the monitor.. which may require as much as the current value of timeout. \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
n\-Ms}]- Number of milliseconds in the new timeout. -1 disables timeouts which in turn makes the time required to kill the thread unbounded. \end{description}
\end{Desc}


Definition at line 512 of file CEvent.cpp.

References m\_\-n\-Ms\-Reactivity.

Referenced by CTimer\-Event::CTimer\-Event(), CTimer\-Event::Enable(), and CTimer\-Event::Set\-Timeout().\index{CEvent@{CEvent}!setTid@{setTid}}
\index{setTid@{setTid}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CEvent::set\-Tid (const DAQThread\-Id {\em Tid})\hspace{0.3cm}{\tt  [inline, protected]}}\label{classCEvent_b1}


Set Thread ID: implies you know a lot about the system.



Definition at line 418 of file CEvent.h.

References m\_\-Tid.

\subsection{Member Data Documentation}
\index{CEvent@{CEvent}!m_fActive@{m\_\-fActive}}
\index{m_fActive@{m\_\-fActive}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool CEvent::m\_\-f\-Active\hspace{0.3cm}{\tt  [private]}}\label{classCEvent_o1}


True if thread is active.



Definition at line 338 of file CEvent.h.

Referenced by Describe\-Self(), is\-Active(), operator()(), and set\-Active().\index{CEvent@{CEvent}!m_fEnabled@{m\_\-fEnabled}}
\index{m_fEnabled@{m\_\-fEnabled}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool CEvent::m\_\-f\-Enabled\hspace{0.3cm}{\tt  [private]}}\label{classCEvent_o0}


Event enabled flag.



Definition at line 337 of file CEvent.h.

Referenced by Describe\-Self(), Disable(), Enable(), is\-Enabled(), Schedule(), and set\-Enable().\index{CEvent@{CEvent}!m_InformTimeouts@{m\_\-InformTimeouts}}
\index{m_InformTimeouts@{m\_\-InformTimeouts}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool CEvent::m\_\-Inform\-Timeouts\hspace{0.3cm}{\tt  [private]}}\label{classCEvent_o2}


Pass timeouts on to reactor.



Definition at line 339 of file CEvent.h.

Referenced by get\-Inform\-Timeout(), On\-Event(), and React\-To\-Timeouts().\index{CEvent@{CEvent}!m_nMsReactivity@{m\_\-nMsReactivity}}
\index{m_nMsReactivity@{m\_\-nMsReactivity}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int CEvent::m\_\-n\-Ms\-Reactivity\hspace{0.3cm}{\tt  [private]}}\label{classCEvent_o3}


Reactivity to external events.



Definition at line 340 of file CEvent.h.

Referenced by Describe\-Self(), get\-Ms\-Reactivity(), operator()(), and set\-Reactivity().\index{CEvent@{CEvent}!m_rMonitor@{m\_\-rMonitor}}
\index{m_rMonitor@{m\_\-rMonitor}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf CEvent\-Monitor}\& CEvent::m\_\-r\-Monitor\hspace{0.3cm}{\tt  [private]}}\label{classCEvent_o4}


Monitor which polls for event.



Reimplemented in {\bf CBuffer\-Event$<$ T $>$} {\rm (p.\,\pageref{classCBufferEvent_o2})}, {\bf CLocation\-Event$<$ T $>$} {\rm (p.\,\pageref{classCLocationEvent_o1})}, {\bf CTimer\-Event} {\rm (p.\,\pageref{classCTimerEvent_o0})}, and {\bf CBuffer\-Event$<$ U $>$} {\rm (p.\,\pageref{classCBufferEvent_o2})}.

Definition at line 341 of file CEvent.h.

Referenced by Describe\-Self(), On\-Event(), and operator()().\index{CEvent@{CEvent}!m_rReactor@{m\_\-rReactor}}
\index{m_rReactor@{m\_\-rReactor}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf CReactor}\& CEvent::m\_\-r\-Reactor\hspace{0.3cm}{\tt  [private]}}\label{classCEvent_o5}


Reactor to the event when it fires.



Reimplemented in {\bf CBuffer\-Event$<$ T $>$} {\rm (p.\,\pageref{classCBufferEvent_o3})}, {\bf CLocation\-Event$<$ T $>$} {\rm (p.\,\pageref{classCLocationEvent_o2})}, {\bf CTimer\-Event} {\rm (p.\,\pageref{classCTimerEvent_o1})}, and {\bf CBuffer\-Event$<$ U $>$} {\rm (p.\,\pageref{classCBufferEvent_o3})}.

Definition at line 342 of file CEvent.h.

Referenced by Describe\-Self(), and On\-Event().\index{CEvent@{CEvent}!m_Tid@{m\_\-Tid}}
\index{m_Tid@{m\_\-Tid}!CEvent@{CEvent}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}DAQThread\-Id CEvent::m\_\-Tid\hspace{0.3cm}{\tt  [private]}}\label{classCEvent_o6}


spectrodaq thread identifier.



Definition at line 343 of file CEvent.h.

Referenced by Disable(), Enable(), get\-Thread\-Id(), Join\-This(), operator()(), and set\-Tid().

The documentation for this class was generated from the following files:\begin{CompactItemize}
\item 
{\bf CEvent.h}\item 
{\bf CEvent.cpp}\end{CompactItemize}
