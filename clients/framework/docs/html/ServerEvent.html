<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Server accept events.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.15 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><a name="ServerEvent"><h2>Server accept events.</h2></a>

<p>
Before reading this page, be sure you are familiar with <a class="el" href="TCPIP.html">TCP/IP  client server programming.</a>  Server accept events allow a Spectrodaq application running under the framework to act as the listener part of a TCP/IP server.
<p>
To do this, the application writer must:<ul>
<li>Subclass the class <a class="el" href="classCServerConnectionEvent.html">CServerConnectionEvent</a> to provide application specific functionality for connection events (override <a class="el" href="classCServerConnectionEvent.html#a12">OnConnecition).</a><li>Create an instance of this class in your application and configure it with the service on which to listen. Note that the service can either be a textual service name, as it appears in the /etc/services file, or it can be a port number.<li>Enable the event.</ul>
When a connection to the service is requested by a client, the framework:<ul>
<li>Creates a <a class="el" href="classCSocket.html">CSocket</a> which represents the connection along which client and server communicate. This <a class="el" href="classCSocket.html">CSocket</a> object is dynamically created and must be deleted when the connection to the client is shutdown.<li>Calls <a class="el" href="classCServerConnectionEvent.html#a12">OnConnection</a>. Normally the application will do the following:<ol>
<li>Optionally validate the connection request, shutting down and destroying the connection socket if necessary.<li>Create a <a class="el" href="classCServerInstance.html">CServerInstance</a> derived object to carry out the dialog between the client and server for that client (see <a class="el" href="SocketEvents.html">Server       Instance Events</a>).</ol>
</ul>
In the example below, the program waits for connection requests on port 2048. When a connection arrives, it is honored by creating an echo server. The echo server simply echoes back lines to the client until the client breaks the connection. Deletion of exiting server instance threads is handled as follows:<ul>
<li>A timer event derived object called GrimReaper is instantiated and started.<li>GrimReaper maintains an interlocked queue of <a class="el" href="classCEvent.html">CEvent</a> object pointers for threads about to be deleted.<li>When GrimReaper executes, it examines entries in the queue, ensures that they are indeed inactive, and if so, deletes them.</ul>
<div class="fragment"><pre><font class="preprocessor">#include &lt;spectrodaq.h&gt;</font>
<font class="preprocessor">#include &lt;<a class="code" href="SpectroFramework_8h.html">SpectroFramework.h</a>&gt;</font>
<font class="preprocessor">#include &lt;list&gt;</font>
<font class="preprocessor">#include &lt;string&gt;</font>


<font class="keyword">typedef</font> list&lt;CEvent*&gt; EventList;

<font class="comment">// Reaper objects are timed events which delete dead process objects:</font>
<font class="comment">//</font>
<font class="keyword">class </font>Reaper : <font class="keyword">public</font> <a class="code" href="classCTimerEvent.html">CTimerEvent</a>
{
<font class="keyword">private</font>:
  EventList m_DeletePending;
<font class="keyword">public</font>:
  Reaper(<font class="keyword">const</font> <font class="keywordtype">char</font>* pName);

  <font class="keywordtype">void</font> QueueEvent(<a class="code" href="classCEvent.html">CEvent</a>* pEvent);
  <a class="code" href="classCEvent.html">CEvent</a>* DeQueueEvent();

  <font class="keyword">virtual</font> <font class="keywordtype">void</font> <a class="code" href="classCTimerEvent.html#a10">OnTimer</a>();
};
<font class="comment">// Implementation of Reaper:</font>

Reaper::Reaper(<font class="keyword">const</font> <font class="keywordtype">char</font>* pname) :
  <a class="code" href="classCTimerEvent.html">CTimerEvent</a>(pname, 1000, true) {}

<font class="keywordtype">void</font> 
Reaper::QueueEvent(<a class="code" href="classCEvent.html">CEvent</a>* pEvent)
{
  <a class="code" href="classCApplicationSerializer.html#d0">CApplicationSerializer::getInstance</a>()-&gt;<a class="code" href="classCThreadRecursiveMutex.html#a6">Lock</a>(); <font class="comment">// Don't assume this is done</font>
  m_DeletePending.push_back(pEvent);             <font class="comment">// in an event context. </font>
  <a class="code" href="classCApplicationSerializer.html#d0">CApplicationSerializer::getInstance</a>()-&gt;<a class="code" href="classCThreadRecursiveMutex.html#a7">UnLock</a>();
}
<a class="code" href="classCEvent.html">CEvent</a>* 
Reaper::DeQueueEvent()          <font class="comment">// Returns NULL if empty queue or front not yet</font>
{                               <font class="comment">// inactive... assumed to run locked.</font>
  <font class="keywordflow">if</font>(m_DeletePending.empty()) <font class="keywordflow">return</font> (<a class="code" href="classCEvent.html">CEvent</a>*)NULL;

  <a class="code" href="classCEvent.html">CEvent</a>* pItem = m_DeletePending.front();
  <font class="keywordflow">if</font>(pItem-&gt;<a class="code" href="classCEvent.html#a5">isActive</a>()) {
    m_DeletePending.pop_front();
    <font class="keywordflow">return</font> pItem;
  }
  <font class="keywordflow">else</font> {
    <font class="keywordflow">return</font> (<a class="code" href="classCEvent.html">CEvent</a>*)NULL;
  }
}
<font class="keywordtype">void</font> 
<a class="code" href="classCTimerEvent.html#a10">Reaper::OnTimer</a>()
{
  <a class="code" href="classCEvent.html">CEvent</a>* pEvent;
  <font class="keywordflow">while</font>(pEvent = DeQueueEvent()) {
    <font class="keyword">delete</font> pEvent;
  }
}

<font class="comment">// Server instance. Echoes client requests on client channel until</font>
<font class="comment">// client exits.. at exit time, disables self and enters the object</font>
<font class="comment">// on the delete pending queue of a reaper.</font>

<font class="keyword">class </font>EchoServer : <font class="keyword">public</font> <a class="code" href="classCServerInstance.html">CServerInstance</a>
{
  Reaper&amp; m_GrimReaper;
<font class="keyword">public</font>:
  EchoServer(<a class="code" href="classCSocket.html">CSocket</a>* pSocket, Reaper&amp; pReapme);
  <font class="keywordtype">void</font> <a class="code" href="classCServerInstance.html#a9">OnRequest</a>(<a class="code" href="classCSocket.html">CSocket</a>* pSocket);
};

EchoServer::EchoServer(<a class="code" href="classCSocket.html">CSocket</a>* pSocket, Reaper&amp; rReapme) :
  <a class="code" href="classCServerInstance.html">CServerInstance</a>(pSocket),
  m_GrimReaper(rReapme) {}

<font class="keywordtype">void</font>
<a class="code" href="classCServerInstance.html#a9">EchoServer::OnRequest</a>(<a class="code" href="classCSocket.html">CSocket</a>* pSocket) {
  <font class="keywordtype">char</font> buffer[1024];
  <font class="keywordtype">int</font> nread = pSocket-&gt;<a class="code" href="classCSocket.html#a11">Read</a>(buffer, <font class="keyword">sizeof</font>(buffer)-1);
  <font class="keywordflow">if</font>(nread &lt;= 0) {              <font class="comment">// Client exited or other error...</font>
    Shutdown();                 <font class="comment">// Shutdown our part of the connection.</font>
    <a class="code" href="classXMButtonList.html#a1">Disable</a>();                  <font class="comment">// Schedule thread exit and</font>
    m_GrimReaper.QueueEvent(<font class="keyword">this</font>); <font class="comment">// Object deletion.</font>
  } <font class="keywordflow">else</font> {                      <font class="comment">// Data available.</font>
    pSocket-&gt;<a class="code" href="classCSocket.html#a12">Write</a>(buffer, nread);
  }
}


<font class="comment">// Server listener.  Only new functionality is the OnConnection</font>
<font class="comment">// which creates a new server instance thread.</font>

<font class="keyword">class </font>EchoListener : <font class="keyword">public</font> <a class="code" href="classCServerConnectionEvent.html">CServerConnectionEvent</a>
{
  Reaper&amp; m_GrimReaper;
<font class="keyword">public</font>:
  EchoListener(<font class="keyword">const</font> <font class="keywordtype">char</font>* pName, <font class="keyword">const</font> string&amp; rservice, Reaper&amp; rReaper);
  <font class="keyword">virtual</font> <font class="keywordtype">void</font> <a class="code" href="classCServerConnectionEvent.html#a12">OnConnection</a>(<a class="code" href="classCSocket.html">CSocket</a>* pSocket);
};

EchoListener::EchoListener(<font class="keyword">const</font> <font class="keywordtype">char</font>* pName, <font class="keyword">const</font> string&amp; rservice,
                           Reaper&amp; rReaper) :
  <a class="code" href="classCServerConnectionEvent.html">CServerConnectionEvent</a>(pName, rservice),
  m_GrimReaper(rReaper)
{}
<font class="keywordtype">void</font>
<a class="code" href="classCServerConnectionEvent.html#a12">EchoListener::OnConnection</a>(<a class="code" href="classCSocket.html">CSocket</a>* pSocket)
{
  EchoServer* pServer = <font class="keyword">new</font> EchoServer(pSocket, m_GrimReaper);
  pServer-&gt;Enable();
}


<font class="keyword">class </font>MyApp : <font class="keyword">public</font> DAQROCNode
{
<font class="keyword">protected</font>:
  <font class="keywordtype">int</font> operator()(<font class="keywordtype">int</font> argc, <font class="keywordtype">char</font>** pargv);

};
<font class="keywordtype">int</font>
MyApp::operator()(<font class="keywordtype">int</font> argc, <font class="keywordtype">char</font>** pargv)
{
  Reaper theReaper(<font class="stringliteral">"GrimReaper"</font>);
  theReaper.Enable();           <font class="comment">// Start off the grim reaper.</font>

  EchoListener Listen(<font class="stringliteral">"EchoListen"</font>, string(<font class="stringliteral">"2048"</font>), theReaper);
  Listen.Enable();

  DAQThreadId id = Listen.getThreadId();
  Join(id);
  
};

MyApp theApplication;
</pre></div>
<p>
<hr><address align="right"><small>Generated on Tue Feb 4 12:35:50 2003 for Spectrodaq External Event Framework by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.15 </small></address>
</body>
</html>
