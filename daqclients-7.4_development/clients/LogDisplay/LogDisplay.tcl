# /*
# 		    GNU GENERAL PUBLIC LICENSE
# 		       Version 2, June 1991
# 
#  Copyright (C) 1989, 1991 Free Software Foundation, Inc.
#                        59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#  Everyone is permitted to copy and distribute verbatim copies
#  of this license document, but changing it is not allowed.
# 
# 			    Preamble
# 
#   The licenses for most software are designed to take away your
# freedom to share and change it.  By contrast, the GNU General Public
# License is intended to guarantee your freedom to share and change free
# software--to make sure the software is free for all its users.  This
# General Public License applies to most of the Free Software
# Foundation's software and to any other program whose authors commit to
# using it.  (Some other Free Software Foundation software is covered by
# the GNU Library General Public License instead.)  You can apply it to
# your programs, too.
# 
#   When we speak of free software, we are referring to freedom, not
# price.  Our General Public Licenses are designed to make sure that you
# have the freedom to distribute copies of free software (and charge for
# this service if you wish), that you receive source code or can get it
# if you want it, that you can change the software or use pieces of it
# in new free programs; and that you know you can do these things.
# 
#   To protect your rights, we need to make restrictions that forbid
# anyone to deny you these rights or to ask you to surrender the rights.
# These restrictions translate to certain responsibilities for you if you
# distribute copies of the software, or if you modify it.
# 
#   For example, if you distribute copies of such a program, whether
# gratis or for a fee, you must give the recipients all the rights that
# you have.  You must make sure that they, too, receive or can get the
# source code.  And you must show them these terms so they know their
# rights.
# 
#   We protect your rights with two steps: (1) copyright the software, and
# (2) offer you this license which gives you legal permission to copy,
# distribute and/or modify the software.
# 
#   Also, for each author's protection and ours, we want to make certain
# that everyone understands that there is no warranty for this free
# software.  If the software is modified by someone else and passed on, we
# want its recipients to know that what they have is not the original, so
# that any problems introduced by others will not reflect on the original
# authors' reputations.
# 
#   Finally, any free program is threatened constantly by software
# patents.  We wish to avoid the danger that redistributors of a free
# program will individually obtain patent licenses, in effect making the
# program proprietary.  To prevent this, we have made it clear that any
# patent must be licensed for everyone's free use or not licensed at all.
# 
#   The precise terms and conditions for copying, distribution and
# modification follow.
# 
# 		    GNU GENERAL PUBLIC LICENSE
#    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
# 
#   0. This License applies to any program or other work which contains
# a notice placed by the copyright holder saying it may be distributed
# under the terms of this General Public License.  The "Program", below,
# refers to any such program or work, and a "work based on the Program"
# means either the Program or any derivative work under copyright law:
# that is to say, a work containing the Program or a portion of it,
# either verbatim or with modifications and/or translated into another
# language.  (Hereinafter, translation is included without limitation in
# the term "modification".)  Each licensee is addressed as "you".
# 
# Activities other than copying, distribution and modification are not
# covered by this License; they are outside its scope.  The act of
# running the Program is not restricted, and the output from the Program
# is covered only if its contents constitute a work based on the
# Program (independent of having been made by running the Program).
# Whether that is true depends on what the Program does.
# 
#   1. You may copy and distribute verbatim copies of the Program's
# source code as you receive it, in any medium, provided that you
# conspicuously and appropriately publish on each copy an appropriate
# copyright notice and disclaimer of warranty; keep intact all the
# notices that refer to this License and to the absence of any warranty;
# and give any other recipients of the Program a copy of this License
# along with the Program.
# 
# You may charge a fee for the physical act of transferring a copy, and
# you may at your option offer warranty protection in exchange for a fee.
# 
#   2. You may modify your copy or copies of the Program or any portion
# of it, thus forming a work based on the Program, and copy and
# distribute such modifications or work under the terms of Section 1
# above, provided that you also meet all of these conditions:
# 
#     a) You must cause the modified files to carry prominent notices
#     stating that you changed the files and the date of any change.
# 
#     b) You must cause any work that you distribute or publish, that in
#     whole or in part contains or is derived from the Program or any
#     part thereof, to be licensed as a whole at no charge to all third
#     parties under the terms of this License.
# 
#     c) If the modified program normally reads commands interactively
#     when run, you must cause it, when started running for such
#     interactive use in the most ordinary way, to print or display an
#     announcement including an appropriate copyright notice and a
#     notice that there is no warranty (or else, saying that you provide
#     a warranty) and that users may redistribute the program under
#     these conditions, and telling the user how to view a copy of this
#     License.  (Exception: if the Program itself is interactive but
#     does not normally print such an announcement, your work based on
#     the Program is not required to print an announcement.)
# 
# These requirements apply to the modified work as a whole.  If
# identifiable sections of that work are not derived from the Program,
# and can be reasonably considered independent and separate works in
# themselves, then this License, and its terms, do not apply to those
# sections when you distribute them as separate works.  But when you
# distribute the same sections as part of a whole which is a work based
# on the Program, the distribution of the whole must be on the terms of
# this License, whose permissions for other licensees extend to the
# entire whole, and thus to each and every part regardless of who wrote it.
# 
# Thus, it is not the intent of this section to claim rights or contest
# your rights to work written entirely by you; rather, the intent is to
# exercise the right to control the distribution of derivative or
# collective works based on the Program.
# 
# In addition, mere aggregation of another work not based on the Program
# with the Program (or with a work based on the Program) on a volume of
# a storage or distribution medium does not bring the other work under
# the scope of this License.
# 
#   3. You may copy and distribute the Program (or a work based on it,
# under Section 2) in object code or executable form under the terms of
# Sections 1 and 2 above provided that you also do one of the following:
# 
#     a) Accompany it with the complete corresponding machine-readable
#     source code, which must be distributed under the terms of Sections
#     1 and 2 above on a medium customarily used for software interchange; or,
# 
#     b) Accompany it with a written offer, valid for at least three
#     years, to give any third party, for a charge no more than your
#     cost of physically performing source distribution, a complete
#     machine-readable copy of the corresponding source code, to be
#     distributed under the terms of Sections 1 and 2 above on a medium
#     customarily used for software interchange; or,
# 
#     c) Accompany it with the information you received as to the offer
#     to distribute corresponding source code.  (This alternative is
#     allowed only for noncommercial distribution and only if you
#     received the program in object code or executable form with such
#     an offer, in accord with Subsection b above.)
# 
# The source code for a work means the preferred form of the work for
# making modifications to it.  For an executable work, complete source
# code means all the source code for all modules it contains, plus any
# associated interface definition files, plus the scripts used to
# control compilation and installation of the executable.  However, as a
# special exception, the source code distributed need not include
# anything that is normally distributed (in either source or binary
# form) with the major components (compiler, kernel, and so on) of the
# operating system on which the executable runs, unless that component
# itself accompanies the executable.
# 
# If distribution of executable or object code is made by offering
# access to copy from a designated place, then offering equivalent
# access to copy the source code from the same place counts as
# distribution of the source code, even though third parties are not
# compelled to copy the source along with the object code.
# 
#   4. You may not copy, modify, sublicense, or distribute the Program
# except as expressly provided under this License.  Any attempt
# otherwise to copy, modify, sublicense or distribute the Program is
# void, and will automatically terminate your rights under this License.
# However, parties who have received copies, or rights, from you under
# this License will not have their licenses terminated so long as such
# parties remain in full compliance.
# 
#   5. You are not required to accept this License, since you have not
# signed it.  However, nothing else grants you permission to modify or
# distribute the Program or its derivative works.  These actions are
# prohibited by law if you do not accept this License.  Therefore, by
# modifying or distributing the Program (or any work based on the
# Program), you indicate your acceptance of this License to do so, and
# all its terms and conditions for copying, distributing or modifying
# the Program or works based on it.
# 
#   6. Each time you redistribute the Program (or any work based on the
# Program), the recipient automatically receives a license from the
# original licensor to copy, distribute or modify the Program subject to
# these terms and conditions.  You may not impose any further
# restrictions on the recipients' exercise of the rights granted herein.
# You are not responsible for enforcing compliance by third parties to
# this License.
# 
#   7. If, as a consequence of a court judgment or allegation of patent
# infringement or for any other reason (not limited to patent issues),
# conditions are imposed on you (whether by court order, agreement or
# otherwise) that contradict the conditions of this License, they do not
# excuse you from the conditions of this License.  If you cannot
# distribute so as to satisfy simultaneously your obligations under this
# License and any other pertinent obligations, then as a consequence you
# may not distribute the Program at all.  For example, if a patent
# license would not permit royalty-free redistribution of the Program by
# all those who receive copies directly or indirectly through you, then
# the only way you could satisfy both it and this License would be to
# refrain entirely from distribution of the Program.
# 
# If any portion of this section is held invalid or unenforceable under
# any particular circumstance, the balance of the section is intended to
# apply and the section as a whole is intended to apply in other
# circumstances.
# 
# It is not the purpose of this section to induce you to infringe any
# patents or other property right claims or to contest validity of any
# such claims; this section has the sole purpose of protecting the
# integrity of the free software distribution system, which is
# implemented by public license practices.  Many people have made
# generous contributions to the wide range of software distributed
# through that system in reliance on consistent application of that
# system; it is up to the author/donor to decide if he or she is willing
# to distribute software through any other system and a licensee cannot
# impose that choice.
# 
# This section is intended to make thoroughly clear what is believed to
# be a consequence of the rest of this License.
# 
#   8. If the distribution and/or use of the Program is restricted in
# certain countries either by patents or by copyrighted interfaces, the
# original copyright holder who places the Program under this License
# may add an explicit geographical distribution limitation excluding
# those countries, so that distribution is permitted only in or among
# countries not thus excluded.  In such case, this License incorporates
# the limitation as if written in the body of this License.
# 
#   9. The Free Software Foundation may publish revised and/or new versions of the General Public License from time to time.  Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.
# 
# Each version is given a distinguishing version number.  If the Program
# specifies a version number of this License which applies to it and "any
# later version", you have the option of following the terms and conditions 
# either of that version or of any later version published by the Free Software 
# Foundation.  If the Program does not specify a version number of this License,
#  you may choose any version ever published by the Free Software Foundation.
# 
#   10. If you wish to incorporate parts of the Program into other free
# programs whose distribution conditions are different, write to the author to 
# ask for permission.  For software which is copyrighted by the Free Software 
# Foundation, write to the Free Software Foundation; we sometimes make 
# exceptions for this.  Our decision will be guided by the two goals of 
# preserving the free status of all derivatives of our free software and of 
# promoting the sharing and reuse of software generally.
# 
# 			    NO WARRANTY
# 
#   11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR
# THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN 
# OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE 
# THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, 
# INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND 
# FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND 
# PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, 
# YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.
# 
#   12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING 
# WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR 
# REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, 
# INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING 
# OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO 
# LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR 
# THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), 
# EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH 
# DAMAGES.
# 
# 		     END OF TERMS AND CONDITIONS
# */

# (C) Copyright Michigan State University 1937, All rights reserved 
#==============================================================================
# Author:
#    Jason Venema
#    NSCL
#    Michigan State University
#    East Lansing, MI 48824-1321
#    mailto: venemaja@msu.edu
#
# This is the script for a tcl/tk sortable, filterable, recoverable tablelist
# which is used as an event logger and displayer. Events are displayed in the 
# tablelist and each event consists of a facility, a severity, a message and a
# date/time at which the event was logged. Events are also written to the log
# file. The logfile defaults to "daq.log" but can be changed with the command
# line option "-l<filename>. 
#==============================================================================

package require Tablelist
package require Hostlist

namespace eval Logger {}

#------------------------------------------------------------------------------
# Logger::Log
#
# This procedure accesses the logfile and logs the entry. Events are
# logged via the following command: Logger::Log <Facility> <Severity> <Message>
# The severity can be one of three options: "Success", "Warning" or "Error".
# The return value is the time which the event was logged. This is useful for
# external programs which are connected to us via a socket and would like to
# display the event with the exact time at which it occurs.
#------------------------------------------------------------------------------
proc Logger::Log {entry} {
    global logfile

    # Break the entry down into its components
    set facility [lindex $entry 0]
    set severity [lindex $entry 1]
    set from     [lindex $entry 2]
    for {set i 3} {$i < [llength $entry]} {incr i} {
	lappend message [lindex $entry $i]
    }
    join $message
    set time [exec date "+%Y-%m-%d  %H:%M:%S %Z %a"]

    # Log the event to file
    if [catch {set file [open $logfile a]} result] {
	puts stderr $result
    } else {
	set line "FACILITY: $facility\nSEVERITY: $severity\nMESSAGE:  $message\nFROM:     $from\nTIME:     $time\n"
	puts $file $line
	close $file
    }
    return $time
}

#------------------------------------------------------------------------------
# Logger::Display
#
# This procedure actually creates the display and defines the buttons.
# Currently, supported actions are:
#    Filter... - Filters out messages by applying a pattern
#    Unfilter  - Redisplays events which have been filtered
#    Dismiss   - Removes the selected event from the display
#    Recover   - Redisplays all events which have been dismissed or which, for
#                any reason, failed to display when the event was logged. Reads
#                all events from the logfile and displays them.
#    Hosts...  - Edit the allowed host list
#    Exit      - Exit from the logger
#------------------------------------------------------------------------------
proc Logger::Display {} {
    global tbl
    global b2
    global b4
    global script_dir

    #
    # Create a top-level widget
    #
    set top .__configTop
    for {set n 2} {[winfo exists $top]} {incr n} {
	set top .__configTop$n
    }
    toplevel $top
    wm title $top "NSCL System Message Logger on [exec hostname]"

    #
    # Create a scrolled tablelist widget with 3 dynamic-width
    # columns, 1 static width column, and interactive sort capability 
    # within the top-level. The message column is static width because
    # messages can be arbitrarily long. If a message doesn't fit in the
    # defined width, double click it.
    #
    set tbl $top.tbl
    set vsb $top.vsb
    set hsb $top.hsb
    tablelist::tablelist $tbl \
	-columns {0 "Facility"
	    0 "Severity"
	    35 "Message"
	    0 "Date/Time"
	    0 "From"} \
	-labelcommand tablelist::sortByColumn \
	-xscrollcommand [list $hsb set] -yscrollcommand [list $vsb set] \
	-background white -selectbackground navy -selectforeground white \
	-height 15 -width 95 -setgrid yes -stretch all -selectmode extended
    foreach col {1 3} {
	$tbl columnconfigure $col -background beige
    }
    scrollbar $vsb -orient vertical   -command [list $tbl yview]
    scrollbar $hsb -orient horizontal -command [list $tbl xview]

    #
    # Create a frame for some buttons
    #
    set f $top.f
    frame $f
    set ft [frame $f.top]
    set fb [frame $f.bot]
    pack $ft $fb -side top -fill x

    #
    # Create some images for use as cool buttons
    #
    image create photo FiltButton -format GIF \
	-file [file join $script_dir ../Images/FiltButton.gif]
    image create photo UfiltButton -format GIF \
	-file [file join $script_dir ../Images/UfiltButton.gif]
    image create photo DisButton -format GIF \
	-file [file join $script_dir ../Images/DisButton.gif]
    image create photo RecovButton -format GIF \
	-file [file join $script_dir ../Images/RecovButton.gif]
    image create photo HostButton -format GIF \
	-file [file join $script_dir ../Images/HostButton.gif]
    image create photo ExitButton -format GIF \
	-file [file join $script_dir ../Images/ExitButton.gif]

    #
    # Create a button for filtering
    #
    set b1 $ft.b1
    button $b1 -image FiltButton -command [list Logger::Filter]
    pack $b1 -side left -expand yes

    #
    # Create a button for unfiltering the entries in the tablelist
    #
    set b2 $ft.b2
    button $b2 -image UfiltButton -command [list Logger::Unfilter]
    pack $b2 -side left -expand yes
    $b2 configure -state disabled

    #
    # Create a button for dismissing entries in the tablelist
    #
    set b3 $ft.b3
    button $b3 -image DisButton -command [list Logger::Dismiss]
    pack $b3 -side left -expand yes

    #
    # Create a button for recovering a display from a logfile
    #
    set b4 $fb.b4
    button $b4 -image RecovButton -command [list Logger::Recover]
    pack $b4 -side left -expand yes
    $b4 configure -state disabled

    #
    # Create a button for editing the host list
    #
    set b5 $fb.b5
    button $b5 -image HostButton -command [list Logger::Read_Hostlist]
    pack $b5 -side left -expand yes

    #
    # Create a button for exiting the logger
    #
    set b6 $fb.b6
    button $b6 -image ExitButton -command {exit}
    pack $b6 -side left -expand yes

    #
    # Bind double clicking to display the attributes of the event
    #
    set body [$tbl bodypath]
    bind $body <Double-1> [list Logger::Display_Attrib]
    bind $body <Button-4> [list $tbl yview scroll -1 units]
    bind $body <Button-5> [list $tbl yview scroll 1 units]
    bind all   <Control-a> [list $tbl selection set 0 end]

    #
    # Manage the children of the top-level widget
    #
    grid $tbl -row 0 -column 0 -sticky news
    grid $vsb -row 0 -column 1 -sticky ns
    grid $hsb -row 1 -column 0 -sticky ew
    grid $f   -row 2 -column 0 -sticky ew -columnspan 2 -pady 10
    grid rowconfigure    $top 0 -weight 1
    grid columnconfigure $top 0 -weight 1

    # 
    # Since this procedure is only called once, we recover everything from
    # the logfile.
    #
    Logger::Recover
}

#------------------------------------------------------------------------------
# proc Logger::Read_Hostlist
#
# The purpose of this procedure is to call the Hostlist package procedure that
# reads in the list of allowed hosts for this machine, and authorizes them on
# the tclserver. This procedure ensures that no other windows can be opened
# until this one has been responded to.
#------------------------------------------------------------------------------
proc Logger::Read_Hostlist {} {
    global tbl

    set old [focus -displayof $tbl]
    set x [Hostlist::Read_List]
    focus $x
    catch {tkwait visibility $x}
    catch {grab $x}

    tkwait window $x
    catch {grab release $x}
    focus $old
}

#------------------------------------------------------------------------------
# proc Logger::Dismiss
#
# Dismisses the current selection from the tablelist. Once an entry has been
# dismissed, the only way to get it back is with a recover. This procedure
# checks whether or not there is currently an entry/entries selected and 
# deletes it/them. If no entry is selected, it is a no-op.
#
# Note: The whole business with incrementing i and subtracting it from the
#       selection index each time is because the value of each entry's index
#       decreases by 1 each time an entry is deleted. This is true because the
#       list "cur" is sorted first.
#------------------------------------------------------------------------------
proc Logger::Dismiss {} {
    global tbl
    global b4

    set cur [$tbl curselection]
    if {$cur != ""} {
	$b4 configure -state active
	set i 0
	lsort -integer $cur
	foreach sel $cur {
	    set sel [expr $sel - $i]
	    $tbl delete $sel
	    incr i
	}
    }
}

#------------------------------------------------------------------------------
# proc Logger::Display_Attrib
#
# This function is invoked when mouse button 1 is double clicked on an entry
# from within the body of the tablelist. It's purpose is to view the entry's
# attributes in the case that the "Message" field is too long to fit in the
# table. By offering a separate window to display long messages, it makes the
# tablelist look neater. It may turn out that this is unnecessary, but it
# couldn't hurt.
#------------------------------------------------------------------------------
proc Logger::Display_Attrib {} {
    global tbl
    global attrib_prompt
    global OkButton
    set row [$tbl get [$tbl curselection]]

    #
    # Create a new window for display
    #
    set f .attrib
    eval {toplevel $f} -width 80 -height 40
    wm title $f "Attributes of Logged Event"
    set top [frame $f.top -relief sunken -borderwidth 2]
    set bot [frame $f.bot]
    pack $top $bot -side top -fill both -expand true
    set t [text $top.t -setgrid true -wrap word \
	       -width 60 -height 15 -bg white \
	       -yscrollcommand [list $top.sy set]]
    scrollbar $top.sy -orient vert -command [list $top.t yview]
    pack $top.sy -side right -fill y
    pack $top.t -side left -fill both -expand true
    $t tag configure hang -lmargin1 0.0i -lmargin2 0.35i
    $t tag configure para -spacing1 0.1i
    $t insert end "Facility: [lindex $row 0]\n"
    $t insert end "Severity: [lindex $row 1]\n"
    $t insert end "Message:  [lindex $row 2]\n"
    $t insert end "Date:     [lindex $row 3]\n\n"
    $t insert end "From:     [lindex $row 4]"
    $t tag add hang 3.0 3.end
    for {set i 2} {$i <= 4} {incr i} {
	$t tag add para $i.0 $i.end
    }
    button $bot.ok -image OkButton -command {set attrib_prompt(ok) 1}
    pack $bot.ok -anchor n

    set attrib_prompt(ok) 0
    Dialog_Wait $f attrib_prompt(ok) $f
    destroy $f
    if {$attrib_prompt(ok)} {
	return 
    }
}

#------------------------------------------------------------------------------
# proc Logger::Filter
#
# This procedure is invoked from the displayer button labeled "Filter". It
# creates a top-level widget which prompts the user for information on what
# events they would like filtered. When return is pressed, procedure
# Perform_Filter is invoked to perform the actual dismissals (if any).
#------------------------------------------------------------------------------
proc Logger::Filter {} {
    global tbl
    global b2
    global hidden
    
    #
    # First we create a list of all facilities which have logged events
    # to pass to the filter dialog box. This allows the user to choose a
    # facility to filter from a list, rather than having to type the name in.
    # NOTE: This feature has not been implemented as of this version.
    #
    foreach row [$tbl get 0 end] {
	set present 0
	if {[info exists faclist]} {
	    foreach item $faclist {
		if {[lindex $row 0] == $item} {
		    set present 1
		}
	    }
	    if {!$present} {
		lappend faclist [lindex $row 0]
	    }
	} else {
	    lappend faclist [lindex $row 0]
	}
    }

    #
    # Create a Dialog prompt so we know what to filter
    #
    set options [Logger::Filter_Dialog_Prompt]
    if {$options == 0} {
	return
    }

    Logger::Perform_Filter $options
    if {[info exists hidden]} {
	$b2 configure -state active
    }
}

#------------------------------------------------------------------------------
# proc Logger::Perform_Filter
#
# This procedure performs the actual filtering. Some combination of list items
# (call options) is passed to us from the Filter_Dialog_Prompt which contains
# information on what item a user would like to have filtered. There are six
# possibilities:
#    - Show only this facility
#    - Hide only this facility
#    - Show only these severities
#    - Show only this facility of these severities
#    - Hide only this facility of these severities
#    - Show all entries...
# For each of these options, a date is also specified and only entries which
# occur either before or after that date will be displayed. For example, 
# option "Show all entries" doesn't do anything if no date is specified. On
# the other hand, option "Show only this facility..." shows only the facility
# requested whether a date is entered or not. The date is simply an additional
# constraint, but not a requirement.
#
# The entries which are "hidden" by the filter are stored in a global variable,
# name hidden, which will be used later to redisplay those item when an
# "unfilter" is requested.
#------------------------------------------------------------------------------
proc Logger::Perform_Filter {options} {
    global tbl
    global hidden
    global incoming
    
    #
    # We need to parse the options list
    #
    set facs    [lindex $options 0]
    set sevs    [lindex $options 1]
    set date    [lindex $options 2]
    set month   [lindex $date 0]
    set day     [lindex $date 1]
    set year    [lindex $date 2]

    # If the month or day begins with a "0", (e.g. 2002-02-02), then tcl
    # wont interpret it as a number, but as a string. So we have to
    # manually parse out the prefix '0'.
    #
    if {[string range $month 0 0] == "0"} {
	set month [string range $month 1 1]
    }
    if {[string range $day 0 0] == "0"} {
	set day [string range $day 1 1]
    }

    if {$month != ""} {
	set dateVal [expr $year*10000 + $month*100 + $day]
    } else {
	set dateVal 0
    } 
    set op1     [lindex $options 3]
    set op2     [lindex $options 4]

    #
    # If "incoming filter" was selected (checkbutton in the dialog box) then
    # we need to keep track of the options list so we can keep filtering later
    # when a new event is logged.
    #
    if {$incoming(on)} {
	set incoming(val) $options
    }

    #
    # Perform the actual filtering by hiding specified logged events
    #
    set i 0
    foreach row [$tbl get 0 end] {
	set tabledate [lindex $row 3]
	set month [string range $tabledate 5 6]
	set day   [string range $tabledate 8 9]
	set year  [string range $tabledate 0 3]
	if {[string range $month 0 0] == "0"} {
	    set month [string range $month 1 1]
	}
	if {[string range $day 0 0] == "0"} {
	    set day [string range $day 1 1]
	}
	set tabledateVal [expr $year*10000 + $month*100 +$day]

	#
	# Show only this facility...
	#
	if {$op1 == 0} {
	    if {$facs != [lindex $row 0] ||
		($facs == [lindex $row 0] &&
		 ($op2 == "before" && $dateVal <= $tabledateVal) ||
		 ($op2 == "after"  && $dateVal >= $tabledateVal))} {
		lappend hidden $row
		$tbl delete $i
	    } else {
		incr i
	    }
	    #
	    # Hide only this facility...
	    #
	} elseif {$op1 == 1} {
	    if {$facs == [lindex $row 0] &&
		(($op2 == "before" && $dateVal > $tabledateVal) ||
		 ($op2 == "after"  && $dateVal < $tabledateVal) ||
		 ($op2 == "none"))} {
		lappend hidden $row
		$tbl delete $i
	    } else {
		incr i
	    }
	    #
	    # Show only these severities...
	    #
	} elseif {$op1 == 2} {
	    if {(([lindex $sevs 0] != [lindex $row 1] &&
		  [lindex $sevs 1] != [lindex $row 1] &&
		  [lindex $sevs 2] != [lindex $row 1])) ||
		(([lindex $sevs 0] == [lindex $row 1] ||
		  [lindex $sevs 1] == [lindex $row 1] ||
		  [lindex $sevs 2] == [lindex $row 1]) &&
		 (($op2 == "before" && $dateVal <= $tabledateVal) ||
		  ($op2 == "after"  && $dateVal >= $tabledateVal)))} {
		lappend hidden $row
		$tbl delete $i
	    } else {
		incr i
	    }
	    #
	    # Show only this facility of these severities...
	    #
	} elseif {$op1 == 3} {
	    if {($facs != [lindex $row 0] ||
		 ([lindex $sevs 0] != [lindex $row 1] &&
		  [lindex $sevs 1] != [lindex $row 1] &&
		  [lindex $sevs 2] != [lindex $row 1]) ||
		 (($op2 == "before" && $dateVal <= $tabledateVal) ||
		  ($op2 == "after"  && $dateVal >= $tabledateVal))) ||
		($facs == [lindex $row 0] &&
		 ([lindex $sevs 0] == [lindex $row 1] ||
		  [lindex $sevs 1] == [lindex $row 1] ||
		  [lindex $sevs 2] == [lindex $row 1]) &&
		 (($op2 == "before" && $dateVal <= $tabledateVal) ||
		  ($op2 == "after"  && $dateVal >= $tabledateVal)))} {
		lappend hidden $row
		    $tbl delete $i
	    } else {
		incr i
	    }
	    #
	    # Hide only this facility of these severities...
	    #
	} elseif {$op1 == 4} {
	    if {($facs == [lindex $row 0] &&
		 ([lindex $sevs 0] == [lindex $row 1] ||
		  [lindex $sevs 1] == [lindex $row 1] ||
		  [lindex $sevs 2] == [lindex $row 1]) &&
		 (($op2 == "before" && $dateVal > $tabledateVal) ||
		  ($op2 == "after"  && $dateVal < $tabledateVal) ||
		  ($op2 == "none")))} {
		lappend hidden $row
		$tbl delete $i
	    } else {
		incr i
	    }
	    #
	    # Show all entries...
	    #
	} elseif {$op1 == 5} {
	    if {(($op2 == "before" && $dateVal <= $tabledateVal) ||
		 ($op2 == "after"  && $dateVal >= $tabledateVal))} {
		lappend hidden $row
		$tbl delete $i
	    } else {
		incr i
	    }
	}
    }
    return
}

#------------------------------------------------------------------------------
# proc Logger::Unfilter
#
# This procedure uses the global variable "hidden", which is a list of the rows
# which have been hidden from the displayer via filter operations, to restore
# the hidden entries. This is different from recover in that recover will
# perform a file read to restore all entries whether they've been filtered or
# dismissed, whereas unfilter will only restore entries which have been
# filtered but not dismissed.
#
# Note: Performing an unfilter causes incoming filter to be terminated as well
#------------------------------------------------------------------------------
proc Logger::Unfilter {} {
    global tbl
    global hidden
    global incoming
    global b2

    #
    # The first thing to do is to unset incoming filter (i.e. no more incoming
    # filtering will take place after an 'unfilter' command). Then we need to
    # see if anything has been filtered out by checking whether or not the
    # hidden array exists.
    #
    set incoming(on) 0
    if {[info exists hidden]} {
	for {set i 0} {$i < [llength $hidden]} {incr i} {
	    set row [lindex $hidden $i]
	    set entry [concat [lindex $row 0] [lindex $row 1] \
			   [lappend stuff [lindex $row 2] [lindex $row 3]] \
			   [lindex $row 4]]
	    Logger::Display_Event $entry
	    unset stuff
	}
	unset hidden
    }
    $b2 configure -state disabled
}

#------------------------------------------------------------------------------
# Logger::Recover
#
# This procedure allows a user to recover from a displayer restart. The logfile
# is accessed and its contents are read into local variables. The display's
# entries are searched and if the current logfile entry is not already in the
# tablelist, it is added to it. The same entry will thus never appear twice in
# the tablelist.
#------------------------------------------------------------------------------
proc Logger::Recover {} {
    global tbl
    global logfile
    global hidden
    global b4

    #
    # First access the logfile
    #
    if [catch {set file [open $logfile r]} result] {
	puts stderr $result
    } else {
	set done 0
	while {![eof $file] && !$done} {
	    for {set n 0} {$n < 5} {incr n} {
		gets $file line
		if {$line == ""} {
		    set done 1
		} else {
		    set item$n [string range $line 10 end]
		}
	    }
	    
	    set index 0
	    set present 0
	    if {!$done} {
		# 
		# Make sure the entry isn't already in the display!
		#
		foreach listEntry [$tbl get 0 end] {
		    if {$item0 == [lindex $listEntry 0] &&
			$item1 == [lindex $listEntry 1] &&
			$item2 == [lindex $listEntry 2] &&
			$item3 == [lindex $listEntry 4] &&
			$item4 == [lindex $listEntry 3]} {
			set present 1
		    }
		    incr index
		}
	    }
	    
	    # 
	    # If it isn't in the display yet, put it there
	    if {!$present && !$done} {
		Display_Event [lappend entry $item0 $item1 $item2 \
				   $item4 $item3]
		unset entry
	    }
	    gets $file junk
	}
    }
    #
    # This is necessary is case someone performs a recover, followed by an
    # unfilter. Once a recover has been performed, there's nothing that will
    # still be hidden by the filter
    #
    if {[info exists hidden]} {
	unset hidden
    }
    $b4 configure -state disabled
}

#------------------------------------------------------------------------------
# Logger::Display_Event
#
# This procedure insert the events into the tablelist for display. In the
# displayer, severity can have one of three different values: Success, Warning,
# or Error. Each severity is displayed in its own special color. If the array
# index incoming(on) is 1, then the user has previously indicated that they
# would like to incoming filter a set of conditions. Those conditions are
# stored in the list contained in incoming(val), and so after inserting the 
# entry into the displayer, a filter is immediately performed with those 
# criteria.
#------------------------------------------------------------------------------
proc Logger::Display_Event {entry} {
    global tbl
    global incoming

    #
    # Insert the entry into the tablelist displayer
    #
    $tbl insert end $entry
    set severity [lindex $entry 1]
    if {$severity == "Success"} {
	$tbl cellconfigure end,1 -foreground \#0d0
    } elseif {$severity == "Warning"} {
	$tbl cellconfigure end,1 -foreground \#fd0
    } else {
	$tbl cellconfigure end,1 -foreground red
    }

    #
    # If incoming filtering is selected, perform incoming filtering
    #
    if {$incoming(on)} {
	Logger::Perform_Filter $incoming(val)
    }
    $tbl sortbycolumn 3 -decreasing
}

#------------------------------------------------------------------------------
# proc Logger::Dialog_Create
#
# Creates a dialog box if it does not already exist. This is a trick which 
# prevents having to re-create the widget each time the dialog is popped up
# and speeds things up a little. Adapted from "Practical Programming in Tcl 
# and Tk" by Brent Welch
#------------------------------------------------------------------------------
proc Logger::Dialog_Create {top title args} {
    global dialog
    if [winfo exists $top] {
	switch -- [wm state $top] {
	    normal {
		raise $top
	    }
	    withdrawn -
	    iconified {
		wm deiconify $top
		catch {wm geometry $top $dialog(geo,$top)}
	    }
	}
	return 0
    } else {
	eval {toplevel $top} $args
	wm title $top $title
	return 1
    }
}

#------------------------------------------------------------------------------
# Logger::Dialog_Wait
#
# This procedure gives focus to the dialog box which expects a user response
# and wont allow the user to do anything else until they have responded (i.e. 
# do something in another frame).
#------------------------------------------------------------------------------
proc Logger::Dialog_Wait {top varName {focus {}}} {
    upvar $varName var
    bind $top <Destroy> [list set $varName $var]

    if {[string length $focus] == 0} {
	set focus $top
    }
    set old [focus -displayof $top]
    focus $focus
    catch {tkwait visibility $top}
    catch {grab $top}
    
    tkwait variable $varName
    catch {grab release $top}
    focus $old
}

#------------------------------------------------------------------------------
# Logger::Dialog_Dismiss
#
# Dismisses the dialog box from the screen.
#------------------------------------------------------------------------------
proc Logger::Dialog_Dismiss {top} {
    global dialog
    catch {
	set dialog(geo,$top) [wm geometry $top]
	wm withdraw $top
    }
}

#------------------------------------------------------------------------------
# Logger::Filter_Dialog_Prompt
#
# This procedure builds the actual filter dialog box and invokes Dialog_Wait
# to wait for a repsonse from the user. When Ok or Cancel is pressed, then
# control is returned to the caller and the filter options are returned to the
# calling function.
#------------------------------------------------------------------------------
proc Logger::Filter_Dialog_Prompt {} {
    global incoming
    global log_prompt
    global OkButton
    global CancelButton
    set f .log_prompt

    #
    # Check whether the dialog has already been created
    #
    if [Dialog_Create $f "Filter" -borderwidth 10 -height 180 -width 350] {

	#
	# These are the frames. By giving them short names, they are easier
	# to type, and keep track of. The letters stand for: 
	#   t - top
	#   b - bottom
	#   r - right
	#   l - left
	#   m - middle
	# So "t" is the top section of the toplevel frame, "tm" is the middle
	# section of frame "t", etc...
	#
	set t [frame $f.top -relief groove -borderwidth 4]
	set m [frame $f.mid -relief groove -borderwidth 4]
	set b [frame $f.bottom]

	set tt [frame $t.top -width 400 -height 35]
	set tm1 [frame $t.mid1 -width 400 -height 35]
	set tm2 [frame $t.mid2 -width 400 -height 35]
	set tb [frame $t.bot -width 400 -height 35]
	set mt [frame $m.top -width 400 -height 135 \
		   -relief ridge -borderwidth 2]
	set mb [frame $m.bot -width 400 -height 65 \
		   -relief ridge -borderwidth 2]

	set tm2t [frame $tm2.top]
	set tm2b [frame $tm2.bot]
	set mbt [frame $mb.top -width 400 -height 15]
	set mbb [frame $mb.bot -width 400 -height 70]
	set mbbl [frame $mbb.lft -width 50 -height 100]
	set mbbr [frame $mbb.rt  -width 350 -height 100]

	#
	# This allows us to set the height and width to exactly what we want
	#
	foreach frm "$tt $tm1 $tm2 $tb $mt $mb $mbt $mbb $mbbl $mbbr" {
	    pack propagate $frm false
	}

	pack $t $m $b -side top -fill x
	pack $tt $tm1 $tm2 $tb -side top -fill x
	pack $mt $mb -side top
	pack $tm2t $tm2b -side top -fill x
	pack $mbt $mbb -side top -fill x
	pack $mbbl $mbbr -side left -fill x

	#
	# Here are all the messages and buttons that appear in the dialog
	#
	message $tt.msg -text "Facility:   " -aspect 1000
	message $tm1.msg -text "Severity:" -aspect 1000
	message $tm2t.msg -text "Date:       " -aspect 1000
	message $tb.msg -text "Filter Incoming:" -aspect 1000
	message $mbt.msg -text "which were..." -aspect 1000
	entry $tt.entry1 -textvariable log_prompt(facility1) -bg white
	entry $tm2t.entry1 -textvariable log_prompt(month) -bg white -width 2
	entry $tm2t.entry2 -textvariable log_prompt(day) -bg white -width 2
	entry $tm2t.entry3 -textvariable log_prompt(year) -bg white -width 4
	label $tm2t.label1 -text "-"
	label $tm2t.label2 -text "-"
	checkbutton $tm1.b0 -text "Success" -fg \#0d0 \
	    -variable log_prompt(sevS) \
	    -onvalue Success -selectcolor blue -anchor sw
	checkbutton $tm1.b1 -text "Warning" -fg \#fd0 \
	    -variable log_prompt(sevW) \
	    -onvalue Warning -selectcolor blue -anchor sw
	checkbutton $tm1.b2 -text "Error" -fg red -variable log_prompt(sevE) \
	    -onvalue Error -selectcolor blue -anchor sw
	radiobutton $mt.rb0 -variable log_prompt(op1) \
	    -text "Show only this facility..." -value 0 \
	    -selectcolor blue
	radiobutton $mt.rb1 -variable log_prompt(op1) \
	    -text "Hide only this facility..." -value 1 \
	    -selectcolor blue
	radiobutton $mt.rb2 -variable log_prompt(op1) \
	    -text "Show only these severities..." \
	    -value 2 -selectcolor blue
	radiobutton $mt.rb3 -variable log_prompt(op1) \
	    -text "Show only this facility of these severities..." \
	    -value 3 -selectcolor blue
	radiobutton $mt.rb4 -variable log_prompt(op1) \
	    -text "Hide only this facility of these severities..." \
	    -value 4 -selectcolor blue
	radiobutton $mt.rb5 -variable log_prompt(op1) \
	    -text "Show all entries..." -value 5 -selectcolor blue
	radiobutton $mbbr.date1 -variable log_prompt(op2) \
	    -text "logged before this date." -value before \
	    -selectcolor blue
	radiobutton $mbbr.date2 -variable log_prompt(op2) \
	    -text "logged after this date." -value after -selectcolor blue
	label $tm2b.msg \
	    -text "                  MM - DD - YYYY" -wraplength 200
	checkbutton $tb.b0 -variable incoming(on) -onvalue 1 \
	    -offvalue 0 -selectcolor blue -anchor sw
	pack $tt.msg $tt.entry1 -side left -anchor nw
	pack $tm1.msg $tm1.b0 $tm1.b1 $tm1.b2 -side left -anchor nw
	pack $tm2t.msg $tm2t.entry1 $tm2t.label1 $tm2t.entry2 $tm2t.label2 \
	    $tm2t.entry3 -side left -anchor nw
	pack $tm2b.msg -side left -anchor n
	pack $tb.msg $tb.b0 -side left -anchor sw
	pack $mt.rb0 $mt.rb1 $mt.rb2 $mt.rb3 $mt.rb4 $mt.rb5 \
	    -side top -anchor nw
	pack $mbt.msg -side top -anchor nw
	pack $mbbr.date1 $mbbr.date2 -side top -anchor nw

	button $b.ok -image OkButton -command {set log_prompt(ok) 1}
	button $b.cancel -image CancelButton -command {set log_prompt(ok) 0}
	pack $b.cancel $b.ok -side right -anchor n
    }
    
    #
    # Now we have to wait for the user to do something 
    # (i.e. press "Ok" or "cancel")
    #
    set log_prompt(ok) 0
    set log_prompt(op1) -1
    set log_prompt(op2) none
    foreach item {log_prompt(sevS) log_prompt(sevW) log_prompt(sevE)} {
	set $item 0
    }
    Dialog_Wait $f log_prompt(ok) $f
    Dialog_Dismiss $f
    if {$log_prompt(ok)} {
	if {[string length $log_prompt(month)] == 0 ||
	    [string length $log_prompt(day)]   == 0 ||
	    [string length $log_prompt(year)]  == 0} {
	    set log_prompt(month) {} ; set log_prompt(day) {} ; \
		set log_prompt(year) {}
	}
	set severities [list $log_prompt(sevS) $log_prompt(sevW) \
			    $log_prompt(sevE)]
	set date [list $log_prompt(month) $log_prompt(day) $log_prompt(year)]
	set result [list $log_prompt(facility1) $severities $date \
			 $log_prompt(op1) $log_prompt(op2)]
	return $result
    } else {
	return 0
    }
}

#------------------------------------------------------------------------------
# This is the end of the function defs.
#------------------------------------------------------------------------------

#
# Check if the default "daq.log" file is there. If not, touch it so the user
# doesn't get an error message
#
set dir [exec ls]
foreach file $dir {
    if {$file == "daq.log"} {
	set logisthere 1
    }
}
if {![info exists logisthere]} {
    exec touch daq.log
}
set logfile [exec pwd]/daq.log
set incoming(on) 0
set argument1 [lindex $argv 1]
set argument2 [lindex $argv 2]
if {$argc == 2} {
    set argument ""
    set script_dir $argument1
} elseif {$argc == 3} {
    set argument $argument1
    set script_dir $argument2
}

#
# See if the user wants to access a different log file with the -l switch
#
if {[llength $argument]} {
    if {[string range $argument 0 1] == "-l"} {
	set logfile [string range $argument 2 end]
	puts "Using logfile $logfile"
	foreach file $dir {
	    if {$file == $logfile} {
		set newlogisthere 1
	    }
	}
	if {![info exists newlogisthere]} {
	    exec touch $logfile
	}
    } else {
	puts stderr "No such command line switch: [string range $argument 0 1]"
    }
}

# 
# Create some button images for global use
#
image create photo OkButton -format GIF \
    -file [file join $script_dir ../Images/OkButton.gif]
image create photo CancelButton -format GIF \
    -file [file join $script_dir ../Images/CancelButton.gif]

Hostlist::Init_List
Logger::Display
