<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>TCL/Tk Guest event loops.</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.2.15 -->
<center>
<a class="qindex" href="main.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; <a class="qindex" href="pages.html">Related Pages</a> &nbsp; </center>
<hr><a name="TCLGuests"><h2>TCL/Tk Guest event loops.</h2></a>

<p>
The framework allows you to include either a TCL (non GUI script engine) or Tk (GUI based script engine) in your application. To do this you must:<ul>
<li>Design the set of command extensions your application needs.<li>Write subclasses of <a class="el" href="classCDAQTCLProcessor.html">CDAQTCLProcessor</a> which implement these commands.<li>Write a subclass of either <a class="el" href="classCTCLInterpreterStartup.html">CTCLInterpreterStartup</a> (non GUI script engine) or CTKInterpreterstartup (GUI script engine) which instantiates your command extensions and registers them with the interpreter.<li>Instantiate your extension of the C*Interpreterstartup class to create and start an interpreter.</ul>
<a name="TclCommandProcessors"><h2>Writing CDAQTCLProcessor extensions.</h2></a>

<p>
It is important that user written extensions to the Tcl/Tk command interpreter. This is done automatically by deriving your command extensions from  <a class="el" href="classCDAQTCLProcessor.html">CDAQTCLProcessor</a>. There are two member functions which must be written:<ul>
<li>The constructor which determines the command keyword (or name).<li>The function call operator (operator()), which gets control when the  command keyword has been recognized by the Tcl/Tk interpreter.</ul>
See <a class="el" href="classCDAQTCLProcessor.html#a0">CDAQTCLProcessor::CDAQTCLProcessor</a> for the call signature of the base class constructor. The parameters are: <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>Command</em>&nbsp;</td><td>
- A specification of the command (char* or string&amp;). </td></tr>
<tr><td valign=top><em>pInterp</em>&nbsp;</td><td>
- A pointer to the interpreter object.</td></tr>
</table>
</dl>The function call operator (operator()) is called when the command  registered by an object has been recognized. The parameters of this function are: <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>rInterpreter</em>&nbsp;</td><td>
- A reference to the <a class="el" href="classCTCLInterpreter.html">interpreter  	object</a> which invoked this command. The interpreter provides several facilities including subscriptexecution support, and parameter parsing utilities. </td></tr>
<tr><td valign=top><em>rResult</em>&nbsp;</td><td>
- A refereince to the interpreter's <a class="el" href="classCTCLResult.html">result 	object.</a> The result object is used to return information from the command to the invoking script. In the event of an error, the error message associated with the error should be returned in the result object. </td></tr>
<tr><td valign=top><em>argc</em>&nbsp;</td><td>
- The number of words in the command (after the interpreter's round of substitutions). </td></tr>
<tr><td valign=top><em>argv</em>&nbsp;</td><td>
- A pointer to a list of pointers to the characters strings which represent the words of the command. Note that the 'first' of these is the command itself.</td></tr>
</table>
</dl>The function call operator must return an int which is one of:<ul>
<li>TCL_OK - The command completed successfully and script execution can continue<li>TCL_ERROR - The command failed, script execution should terminate unless the command was invoked within a catch command.</ul>
<a name="TclInterpreters"><h2>Writing the interpreter startup functions</h2></a>

<p>
This section describes the member functions you may need to override when  deriving your command interpreter startup class (subclass of either <a class="el" href="classCTCLInterpreterStartup.html">CTCLInterpreterStartup</a> or <a class="el" href="classCTKInterpreterStartup.html">CTKInterpreterStartup</a>). The functions you may need to write are:<ul>
<li><a class="el" href="classCInterpreterStartup.html#b0">OnInitialize</a> which is called to allow you a chance to process command line parameters and do other pre-interpreter startup initializations.<li><a class="el" href="classCInterpreterStartup.html#b1">which is called after the   Tcl/Tk interpreter has been created and initialized and is intended to be   the member in which you instantiate and register your command extensions.  \section OnInitialize  	OnInitialize()</a> member function.</ul>
This member function is called prior to the creation and initialization of the interpreter object. The parameters passed to this member are: <dl compact><dt><b>
Parameters: </b><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>argc</em>&nbsp;</td><td>
- Number of command line parameters with which to invoke the interpreter. </td></tr>
<tr><td valign=top><em>argv</em>&nbsp;</td><td>
- char** pointer to the list of pointers to the parameter strings.</td></tr>
</table>
</dl><a name="RegisterExtensions"><h3>The</h3></a>
 <a class="el" href="classCInterpreterStartup.html#b1">RegisterExtensions()</a> member function.
<p>
Once the interpreter has been created and initialized, the framework calls RegisterExtensions with no parameters. The interpreter can be retrieved via <a class="el" href="classCInterpreterStartup.html#a2">getInterpreter().</a> In this function you should provide code to make instances of your command processors and register them with the interpreter. A normal tactic is to use new to  instantiate a processor, save the processor's pointer as member data which is deleted' by the destructor.
<p>
<a name="TclExample"><h2>Example application.</h2></a>

<p>
The sample application in this section shows how to create a Tcl interpreter as a guest event loop. A simple Echo command is added which simply takes  command parameters and places them in the result.
<p>
<div class="fragment"><pre><font class="comment">//</font>
<font class="comment">// Test program for the CTCLInterpreterStartup.</font>
<font class="comment">//   We start up a TCL interpreter in its own thread</font>
<font class="comment">//   and register the Echo command extension as a synchronized</font>
<font class="comment">//   extension.</font>
<font class="comment">//   The program should also understand the sync command.</font>
<font class="comment">//</font>

<font class="preprocessor">#include &lt;spectrodaq.h&gt;</font>
<font class="preprocessor">#include &lt;iostream.h&gt;</font>
<font class="preprocessor">#include &lt;<a class="code" href="CTCLInterpreterStartup_8h.html">CTCLInterpreterStartup.h</a>&gt;</font>


<font class="preprocessor">#include &lt;<a class="code" href="CDAQTCLProcessor_8h.html">CDAQTCLProcessor.h</a>&gt;</font>



<font class="keyword">class </font>TCLExtension : <font class="keyword">public</font> <a class="code" href="classCDAQTCLProcessor.html">CDAQTCLProcessor</a>
{

<font class="keyword">public</font>:
  TCLExtension(<a class="code" href="classCTCLInterpreter.html">CTCLInterpreter</a>* pInterp);
  <font class="keyword">virtual</font> <font class="keywordtype">int</font>  <a class="code" href="classCTCLProcessor.html#a7">operator() </a>(<a class="code" href="classCTCLInterpreter.html">CTCLInterpreter</a> &amp;rInterpreter, <a class="code" href="classCTCLResult.html">CTCLResult</a> &amp;rResult, 
                           <font class="keywordtype">int</font> nArguments, <font class="keywordtype">char</font> *pArguments[]);

};


TCLExtension::TCLExtension(<a class="code" href="classCTCLInterpreter.html">CTCLInterpreter</a>* pInterp) :
  <a class="code" href="classCDAQTCLProcessor.html">CDAQTCLProcessor</a>("Echo", pInterp)
{
}

<font class="keywordtype">int</font>
<a class="code" href="classCTCLProcessor.html#a7">TCLExtension::operator() </a>(<a class="code" href="classCTCLInterpreter.html">CTCLInterpreter</a> &amp;rInterpreter, <a class="code" href="classCTCLResult.html">CTCLResult</a> &amp;rResult, 
                          <font class="keywordtype">int</font> nArguments, <font class="keywordtype">char</font> *pArguments[])
{
  <font class="keywordflow">for</font>(<font class="keywordtype">int</font> i = 1; i &lt; nArguments; i++) {
    rResult.<a class="code" href="classCTCLResult.html#a13">AppendElement</a>(pArguments[i]);
  }
  <font class="keywordflow">return</font> TCL_OK;
}




<font class="keyword">class </font>MyInterpThread : <font class="keyword">public</font> <a class="code" href="classCTCLInterpreterStartup.html">CTCLInterpreterStartup</a>
{
  TCLExtension* m_pCommand;
<font class="keyword">protected</font>:
  <font class="keyword">virtual</font> <font class="keywordtype">void</font>  <a class="code" href="classCInterpreterStartup.html#b1">RegisterExtensions</a> () {
    cerr &lt;&lt; <font class="stringliteral">"Registering extensions\n"</font>;
    cerr.flush();
    m_pCommand = <font class="keyword">new</font> TCLExtension(<a class="code" href="classCInterpreterStartup.html#a2">getInterpreter</a>());
    m_pCommand-&gt;Register();
    cerr &lt;&lt; <font class="stringliteral">"Registering base class extensions\n"</font>;
    cerr.flush();
    <a class="code" href="classCInterpreterStartup.html#b1">CTCLInterpreterStartup::RegisterExtensions</a>();
    cerr &lt;&lt; <font class="stringliteral">"Returning to TCL Main loop\n"</font>;
    cerr.flush();
  }
};

<font class="keyword">class </font>App : <font class="keyword">public</font> DAQROCNode
{
  <font class="keyword">virtual</font> <font class="keywordtype">int</font>  operator() (<font class="keywordtype">int</font> argc, <font class="keywordtype">char</font> **argv) {
    MyInterpThread Tcl;
    DAQThreadId tid = daq_dispatcher.Dispatch(Tcl);

    DAQStatus stat;
    Join(tid, &amp;stat);
    cerr &lt;&lt; <font class="stringliteral">"Tcl interpreter exited"</font> &lt;&lt; stat.GetStatusCode() &lt;&lt; endl;
    <font class="keywordflow">return</font> 0;
  }

};

App theApp;
</pre></div>
<p>
<a name="TkExample"><h2>example application</h2></a>

<p>
This sample application is the same as the one shown in section TclExample, however a Tk interpreter is started up rather  than a Tcl interpreter. This provides the capability of a scripted GUI for the application.
<p>
<div class="fragment"><pre><font class="comment">//</font>
<font class="comment">// Test program for the CTCLInterpreterStartup.</font>
<font class="comment">//   We start up a TCL interpreter in its own thread</font>
<font class="comment">//   and register the Echo command extension as a synchronized</font>
<font class="comment">//   extension.</font>
<font class="comment">//   The program should also understand the sync command.</font>
<font class="comment">//</font>

<font class="preprocessor">#include &lt;spectrodaq.h&gt;</font>
<font class="preprocessor">#include &lt;iostream.h&gt;</font>
<font class="preprocessor">#include &lt;<a class="code" href="CTKInterpreterStartup_8h.html">CTKInterpreterStartup.h</a>&gt;</font>


<font class="preprocessor">#include &lt;<a class="code" href="CDAQTCLProcessor_8h.html">CDAQTCLProcessor.h</a>&gt;</font>



<font class="keyword">class </font>TCLExtension : <font class="keyword">public</font> <a class="code" href="classCDAQTCLProcessor.html">CDAQTCLProcessor</a>
{

<font class="keyword">public</font>:
  TCLExtension(<a class="code" href="classCTCLInterpreter.html">CTCLInterpreter</a>* pInterp);
  <font class="keyword">virtual</font> <font class="keywordtype">int</font>  <a class="code" href="classCTCLProcessor.html#a7">operator() </a>(<a class="code" href="classCTCLInterpreter.html">CTCLInterpreter</a> &amp;rInterpreter, <a class="code" href="classCTCLResult.html">CTCLResult</a> &amp;rResult, 
                           <font class="keywordtype">int</font> nArguments, <font class="keywordtype">char</font> *pArguments[]);

};


TCLExtension::TCLExtension(<a class="code" href="classCTCLInterpreter.html">CTCLInterpreter</a>* pInterp) :
  <a class="code" href="classCDAQTCLProcessor.html">CDAQTCLProcessor</a>("Echo", pInterp)
{
}

<font class="keywordtype">int</font>
<a class="code" href="classCTCLProcessor.html#a7">TCLExtension::operator() </a>(<a class="code" href="classCTCLInterpreter.html">CTCLInterpreter</a> &amp;rInterpreter, <a class="code" href="classCTCLResult.html">CTCLResult</a> &amp;rResult, 
                          <font class="keywordtype">int</font> nArguments, <font class="keywordtype">char</font> *pArguments[])
{
  <font class="keywordflow">for</font>(<font class="keywordtype">int</font> i = 1; i &lt; nArguments; i++) {
    rResult.<a class="code" href="classCTCLResult.html#a13">AppendElement</a>(pArguments[i]);
  }
  <font class="keywordflow">return</font> TCL_OK;
}




<font class="keyword">class </font>MyInterpThread : <font class="keyword">public</font> <a class="code" href="classCTKInterpreterStartup.html">CTKInterpreterStartup</a>
{
  TCLExtension* m_pCommand;
<font class="keyword">protected</font>:
  <font class="keyword">virtual</font> <font class="keywordtype">void</font>  <a class="code" href="classCInterpreterStartup.html#b1">RegisterExtensions</a> () {
    cerr &lt;&lt; <font class="stringliteral">"Registering extensions\n"</font>;
    cerr.flush();
    m_pCommand = <font class="keyword">new</font> TCLExtension(<a class="code" href="classCInterpreterStartup.html#a2">getInterpreter</a>());
    m_pCommand-&gt;Register();
    cerr &lt;&lt; <font class="stringliteral">"Registering base class extensions\n"</font>;
    cerr.flush();
    <a class="code" href="classCInterpreterStartup.html#b1">CTKInterpreterStartup::RegisterExtensions</a>();
    cerr &lt;&lt; <font class="stringliteral">"Returning to TCL Main loop\n"</font>;
    cerr.flush();
  }
};

<font class="keyword">class </font>App : <font class="keyword">public</font> DAQROCNode
{
  <font class="keyword">virtual</font> <font class="keywordtype">int</font>  operator() (<font class="keywordtype">int</font> argc, <font class="keywordtype">char</font> **argv) {
    MyInterpThread Tcl;
    DAQThreadId tid = daq_dispatcher.Dispatch(Tcl);

    DAQStatus stat;
    Join(tid, &amp;stat);
    cerr &lt;&lt; <font class="stringliteral">"Tcl interpreter exited"</font> &lt;&lt; stat.GetStatusCode() &lt;&lt; endl;
    <font class="keywordflow">return</font> 0;
  }

};

App theApp;
</pre></div>
<p>
<hr><address align="right"><small>Generated on Tue Feb 4 12:35:50 2003 for Spectrodaq External Event Framework by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.15 </small></address>
</body>
</html>
