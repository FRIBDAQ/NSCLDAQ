\section{CSocket  Class Reference}
\label{classCSocket}\index{CSocket@{CSocket}}
{\tt \#include $<$CSocket.h$>$}

\subsection*{Public Types}
\begin{CompactItemize}
\item 
enum {\bf State} \{ {\bf Disconnected}, 
{\bf Bound}, 
{\bf Listening}, 
{\bf Connected}
 \}
\begin{CompactList}\small\item\em Captures the state of the socket. See general remarks for more info.\item\end{CompactList}\end{CompactItemize}
\subsection*{Public Methods}
\begin{CompactItemize}
\item 
{\bf CSocket} ()
\item 
{\bf CSocket} (int am\_\-Fd, {\bf CSocket::State} am\_\-State)
\item 
virtual {\bf $\sim$CSocket} ()
\item 
int {\bf get\-Socket\-Fd} () const
\begin{CompactList}\small\item\em Get accessor function socket file descriptor.\item\end{CompactList}\item 
{\bf CSocket::State} {\bf get\-State} () const
\begin{CompactList}\small\item\em Get accessor function for socket state.\item\end{CompactList}\item 
void {\bf Connect} (const string \&host, const string \&service)
\item 
void {\bf Connect} (unsigned long int Ip\-Address, unsigned short service)
\item 
void {\bf Bind} (const string \&service)
\item 
void {\bf Listen} (unsigned int n\-Backlog=5)
\item 
CSocket $\ast$ {\bf Accept} (string \&client)
\item 
void {\bf Shutdown} ()
\item 
int {\bf Read} (void $\ast$p\-Buffer, size\_\-t n\-Bytes)
\item 
int {\bf Write} (void $\ast$p\-Buffer, size\_\-t n\-Bytes)
\item 
void {\bf get\-Peer} (unsigned short \&port, string \&peer)
\item 
void {\bf OOBInline} (bool {\bf State}=TRUE)
\item 
bool {\bf is\-OOBInline} ()
\item 
void {\bf set\-Rcv\-Low\-Water\-Mark} (size\_\-t n\-Bytes)
\item 
size\_\-t {\bf get\-Rcv\-Low\-Water\-Mark} ()
\item 
void {\bf set\-Snd\-Low\-Water\-Mark} (size\_\-t n\-Bytes)
\item 
size\_\-t {\bf get\-Snd\-Low\-Water\-Mark} ()
\item 
void {\bf set\-Rcv\-Timeout} (unsigned int n\-Ms)
\item 
unsigned int {\bf get\-Rcv\-Timeout} ()
\item 
void {\bf set\-Snd\-Timeout} (unsigned int n\-Ms)
\item 
unsigned int {\bf get\-Snd\-Timeout} ()
\item 
void {\bf Debug} (bool f\-State=TRUE)
\item 
bool {\bf is\-Debug} ()
\item 
void {\bf Set\-Not\-Routable} (bool f\-Routable=TRUE)
\item 
bool {\bf is\-Not\-Routable} ()
\item 
void {\bf set\-Snd\-Buf\-Size} (size\_\-t n\-Buffer\-Size)
\item 
size\_\-t {\bf get\-Snd\-Buf\-Size} ()
\item 
void {\bf set\-Rcv\-Buf\-Size} (size\_\-t n\-Bytes)
\item 
size\_\-t {\bf get\-Rcv\-Buf\-Size} ()
\item 
void {\bf set\-Linger} (bool l\-On, int n\-Linger\-Seconds)
\item 
void {\bf get\-Linger} (bool \&is\-Lingering, int \&n\-Linger\-Seconds)
\end{CompactItemize}
\subsection*{Static Public Methods}
\begin{CompactItemize}
\item 
string {\bf State\-Name} ({\bf CSocket::State} state)
\end{CompactItemize}
\subsection*{Protected Methods}
\begin{CompactItemize}
\item 
void {\bf set\-Socket\-Fd} (const int am\_\-Fd)
\begin{CompactList}\small\item\em Set accessor function for Socket file descriptor.\item\end{CompactList}\item 
void {\bf set\-State} (const {\bf CSocket::State} am\_\-State)
\begin{CompactList}\small\item\em Set accessor function for current socket state.\item\end{CompactList}\item 
unsigned short {\bf Service} (const string \&r\-Service)
\item 
string {\bf Address\-To\-Host\-String} (in\_\-addr peer)
\item 
void {\bf Open\-Socket} ()
\end{CompactItemize}
\subsection*{Static Protected Methods}
\begin{CompactItemize}
\item 
void {\bf Stock\-State\-Map} ()
\end{CompactItemize}
\subsection*{Private Methods}
\begin{CompactItemize}
\item 
{\bf CSocket} (const CSocket \&a\-CSocket)
\begin{CompactList}\small\item\em Copy Constructor forbidden.\item\end{CompactList}\item 
CSocket \& {\bf operator=} (const CSocket \&a\-CSocket)
\begin{CompactList}\small\item\em Assignment Operator Forbidden.\item\end{CompactList}\item 
int {\bf operator==} (const CSocket \&a\-CSocket) const
\begin{CompactList}\small\item\em Equality Operator Forbidden.\item\end{CompactList}\end{CompactItemize}
\subsection*{Private Attributes}
\begin{CompactItemize}
\item 
int {\bf m\_\-Fd}
\begin{CompactList}\small\item\em Socket.\item\end{CompactList}\item 
{\bf CSocket::State} {\bf m\_\-State}
\begin{CompactList}\small\item\em State of socket.\item\end{CompactList}\end{CompactItemize}
\subsection*{Static Private Attributes}
\begin{CompactItemize}
\item 
map$<$ {\bf CSocket::State}, string $>$ {\bf m\_\-State\-Names}
\begin{CompactList}\small\item\em State name lookup tbl.\item\end{CompactList}\end{CompactItemize}


\subsection{Detailed Description}
Encapsulates a generalized TCP/IP SOCK\_\-STREAM socket.  Note that TCP/IP Sockets can come in two flavors: Clients and Servers. Clients must perform a connect, while servers perform a bind, listen and then serveral accepts to create 'server instances'. The state of a socket is maintained in the m\_\-State variable and is from the enumerator: {\bf CSocket::State} {\rm (p.\,\pageref{classCSocket_s4})}

\begin{CompactItemize}
\item 
Disconnected: The socket is not connected to anything.\item 
Bound: The socket is a server socket which is not connected, but has been bound to a service port.\item 
Listening: The socket is a server port which is listening and can therefore accept connections\item 
Connected The socket is either a client or a  server instance and is connected to it's counterpart. \end{CompactItemize}




Definition at line 338 of file CSocket.h.

\subsection{Member Enumeration Documentation}
\index{CSocket@{CSocket}!State@{State}}
\index{State@{State}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}enum CSocket::State}\label{classCSocket_s4}


Captures the state of the socket. See general remarks for more info.

\begin{Desc}
\item[Enumeration values:]\par
\begin{description}
\index{Disconnected@{Disconnected}!CSocket@{CSocket}}\index{CSocket@{CSocket}!Disconnected@{Disconnected}}\item[{\em 
{\em Disconnected}\label{classCSocket_s4s0}
}]\index{Bound@{Bound}!CSocket@{CSocket}}\index{CSocket@{CSocket}!Bound@{Bound}}\item[{\em 
{\em Bound}\label{classCSocket_s4s1}
}]\index{Listening@{Listening}!CSocket@{CSocket}}\index{CSocket@{CSocket}!Listening@{Listening}}\item[{\em 
{\em Listening}\label{classCSocket_s4s2}
}]\index{Connected@{Connected}!CSocket@{CSocket}}\index{CSocket@{CSocket}!Connected@{Connected}}\item[{\em 
{\em Connected}\label{classCSocket_s4s3}
}]\end{description}
\end{Desc}



Definition at line 343 of file CSocket.h.

Referenced by CSocket(), CTCPBad\-Socket\-State::CTCPBad\-Socket\-State(), CTCPBad\-Socket\-State::get\-Bad\-State(), get\-State(), OOBInline(), CTCPBad\-Socket\-State::set\-Bad\-State(), set\-State(), and State\-Name().

\subsection{Constructor \& Destructor Documentation}
\index{CSocket@{CSocket}!CSocket@{CSocket}}
\index{CSocket@{CSocket}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}CSocket::CSocket ()}\label{classCSocket_a0}


The default constructor initializes the fd to an illegal value and sets the state to Disconnected.  The body of the constructor attempts to set the m\_\-Fd member via a call to  socket(2) to create an INET domain SOCK\_\-STREAM, protocl tcp.

It is up to the user to call Connect or alternatively set up the socket as a server by binding and listening.

Exceptions:

\begin{CompactItemize}
\item 
{\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})} if getprotoent for tcp fails or if the socket call itself fails. \end{CompactItemize}


Definition at line 365 of file CSocket.cpp.

References Open\-Socket().

Referenced by Accept().\index{CSocket@{CSocket}!CSocket@{CSocket}}
\index{CSocket@{CSocket}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}CSocket::CSocket (int {\em am\_\-Fd}, {\bf CSocket::State} {\em am\_\-State})}\label{classCSocket_a1}


This parameterized constructor is intended to allow a program which already has created a socket in some arbitrary state to wrap it inside a CSocket object. It must be used with care.. in the sense that the am\_\-State parameter must match the actual socket state.\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
am\_\-Fd}]The file descriptor already open on a socket. \item[{\em 
am\_\-State}]The current state of the socket am\_\-Fd \end{description}
\end{Desc}


Definition at line 398 of file CSocket.cpp.

References State, and Stock\-State\-Map().\index{CSocket@{CSocket}!~CSocket@{$\sim$CSocket}}
\index{~CSocket@{$\sim$CSocket}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}CSocket::$\sim$CSocket ()\hspace{0.3cm}{\tt  [virtual]}}\label{classCSocket_a2}


Destructor action depends on the state: sockets which are Connected are shutdown and then closed. Sockets which are in other states are just closed if the fd $>$ 0. 

Definition at line 378 of file CSocket.cpp.\index{CSocket@{CSocket}!CSocket@{CSocket}}
\index{CSocket@{CSocket}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}CSocket::CSocket (const CSocket \& {\em a\-CSocket})\hspace{0.3cm}{\tt  [private]}}\label{classCSocket_c0}


Copy Constructor forbidden.



\subsection{Member Function Documentation}
\index{CSocket@{CSocket}!Accept@{Accept}}
\index{Accept@{Accept}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}CSocket $\ast$ CSocket::Accept (string \& {\em client})}\label{classCSocket_a9}


This member function can be called on  a server socket. The calling thread is blocked until a connection request is received. At that time, the connection is accepted (granted), and a new CSocket is created in the Connected state. The new CSocket represents a Server Instance socket, communication along that socket can take place immediately and will represent communication with the client.

Exceptions which can be thrown:

\begin{CompactItemize}
\item 
{\bf CTCPBad\-Socket\-State} {\rm (p.\,\pageref{classCTCPBadSocketState})} m\_\-State != Listening\item 
{\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})} accept(2) call failed.\end{CompactItemize}
Side effects:

The client parameter is  written with a string representing the hostname of the client or the IP address if the hostname can not be determined.

The socket created is created via new, therefore  it is the responsibility of the caller to delete it.\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
client}]Recieves the IP information of the connecting host. Where possible, this is the hostname. Where not, a dotted IP address. \end{description}
\end{Desc}


Definition at line 659 of file CSocket.cpp.

References Address\-To\-Host\-String(), Connected, CSocket(), Listening, m\_\-Fd, and m\_\-State.

Referenced by CServer\-Connection\-Event::On\-Readable().\index{CSocket@{CSocket}!AddressToHostString@{AddressToHostString}}
\index{AddressToHostString@{AddressToHostString}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}string CSocket::Address\-To\-Host\-String (in\_\-addr {\em peer})\hspace{0.3cm}{\tt  [protected]}}\label{classCSocket_b3}


Purpose: Given an IP address in in\_\-addr format, returns a string describing the address. First gethostbyaddr(3) is used to attempt to get the primary DNS name of the address. If this fails, then inet\_\-ntoa(3) is called to get a dotted string. Note that this entire function must run syncrhonized to the global application mutex since the (3) network database calls are assumed to be nonthreadsafe.\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
peer}]- The network address of a host in in\_\-addr, network byte order form. \end{description}
\end{Desc}


Definition at line 1503 of file CSocket.cpp.

References CApplication\-Serializer::get\-Instance(), CThread\-Recursive\-Mutex::Lock(), and CThread\-Recursive\-Mutex::Un\-Lock().

Referenced by Accept(), and get\-Peer().\index{CSocket@{CSocket}!Bind@{Bind}}
\index{Bind@{Bind}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CSocket::Bind (const string \& {\em service})}\label{classCSocket_a7}


Indicates that the socket will be used as a server listener socket, and binds it to a service port. The service can be provided either as a numerical string or as a string translated via getservbyname().

The following exceptions can be thrown:

\begin{CompactItemize}
\item 
{\bf CTCPBad\-Socket\-State} {\rm (p.\,\pageref{classCTCPBadSocketState})} m\_\-State != Disconnected\item 
{\bf CTCPNo\-Such\-Service} {\rm (p.\,\pageref{classCTCPNoSuchService})} Service could not be determined.\item 
{\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})} bind(2) failed.\end{CompactItemize}
On success, m\_\-State = Bound 

Definition at line 562 of file CSocket.cpp.

References Bound, Disconnected, m\_\-Fd, m\_\-State, and Service().

Referenced by CServer\-Connection\-Event::Configure\-Socket().\index{CSocket@{CSocket}!Connect@{Connect}}
\index{Connect@{Connect}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CSocket::Connect (unsigned long int {\em Ip\-Address}, unsigned short {\em service})}\label{classCSocket_a6}


Connects a socket as a client given numerical host, and port numbers in  host byte order. For the host that means that an ip address of form:

aa.bb.cc.dd is stored Hi-$>$Low as aabbccdd in a longword.

See {\bf Connect}(const string\&host, const string\& service) {\rm (p.\,\pageref{classCSocket_a5})} for more information.\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
Ip\-Address}]The numerical ip address of the server in host byte order. \item[{\em 
service}]The port number of the service. \end{description}
\end{Desc}


Definition at line 495 of file CSocket.cpp.

References Connected, Disconnected, CApplication\-Serializer::get\-Instance(), CThread\-Recursive\-Mutex::Lock(), m\_\-Fd, m\_\-State, and CThread\-Recursive\-Mutex::Un\-Lock().\index{CSocket@{CSocket}!Connect@{Connect}}
\index{Connect@{Connect}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CSocket::Connect (const string \& {\em host}, const string \& {\em service})}\label{classCSocket_a5}


Operation Type: Connection Control

Indicates that the socket will be used as a client socket and attempts to connect it to a server.  The address of the server can be passed in either in IP address or IP name textual format. Similarly, the port can be passed in as a textual port name (in /etc/services) or a port number.

The action of this function is to convert (if possible) the Host and service  into numeric equivalents and call the overloaded Connect(int Ip\-Address, int service)

Exceptions which can be thrown:

\begin{CompactItemize}
\item 
{\bf CTCPBad\-Socket\-State} {\rm (p.\,\pageref{classCTCPBadSocketState})} -- m\_\-State was not Disconnected\item 
{\bf CTCPNo\-Such\-Host} {\rm (p.\,\pageref{classCTCPNoSuchHost})} - Host not in DNS or nonexistent.\item 
{\bf CTCPNo\-Such\-Service} {\rm (p.\,\pageref{classCTCPNoSuchService})} - Named service does not translate.\item 
{\bf CTCPConnection\-Failed} {\rm (p.\,\pageref{classCTCPConnectionFailed})}- Connection refused by remote host (from Connect(int Ip\-Address, int service).\end{CompactItemize}
\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
host}]Specifies the system to connect to. This can be either a DNS textual name or a string in dotted IP address format. \item[{\em 
service}]Specifies a service offered by the host. This can be either a service name or the textual equivalent of a service number.\end{description}
\end{Desc}
On Success the socket state is set to Connected. 

Definition at line 443 of file CSocket.cpp.

References Disconnected, CApplication\-Serializer::get\-Instance(), CThread\-Recursive\-Mutex::Lock(), m\_\-State, Service(), and CThread\-Recursive\-Mutex::Un\-Lock().

Referenced by CLogger::Log(), and CAlarm\-Logger::Log().\index{CSocket@{CSocket}!Debug@{Debug}}
\index{Debug@{Debug}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CSocket::Debug (bool {\em f\-State} = TRUE)}\label{classCSocket_a24}


Purpose:

Attempts to turn on Socket debugging. To support this. The user must have effective UID = 0. .

Throws:\begin{CompactItemize}
\item 
{\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})} if an error was returned from setsockopt(2) At present we don't know of systems which don't implement this so all errors will throw.\end{CompactItemize}
\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
f\-State}][TRUE] Desired state of debugging. TRUE will cause debugging to be turned on. FALSE turned off. \end{description}
\end{Desc}


Definition at line 1193 of file CSocket.cpp.

References m\_\-Fd, and TRUE.\index{CSocket@{CSocket}!getLinger@{getLinger}}
\index{getLinger@{getLinger}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CSocket::get\-Linger (bool \& {\em is\-Lingering}, int \& {\em n\-Linger\-Seconds})}\label{classCSocket_a33}


Purpose:

Retrieve the linger parameters.

Throws:\begin{CompactItemize}
\item 
{\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})} if the setsockopt(2) call failed.\end{CompactItemize}
\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
is\-Lingering}][out] Receives the value of the linger state:\begin{CompactItemize}
\item 
TRUE linger is enabled.\item 
FALSE linger is not enabled. \end{CompactItemize}
\end{description}
\end{Desc}
\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
n\-Linger\-Seconds}][out] Receives the value of the linger timeout. This only has meaning in the event that is\-Lingering == TRUE. \end{description}
\end{Desc}


Definition at line 1441 of file CSocket.cpp.

References m\_\-Fd.\index{CSocket@{CSocket}!getPeer@{getPeer}}
\index{getPeer@{getPeer}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CSocket::get\-Peer (unsigned short \& {\em port}, string \& {\em peer})}\label{classCSocket_a13}


Purpose:

Returns information about who a socket is connected to. If the socket is not connected, {\bf CTCPBad\-Socket\-State} {\rm (p.\,\pageref{classCTCPBadSocketState})} is thrown. If possible, the peername parameter is returned as a string containing the DNS name of the peer. If the DNS lookup fails, the IP address is converted into dotted form.\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
port}]The number of the port to which the socket is connected. \item[{\em 
peer}]The peer as either a DNS hostname or a dotted IP address.\end{description}
\end{Desc}
Throws:\begin{CompactItemize}
\item 
{\bf CTCPBad\-Socket\-State} {\rm (p.\,\pageref{classCTCPBadSocketState})} if m\_\-State != Connected\item 
{\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})} if getpeeername(2) failed. \end{CompactItemize}


Definition at line 870 of file CSocket.cpp.

References Address\-To\-Host\-String(), Connected, m\_\-Fd, and m\_\-State.

Referenced by CServer\-Instance::get\-Peername(), and CServer\-Instance::get\-Peer\-Port().\index{CSocket@{CSocket}!getRcvBufSize@{getRcvBufSize}}
\index{getRcvBufSize@{getRcvBufSize}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}size\_\-t CSocket::get\-Rcv\-Buf\-Size ()}\label{classCSocket_a31}


Purpose:

Returns the maximum number of bytes which can be  recieved in a single read(2) call.

Throws:\begin{CompactItemize}
\item 
{\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})} if getsockopt(2) fails. \end{CompactItemize}


Definition at line 1375 of file CSocket.cpp.

References m\_\-Fd.\index{CSocket@{CSocket}!getRcvLowWaterMark@{getRcvLowWaterMark}}
\index{getRcvLowWaterMark@{getRcvLowWaterMark}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}size\_\-t CSocket::get\-Rcv\-Low\-Water\-Mark ()}\label{classCSocket_a17}


Returns the size of the current receive low water mark. See set\-Rcv\-Low\-Water\-Mark for information about what this parameter does. Note that the value returned is inquired from the socket rather than stored in internal state.

Throws:\begin{CompactItemize}
\item 
{\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})} if an error from getsockopt is detected. \end{CompactItemize}


Definition at line 997 of file CSocket.cpp.

References m\_\-Fd.\index{CSocket@{CSocket}!getRcvTimeout@{getRcvTimeout}}
\index{getRcvTimeout@{getRcvTimeout}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}unsigned int CSocket::get\-Rcv\-Timeout ()}\label{classCSocket_a21}


Purpose:

Retrieve the protocol receive timeout. The time out is returned as an integer number of milliseconds.

Throws:\begin{CompactItemize}
\item 
{\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})} if getsockopt(3) returns an error. \end{CompactItemize}


Definition at line 1098 of file CSocket.cpp.

References m\_\-Fd.\index{CSocket@{CSocket}!getSndBufSize@{getSndBufSize}}
\index{getSndBufSize@{getSndBufSize}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}size\_\-t CSocket::get\-Snd\-Buf\-Size ()}\label{classCSocket_a29}


Purpose:

Returns the number of bytes that can be written in a single write(2) call.

Throws:\begin{CompactItemize}
\item 
{\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})} if getsockopt(2) fails. \end{CompactItemize}


Definition at line 1326 of file CSocket.cpp.

References m\_\-Fd.\index{CSocket@{CSocket}!getSndLowWaterMark@{getSndLowWaterMark}}
\index{getSndLowWaterMark@{getSndLowWaterMark}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}size\_\-t CSocket::get\-Snd\-Low\-Water\-Mark ()}\label{classCSocket_a19}


Return the value of the current Send Low Water Mark Set set\-Snd\-Low\-Water\-Marrk for more information.

Throws:\begin{CompactItemize}
\item 
{\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})} if an error from getsockopt is detected. \end{CompactItemize}


Definition at line 1044 of file CSocket.cpp.

References m\_\-Fd.\index{CSocket@{CSocket}!getSndTimeout@{getSndTimeout}}
\index{getSndTimeout@{getSndTimeout}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}unsigned int CSocket::get\-Snd\-Timeout ()}\label{classCSocket_a23}


Purpose:

Returns the current send timeout in ms.

Throws:\begin{CompactItemize}
\item 
{\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})} if there was an error in getsockopt(2). \end{CompactItemize}


Definition at line 1159 of file CSocket.cpp.

References m\_\-Fd.\index{CSocket@{CSocket}!getSocketFd@{getSocketFd}}
\index{getSocketFd@{getSocketFd}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int CSocket::get\-Socket\-Fd () const\hspace{0.3cm}{\tt  [inline]}}\label{classCSocket_a3}


Get accessor function socket file descriptor.



Definition at line 383 of file CSocket.h.

References m\_\-Fd.

Referenced by CServer\-Instance::Describe\-Self(), CServer\-Connection\-Event::Describe\-Self(), CTCPConnection\-Lost::Host(), and CTCPConnection\-Lost::Port().\index{CSocket@{CSocket}!getState@{getState}}
\index{getState@{getState}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf CSocket::State} CSocket::get\-State () const\hspace{0.3cm}{\tt  [inline]}}\label{classCSocket_a4}


Get accessor function for socket state.



Definition at line 388 of file CSocket.h.

References m\_\-State, and State.

Referenced by CServer\-Instance::Describe\-Self(), CServer\-Connection\-Event::Describe\-Self(), CServer\-Instance::Shutdown(), and CServer\-Instance::$\sim$CServer\-Instance().\index{CSocket@{CSocket}!isDebug@{isDebug}}
\index{isDebug@{isDebug}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool CSocket::is\-Debug ()}\label{classCSocket_a25}


Purpose:

Returns TRUE if socket debugging is turned on and False otherwise.

Exceptions:\begin{CompactItemize}
\item 
{\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})} if an error is returned from the getsockopt(2) call. \end{CompactItemize}


Definition at line 1214 of file CSocket.cpp.

References FALSE, m\_\-Fd, and TRUE.\index{CSocket@{CSocket}!isNotRoutable@{isNotRoutable}}
\index{isNotRoutable@{isNotRoutable}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool CSocket::is\-Not\-Routable ()}\label{classCSocket_a27}


Purpose:

Returns the state of the routability flag.

Throws:\begin{CompactItemize}
\item 
{\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})} If getsockopt(2) failed.\end{CompactItemize}
Return values:\begin{CompactItemize}
\item 
TRUE Routing is turned off.\item 
FALSE Routing is tured on. \end{CompactItemize}


Definition at line 1272 of file CSocket.cpp.

References FALSE, m\_\-Fd, and TRUE.\index{CSocket@{CSocket}!isOOBInline@{isOOBInline}}
\index{isOOBInline@{isOOBInline}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}bool CSocket::is\-OOBInline ()}\label{classCSocket_a15}


Purpose:

Returns TRUE if OOBinline is set FALSE otherwise. Note that the underlying socket state is inquired, not some saved internal state.

This function is valid in any socket state.

Throws:\begin{CompactItemize}
\item 
{\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})} if getsockopt(2) fails\end{CompactItemize}
 

Definition at line 941 of file CSocket.cpp.

References FALSE, m\_\-Fd, and TRUE.\index{CSocket@{CSocket}!Listen@{Listen}}
\index{Listen@{Listen}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CSocket::Listen (unsigned int {\em n\-Backlog} = 5)}\label{classCSocket_a8}


Indicates that the specified server  listener socket is ready to listen for connections.

The Following exceptions can be  thrown:

\begin{CompactItemize}
\item 
{\bf CTCPBad\-Socket\-State} {\rm (p.\,\pageref{classCTCPBadSocketState})} - m\_\-State != Bound\item 
{\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})} - listen(2) failed.\end{CompactItemize}
On success, m\_\-State = Listening\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
n\-Backlog}]The limit on the queue size for incomming connections.  This value of this parameter defaults to 5. If a a connection is requested when the listen queue is full, it is refused or allowed to retry depending on the protocol (according to linux man connect(2)). On some systems this parameter may be ignored or have other meaning. \end{description}
\end{Desc}


Definition at line 610 of file CSocket.cpp.

References Bound, Listening, m\_\-Fd, and m\_\-State.

Referenced by CServer\-Connection\-Event::Configure\-Socket().\index{CSocket@{CSocket}!OOBInline@{OOBInline}}
\index{OOBInline@{OOBInline}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CSocket::OOBInline (bool {\em State} = TRUE)}\label{classCSocket_a14}


Purpose:

Allows Out Of Band (OOB) data to be inserted in line with buffered data. OOB data is data with a higher delivery priority than 'normal data'. If this flag is not set, then by default OOB data must be read through normal socket interface functions by specifying it in the recv flags parameter. If this flag is set, oob data is queue at the front of the data to be read with the Read member.

This is allowed in any socket state. Exceptions:\begin{CompactItemize}
\item 
{\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})} if the setsockopt(2) function failed.\end{CompactItemize}
\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
State}]This can be (Defaults to TRUE):\begin{CompactItemize}
\item 
TRUE Enables out of band inline data.\item 
FALSE disables out of band inline data. \end{CompactItemize}
\end{description}
\end{Desc}


Definition at line 916 of file CSocket.cpp.

References m\_\-Fd, and State.\index{CSocket@{CSocket}!OpenSocket@{OpenSocket}}
\index{OpenSocket@{OpenSocket}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CSocket::Open\-Socket ()\hspace{0.3cm}{\tt  [protected]}}\label{classCSocket_b4}


Opens the socket on a TCP/IP endpoint. 

Definition at line 1557 of file CSocket.cpp.

References CApplication\-Serializer::get\-Instance(), CThread\-Recursive\-Mutex::Lock(), m\_\-Fd, Stock\-State\-Map(), and CThread\-Recursive\-Mutex::Un\-Lock().

Referenced by CSocket(), and Shutdown().\index{CSocket@{CSocket}!operator=@{operator=}}
\index{operator=@{operator=}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}CSocket\& CSocket::operator= (const CSocket \& {\em a\-CSocket})\hspace{0.3cm}{\tt  [private]}}\label{classCSocket_c1}


Assignment Operator Forbidden.

\index{CSocket@{CSocket}!operator==@{operator==}}
\index{operator==@{operator==}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int CSocket::operator== (const CSocket \& {\em a\-CSocket}) const\hspace{0.3cm}{\tt  [private]}}\label{classCSocket_c2}


Equality Operator Forbidden.

\index{CSocket@{CSocket}!Read@{Read}}
\index{Read@{Read}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int CSocket::Read (void $\ast$ {\em p\-Buffer}, size\_\-t {\em n\-Bytes})}\label{classCSocket_a11}


Purpose:

Performs a read on the socket. The read will transfer all of the bytes currently waiting in the socket buffers or block until data is avaialble. The return valiue will be the number of bytes transferred. If the connection is lost, {\bf CTCPConnection\-Lost} {\rm (p.\,\pageref{classCTCPConnectionLost})} will be thrown. Multiple reads will not be performed so that any known messaging structure can be maintained.

Throws:\begin{CompactItemize}
\item 
{\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})} - the read(2) system service returned an error.\item 
{\bf CTCPConnection\-Lost} {\rm (p.\,\pageref{classCTCPConnectionLost})} - the read(2) system service returned 0 indicating an end of file condition.\item 
{\bf CTCPBad\-Socket\-State} {\rm (p.\,\pageref{classCTCPBadSocketState})} - m\_\-State != Connected. \end{CompactItemize}


Definition at line 749 of file CSocket.cpp.

References Connected, Disconnected, m\_\-Fd, and m\_\-State.

Referenced by CLogger::Log().\index{CSocket@{CSocket}!Service@{Service}}
\index{Service@{Service}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}unsigned short CSocket::Service (const string \& {\em r\-Service})\hspace{0.3cm}{\tt  [protected]}}\label{classCSocket_b2}


Purpose: Determines the service which corresponds to a service string. Service strings can either be a numerical equivalent of a service port number or a service name which can be looked up in the service database.\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
r\-Service}]The service name.\end{description}
\end{Desc}
Returns: The port number or throws: -{\bf CTCPNo\-Such\-Service} {\rm (p.\,\pageref{classCTCPNoSuchService})} The service cannot be translated. 

Definition at line 1466 of file CSocket.cpp.

References CApplication\-Serializer::get\-Instance(), CThread\-Recursive\-Mutex::Lock(), and CThread\-Recursive\-Mutex::Un\-Lock().

Referenced by Bind(), and Connect().\index{CSocket@{CSocket}!setLinger@{setLinger}}
\index{setLinger@{setLinger}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CSocket::set\-Linger (bool {\em l\-On}, int {\em n\-Linger\-Seconds})}\label{classCSocket_a32}


Purpose:

Sets the socket linger parameters. Linger properties govern the way a shutdown, operates. Note that object destruction which requires a shutdown implicitly turns off linger.  If linger is enabled, then the close will block until all pending data has been successfully sent or until the linger timeout is exceeded.

Throws:\begin{CompactItemize}
\item 
{\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})} if the setsockopt(2) call failed.\end{CompactItemize}
\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
l\-On}]Determines if linger is on or off:\begin{CompactItemize}
\item 
TRUE Linger is on.\item 
FALSE Linger is off. \end{CompactItemize}
\end{description}
\end{Desc}
\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
n\-Linger\-Seconds}](only used if l\-On is TRUE). Indicates how many seconds to linger on the close until a timeout is declared and the close unblocks. \end{description}
\end{Desc}


Definition at line 1407 of file CSocket.cpp.

References m\_\-Fd.\index{CSocket@{CSocket}!SetNotRoutable@{SetNotRoutable}}
\index{SetNotRoutable@{SetNotRoutable}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CSocket::Set\-Not\-Routable (bool {\em f\-Routable} = TRUE)}\label{classCSocket_a26}


Purpose:

Allows the caller to control the routability of messages sent on the socket. If set, messages will not be sent through a gateway. Note: The socket need not be connected. Presumably, if this flag is set prior to Connect on a client socket the client will be unable to connect outside the local subnet, and if set prior to Bind for a server, the server will be unable to accept connections from outside the subnet.

Exceptions: -{\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})} if the setsockopt(2) call failed.\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
f\-Routable}][TRUE] :\begin{CompactItemize}
\item 
TRUE to turn OFF Routing\item 
FALSE to turn ON Routing. \end{CompactItemize}
\end{description}
\end{Desc}


Definition at line 1247 of file CSocket.cpp.

References m\_\-Fd.\index{CSocket@{CSocket}!setRcvBufSize@{setRcvBufSize}}
\index{setRcvBufSize@{setRcvBufSize}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CSocket::set\-Rcv\-Buf\-Size (size\_\-t {\em n\-Bytes})}\label{classCSocket_a30}


Purpose:

Sets the maximum number of bytes which can be received in a single read(2) operation. Note that CTCPSocket::Read does $>$NOT$<$  automatically segment or else you may block when you'd like to believe that a message has been received.

Throws:\begin{CompactItemize}
\item 
{\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})} if setsockopt(2) fails.\end{CompactItemize}
\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
n\-Buffer\-Size}]Number of bytes which can be sent in one write(2) call \end{description}
\end{Desc}


Definition at line 1353 of file CSocket.cpp.

References m\_\-Fd.\index{CSocket@{CSocket}!setRcvLowWaterMark@{setRcvLowWaterMark}}
\index{setRcvLowWaterMark@{setRcvLowWaterMark}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CSocket::set\-Rcv\-Low\-Water\-Mark (size\_\-t {\em n\-Bytes})}\label{classCSocket_a16}


Purpose:

Sets the Receive low water mark for the socket. This is the number of bytes received by the protocol before any is made available to the user. Note that some systems do not allow  this to be changed. It is not an error at this level to attempt to do so, however you will need to  call get\-Rcvlow\-Water\-Mark to be sure the change was actually made.

Throws:\begin{CompactItemize}
\item 
{\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})} if an error from setsockopt is detected other than that the system doesn't support resetting the low water mark. \end{CompactItemize}


Definition at line 973 of file CSocket.cpp.

References m\_\-Fd.\index{CSocket@{CSocket}!setRcvTimeout@{setRcvTimeout}}
\index{setRcvTimeout@{setRcvTimeout}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CSocket::set\-Rcv\-Timeout (unsigned int {\em n\-Ms})}\label{classCSocket_a20}


Set the protocol receive timeouts. Note that in some systems, these are not settable. However it is not an error to attempt to do so.\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
n\-Ms}]number of milliseconds of timeout to set.\end{description}
\end{Desc}
Throws:\begin{CompactItemize}
\item 
{\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})} if a setsockopt(3) returns an error other than that this is unsupported. \end{CompactItemize}


Definition at line 1067 of file CSocket.cpp.

References m\_\-Fd.\index{CSocket@{CSocket}!setSndBufSize@{setSndBufSize}}
\index{setSndBufSize@{setSndBufSize}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CSocket::set\-Snd\-Buf\-Size (size\_\-t {\em n\-Buffer\-Size})}\label{classCSocket_a28}


Operation Type: Configuration

Purpose:

Sets the socket send buffer size. This  has to do with how many bytes can be  sent in a single write(2) service call. Messages larger than that must be segmented into multiple write(2) calls. Note howerver that  CTCPSocket::Write automatically handles any necessary segmentation.

Throws:\begin{CompactItemize}
\item 
{\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})} if setsockopt(2) fails.\end{CompactItemize}
\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
n\-Buffer\-Size}]Number of bytes which can be sent in one write(2) call \end{description}
\end{Desc}


Definition at line 1305 of file CSocket.cpp.

References m\_\-Fd.\index{CSocket@{CSocket}!setSndLowWaterMark@{setSndLowWaterMark}}
\index{setSndLowWaterMark@{setSndLowWaterMark}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CSocket::set\-Snd\-Low\-Water\-Mark (size\_\-t {\em n\-Bytes})}\label{classCSocket_a18}


Sets the new value of the Send Low water mark. This controls the number of bytes which must be written before transferring data to the protocol layers for transmission. Note that some systems don't allow this value to be changed. It is not an error to attempt to change this value on those systems, however you should use get\-Snd\-Low\-Water\-Mark to determine the actual value negotiated by the system.\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
n\-Bytes}]Number of bytes in the low water mark.\end{description}
\end{Desc}
Throws:\begin{CompactItemize}
\item 
{\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})} if an error from setsockopt is detected other than that the system doesn't support resetting the low water mark. \end{CompactItemize}


Definition at line 1026 of file CSocket.cpp.

References m\_\-Fd.\index{CSocket@{CSocket}!setSndTimeout@{setSndTimeout}}
\index{setSndTimeout@{setSndTimeout}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CSocket::set\-Snd\-Timeout (unsigned int {\em n\-Ms})}\label{classCSocket_a22}


Purpose:

Set the number of milliseconds in the send timeout. Some systems may not allow this to be set, however it is not an error to try.

Throws:\begin{CompactItemize}
\item 
{\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})} if setsockop(2) returned an error other than this option is not supported.\end{CompactItemize}
\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
n\-Ms}]Number of milliseconds in the desired timeout. \end{description}
\end{Desc}


Definition at line 1131 of file CSocket.cpp.

References m\_\-Fd.\index{CSocket@{CSocket}!setSocketFd@{setSocketFd}}
\index{setSocketFd@{setSocketFd}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CSocket::set\-Socket\-Fd (const int {\em am\_\-Fd})\hspace{0.3cm}{\tt  [inline, protected]}}\label{classCSocket_b0}


Set accessor function for Socket file descriptor.



Definition at line 397 of file CSocket.h.

References m\_\-Fd.\index{CSocket@{CSocket}!setState@{setState}}
\index{setState@{setState}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CSocket::set\-State (const {\bf CSocket::State} {\em am\_\-State})\hspace{0.3cm}{\tt  [inline, protected]}}\label{classCSocket_b1}


Set accessor function for current socket state.



Definition at line 401 of file CSocket.h.

References m\_\-State, and State.\index{CSocket@{CSocket}!Shutdown@{Shutdown}}
\index{Shutdown@{Shutdown}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CSocket::Shutdown ()}\label{classCSocket_a10}


Purpose:

Shuts down a connection to a remote system. Unlike shutdown(2) this function does not support selectively shutting down reads or writes. Both are unconditionally shutdown. Note that the destructor will automatically call Shutdown if necessary.

Exceptions:\begin{CompactItemize}
\item 
{\bf CTCPBad\-Socket\-State} {\rm (p.\,\pageref{classCTCPBadSocketState})} m\_\-State != Connected.\item 
{\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})} shutdown(2) failed. \end{CompactItemize}


Definition at line 708 of file CSocket.cpp.

References Connected, Disconnected, m\_\-Fd, m\_\-State, and Open\-Socket().

Referenced by CLogger::Log(), CAlarm\-Logger::Log(), CServer\-Connection\-Event::On\-Connection(), CServer\-Instance::Shutdown(), CServer\-Connection\-Event::$\sim$CServer\-Connection\-Event(), and CServer\-Instance::$\sim$CServer\-Instance().\index{CSocket@{CSocket}!StateName@{StateName}}
\index{StateName@{StateName}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}string CSocket::State\-Name ({\bf CSocket::State} {\em state})\hspace{0.3cm}{\tt  [static]}}\label{classCSocket_d0}


Purpose: Given a state, returns a text string which describes the state. \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
state}]- State to describe.\end{description}
\end{Desc}
NOTE: Since this is a static member which can be called before any instances of CSocket have been created, we call {\bf Stock\-State\-Map}() {\rm (p.\,\pageref{classCSocket_e0})}. 

Definition at line 1532 of file CSocket.cpp.

References m\_\-State\-Names, State, and Stock\-State\-Map().

Referenced by CServer\-Instance::Describe\-Self(), CServer\-Connection\-Event::Describe\-Self(), and CTCPBad\-Socket\-State::Reason\-Text().\index{CSocket@{CSocket}!StockStateMap@{StockStateMap}}
\index{StockStateMap@{StockStateMap}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CSocket::Stock\-State\-Map ()\hspace{0.3cm}{\tt  [static, protected]}}\label{classCSocket_e0}


Purpose: Stocks the static member: m\_\-State\-Names with the states and their names. This is only done if the map is empty. This function must be updated if the set of states is modified. 

Definition at line 1544 of file CSocket.cpp.

References Bound, Connected, Disconnected, Listening, and m\_\-State\-Names.

Referenced by CSocket(), Open\-Socket(), and State\-Name().\index{CSocket@{CSocket}!Write@{Write}}
\index{Write@{Write}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int CSocket::Write (void $\ast$ {\em p\-Buffer}, size\_\-t {\em n\-Bytes})}\label{classCSocket_a12}


Purpose:

Writes data to the socket. Note that this member will block as needed until all data has been queued to the socket buffers. This may require multiple write(2) function calls if the amount of data to be written is larger than the socket's blocking factor. Note that if the connection is lost during the write, {\bf CTCPConnection\-Lost} {\rm (p.\,\pageref{classCTCPConnectionLost})} will be thrown.

Exceptions:\begin{CompactItemize}
\item 
{\bf CTCPBad\-Socket\-State} {\rm (p.\,\pageref{classCTCPBadSocketState})} m\_\-State != Connected\item 
{\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})} write(2) returned an error condition.\item 
{\bf CTCPConnection\-Lost} {\rm (p.\,\pageref{classCTCPConnectionLost})} write(2) indicated an EPIPE condition which says the peer closed the socket. 

\end{CompactItemize}
\begin{Desc}
\item[{\bf Bug: }]\par
There's not a good way to handle failures on the second or later call to write(2). Since we'd like to indicate that part of the write completed before an error occured. The current assumption is that a followup write will produce the same error. Perhaps the best long term thing to do is to define a CTCPSocket\-IOError which will include as data the number of bytes written along with a {\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})} which describes why the write actually failed??\end{Desc}
 

Definition at line 810 of file CSocket.cpp.

References Disconnected, m\_\-Fd, and m\_\-State.

Referenced by CLogger::Log(), and CAlarm\-Logger::Log().

\subsection{Member Data Documentation}
\index{CSocket@{CSocket}!m_Fd@{m\_\-Fd}}
\index{m_Fd@{m\_\-Fd}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int CSocket::m\_\-Fd\hspace{0.3cm}{\tt  [private]}}\label{classCSocket_o0}


Socket.



Definition at line 353 of file CSocket.h.

Referenced by Accept(), Bind(), Connect(), Debug(), get\-Linger(), get\-Peer(), get\-Rcv\-Buf\-Size(), get\-Rcv\-Low\-Water\-Mark(), get\-Rcv\-Timeout(), get\-Snd\-Buf\-Size(), get\-Snd\-Low\-Water\-Mark(), get\-Snd\-Timeout(), get\-Socket\-Fd(), is\-Debug(), is\-Not\-Routable(), is\-OOBInline(), Listen(), OOBInline(), Open\-Socket(), Read(), set\-Linger(), Set\-Not\-Routable(), set\-Rcv\-Buf\-Size(), set\-Rcv\-Low\-Water\-Mark(), set\-Rcv\-Timeout(), set\-Snd\-Buf\-Size(), set\-Snd\-Low\-Water\-Mark(), set\-Snd\-Timeout(), set\-Socket\-Fd(), Shutdown(), and Write().\index{CSocket@{CSocket}!m_State@{m\_\-State}}
\index{m_State@{m\_\-State}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}{\bf CSocket::State} CSocket::m\_\-State\hspace{0.3cm}{\tt  [private]}}\label{classCSocket_o1}


State of socket.



Definition at line 354 of file CSocket.h.

Referenced by Accept(), Bind(), Connect(), get\-Peer(), get\-State(), Listen(), Read(), set\-State(), Shutdown(), and Write().\index{CSocket@{CSocket}!m_StateNames@{m\_\-StateNames}}
\index{m_StateNames@{m\_\-StateNames}!CSocket@{CSocket}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}map$<$ {\bf CSocket::State}, string $>$ CSocket::m\_\-State\-Names\hspace{0.3cm}{\tt  [static, private]}}\label{classCSocket_r0}


State name lookup tbl.



Definition at line 348 of file CSocket.cpp.

Referenced by State\-Name(), and Stock\-State\-Map().

The documentation for this class was generated from the following files:\begin{CompactItemize}
\item 
{\bf CSocket.h}\item 
{\bf CSocket.cpp}\end{CompactItemize}
