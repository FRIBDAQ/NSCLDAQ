\section{CConfiguration\-Manager  Class Reference}
\label{classCConfigurationManager}\index{CConfigurationManager@{CConfiguration\-Manager}}
{\tt \#include $<$CConfiguration\-Manager.h$>$}

\subsection*{Public Methods}
\begin{CompactItemize}
\item 
{\bf CConfiguration\-Manager} ()
\begin{CompactList}\small\item\em Default construtor.\item\end{CompactList}\item 
{\bf CConfiguration\-Manager} (list$<$ {\bf CType\-Free\-Binding} $\ast$ $>$ \&r\-Bindings)
\begin{CompactList}\small\item\em Prestocked configuration.\item\end{CompactList}\item 
{\bf $\sim$CConfiguration\-Manager} ()
\begin{CompactList}\small\item\em Destruction requires nothing special.\item\end{CompactList}\item 
{\bf CConfiguration\-Manager} (const CConfiguration\-Manager \&rhs)
\begin{CompactList}\small\item\em Copy constructor.\item\end{CompactList}\item 
CConfiguration\-Manager \& {\bf operator=} (const CConfiguration\-Manager \&rhs)
\begin{CompactList}\small\item\em Assignment operator.\item\end{CompactList}\item 
int {\bf operator==} (const CConfiguration\-Manager \&rhs)
\item 
int {\bf operator!=} (const CConfiguration\-Manager \&rhs)
\item 
list$<$ {\bf CType\-Free\-Binding} $\ast$ $>$ {\bf get\-Bindings} () const
\item 
void {\bf set\-Bindings} (list$<$ {\bf CType\-Free\-Binding} $\ast$ $>$ new\-Bindings)
\begin{CompactList}\small\item\em Replace all bindings.\item\end{CompactList}\item 
void {\bf Add\-Binding} ({\bf CType\-Free\-Binding} \&r\-Binding)
\item 
void {\bf Add\-Binding} (list$<$ {\bf CType\-Free\-Binding} $\ast$ $>$ addlist)
\item 
void {\bf Read\-Config\-File} (const char $\ast$p\-Name)
\item 
void {\bf Read\-Config\-File} (const string \&r\-Name)
\item 
void {\bf Read\-Config\-File} (int fd)
\item 
void {\bf Read1st\-Config\-File} (const vector$<$ string $>$ \&Names)
\item 
void {\bf Read1st\-Config\-File} (const vector$<$ string $>$ \&Paths, const char $\ast$p\-Name)
\item 
void {\bf Read1st\-Config\-File} (const vector$<$ string $>$ \&Paths, const string \&r\-Name)
\item 
void {\bf Read\-All\-Config\-Files} (const vector$<$ string $>$ \&Name)
\item 
void {\bf Read\-All\-Config\-Files} (const vector$<$ string $>$ \&Paths, const char $\ast$p\-Name)
\item 
void {\bf Read\-All\-Config\-Files} (const vector$<$ string $>$ \&Paths, const string \&r\-Name)
\item 
void {\bf Write\-Config\-File} (const char $\ast$p\-Name)
\item 
void {\bf Write\-Config\-File} (const string \&r\-Name)
\item 
void {\bf Write\-Config\-File} (int fd)
\end{CompactItemize}
\subsection*{Protected Methods}
\begin{CompactItemize}
\item 
void {\bf Internal\-Read\-Config\-File} ({\bf CTCLInterpreter} \&r\-Interp, int fd)
\end{CompactItemize}
\subsection*{Private Attributes}
\begin{CompactItemize}
\item 
list$<$ {\bf CType\-Free\-Binding} $\ast$ $>$ {\bf m\_\-l\-Bindings}
\begin{CompactList}\small\item\em List of configuration bindings.\item\end{CompactList}\end{CompactItemize}


\subsection{Detailed Description}
Configuration\-Manager provides a flexible scheme for configuring  various application parameters. The idea is that a script or set of scripts will hold configuration information (variable sets e.g.). These configuration scripts are linked to application variables via instances of subclasses of {\bf CBinding} {\rm (p.\,\pageref{classCBinding})}. The configuration manager is asked to read a set of configuration files, it instantiates a TCLInterpreter with which to interpret the files. Folowing this, the application has its configuration variable set as a result of this script exeuction and the set of defined bindings between TCL variables and application variables.

The following bindings are supported:\begin{CompactItemize}
\item 
{\bf CVariable\-Binding} {\rm (p.\,\pageref{classCVariableBinding})} - Binds a single C/C++ variable location to a TCL variable. After the configuration completes, this variable will contain the value which was set in the corresponding TCL variable, or a default value if the variable was not set during configuration.\item 
{\bf CArray\-Binding} {\rm (p.\,\pageref{classCArrayBinding})} - Binds a slice of a C/C++ array to a TCL array which is assumed to be indexed by numerically encoded indices. After configuration completes, the slice contains the corresponding values from the TCL array or an optional default value if element(s) were not set.\item 
{\bf CAssoc\-Array\-Binding} {\rm (p.\,\pageref{classCAssocArrayBinding})} - Encapsulates an associative array (STL map$<$string,T$>$). and binds it to a corresponding TCL array which is assumed to have arbitrary indices. After the configuration is done, TCL array elements are copied to corresponding Map entries, creating new entries as needed.\end{CompactItemize}
All of the bindings types are templated types. However due to TCL  restrictions, only some type parameterizations are allowed:\begin{CompactItemize}
\item 
int - corresponds to TCL\_\-LINK\_\-INT in Tcl\_\-Link\-Var e.g.\item 
double - Corresponds to TCL\_\-LINK\_\-DOUBLE in Tcl\_\-Link\-Var e.g.\item 
bool - Corresponds to TCL\_\-LINK\_\-BOOLEAN in Tcl\_\-Link\-Var e.g.\item 
char$\ast$ - Corresponds to TCL\_\-LINK\_\-STRING in Tcl\_\-Link\-Var e.g.\end{CompactItemize}
All of these type parameterizations are straightforward with the exception of char$\ast$ char$\ast$ variables are filled in with pointers to malloc'd copies of the contents of the variable after configuration is done. In practice this is only an issue if multiple configurations reads members are performed (e.g. reconfiguration after complete configuration).

The major member functions supported by this class are:\begin{CompactItemize}
\item 
Read\-Config\-File - Reads in a single configuration file.\item 
Read1st\-Config\-File - Reads in a single config file searched from path.\item 
Read\-Config\-Files - Reads in a set of configuration files.\item 
Write\-Config\-File - Writes a file which can recover the current  configuration. \end{CompactItemize}




Definition at line 357 of file CConfiguration\-Manager.h.

\subsection{Constructor \& Destructor Documentation}
\index{CConfigurationManager@{CConfiguration\-Manager}!CConfigurationManager@{CConfigurationManager}}
\index{CConfigurationManager@{CConfigurationManager}!CConfigurationManager@{CConfiguration\-Manager}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}CConfiguration\-Manager::CConfiguration\-Manager ()\hspace{0.3cm}{\tt  [inline]}}\label{classCConfigurationManager_a0}


Default construtor.



Definition at line 365 of file CConfiguration\-Manager.h.\index{CConfigurationManager@{CConfiguration\-Manager}!CConfigurationManager@{CConfigurationManager}}
\index{CConfigurationManager@{CConfigurationManager}!CConfigurationManager@{CConfiguration\-Manager}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}CConfiguration\-Manager::CConfiguration\-Manager (list$<$ {\bf CType\-Free\-Binding} $\ast$ $>$ \& {\em r\-Bindings})\hspace{0.3cm}{\tt  [inline]}}\label{classCConfigurationManager_a1}


Prestocked configuration.



Definition at line 366 of file CConfiguration\-Manager.h.

References m\_\-l\-Bindings.\index{CConfigurationManager@{CConfiguration\-Manager}!~CConfigurationManager@{$\sim$CConfigurationManager}}
\index{~CConfigurationManager@{$\sim$CConfigurationManager}!CConfigurationManager@{CConfiguration\-Manager}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}CConfiguration\-Manager::$\sim$CConfiguration\-Manager ()\hspace{0.3cm}{\tt  [inline]}}\label{classCConfigurationManager_a2}


Destruction requires nothing special.



Definition at line 368 of file CConfiguration\-Manager.h.\index{CConfigurationManager@{CConfiguration\-Manager}!CConfigurationManager@{CConfigurationManager}}
\index{CConfigurationManager@{CConfigurationManager}!CConfigurationManager@{CConfiguration\-Manager}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}CConfiguration\-Manager::CConfiguration\-Manager (const CConfiguration\-Manager \& {\em rhs})\hspace{0.3cm}{\tt  [inline]}}\label{classCConfigurationManager_a3}


Copy constructor.



Definition at line 374 of file CConfiguration\-Manager.h.

References m\_\-l\-Bindings.

\subsection{Member Function Documentation}
\index{CConfigurationManager@{CConfiguration\-Manager}!AddBinding@{AddBinding}}
\index{AddBinding@{AddBinding}!CConfigurationManager@{CConfiguration\-Manager}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CConfiguration\-Manager::Add\-Binding (list$<$ {\bf CType\-Free\-Binding} $\ast$ $>$ {\em addlist})\hspace{0.3cm}{\tt  [inline]}}\label{classCConfigurationManager_a10}


\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
addlist}]Append list of bindings \end{description}
\end{Desc}


Definition at line 401 of file CConfiguration\-Manager.h.

References m\_\-l\-Bindings.\index{CConfigurationManager@{CConfiguration\-Manager}!AddBinding@{AddBinding}}
\index{AddBinding@{AddBinding}!CConfigurationManager@{CConfiguration\-Manager}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CConfiguration\-Manager::Add\-Binding ({\bf CType\-Free\-Binding} \& {\em r\-Binding})\hspace{0.3cm}{\tt  [inline]}}\label{classCConfigurationManager_a9}




Definition at line 398 of file CConfiguration\-Manager.h.

References m\_\-l\-Bindings.\index{CConfigurationManager@{CConfiguration\-Manager}!getBindings@{getBindings}}
\index{getBindings@{getBindings}!CConfigurationManager@{CConfiguration\-Manager}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}list$<${\bf CType\-Free\-Binding}$\ast$$>$ CConfiguration\-Manager::get\-Bindings () const\hspace{0.3cm}{\tt  [inline]}}\label{classCConfigurationManager_a7}




Definition at line 388 of file CConfiguration\-Manager.h.

References m\_\-l\-Bindings.\index{CConfigurationManager@{CConfiguration\-Manager}!InternalReadConfigFile@{InternalReadConfigFile}}
\index{InternalReadConfigFile@{InternalReadConfigFile}!CConfigurationManager@{CConfiguration\-Manager}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CConfiguration\-Manager::Internal\-Read\-Config\-File ({\bf CTCLInterpreter} \& {\em r\-Interp}, int {\em fd})\hspace{0.3cm}{\tt  [protected]}}\label{classCConfigurationManager_b0}


Internal function to read a configuration file and execute it. since the lowest common denominator is a file descriptor and  Tcl/Tk doesn't have a function to process a script given an fd, we'll read the entire file into a buffer and process the file from that string. In practice, configuration files will not be too large so this will not be a serious problem.\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
r\-Interp}]- Tcl Interpreter which will interpret the file. \item[{\em 
fd}]- File descriptor already open on the file.\end{description}
\end{Desc}
\begin{Desc}
\item[Exceptions: ]\par
\begin{description}
\item[{\em 
{\bf CTCLException} {\rm (p.\,\pageref{classCTCLException})}}] - if the script does not parse properly etc. \item[{\em 
{\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})}}] - if unable to determine file size.\end{description}
\end{Desc}
\begin{Desc}
\item[Note: ]\par
It is the caller's responsibility to close the file. \end{Desc}


Definition at line 678 of file CConfiguration\-Manager.cpp.

References CTCLInterpreter::Global\-Eval().

Referenced by Read\-All\-Config\-Files(), and Read\-Config\-File().\index{CConfigurationManager@{CConfiguration\-Manager}!operator"!=@{operator"!=}}
\index{operator"!=@{operator"!=}!CConfigurationManager@{CConfiguration\-Manager}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int CConfiguration\-Manager::operator!= (const CConfiguration\-Manager \& {\em rhs})\hspace{0.3cm}{\tt  [inline]}}\label{classCConfigurationManager_a6}




Definition at line 382 of file CConfiguration\-Manager.h.

References operator==().\index{CConfigurationManager@{CConfiguration\-Manager}!operator=@{operator=}}
\index{operator=@{operator=}!CConfigurationManager@{CConfiguration\-Manager}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}CConfiguration\-Manager\& CConfiguration\-Manager::operator= (const CConfiguration\-Manager \& {\em rhs})\hspace{0.3cm}{\tt  [inline]}}\label{classCConfigurationManager_a4}


Assignment operator.



Definition at line 376 of file CConfiguration\-Manager.h.

References m\_\-l\-Bindings.\index{CConfigurationManager@{CConfiguration\-Manager}!operator==@{operator==}}
\index{operator==@{operator==}!CConfigurationManager@{CConfiguration\-Manager}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}int CConfiguration\-Manager::operator== (const CConfiguration\-Manager \& {\em rhs})\hspace{0.3cm}{\tt  [inline]}}\label{classCConfigurationManager_a5}




Definition at line 379 of file CConfiguration\-Manager.h.

References m\_\-l\-Bindings.

Referenced by operator!=().\index{CConfigurationManager@{CConfiguration\-Manager}!Read1stConfigFile@{Read1stConfigFile}}
\index{Read1stConfigFile@{Read1stConfigFile}!CConfigurationManager@{CConfiguration\-Manager}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CConfiguration\-Manager::Read1st\-Config\-File (const vector$<$ string $>$ \& {\em Paths}, const string \& {\em r\-Name})}\label{classCConfigurationManager_a16}


Reads the first configuration file which can be opened from a vector of path strings and a string filename. We just call the previous member fucnction passing the c\_\-str() of the filename. \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
Paths}]- STL String vector of paths. \item[{\em 
r\-Name}]- STL string filename. \end{description}
\end{Desc}


Definition at line 490 of file CConfiguration\-Manager.cpp.

References Read1st\-Config\-File().\index{CConfigurationManager@{CConfiguration\-Manager}!Read1stConfigFile@{Read1stConfigFile}}
\index{Read1stConfigFile@{Read1stConfigFile}!CConfigurationManager@{CConfiguration\-Manager}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CConfiguration\-Manager::Read1st\-Config\-File (const vector$<$ string $>$ \& {\em Paths}, const char $\ast$ {\em p\-Name})}\label{classCConfigurationManager_a15}


Given a set of directory paths, and a filename which is appended to the path, this member locates the first filename path / filename which can be opened for read and runs it as a configuration file.

What really happens is that the path vector and filename are used to create a vector of filenames to try and then the previous member function is called to do the rest. \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
Paths}]- Set of paths within which to search for the filename. \item[{\em 
p\-Name}]- Cstring pointer to the filename. \end{description}
\end{Desc}


Definition at line 465 of file CConfiguration\-Manager.cpp.

References Path\-Sep, and Read1st\-Config\-File().\index{CConfigurationManager@{CConfiguration\-Manager}!Read1stConfigFile@{Read1stConfigFile}}
\index{Read1stConfigFile@{Read1stConfigFile}!CConfigurationManager@{CConfiguration\-Manager}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CConfiguration\-Manager::Read1st\-Config\-File (const vector$<$ string $>$ \& {\em r\-Names})}\label{classCConfigurationManager_a14}


Executes the first configuration file which can be successfully opened from a list of configuration files. Note that if none of the configuration files can be located or opened, this function is a silent no-op. \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
Names}]- An STL vector of filenames to search. Names are searched for in vector order.\end{description}
\end{Desc}
\begin{Desc}
\item[Exceptions: ]\par
\begin{description}
\item[{\em 
{\bf CTCLException} {\rm (p.\,\pageref{classCTCLException})}}] - if there was an error executing the script. \end{description}
\end{Desc}


Definition at line 434 of file CConfiguration\-Manager.cpp.

References Read\-Config\-File().

Referenced by Read1st\-Config\-File().\index{CConfigurationManager@{CConfiguration\-Manager}!ReadAllConfigFiles@{ReadAllConfigFiles}}
\index{ReadAllConfigFiles@{ReadAllConfigFiles}!CConfigurationManager@{CConfiguration\-Manager}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CConfiguration\-Manager::Read\-All\-Config\-Files (const vector$<$ string $>$ \& {\em r\-Paths}, const string \& {\em r\-Filename})}\label{classCConfigurationManager_a19}


Reads all of the configuration files which can be found that are built by concatenating path names with a path separator and a filename. This is done by simply building a vector of the resulting filenames and passing it to the previous member \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
r\-Paths}]- STL Vector of STL strings which represent filesystem paths in which the file could live. \item[{\em 
r\-Filename}]- STL String which is the filename to execute. \end{description}
\end{Desc}


Definition at line 550 of file CConfiguration\-Manager.cpp.

References Path\-Sep, and Read\-All\-Config\-Files().\index{CConfigurationManager@{CConfiguration\-Manager}!ReadAllConfigFiles@{ReadAllConfigFiles}}
\index{ReadAllConfigFiles@{ReadAllConfigFiles}!CConfigurationManager@{CConfiguration\-Manager}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CConfiguration\-Manager::Read\-All\-Config\-Files (const vector$<$ string $>$ \& {\em r\-Paths}, const char $\ast$ {\em p\-Filename})}\label{classCConfigurationManager_a18}


Reads in all files which can be found from the filenames constructed by contcatenating a filename with set of paths. The only difference from the previous member is that the filename is represented as a C null terminated string. We'll generate an STL string from it and delegate to the previous overload. \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
r\-Paths}]- STL vector of STL strings which give the list of paths to search. \item[{\em 
p\-Filename}]- Pointer to a null terminated string of characters which will be appended to each path in turn to generate the names of the script files which will be executed. \end{description}
\end{Desc}


Definition at line 579 of file CConfiguration\-Manager.cpp.

References Read\-All\-Config\-Files().\index{CConfigurationManager@{CConfiguration\-Manager}!ReadAllConfigFiles@{ReadAllConfigFiles}}
\index{ReadAllConfigFiles@{ReadAllConfigFiles}!CConfigurationManager@{CConfiguration\-Manager}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CConfiguration\-Manager::Read\-All\-Config\-Files (const vector$<$ string $>$ \& {\em Names})}\label{classCConfigurationManager_a17}


Reads all configuration files which can be found from a set of filenames. If any filename cannot be found it is silently ignored. Files are executed in vector order.

Note that all configuration files are taken as a single configuration. An error in a single configuration script results in an exception which  terminates the search.\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
Names}]- STL vector of STL strings which contains the set of  filenames to try to open.\end{description}
\end{Desc}
\begin{Desc}
\item[Exceptions: ]\par
\begin{description}
\item[{\em 
{\bf CTCLException} {\rm (p.\,\pageref{classCTCLException})}}] - If there is an error executing a script (e.g. syntax). \end{description}
\end{Desc}


Definition at line 511 of file CConfiguration\-Manager.cpp.

References Internal\-Read\-Config\-File(), and m\_\-l\-Bindings.

Referenced by Read\-All\-Config\-Files().\index{CConfigurationManager@{CConfiguration\-Manager}!ReadConfigFile@{ReadConfigFile}}
\index{ReadConfigFile@{ReadConfigFile}!CConfigurationManager@{CConfiguration\-Manager}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CConfiguration\-Manager::Read\-Config\-File (int {\em fd})}\label{classCConfigurationManager_a13}


Reads a configuration file given that it is open on a file descriptor. The file is interpreted from its current location until end of file. \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
fd}]- File descriptor open on the file.\end{description}
\end{Desc}
\begin{Desc}
\item[Exceptions: ]\par
\begin{description}
\item[{\em 
{\bf CTCLException} {\rm (p.\,\pageref{classCTCLException})}}] - if there was a problem interpreting the script e.g. \end{description}
\end{Desc}


Definition at line 399 of file CConfiguration\-Manager.cpp.

References Internal\-Read\-Config\-File(), and m\_\-l\-Bindings.\index{CConfigurationManager@{CConfiguration\-Manager}!ReadConfigFile@{ReadConfigFile}}
\index{ReadConfigFile@{ReadConfigFile}!CConfigurationManager@{CConfiguration\-Manager}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CConfiguration\-Manager::Read\-Config\-File (const string \& {\em r\-Name})}\label{classCConfigurationManager_a12}


Reads a single configuration file specified by an stl string. Just calls the previous function with the name passed by cstring. See the documentation of the above function for more information. \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
r\-Name}]- stl string containing the filename of the configuration script. \end{description}
\end{Desc}


Definition at line 387 of file CConfiguration\-Manager.cpp.

References Read\-Config\-File().\index{CConfigurationManager@{CConfiguration\-Manager}!ReadConfigFile@{ReadConfigFile}}
\index{ReadConfigFile@{ReadConfigFile}!CConfigurationManager@{CConfiguration\-Manager}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CConfiguration\-Manager::Read\-Config\-File (const char $\ast$ {\em p\-Name})}\label{classCConfigurationManager_a11}


Reads a single configuration file. This involves:\begin{enumerate}
\item 
Ensuring the file exists.\item 
Creating a {\bf CTCLInterpreter} {\rm (p.\,\pageref{classCTCLInterpreter})} on which to interpret the config file.\item 
Initializing all bindings on the interpreter.\item 
Interpreting the script file.\item 
Committing all bindings on the interpreter.\item 
Shutting down all bindings on the interpreter.\item 
Destroying the CTCLIntpereter.\end{enumerate}
\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
p\-Name}]- Pointer to the name of the file to read. This must be fully specified (absolute or relative path).\end{description}
\end{Desc}
\begin{Desc}
\item[Exceptions: ]\par
\begin{description}
\item[{\em 
{\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})}}] - if e.g. file cannot be opened for read. \item[{\em 
{\bf CTCLException} {\rm (p.\,\pageref{classCTCLException})}}] - if there was a problem (e.g. syntax error) interpreting the configuration script. \end{description}
\end{Desc}


Definition at line 364 of file CConfiguration\-Manager.cpp.

Referenced by Read1st\-Config\-File(), and Read\-Config\-File().\index{CConfigurationManager@{CConfiguration\-Manager}!setBindings@{setBindings}}
\index{setBindings@{setBindings}!CConfigurationManager@{CConfiguration\-Manager}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CConfiguration\-Manager::set\-Bindings (list$<$ {\bf CType\-Free\-Binding} $\ast$ $>$ {\em new\-Bindings})\hspace{0.3cm}{\tt  [inline]}}\label{classCConfigurationManager_a8}


Replace all bindings.



Definition at line 395 of file CConfiguration\-Manager.h.

References m\_\-l\-Bindings.\index{CConfigurationManager@{CConfiguration\-Manager}!WriteConfigFile@{WriteConfigFile}}
\index{WriteConfigFile@{WriteConfigFile}!CConfigurationManager@{CConfiguration\-Manager}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CConfiguration\-Manager::Write\-Config\-File (int {\em fd})}\label{classCConfigurationManager_a22}


Writes a configuration file which can be re-read to duplicate the current state of the configuration variables. The configuration file will contain a comment which will give the following information:\begin{CompactItemize}
\item 
Identifying information to indicate that this is a configuration file written by the configuration subsystem. - When written\item 
Name of user executing this program.\end{CompactItemize}
\begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
fd}]- File descriptor of file open on the output configuration file.\end{description}
\end{Desc}
\begin{Desc}
\item[Exceptions: ]\par
\begin{description}
\item[{\em 
{\bf CErrno\-Exception} {\rm (p.\,\pageref{classCErrnoException})}}] - If there are problems writing to the file.\end{description}
\end{Desc}
\begin{Desc}
\item[Note: ]\par
It is the caller's responsibilility to close the file. \end{Desc}


Definition at line 601 of file CConfiguration\-Manager.cpp.

References m\_\-l\-Bindings.\index{CConfigurationManager@{CConfiguration\-Manager}!WriteConfigFile@{WriteConfigFile}}
\index{WriteConfigFile@{WriteConfigFile}!CConfigurationManager@{CConfiguration\-Manager}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CConfiguration\-Manager::Write\-Config\-File (const string \& {\em r\-Name})}\label{classCConfigurationManager_a21}


Writes a configuration file which can be re-read to duplicate the current configuration. The file is specified by an STL string object. This file simply calls the prior overload of this function specifying  the .c\_\-str() return value of the filename. \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
r\-Name}]- STL const string\& name of the file to write to. \end{description}
\end{Desc}


Definition at line 657 of file CConfiguration\-Manager.cpp.

References Write\-Config\-File().\index{CConfigurationManager@{CConfiguration\-Manager}!WriteConfigFile@{WriteConfigFile}}
\index{WriteConfigFile@{WriteConfigFile}!CConfigurationManager@{CConfiguration\-Manager}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}void CConfiguration\-Manager::Write\-Config\-File (const char $\ast$ {\em p\-Name})}\label{classCConfigurationManager_a20}


Writes a configuraiton file which can be re-read to duplicate the current configuration. The file is specified by a null terminated array of characters (C-string). This function attempts to open the specified file for write and on success delegates the actual  write operation to the previous overload of this function. \begin{Desc}
\item[Parameters: ]\par
\begin{description}
\item[{\em 
p\-Name}]- Pointer to the filename as a C-string. \end{description}
\end{Desc}


Definition at line 641 of file CConfiguration\-Manager.cpp.

Referenced by Write\-Config\-File().

\subsection{Member Data Documentation}
\index{CConfigurationManager@{CConfiguration\-Manager}!m_lBindings@{m\_\-lBindings}}
\index{m_lBindings@{m\_\-lBindings}!CConfigurationManager@{CConfiguration\-Manager}}
\subsubsection{\setlength{\rightskip}{0pt plus 5cm}list$<${\bf CType\-Free\-Binding}$\ast$$>$ CConfiguration\-Manager::m\_\-l\-Bindings\hspace{0.3cm}{\tt  [private]}}\label{classCConfigurationManager_o0}


List of configuration bindings.



Definition at line 361 of file CConfiguration\-Manager.h.

Referenced by Add\-Binding(), CConfiguration\-Manager(), get\-Bindings(), operator=(), operator==(), Read\-All\-Config\-Files(), Read\-Config\-File(), set\-Bindings(), and Write\-Config\-File().

The documentation for this class was generated from the following files:\begin{CompactItemize}
\item 
{\bf CConfiguration\-Manager.h}\item 
{\bf CConfiguration\-Manager.cpp}\end{CompactItemize}
