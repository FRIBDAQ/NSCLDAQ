<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"file:///usr/share/xml/docbook/schema/dtd/4.3/docbookx.dtd"
 [] 
>
<book>
<title>NSCL Daq Next Generation</title>
<part>
<title>utilities</title>

<chapter id="chapter.chanlog">
   <title>Epics Channel logging</title>
   <para>
      <application>chanlog</application>
      is a utility that allows you to log the values of a set of EPICS
      channels.
      <link linkend="manpage.chanlog">The chanlog manpage</link>
      provides full reference material for chanlog program.
   </para>
   <para>
      Chanlog allows you to:
      <itemizedlist>
         <listitem><para>
	    Interactively view a set of channel values.
	 </para></listitem>
	 <listitem><para>
	    Write or append a set of channel values to a text file.
	 </para></listitem>
	 <listitem><para>
	    Pipe a set of channel values to a program for processing.
	  </para></listitem>
      </itemizedlist>
   </para>
</chapter>

<chapter id="chapter.controlpush">
   <title>Providing EPICS channel information to Tcl Servers</title>
   <para>
      <application>controlpush</application>
      is a program that is part of the EPICS support package.  It uses a
      configuration file to connect to a set of EPICS channels, connects to
      some TCP/IP server and then sends Tcl commands to that server to maintain 
      a set of Tcl arrays that allow the server process to maintain a copy of
      the state of those channels, their units and when their values were last updated.
   </para>
   <para>
      <application>controlpush</application>
      is descsribed fully in:
      <link linkend="manpage.controlpush">the controlpush manpage</link>.
   </para>
   <para>
      The intent is that 
      <application>controlpush</application> be pointed at a 
      <application>TclServer.</application>
      <link linkend="chapter.tclserver">The TclServer</link>
      is a wish shell extended with the ability to accept commands from 
      TCP/IP connected clients.  
   </para>
   <para>
      You can use 
      <application>controlpush</application>
      in conjunction with 
      <application>TclServer</application> 
      and application specific scripts to provide a visual display of control
      system parameters. 
      <link linkend="chapter.epicsdisplay">epicsdisplay</link> is an example
      of this technique.  Another typical use of 
      <application>controlpush</application> is in conjunction with readout
      skeletons that support 
      <application>tclserver</application> functionality to provide a set of
      data in the event stream that logs the control system parameters and
      their changes throughout the run.
   </para>
   <para>
       <application>controlpush</application>
       Maintains information in arrays that are indexed by channel name:
       <variablelist>
          <varlistentry>
	     <term><varname>EPICS_DATA(channelName)</varname></term>
	     <listitem><para>
	        Is the most recently received update for 
		<varname>channelName</varname>.
	     </para></listitem>
          </varlistentry>
	  <varlistentry>
	     <term><varname>EPICS_UNITS(channelName)</varname></term>
	     <listitem><para>
	        Are the engineering units for 
		<varname>channelName</varname>
             </para></listitem>
         </varlistentry>
         <varlistentry>
             <term><varname>EPICS_UPDATED(channelName)</varname></term>
	     <listitem><para>
	         Is the timestamp of the alst update received for
		 <varname>channelName</varname>.
             </para></listitem>
          </varlistentry>
       </variablelist>
   </para>

     
</chapter>


<chapter id="chapter.daqstart">
    <title>daqstart - Starting programs with logging and monitoring</title>
    <para>
        When running a critical component of a system, it is important to
        know if that component exits.  Furthermore, if the exit is unintended,
        maintaining a log of the output and error streams for that component
        can aid in failure analysis.
    </para>
    <para>
        The <application>daqstart</application> component provides the ability
        to run an arbitrary executable (or script), capturing the error and or
        output to a timestamped log and informing you if the executable or script
        exits.
        The
        <link linkend="manpage.daqstart">daqstart</link>
        reference page describes the detailed use of the
        <application>daqstart</application> program.
    </para>
    <para>
        Output monitoring by
        <application>daqstart</application>
        uses the concept of
        <firstterm>sinks</firstterm>.
        While the current implementation only supports file sinks, future implementations
        may provide other types of sinks such as pipes or interfaces to the
        unix system log facility, or even database logs.
    </para>
    <para>
        Output sinks are specified using the form:
        <literal>type:destination</literal>
        where <literal>type</literal> defines the sink type (e.g. <literal>file</literal>),
        and the <literal>destination</literal> is sink type specific
        (e.g. for a <literal>file</literal> sink the destination is the
        name of the file that will be the sink).
    </para>
    <para>
        Now a simple example:
    </para>
    <example>
        <title>Logging errors and informing on exit</title>
        <programlisting>
daqstart --error=file:/user/fox/logs/critical.log --notify \
                   mycriticalprogram --anoption=avalue argument
        </programlisting>
    </example>
    <para>
        The logfile will be
        <filename>/user/fox/logs/critical.log</filename>.  If that file
        exists new data will be appended to the log.  Once a command argument that
        is not recognized by the
        <application>daqstart</application>
        program appears on the command line, the remainder of the line is considered
        to be the application that will be logged.
    </para>
</chapter>

<chapter id="chapter.dvdburner">
    <title>DvdBurner - Using Tcl to burn runs to DVD</title>
    <para>
        <application>DvdBurner</application> is a Tcl package that allows you to
        burn NSCL data runs to DVD.  The DvdBurner package breaks the data up
        among as many DVD's as needed, however it requires that the data
        from a single run fit completely on a single DVD.
        The package is completey described in the
        <link linkend="manpage.dvdburner">dvdburner package manpage</link>.
    </para>
    <para>
        To use
        <application>DvdBurner</application>
        you must make the package known to your script.  Doing this involves
        both making the location of the package known to the Tcl package loader
        and requiring the package.
        The following example shows how to do it assuming that you've defined
        the envirionment varible DAQROOT to point to the directory in which the
        NSCL DAQ system is installed.  At the NSCL, this directory is usually
        <filename>/usr/opt/daq/someversion</filename> where
        <literal>someversion</literal> is the version of nscldaq you are using.
    </para>
    <example>
        <title>Requesting the DvdBurner package</title>
        <programlisting>
set libdir [file join $::env(DAQROOT) TclLibs]
set auto_path [concat $libdir $auto_path]

package require DvdBurner
        </programlisting>
    </example>
    <para>
        The example prepends the path to the NSCL DAQ libraries to the
        <varname>auto_path</varname>
        that lists the directories searched by the Tcl package loader.
        Prepending ensures that if there are accidental duplicate package names,
        we get the one in the NSCL DAQ software.
    </para>
    <para>
        Typically, the only thing you'll want your script to do is burn a set
        of runs to DVD, partitioning the data amongst several DVDs as needed.
        The script below shows how to do write runs 100 through 150 to DVD:
    </para>
    <example>
        <title>Writing runs to DVD using <application>DvdBurner</application></title>
        <programlisting>
DvdBurner::CreateDvds [list 100 150]
        </programlisting>
    </example>
    <para>
        If the second parameter to
        <function>DvdBurner::CreateDvds</function>
        is omitted, all runs starting with  first parameter are written to DVD.
        With no parameters, all runs are written to DVD:
    </para>
    <example>
        <title>Writing all runs to DVD</title>
        <programlisting>
DvdBurner::CreateDvds
        </programlisting>
    </example>
    <para>
        Writes all runs to DVD.
    </para>
</chapter>


<chapter id="chapter.dvdburn">
    <title>Utilities for burning data to DVD</title>
    <para>
        While the NSCL does not officially support burning data to DVD, two
        utilities are provided that allow you to create informal archives of
        data taken with NSCLDAQ on DVD.
    </para>
    <para>
        The command line utility
        <application>dvdburn</application>
        provides a simple command that burns a set of run to DVD,
        creating more than one DVD if needed, splitting DVDs between runs.
        See the
        <link linkend="manpage.dvdburn">dvdburn reference page</link>
        for information about how to use this program.
    </para>
    <para>
        A simple graphical user interface wizard for burning NSCLDAQ data to
        DVD is provided by
        <application>burngui</application>.
        <application>burngui</application> is really a front end for
        <application>dvdburn</application>.
        See the
        <link linkend="manpage.burngui">burngui reference page</link>
        for complete information on that application.
    </para>
</chapter>


<chapter id="chapter.epicsdisplay">
    <title>The epics display utility</title>
    <para>
        The
        <application>epicsdisplay</application>
        utility provides a tabular display of an arbitrary set of epics channels.
        It is possible to configure a set of channels to be displayed on a chart
        recorder at the bottom of the display as well.
        Complete reference documentation is available at the
        <link linkend="manpage.epicsdisplay">epicsdisplay reference page</link>
    </para>
    <para>
        <application>epicsdisplay</application> reads in a configuration file.
        The configuration file is compatible with
        <link linkend="manpage.controlpush">the controlpush</link> application,
        which uses it to fetch epics channesl and make them known to
        <application>epicsdisplay</application>.
        <application>epicsdisplay</application> interprets additional information
        in the file as metadata that describes such things as:
        <itemizedlist>
            <listitem><para>
                Alarms on the channel and how to display the alarm condition.
                      </para>
            </listitem>
            <listitem><para>
                Whether or not a channel should be displayed as a trace on a
                chart recorder graph at the bottom of the window.
                      </para>
            </listitem>
        </itemizedlist>
    </para>
    <para>
        Extensive online help is provided via the
        <menuchoice><guimenu>Help</guimenu><guimenuitem>Topics...</guimenuitem></menuchoice>
        menu entry.
    </para>
</chapter>


<!-- manpage 1tcl -->
    <refentry id="manpage.epicsdisplay">
    <beginpage />
    <refmeta>
        <refentrytitle>epicsdisplay</refentrytitle>
        <manvolnum>1tcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>epicsdisplay</refname>
        <refpurpose>Display epics channels</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
epicsdisplay channel file
            </command>
        </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
       Monitors  a  set  of EPICS channels in tabular and, optionally, chart recorder
       form.  channelfile is the name of a file that describes the epics channels  to
       monitor.   The  file consists of two types of text lines; comments and channel
       lines.  Comment lines begin with the hash character lines begin with a channel
       name  followed  by  whitespace,  followed  by  an  optional  comment.   If the
       optional comment contains the special word ââchartââ, the channel is added  to
       the chart recorder.
        </para>
        <para>
       Channels can also have alarms defined on them.  An alarm is said to fire whenâ[m
       ever the channel value is outside of a  ânominalâ  window.   Alarms  are  also
       defined  using special keywords in the comment field of the channel.  The keyâ[m
       word nominal indicates that the next word on the line  defines  the  channelâs
       nominal window.  The nominal window definition can be defined either symmetriâ[m
       cally or asymmetrically about a nominal value.  The nominal window can also be
       defined  in  absolute  terms  or  in  terms  of a percentage of nominal value.
       Describing nominal windows is most easily done via example.
        </para>
        <variablelist>
            <varlistentry>
                <term><literal>nominal 35:3</literal></term>
                <listitem>
                    <para>
                        Defines a symmetric nominal window about the nominal  value  35.   This
                        nominal window is the range 32 through 38.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>nominal 35:10%</literal></term>
                <listitem>
                    <para>
                        Defines  a  nominal interval that is +/- 10% of 35... e.g. the interval
                          32.5 through 38.5
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>nominal 35+3-4</literal></term>
                <listitem>
                    <para>
                      Defines a nominal window between 31 and 38.  Similarly:
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>nominal 35+5%-10%</literal></term>
                <listitem>
                    <para>
                        Defines the nominal interval 32.5 through 36.75.  Note that  for  asymâ[m
                        metric  intervals  mixes  of  absolute  and  percentage  tolerances are
                        allowed.  Furthermore, the - and + are interchangeable.
                    </para>
                 </listitem>
             </varlistentry>
        </variablelist>
        <para>
       When a channel transitions to the alarmed state, actions defined on  the  comâ[m
       ment line for the channel are taken.  Actions are defined by the keyword alarâ[m
       mactions followed by a comma separated list  of  actions.   Supported  actions
       are:
       </para>
        <variablelist>
            <varlistentry>
                <term><literal>page</literal></term>
                <listitem>
                    <para>
                        The alarm is added to a page that describes all the current alarms.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>beep</literal></term>
                <listitem>
                    <para>
                        A  beep  is  periodically  emitted  while the channel is in the alarmed
                          state.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>popup</literal></term>
                <listitem>
                    <para>A popup window is displayed when the alarm is in the alarmed state.</para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>color=colorspec</literal></term>
                <listitem>
                    <para>
              The alarm is displayed with the specified colorspec colored background.
              colorspec  is  a color using any color specification that is recognized
              by Tcl.  (.e.g. color=red  is the same as color=&#035;ff0000).
                    </para>
                </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
        <refsect1>
            <title>OPERATING INSTRUCTIONS</title>
            <para>
       The display is divided into three sections. The top section is the channel taâ[m
       ble.  The middle section the chart recorder section and the bottom section the
       chart control panel.
        </para>
        <para>
       While it appears as if the table section has no controls,  in  reality  it  is
       possible  to  resize  all  of  the columns of the table.  Expanding the window
       width adds space to the right most, Comment column.  All other columns may  be
       expanded by dragging their borders with the mouse.
        </para>
        <para>
       The  chart  recorder control panel allows the user to perform a few operations
       on the chart.  The Clear button resets the time to 0 and clears the data accumulated so far.
        </para>
        <para>
       The  rightmost  three  controls  manage  the  time  scale of the chart widget.
       Changes to these widgets do nothing until the Set  button  is  clicked.    The
       widget  states at that time determine the scale of the chart recorder.  If the
       ââAuto Rangeââ checkbutton is set, the time scale will change  dynamically  to
       accomodate  the  full  time  range  of values.  If unchecked, the value in the
       entry widget labelled <literal>Range (min):</literal>  determines the width in  time  of  the
       chart.  The chart is scrolled as needed (by 10% of the range) to keep the most
       recent data visible.
       </para>
        
    </refsect1>
    <refsect1>
        <title>Dependencies</title>
        
        <itemizedlist>
            <listitem><para>
            Requires the
            <link linkend="manpage.controlpush">controlpush</link> utility.
            </para></listitem>
            <listitem><para>
                Requires the server port manager application.
            </para></listitem>
        </itemizedlist>
        
    </refsect1>
    </refentry>

    

<!-- /manpage -->
    
<chapter id="chapter.scalerdisplay">
    <title>Scaler Display Software.</title>
       <para>
            The scaler display software consists of two components:
       </para>
       <variablelist>
            <varlistentry>
                <term>
                    <link linkend="manpage.sclclient"><application>sclclient</application></link></term>
                <listitem>
                    <para>
                        Connects to the NSCL data acquisition system buffer manager
                        and accepts scaler and run state-change buffers.  The software
                        connects to a
                        <link  linkend="manpage.tclserver">tclserver</link>
                        application and maintains a set of Tcl variables in that server
                        that describe instantaneous and continuous scaler state.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <link linkend="manpage.scalerdisplay"><application>ScalerDisplay</application></link></term>
                <listitem>
                    <para>
                        A script that starts up a
                        <link linkend="manpage.tclserver">tclserver</link> that runs a script
                        which takes the variables maintained by
                        <link linkend="manpage.sclclient">sclclient</link>, a configuration file
                        and produces a scaler display.
                    </para>
                </listitem>
            </varlistentry>
       </variablelist>
</chapter>

<chapter id="chapter.sequencer">
    <title>Sequencing runs</title>
    <para>
        The NSCL Run sequencer provides a mechanism for scheduling as series
        of timed runs.  Prior to the start of each run, the sequencer
        allows custom actions to be taken. While these actions normally
        set up hardware, there is no actual requirement this be the case.
        Any parameterizable action can be taken.
    </para>
    <para>
        For a full description of the sequencer, see its
        <link linkend="manpage.sequencer">reference manual page.</link>.
        This chapter gives an overview that describes how to use and configure
        the sequencer.
    </para>
    <section>
        <title>Configuring the sequencer.
        </title>
        <para>
            The sequencer requires the following configuration work:
            <itemizedlist>
                <listitem><para>
                    The actions executed prior to each run must be defined.
                    Each action accepts a parameter which becomes a column of the
                    run plan.
                </para></listitem>
                <listitem><para>
                    A run plan.  This is a specification of the parameters
                    for each  of the actions to be taken prior to starting a run.
                    The run plan is displayed to the user as a table which can
                    be edited.
                </para></listitem>
                <listitem><para>
                    The sequencer must be incorporated into the Readout GUI
                    (see the chapter on the Readout GUI).
                </para></listitem>
            </itemizedlist>
        </para>
        <para>
            Furthermore, each action must provide Tcl code that executes it and,
            optionally initializes its access to whatever it might control.
        </para>
        <para>
            The actions are defined in a file named
            <filename>sequencer.conf</filename> in the current working directory
            at the time the sequencer starts.  This file describes one action
            on each line.  Each sequencer line contains several whitespace
            separated fields.  In order:
            <itemizedlist>
                <listitem><para>
                    Name of the action.  This name will be passed to the
                    action's procedure. 
                </para></listitem>
                <listitem><para>
                    GUI name of the action.  This name will be used to label the
                    action's column in the run plan table.
                </para></listitem>
                <listitem><para>
                    Set action (optional):  This is the name of a Tcl <command>proc</command>
                    used to perform the action.  It is passed the name of the
                    action (value of the first column), and the value of the
                    action parameter.  If omitted no action is taken at the beginning
                    of the run.
                </para></listitem>
                <listitem><para>
                    Initialize action (optional):  This is the name of a Tcl
                    <command>proc</command> that is called as the sequencer initializes.
                    it is passed tha name of the action.
                </para></listitem>
            </itemizedlist>
        </para>
        <para>
            When the sequencer starts it will source in the Tcl script file
            <filename>sequencerActions.tcl</filename> from the current working
            directory.  This file contains arbitrary Tcl scripts.  It is expected
            to define all of the action
            <command>proc</command>s described in <filename>sequencer.config</filename>.
        </para>
        <para>
            Run plan files can be created graphically in the sequencer table.
            Simply edit each cell of the table with the appropriate
            parameter for that run and that action.    The
            <menuchoice><guimenu>File</guimenu><guimenuitem>Save...</guimenuitem></menuchoice>
            menu selection allows yoj to save run plans for later (re)use.
        </para>
        <para>
            Run plan files are plain text files.  Each line contains the parameterization
            of a run. Lines contain whitespace separated fields where each field is
            a parameter value for a run.
        </para>
        <para>
	   The run sequencer must be integrated with the Readout GUI.  This is
	   done by providing (or modifying an existing) 
	   <filename>ReadoutCallouts</filename>.
	   See the
	   Readout GUI reference
	   page
	   for information about how the readout GUI locates its 
	   <filename>ReadoutCallouts</filename>
	   file.
        </para>
	<para>
	   The sequencer is provided as a Tcl package located in the 
	   <filename>TclLibs</filename> directory tree of the NSCL DAQ
	   installation.  To load it you will need to have this 
	   directory in your Tcl Load path.  This can be done either
	   by setting the <varname>TCLLIBPATH</varname>
	   environment variable, or by having 
	   <filename>ReadoutCallouts.tcl</filename>
	   add the appropriate directory to the
	   <varname>auto_path</varname> loader list.
	</para>
	<para>
	  The example below takes a hybrid approach.  We assume you've 
	  set an environment variable <varname>DAQROOT</varname> to be
	  the top level directory of the NSCL DAQ installation.
	  At this NSCL, this might be 
	  <filename>/usr/opt/daq/9.0</filename> for example.
          The example shows additions to the top of the
	  <filename>ReadoutCallouts.tcl</filename> script
	  that make the sequencer package loadable, and
	  load it:
	</para>
	<example>
	   <title>Loading the sequencer package</title>
	   <programlisting>
set daqroot $env(DAQROOT)                <co id="chapter.sequencer.env" />
set libdir [file join $daqroot TclLibs]  <co id="chapter.sequencer.join" />

set auto_path [concat $libdir $auto_path] <co id="chapter.sequencer.path" />

package require runSequencer             <co id="chapter.sequencer.require" />

	   </programlisting>
	</example>
	<calloutlist>
	   <callout arearefs="chapter.sequencer.env">
	      <para>
	         The global <varname>env</varname> array contains a 
		 copy of the environment variables indexed by 
		 variable name.  This line gets the 
		 <varname>DAQROOT</varname> environement
		 variable.
              </para>
           </callout>
	   <callout arearefs="chapter.sequencer.join">
	      <para>
	          The Tcl <command>file join</command> joins 
		  filename path elements inserting the appropriate
		  path separator, and quoting if needed.  This
		  line constructs the name of the directory 
		  in which NSCL DAQ packages are found.
	      </para>
           </callout>
	   <callout arearefs="chapter.sequencer.path">
	      <para>
	         This line pre-pends the NSCL DAQ Tcl library
		 directory to the list of directories 
		 (<varname>auto_path</varname>) searched by
		 the Tcl.  Prepending ensures that if there are
		 any package name collisions, the NSCL DAQ
		 packages will be found first.
	      </para>
           </callout>
	   <callout arearefs="chapter.sequencer.require">
	      <para>
	         This line actually loads the sequencer package.
		 By the time this line finishes, the sequencer
		 configuration files, and action scripts will have
		 been read, and the sequencer user interface created.
              </para>
           </callout>
	</calloutlist>
    </section>
    <section>
        <title>Using the sequencer.</title>
        <para>
	   The sequencer GUI consists of a table called the
	   <firstterm>run plan table</firstterm> Edit this
	   table to set the parameters for each action item
           column for each run in the plan (runs are rows across
	   the table).
        </para>
	<para>
	   The
	   <menuchoice><guimenu>File</guimenu><guimenuitem>Save...</guimenuitem></menuchoice>
	   menu will save a run plan for later use.  If you've already created
	   a run plan, you can read it in with the
	   <menuchoice><guimenu>File</guimenu><guimenuitem>Open...</guimenuitem></menuchoice>	   
	   menu selection.
	   Finally the
	   <menuchoice><guimenu>File</guimenu><guimenuitem>Clear</guimenuitem></menuchoice>
	   menu selection clears the run plan table.
	</para>
	<para>
	  The length of each run is set by the length of the timed run section
	  on the main ReadoutGUI window.  To execute a run plan, 
	  click the <guibutton>Execute</guibutton> button on the 
	  run plan table window.  This button then is relabeled
	  <guibutton>Abort</guibutton>, and can be used to abort
	  a run plan if something goes wrong.
	</para>
	<para>
	   As the run plan executes, the run that is active is highlighted on
           the run plan table.
           When the run plan is complete, or if the run plan was
	   aborted,  the 
	   <guibutton>Abort</guibutton> is relabeled
	   <guibutton>Execute</guibutton> and will restart the
	   run plan if clicked.
	</para>
    </section>
</chapter>

    
<chapter id="chapter.tclserver">
    <title>The tcl server application</title>
    <para>
        TclServer is a deceptively simple program.  It is a wish (Tk) interpreter
        that allows Tcp/IP connections from a local or remote client.
        Once connected, the client can send messages consisting of Tcl commands
        and receive the result of executing those commands from the server.
    </para>
    <para>
        TclServer is used as the basis of a number of applications in the
        NSCLDAQ system including the scaler display program, the epicsdisplay
        program and other software written by specific groups. Tcl servers can
        be used as distributed data repositories (store data in server Tcl variables and/or
        arrays and get them back out), or as display programs that can be remote-controlled.
        The production readout framework has a Tcl Server component that can be enabled.
    </para>
    <para>
        This chapter contains:
	A description of the TclServer protection model.  For complete
    information about the TclServer see
    <link linkend="manpage.tclserver"> the TclServer reference pages
    </link>.
    </para>
        <para>
            The TclServer protection model is not very stringent.  The assumption
            is that TclServers can only be reached by trusted systems.  Specifically
            systems that have not been broken into and will not spoof host names.
            When a TclServer starts, it will only allow connections from
            <literal>localhost</literal>.
        </para>
        <para>
            The TclServer extends the Tcl/Tk command set with the command
            <command>serverauth</command> this command allows you to authorize
            additional systems to connect  to the server.  The complete form
            of the <command>serverauth</command> command is described in
            the <link linkend="manpage.serverauth"> reference page for the
	    <command>serverauth</command> command.</link>.
            section.
        </para>
        <para>
            The following command adds the node <literal>spdaq20.nscl.msu.edu</literal>
            to the set of hosts that are allowed to connnect to the server.
        </para>
        <example>
            <title>Using <command>serverauth</command> to authorize a node</title>
            <programlisting>
serverauth add spdaq20.nscl.msu.edu
            </programlisting>
        </example>
</chapter>


</part>
<part>
<title>libraries</title>
<chapter>
    <title>Integer byte order conversion library</title>
    <para>
        The <application>cvt</application> package provides functions that convert
        data from foreign host to local host integer formats and back.
        These functions are designed to make use of a byte order signature
        that describes the byte order of the foreign host.
    </para>
    <para>
        Reference material for this library is available in the
        <link linkend="manpage.cvt">reference manual page for cvt </link>.
    </para>
    <para>
        This chapter gives an high level view of how the
        library should be used.
    </para>
    <section>
        <title>Using the conversion library in your code</title>
        <para>
            The conversion library is a set of C functions.  To use it,
            you will need to include the library header in your source code
            with a line like:
            <example>
                <title>Including the cvt header</title>
                <programlisting>
#include &lt;cvt.h&gt;
                </programlisting>
            </example>
        </para>
        <para>
            You will also need to link the conversion library into your executable
            program.  Since the conversion headers and libraries are generally
            not installed in the normal search paths for headers and libraries,
            you will need to help the compiler find them at compile and link time.
            In this discussion, we will assume you have defined an environment
            variable DAQROOT to point to he NSCL DAQ installation directory
            (at the NSCL this will typically be in
            <filename>/usr/opt/daq/some-version</filename>
            where <literal>some-version</literal> is the version of the NSCLDAQ
            you are selecting.
        </para>
        <example>
            <title>Compiling a C or C++ source file that includes <filename>cvt.h</filename></title>
            <programlisting>
gcc -c -I$DAQROOT/include myprogram.c

or

g++ -c -I$DAQROOT/include myprogram.cpp

            </programlisting>
        </example>
        <example>
            <title>A makefile rule that builds a C++ program using the
                <application>cvt</application> package</title>
            <programlisting>
theprogram: $(OBJECTS)
    g++ -o theprogram $(OBJECTS) -L$(DAQROOT)/lib -lcvt -Wl,"-rpath=$(DAQROOT)/lib"
            </programlisting>
        </example>
    </section>
    <section>
        <title>Byte order signatures and conversion blocks</title>
        <para>
            Byte order signatures are known integer values that are available
            in the foreign system's byte oder.  By examining these on a byte by byte
            basis, the byte ordering of the remote system can be determined.
            While typically systems have a consistent ordering of bytes in words
            and words in longwords, the library does not assume that.
        </para>
        <para>
            A system that is supplying data to be converted with this library
            must provide a 16 bit and a 32 bit signature.  These are the
            values <literal>0x0102</literal> and <literal>0x01020304</literal>
            repsectively written in that system's native byte ordering.
        </para>
        <para>
            The function <function>makecvtblock</function> takes those signatures
            and delivers a <type>DaqConversion</type> block.  The
            <type>DaqConversion</type> block is a data structure that provides
            conversion tables for foreign to host and host to foreign conversions.
        </para>
        <para>
            Suppose you have data in a structure that contains these signatures
            as fields named <varname>s_ssig</varname> and
            <varname>s_lsig</varname>.  The example below shows how to
            create a conversion block:
        </para>
        <example>
            <title>Creating a <type>DaqConversion</type></title>
            <programlisting>
#include &lt;cvt.h&gt;
...
DaqConversion conversionBlock;
makecvtblock(data.s_lsig, data.s_ssig, &amp;conversionBlock);
...
            </programlisting>
        </example>
        <para>
            The <type>DaqConversion</type> block
            <varname>conversionBlock</varname>
            can be used in subsequent calls to do byte order conversions.
        </para>
    </section>
    <section>
        <title>Data conversion</title>
        <para>
            Data conversion functions are provided to convert both from
            the foreign system to the host, and from the host to the foreign
            system.  Before we look at these functions, some definitions:
        </para>
        <variablelist>
            <varlistentry>
                <term><firstterm>host</firstterm></term>
                <listitem><para>
                    The system that is running our program.
                </para></listitem>
            </varlistentry>
            <varlistentry>
                <term><firstterm>foreign system</firstterm></term>
                <listitem><para>
                    The system that produced the data we are trying to process.
                    This could be the same system as the host or a different system.
                    This could have the same or different native byte ordering
                    than the host.
                </para></listitem>
            </varlistentry>
        </variablelist>
        <para>
            Functions are provided that allow you to convert shorts and longs
            in either direction.  These functions are described more completely
            in the
            <link linkend="manpage.cvt">cvt reference page</link>.
            Briefly however:
        </para>
        <variablelist>
            <varlistentry>
                <term><function>ftohl</function></term>
                <listitem><para>
                            Converts a longword (32 bit integer) from foreign
                            to host format.
                </para></listitem>
            </varlistentry>
            <varlistentry>
                <term><function>ftohw</function></term>
                <listitem><para>
                            Converts a short (16 bit word) from foreign to host
                            format.
                </para></listitem>
            </varlistentry>
            <varlistentry>
                <term><function>htofl</function></term>
                <listitem><para>
                            Converts a longword (32 bit integer)
                            from host to foreign system format.
                          </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><function>htofs</function></term>
                <listitem><para>
                            Converts a short (16 bit integer)
                            from host to foreign system format.
                          </para>
                </listitem>
            </varlistentry>
        </variablelist>
            
    </section>
</chapter>


<chapter id="chapter.exception">
    <title>The NSCL Exception class library</title>
        <para>
            C++ provides an error detection/recovery mechanism called
            exception handling.  Exception handling, while not always easy
            to program correctly is well suited to object oriented software
            development.
        </para>
        <para>
            Exceptions in C++ are objects that are thrown in search of catchers.
            As each call frame is searched for a catcher, and the exception propagates up
            the call chain.  Object destructors for non-dynamically allocated objects
            get called ensuring proper object cleanup.  If an exception can find no
            catcher, the application exits with an error.
        </para>
        <para>
            The linguistic construction for emitting, or throwing and exception is the
            <command>throw</command> statement. For example:
            <programlisting>
throw SomeObject;
            </programlisting>
        </para>
        <para>
            The linguistic mechanism for specifying exception catchers is the
            <command>try/catch</command> block:
            <programlisting>
try {
   &hellip;
}
catch (SomeType variable) {
   &hellip;
}
&hellip;
catch (...) {
&hellip;
}
            </programlisting>
        </para>
        <para>
            If an exception is thrown within the block body of the <command>catch</command>
            statement, the catch blocks are searched for a matching data type, and the
            textually first matching block is executed.  If none match and a
            <command>catch (...)</command> is specified it is invoked.
        </para>
        <para>
            You can also re-throw an exception after processing using an empty <command>throw</command>
            statement.  This is used in the following example to destroy some dynamically
            allocated memory.
            <programlisting>
SomeType* pType;
try {
   pType = new SomeType;
   &hellip;
}
catch (...) {
    delete pType;
    throw;
}
            </programlisting>
        </para>
        <para>
            Exception catching does allow polymorphism.  For example, suppose we have a base class
            <classname>MyBase</classname> and a derived class <classname>Derived</classname>.
            <programlisting>
try {
    &hellip;
    throw Derived;
    &hellip;
}
catch (MyBase&amp; reason) {
    &hellip;
}
            </programlisting>
            The catch block will execute, and if virtual methods are called, the <classname>Derived</classname>
            implementation will be used.
        </para>
        <section>
            <title>Incorporating the library in your programs</title>
            <para>
                So much for an introduction to C++ exception handling.  Based on the presentation so far,
                however there are clear advantages to defining a hierarchy of exceptions that derive
                from a common base class that provides a common set of reporting facilities.  The
                NSCL Exception class library in SpecTcl and nscldaq does this.  This library named
                <filename>libException.so</filename> that can be found in the lib directory of the
                NSCL DAQ or SpecTcl installations.   Linking with that library is a matter of e.g.:
                <programlisting>
g++   &hellip;  -L/usr/opt/spectcl/3.2/lib -lException -Wl,"-rpath=/usr/opt/spectcl/3.2/lib"
                </programlisting>
            </para>
            <para>
                Be sure to substitute the correct top level directory for
                <filename>/usr/opt/spectcl/3.2</filename> in both places in the example above.
            </para>
            <para>
                The base class of the library is called <classname>CException</classname>.  All NSCL
                frameworks and applications enclose essentially the entire program or the body of each thread
                in a try/catch block that can catch and report the error information from a
                <classname>CException</classname> prior to exiting.  Your code can catch this or
                derived class issues either for error reporting or error recovery purposes.
            </para>
        </section>
        <section>
            <title>Exception classes</title>
            <para>
                The exception classes forma hierarchy with
                <classname>CException</classname>
                as the base class.
                <classname>CException</classname> provides a unified interface
                to all exceptions that allow you to get human readable messages
                and status information that can be processed by computers (e.g.
                for exception recovery).
            </para>
            <para>
                All exceptions have the following member functions (virtual):
                <itemizedlist>
                    <listitem><para>
                        <methodsynopsis>
                        <modifier>virtual const</modifier> <type>char*</type> <methodname>ReasonText</methodname>
                        <void /> <modifier>const</modifier>
                        </methodsynopsis>
                        Which returns a human readable error string that contains an error
                        message describing why the exception was thrown and what was being done
                        when the error that triggered the exception occured.
                </para></listitem>
                <listitem><para>
                            <methodsynopsis>
                                <modifier>virtual</modifier> <type>Int_t</type>
                                <methodname>ReasonCode</methodname>
                                <void /> <modifier>const</modifier>
                            </methodsynopsis>
                            Which returns some exception specific error code, that
                            can be processed by software for error recovery.
                          </para>
                </listitem>
            </itemizedlist>
        </para>
        <para>
            The example below shows the simplest handling of
            <classname>CException</classname> types.  Note that the exception
            is caught by reference so that member functions retain their
            polymorphism.
        </para>
        <example>
            <title>Catching <classname>CException</classname> and exiting</title>
            <programlisting>
#include &lt;Exception.h&gt;
#include &lt;iostream&gt;
using namespace std;
...
try {
...
}
catch (CException&amp; error) {
    cerr &lt;&lt; err.ReasonText() &lt;&lt; endl;
    exit(-1);
}
            </programlisting>
        </example>
        <para>
            The example prints out a meaningful error message and exits the program.
        </para>
    </section>
</chapter>


<chapter id="chapter.security">
    <title>Access control and security</title>
    <para>
        Security consists of authentication, and authorization.
        Authentication determines who the entity requesting service is.
        Authorization determines if the authenticated entity has a right to
        request the service it has requested.
    </para>
    <para>
        The NSCLDAQ security software helps your application to perform simple
        authentication and authorization according to policies set by your application.
        The NSCLDAQ security software is not a high security system.  It is
        primarily intended to avoid errors on multi users data taking systems.
        It is not intended to secure against malicious attacks.
    </para>
    <para>
        The assumption is that your data acquisition system is already secured,
        from unauthorized users either by living behind a firewall, or by security
        management in the system itself.
    </para>
    <para>
        Two class hierarchies work together to do authentication.  Authenticators,
        and Interactors.  Interactors accept authentication credentials from
        some source (credentials are anything that identify an entity within some
        authentication scheme).  Authenticators examine those credentials to determine
        if they are legitimate.
    </para>
    <section>
        <title>Incorporting the software into your code</title>
        <para>
            In order to incorporate this software into your application you will
            need to include various header files.  The reference section for
            each class describes the headers you need.  The headers live in the
            <filename>include</filename> subdirectory of the nscldaq installation.
            Suppose you have an environment variable <literal>DAQROOT</literal>
            defined that points to the top level directory of the NSCL DAQ installation
            (at the NSCL, this is <filename>/usr/opt/daq/someversion</filename> where
            <literal>someversion</literal> is the version installed), to compile
            modules that include headers from this library you must:
        </para>
        <example>
            <title>Compilation switches for the security includes</title>
            <screen>
g++ -c -I$DAQROOT/include ...
            </screen>
        </example>
        <para>
            At link time, you must link the security library into your
            application.  To do this you must supply switches to help the
            linker locate the library at both link and run time, as the
            library is typically a shared library.  For example:
        </para>
        <example>
            <title>Link switches for the security library</title>
            <screen>
g++ -o myapplication ... -L$DAQROOT/lib -lSecurity -Wl,"-rpath=$DAQROOT/lib"...
            </screen>
        </example>
    </section>
    <section>
        <title>Authenticators</title>
        <para>
            The
            <classname>CAuthenticator</classname>
            class is the abstract base class of all authenticators.
            It provides an interface that all authenticators must meet.
            In typical operation, an application will select a concrete authenticator,
            and pair it with a concrete interactor.  The application will then
            authenticate requestors using this pair of objects.
            Here's some sample boilerplate code:
        </para>
        <example>
            <title>Boilerplate DAQ Authorization code </title>
            <programlisting>
#include &lt;Authenticator.h&gt;
#include &lt;Interactor&gt;

...
    CAutenticator* pAuthenticator =  selectAuthenticator();
    CInteractor*   pInteractor    =  selectInteractor();
    if (pAuthenticator-&gt;Authenticate(*pInteractor)) {
        // Authorized to use the service.
        ...
     }
    else {
     // Not authorized to use the service.
     ...
    }
    // Assuming the interactor an authenticator are dynamically allocated
    // by the selection functions.
    
    delete pAuthenticator;
    delete pInteractor;
            </programlisting>
        </example>
        <para>
            In the example above, the functions not shown,
            <function>selectAuthenticator</function>
            and
            <function>selectInteractor</function>
            determine the actual authentication method and authorization policy.
            The implementation of these functions will vary from application to
            application.
        </para>
        <para>
            The complete definitinon of
            <classname>CAuthenticator</classname> is provided in
            <link linkend="manpage.cauthenticator">its reference pages</link>.
            The library provides the following concrete authentication classes:
        </para>
        <variablelist>
            <varlistentry>
                <term><link linkend="manpage.cpasswordcheck"><classname>CPasswordCheck</classname></link></term>
                <listitem><para>
                    The entity must provide a correct password.  Note that the current
                    set of interactors do not support encrypted interactors.  This can be
                    extended if required.
                </para></listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend="manpage.cunixusercheck"><classname>CUnixUserCheck</classname></link></term>
                <listitem>
                    <para>
                        The entity must provide a valid username and password
                        that is could login to the local unix system.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend="manpage.ctclaccesslistcheck"><classname>CTclAccesListCheck</classname></link></term>
                <listitem>
                    <para>
                        Intended for use within a Tcl interpreter.  The entity must
                        supply some string that is an element of a Tcl list
                        held in a Tcl variable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend="manpage.caccesslistcheck"><classname>CAccessListCheck</classname></link></term>
                <listitem>
                    <para>
                        The entity must supply a string that is one of a set of strings
                            given to the authenticator.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend="manpage.chostlistcheck"><classname>CHostListCheck</classname></link></term>
                <listitem>
                    <para>
                        Same as <classname>CAccessListCheck</classname> but the
                        access list is a set of IP addresses.  The entity's
                        credentials are translated to an IP address and looked up
                        in the set of allowed items.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </section>
    <section>
        <title>Interactors</title>
        <para>
            Interactors are classes that are concrete classes derived
            from the abstract base class
            <link linkend="manpage.cinteractor"><classname>CInteractor</classname></link>.
            They are intended to obtain the authentication credentials from the
            entity requesting service.  If the interactor is in some way
            interactive, it may also prompt the user for the elements of the
            credentials required.
        </para>
        <para>
            The abstract base class
            <classname>CInteractor</classname> provides the following
            member functions as abstract virtual functions that will be
            implemented differently in each concrete interactor class:
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier>
            <type>int</type> <methodname>Read</methodname>
            <methodparam>
                <type>Uint_t</type> <parameter>nBytes</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>pData</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Reads data from the interactor.  The
            <classname>CAuthenticator</classname>
            base class provides a convenience method that reads an entire
            line of text from the requestor.
        </para>
        
            
        <methodsynopsis>
            <modifier>virtual</modifier> <type>int</type> <methodname>Write</methodname>
            <methodparam>
                <type>UInt_t</type> <parameter>nBytes</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>pData</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Writes data to the entity that's behind the interactor.
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier> <type>int</type> <methodname>ReadWithPrompt</methodname>
            <methodparam>
                <type>Uint_t</type> <parameter>nPromptSize</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>pPrompt</parameter>
            </methodparam>
            <methodparam>
                <type>UInt_t</type> <parameter>nReadSize</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>pReadData</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Prompts for input if the interactor supports prompting and then
            accepts data from the entitiy.
        </para>
        <para>
            In addition to
            <link linkend="manpage.cinteractor">CInteractor</link>, the following
            concrete interactors have been supplied.
        </para>
        <variablelist>
            <varlistentry>
                <term><link linkend="manpage.cstringinteractor"><classname>CStringInteractor</classname></link></term>
                <listitem>
                    <para>
                        This interactor supplies a string that you have gotten by
                        whatever means you got it.  It can be used when interactors
                        are not suitable for acquiring the stringified credentials.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend="manpage.cfdinteractor"><classname>CFdInteractor</classname></link></term>
                <listitem>
                    <para>
                        This interactor accepts the credentials via an open file
                        descriptor.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><link linkend="manpage.ciointeractor"><classname>CIOInteractor</classname></link></term>
                <listitem>
                    <para>
                        This interator uses a pair of other interactors, an output and
                        an input interactor. Prompting is done on the output interactor and
                        the credentials read from the input interactor.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </section>
        
</chapter>


<chapter id="chapter.tclplus">
    <title>C++ encapsulation of a Tcl API subset</title>
    
        <para>
            The tclPlus library provides a C++ object oriented
            encapsulation of a large subset of the Tcl application programming
            interface.  This section provides reference material for this class library.
        </para>
        <para>
            Sections of the NSCLDAQ and SpecTcl products both make extensive use of this
            library.  It is therefore distributed with both prodcuts, from a common source base.
            Therefore, there are two ways to link to this library.
            First, using SpecTcl:
            <programlisting>
            <command>
g++ -o <replaceable>yourprogram yoursources</replaceable>  \
               -L${SPECTCLHOME}/lib -ltclPlus -lException
            </command>
            </programlisting>
            where <literal>${SPECTCLHOME}</literal> represents the top level director of
            your SpecTcl installation.  At the NSCL, for example, this could be
            <filename>/usr/opt/spectcl/3.2</filename>
        </para>
        <para>
            Second, using nscldaq, replace <literal>${SPECTCLHOME}</literal> with the top
            level directory of your NSCLDAQ installation, e.g.
            <filename>/usr/opt/daq/8.1</filename>.
        </para>
        <para>
            Some brief descriptions of the primary classes in this library follow:
        </para>
        <para>
            <classname>CTCLApplication</classname>
        </para>
        <para>
            This is a base class for complete applications that extend the Tcl/Tk
            interpreter.  By appropriately subclassing it you can build your own
            standalong extended Tcl/Tk interpreters.
        </para>
        <para>
            <classname>CTCLException</classname>
        </para>
        <para>
            The Tcl/Tk API use return codes to indicate error conditions.  This is
            error prone.  The tclPlus library converts these return codes in to
            thrown exceptions of the type <classname>CTCLException</classname>.
            To handle these exceptions properly requires use of  C++ try/catch blocks.
            A code fragment example of this is provided in the
            <classname>CTCLException</classname>(3) manpage.
        </para>
        <para>
            <classname>CTCLInterpreter</classname>
        </para>
        <para>
            The <classname>CTCLInterpreter</classname> object is at the core of the
            library.  It is a wrapping of a <type>Tcl_Interp*</type> along with member
            functions that access many functions that logically operate on a Tcl interpreter.
        </para>
        <para>
            <classname>CTCLInterpreterObject</classname>
        </para>
        <para>
            The <classname>CTCLInterpreterObject</classname> wraps objects that
            require an interpreter to function correctly.  It is a base class for
            many of the classes in the library.  It provides common services for those
            objects.
        </para>
        <para>
            <classname>CTCLList</classname>
        </para>
        <para>
            In Tcl scripting, lists play a key role in providing a structured
            data type.  The <classname>CTCLList</classname> object can be created
            on a string believed to be a list, and used to split a list into its
            elements or merge a set of words into a list.
        </para>
        <para>
            <classname>CTCLObject</classname>
        </para>
        <para>
            Tcl has the philosophy that everything can be treated as if it were a string.
            In older versions of the interpreter, everything <emphasis>was</emphasis> a
            string. This led to a great deal of inefficiency converting other data types
            to and from strings.  The <type>Tcl_Obj</type> type was created to reduce this
            inefficiency and to reduce the amount of string copying that was necessary
            to invoke commands.
        </para>
        <para>
            A <type>Tcl_Obj</type> is an object  that stores the string representation
            and another representation type for a Tcl interpreter entity.  <type>Tcl_Obj</type>
            also provides for object sharing with copy on modify semantics.  This reduces
            much of the string copying overhead that was previously associated with executing
            Tcl interpreter commands.
        </para>
        <para>
            The <classname>CTCLObject</classname> is a wrappig of a <type>Tcl_Obj</type>
            along with functions that operate on the underlying object.
        </para>
        <para>
            <classname>CTCLObjectProcessor</classname>
        </para>
        <para>
            Key to the concept of the Tcl interpreter as an application scripting language
            is the ability to add new commands to the interpreter that are application
            specific.  The <classname>CTCLObjectProcessor</classname> class is an
            abstract base class that, when subclassed and instantiated adds new
            commands to the interpreter.
        </para>
        <para>
            <classname>CTCLVariable</classname>
        </para>
        <para>
            The <classname>CTCLVariable</classname> class provides access to
            Tcl script variables.
        </para>
</chapter>


<chapter id="chapter.threads">
    <title>NSCL DAQ Thread Library</title>
    <para>
        The NSCL DAQ thread library supplies object oriented threading support.
        This chapter describes:
        <itemizedlist>
            <listitem>
                <para>
                    The thread and synchronization model supported by the library
                </para>
            </listitem>
            <listitem>
                <para>
                    What you need to do to incorporate the library into your
                    application code.
                </para>
            </listitem>
            <listitem>
                <para>
                    A summary of the classes in the library and links to the
                    reference material for each of them.
                </para>
            </listitem>
        </itemizedlist>
    </para>
    <section>
        <title>The thread and synchronization model</title>
        <para>
            The NSCL Daq software models each thread as an object from a
            class that is derived from the
            <classname>Thread</classname> base class.  This class provides
            functions that allow a thread to be created, started, exited,
            joined to and detached.  
        </para>
        <para>
            The body of a thread is provided by you when you create your concrete
            <classname>Thread</classname>
            subclass.  The thread body is just your implementation of the
            <methodname>virtual run</methodname> method.
            Threads exit by returning from the
            <methodname>run</methodname>
            method.
        </para>
        <para>
            Given a running thread, the
            <methodname>join</methodname>
            thread allows the caller to block until the thread represented
            by the object exits.
            <methodname>join</methodname>ing is a necessary part of thread
            cleanup, unless the thread invokes its own
            <methodname>detach</methodname> member.
        </para>
        <para>
            In the following example, a thread is designed that will block itself
            for a second, print a message and exit.  Code is shown that
            creates the thread, starts it, joins it an deletes it.  Note that
            deleting a running thread object is a bad idea and has undefined
            consequences.
        </para>
        <example>
            <title>The life of a thread</title>
            <programlisting>
        ...
class MyThread : public Thread {      <co id="chapter.thread.mythread" />
public:
    virtual void run();
};
void
MyThread::run()                      <co id="chapter.thread.run" />
{
    sleep(1);
    std::cerr &lt;&lt; "My thread " &lt;&lt; getId() &lt;&lt; " is exiting\n";
    return;
};
   ...
   
MyThread* aThread = new MyThread;   <co id="chapter.thread.creation" />
aThread->start();                     <co id="chapter.thread.start" />

   ...
   
aThread->join();                    <co id="chapter.thread.join" />
delete aTrhead;                     <co id="chapter.thread.destroy" />
 
    ...

            </programlisting>
        </example>
        <calloutlist>
            <callout arearefs="chapter.thread.mythread">
                <para>
                    By making
                    <classname>MyThread</classname> a subclass of
                    <classname>Thread</classname>,
                    objects from class
                    <classname>MyThread</classname>
                    can be started as independent threads of execution
                </para>
            </callout>
            <callout arearefs="chapter.thread.run">
                <para>
                    The
                    <methodname>run</methodname>
                    member of a thread is an abstract method.  Your thread classes
                    must supply the behavior for this member.  When the
                    thread is started, the
                    <methodname>run</methodname>
                    method gains control in the context of the new thread.
                </para>
            </callout>
            <callout arearefs="chapter.thread.creation">
                <para>
                    Creating a thread is simple.  Just create an object that
                    is of the thread class type.
                </para>
            </callout>
            <callout arearefs="chapter.thread.start">
                <para>
                    Starting a thread is equally simple, Just call the
                    thread's
                    <methodname>start</methodname>
                    method.  That starts the thread with an entry point that
                    eventually calls the
                    <methodname>run</methodname>
                    method.
                </para>
            </callout>
            <callout arearefs="chapter.thread.join">
                <para>
                    It's not safe to destroy a thread that is executing.
                    Calling a thread's
                    <methodname>join</methodname>
                    method blocks the caller's thread until the thread exits.
                    Note that it is not safe for a thread to call its own
                    <methodname>join</methodname>
                    method since that will block the thread forever.
                </para>
            </callout>
            <callout arearefs="chapter.thread.destroy">
                <para>
                    Once a thread has exited, the object that ran it can be
                    destroyed.  That effectively destroys the thread.
                    If the state of the exiting thread allows, it is possible
                    to start the thread again after it has exited.
                </para>
            </callout>
        </calloutlist>
        <para>
            Non trivial threaded software will almost always need some means
            for threads to synchronize against one another.  Consider the following
            trivial, but wrong, example:
        </para>
        <example>
            <title>Why synchonization is needed</title>
            <programlisting>
int someCounter = 0;

class MyThread : public Thread
{
    virtual void run() {
        for (int i=0; i &lt; 10000; i++) {
            someCounter++;
        }
};

...
MyThread* th1 = new MyThread;
MyThread* th2 = new MyThread;
th1->start();
th2->start();
th1->join();
th2->join();
delete th1;
delete th2;
std::cerr &lt;&lt; "someCounter = " &lt;&lt; someCounter &lt;&lt; std::endl;
...


            </programlisting>
        </example>
        <para>
            In this program, two threads increment the variable someCounter
            in parallel 10,000 times each.  You might expect the output of this
            program to always be 20000.  Most of the time, it probably will be.
            Sometimes it will be something less than 20000.
        </para>
        <para>
            Consider what
            <programlisting>
someCounter++;
            </programlisting>
            actually does.  The value of 
            <varname>someCounter</varname>
            is fetched to a processor register,
            the register is incremented and finally, the
            register is stored back into
            <varname>someCounter</varname>.
        </para>
        <para>
            Suppose thread <varname>th1</varname>
            fetches <varname>someCounter</varname>, and increments the register
            but before it has a chance to store the incremented value back into
            <varname>someCounter</varname>
            <varname>th2</varname> executes, fetches
            <varname>someCounter</varname> (the old value), increments the
            register and stores the value back.
            Now <varname>th1</varname> gets scheduled, and stores its value back.
        </para>
        <para>
            This sequence of steps results in a lost increment.  It is possible
            to construct sequences of execution, that result in a final value
            of <varname>someCounter</varname> holding any value from
            10000 through 20000 depending on how access to
            <varname>someCounter</varname> is interleaved.
        </para>
        <para>
            One way to fix this is to ensure that the increment of
            <varname>someCounter</varname> is
            <firstterm>atomic</firstterm> with respect to the increment.
            The NSCLDAQ threading library provides a synchonization primitive
            called a
            <classname>SyncGuard</classname> that can be used to implement
            the Monitor construct first developed by Per Brinch Hansen
            (see
            <ulink url="http://en.wikipedia.org/wiki/Monitor_%28synchronization%29">
            Wikipedia's Monitor (synchronization)</ulink> page.
        </para>
        <para>
            Let's rewrite the previous example so that the increment is atomic
            with respect to the scheduler.   To do this we will isolate the
            counter in a class/object of its own so that it is not possible to
            use it incorrectly
        </para>
        <example>
            <title>Using <classname>SyncGuard</classname> to implement a monitor</title>
            <programlisting>
class ThreadedCounter {
private:
    Synchronizeable  m_guard;      <co id="chapter.thread.synchronizable" />
    int              m_counter;
public:
    void increment();
    int  get() const;
};
void
ThreadedCounter::increment()
{
    sync_begin(m_guard);          <co id="chapter.thread.enter" />
    m_counter++;
    sync_end();                  <co id="chapter.thread.leave" />
}
int
ThreadedCounter::get() const
{
    return m_counter;
}

ThreadedCounter someCounter;
class MyThread : public Thread
{
    virtual void run() {
        for (int i=0; i &lt; 10000; i++) {
            someCounter.increment();     <co id="chapter.thread.monitoredincr" />
        }
};

...
MyThread* th1 = new MyThread;
MyThread* th2 = new MyThread;
th1->start();
th2->start();
th1->join();
th2->join();
delete th1;
delete th2;
std::cerr &lt;&lt; "someCounter = " &lt;&lt; someCounter.get() &lt;&lt; std::endl;
...

            </programlisting>
        </example>
        <calloutlist>
            <callout arearefs="chapter.thread.synchronizable">
                <para>
                    This member is the synchronization element.  We will see
                    it used in the
                    <methodname>increment</methodname>
                    member.
                </para>
            </callout>
            <callout arearefs="chapter.thread.enter">
                <para>
                    The
                    <function>sync_begin()</function>
                    enters the monitor.  Only one thread at a time is allowed
                    to execute the code between a
                    <function>sync_begin</function>
                    and a
                    <function>sync_end</function> for the same synchronizing
                    object.
                </para>
            </callout>
            <callout arearefs="chapter.thread.leave">
                <para>
                    This call leaves the monitor.  The effect of the
                    monitor is to make the increment atomic with respect to the
                    scheduler.
                </para>
            </callout>
            <callout arearefs="chapter.thread.monitoredincr">
                <para>
                    By using the
                    <methodname>increment</methodname>
                    function, the counter is incremented atomically.
                </para>
            </callout>
        </calloutlist>
    </section>
    <section>
        <title>Incorporating the library into an application.</title>
        <para>
            To incorporate the thread library in your software, you will
            need to ensure that the compiler can locate the library headers
            and the library, both at link time and at load time.
        </para>
        <para>
            The library headers are in the
            <filename>include</filename>
            directory of the NSCLDAQ installation tree.  The library is called
            <filename>libthreads</filename> and is in the
            <filename>lib</filename>
            directory of the installation tree.
        </para>
        <para>
            In the compilation example below, we assume that an
            environment variable named DAQROOT has been defined to point to the
            top level of the NSCLDAQ installation tree:
        </para>
        <example>
            <title>Compiling and linking NSCLDAQ threaded software</title>
            <programlisting>
g++ -o mythreadedapp -I$DAQROOT/include mythreadedapp.cpp -L$DAQROOT/lib -lthreads \
    -Wl,"-rpath=$DAQROOT/lib"
            </programlisting>
        </example>
    </section>
    <section>
        <title>Pointers to the reference material</title>
        <para>
            This section provides pointers to the reference sections.
            The following three classes define the public interfaces
            for the threading and synchronization library:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    <link linkend="manpage.thread"><classname>Thread</classname></link>
                    is the abstract base class from which you can construct
                    application specific threads.
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend="manpage.synchronizable"><classname>Synchronizable</classname></link>
                    is the class used to perform synchronization.
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend="manpage.syncguard"><classname>SyncGuard</classname></link>
                    is built on top of <classname>Synchronizable</classname> to 
                    provide monitor like synchronization semantics.
                </para>
            </listitem>
        </itemizedlist>
    </section>
</chapter>


<chapter id="chapter.uri">
    <title>Parsing and URIs</title>
    <para>
        Elements of the NSCL acquisition system are named with Universal Resource
        Locators, or URIs.  For the purposes of the NSCLDAQ, a URI is not really
        distinguishable from a URL (Universal Resource Locator).  It has the form:
        <literal>protocol://host:port/path</literal>, or
        <literal>protocol://host:port</literal>
    </para>
    <variablelist>
        <varlistentry>
            <term><firstterm>protocol</firstterm></term>
            <listitem>
                <para>
                    Is the means used to talk with a resource.  For nscldaq
                    this is most often <literal>tcp</literal>
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><firstterm>host</firstterm></term>
            <listitem>
                <para>
                    Is the system that hosts the resource that is identified
                    by the URI. The host can either be a dotted IP address,
                    or the DNS name of a host on the network.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><firstterm>path</firstterm></term>
            <listitem>
                <para>
                    Identifies the resource within the host. This identification
                    may differ depending on what the resource is.  For a ring buffer,
                    for example, the path is the name of the ring buffer.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><firstterm>port</firstterm></term>
            <listitem>
                <para>
                    Identifes the network port number used to contact the server
                    that provides the resource to the network.
                </para>
            </listitem>
        </varlistentry>
    </variablelist>
    <para>
        The URI library is a class that parses URI's and provides member
        functions that return the elements of a URI.  Here's a trivial example
        of the URI library in use:
    </para>
    <example>
        <title>Sample URI library program</title>
        <programlisting>
#include &lt;URL.h&gt;
#include &lt;URIFormatException.h&gt;
#include &lt;iostream&gt;
#include &lt;stdlib.h&gt;
int main(int argc, char** argv)
{
    if (argc != 2) {
        cerr &lt;&lt; "Usage:\n";
        cerr &lt;&lt; "  urltest URI\n";             <co id="chapter.uri.usage" />
        exit(-1);
    }
    
    try {                                           <co id="chapter.uri.try" />
       URL uri(argv[1]);                            <co id="chapter.uri.construct" />
       cout &lt;&lt; "Protocol: " &lt;&lt; uri.getProto()
            &lt;&lt; " host : "   &lt;&lt; uri.getHostName()
            &lt;&lt; " path: "    &lt;&lt; uri.getPath()       <co id="chapter.uri.pieces" />
            &lt;&lt; " port: "    &lt;&lt; uri.getPort() &lt;&lt; endl;
    }
    catch(CURIFormatException&amp; error) {
        cerr &lt;&lt; "URI was not valid: "
             &lt;&lt; except.ReasonText()           <co id="chapter.uri.catch" />
             &lt;&lt; endl;
        exit(-1);
    }
    exit(0);
}
        </programlisting>
    </example>
    <calloutlist>
        <callout arearefs="chapter.uri.usage">
            <para>
                The test program accepts the URL to parse as its command line
                parameter.  If the user does not provide a URL or provides too
                many parameters, the progrm's usage is printed on
                <literal>stderr</literal> before the program exits.
            </para>
        </callout>
        <callout arearefs="chapter.uri.try">
            <para>
                The <classname>URL</classname> constructor parses the
                URI. If, however the URI is not valid syntax, or refers to
                a host that does not exist, it will throw an
                exception (<classname>CUIRFormatException</classname>).
                The construction and manipulation of the URI is therefore
                wrapped in a <command>try</command>/<command>catch</command>
                block.
            </para>
        </callout>
        <callout arearefs="chapter.uri.pieces">
            <para>
                This section of code takes the parsed URI and demonstrates
                how to pull the elements of the URI out and print them.
            </para>
        </callout>
        <callout arearefs="chapter.uri.catch">
            <para>
                This code catches errors that may be thrown by the URI
                parse.  The reason for the error is printed out.
                For more information see
                the
                <link linkend="manpage.curiformatexception">
                    <classname>CURIFormatException</classname> reference page</link>.
            </para>
        </callout>
    </calloutlist>
    
    <para>
        To incorporate the URI library into your source code, you must compile
        with an appropriate set of switches to allow the compiler to locat your
        header files, and the linker to locate the URL library both at link time
        and at load time.  If the example program above is called
        <literal>urltest.cpp</literal> and if you have an environment variable
        DAQROOT that points to the top level directory of the NSCLDAQ
        install tree the command below will compile and link the program.
        <example>
            <title>Building <literal>urltst.cpp</literal></title>
            <programlisting>
g++ -o urltest -I$DAQROOT/include urltest.cpp -L$DAQROOT/lib -lurl -Wl,"-rpath=$DAQROOT/lib"
            </programlisting>
        </example>
    </para>
</chapter>

</part>
<part>
<title>servers</title>
<chapter id="chapter.daqportmanager">
    <title>Service Port Manager.</title>
       <para>
            The TclServer application makes it trivial for users
            to create and use application specific servers.  When doing so,
            however one problem that crops up is which service port should be
            used by the service when it listens for connections.  The service
            port used must be unique across all servers within a specific system.
       </para>
       <para>
          The NSCL <application>PortManager</application> application attempts to
            solve this by managing a block of ports on behalf of servers running in a
            specific system and advertising the application and user names associated with
            ports that it has allocated.  By interacting with the port manager, servers
            can be assured of getting a unique port.  By interacting with the port manager,
            clients can determine the likely port on which a server they are interested in is
            listening.
       </para>
       <para>
            The Port manager conists of the following components, which are described in this
            reference material:
            <itemizedlist>
                <listitem>
                    <para>The
                        <link linkend="manpage.DaqPortManager">port manager daemon</link>
                        manages a block of ports for the
                        system in which it is run.  The reference material for the application
                        describes the switches that control the port manager's operation,
                        the log/status files it creates and the protocol that should be used to
                        interact with the daemon.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        A
                        <link linkend="manpage.CPortManager">C++ class library</link>
                        that allows C++ software to interact with the
                        port manager either as a server or as a client.
                    </para>
                </listitem>
                <listitem>
                    <para>
                    The
                    <link linkend="manpage.portAllocator">portAllocator package</link>,
                    which allows Tcl scripts to interact with a
                    port manager either as a server or a client.
                    </para>
                </listitem>
            </itemizedlist>
       </para>
</chapter>


</part>
<part>
<title>Reference Pages</title>
<reference>
<title>1daq</title>

    
<refentry id="manpage.daqstart">
  <refmeta>
     <refentrytitle>daqstart</refentrytitle>
     <manvolnum>1daq</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>daqstart</refname>
     <refpurpose>Monitor essential programs</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
daqstart <option>options...</option> <replaceable>command </replaceable>
	</command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
       This  utility facilitates the collection of logging/debugging information from
       programs that were not originally intended to produce logs.  daqstart  runs  a
       target  program.   Stdout  and stderr of the target program are initialized as
       pipes that are monitored by the daqstart program.  Output on each pipe is
       collected a line at a time and relayed to daqstarts stdout or stderr as
       appropriate.  If a logging sink has been attached to  the  standard  file,  lines  are
       timestamped and logged to that sink as well.  This utility is also very useful
       for programs that are run from desktop shortcuts under window managers such as
       e.g. kde.
       </para>
        <para>
       On  target  program  exit,  if  an error sink is specified, an exit message is
       logged to the error sink.  The exit message contains  such  information  about
       why  the  program  exited as UNIX can provide (exit status and signal), and is
       also timestamped.
        </para>
        <para>
       If the <option>--notify</option>
        option is specified, the exit message is also  sent  to  daqstart's
        stderr.  Additionally,  if the DISPLAY environment variable is defined
       and the PopUp program is executable in the current path, it is invoked to  pop
       up an Xwindows dialog with similar information.
     </para>
  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <para>Each option has a short and a long form.  Short form options are preceded
        by  a single <literal>-</literal>.  Long options are preceeded by
        <literal>--</literal>.  If a value is required, it should be butted up against
        short options or separated from long options by an <literal>=</literal>.  For
        example: <option>-osomesink</option> and <option>--output=somesink</option>
        are equivalent.
     </para>
     <variablelist>
	<varlistentry>
	    <term><option>-h --help</option></term>
	    <listitem>
		<para>
                     Display short help and exit.
		</para>
	    </listitem>
	</varlistentry>
        <varlistentry>
            <term><option> -V --version</option></term>
            <listitem>
                <para>
                     Print program version number and exit
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-e<replaceable>Sink</replaceable> --error=<replaceable>Sink</replaceable></option></term>
            <listitem>
                <para>
                   Specify  a  logging  sink  for the program's standard error output.  If
              specified, lines sent by the program to stderr are timestamped and teed
              to  this  sink  as  well.  See
              <link linkend="daqstartSINKSPECS">SINK SPECIFICATIONS</link>
                for more information
                about specifying sinks.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-o<replaceable>Sink</replaceable> --output=<replaceable>Sink</replaceable></option></term>
            <listitem>
                <para>
                     Specify a logging sink for the program's standard  output  output.   If
              specified, lines sent by the program to stdout are timestamped and teed
              to this sink as well.  See
              <link linkend="daqstartSINKSPECS">SINK SPECIFICATIONS</link>
              for  more  information
              about specifying sinks.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-n --notify</option></term>
            <listitem>
                <para>
                Enables  exit  notification for the command.  If specified, the user is
              notified of command exit.  Commend exit is always logged to  the  error
              sink.   <option>--notify</option>
                      causes  an message to be sent to stderr that includes
              the command name, the exit status and, if exit was due to  an  uncaught
              signal, the signal that caused the process to exit.  If the environment
              variable <varname>DISPLAY</varname>
              is defined and the program <application>PopUp</application>
              is in the path, it is
              run to produce an X11 pop up message as well.
                </para>
            </listitem>
        </varlistentry>
     </variablelist>
  </refsect1>
  <refsect1 id="daqstartSINKSPECS">
     <title>SINK SPECIFICATIONS</title>
        <para>
          A sink is specified by a string containing two fields separated by a colon:
       <replaceable>sinktype:sinkname</replaceable>
       The left field is the sink type, while the right field is  a
       sink  name interpreted within the sink type.  For example, the sink specification:
       <literal>file:/user/fox/output.log</literal>
       specifies the sink is a  file,  and  that  the
       file is <filename>/user/fox/output.log.</filename>
         </para>
        <para>
       Sink types that are currently supporteed include:
        </para>
        <variablelist>
            <varlistentry>
                <term><literal>file</literal></term>
                <listitem>
                    <para>
                        A file.  The sink name is the name of the file.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
       <para>
       If  all this seems like a bit much to specify a file, recall that this is
       version 1.0 of the program and future versions will probably support  other  sink
       types.
       </para>
  </refsect1>

</refentry>


<refentry id="manpage.sclclient">
  <refmeta>
     <refentrytitle>sclclient</refentrytitle>
     <manvolnum>1daq</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>sclclient</refname>
     <refpurpose>Maintain scaler state in a tclserver</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
sclclient <optional>options</optional>
	</command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
       sclclient accepts scaler buffers from a  DAQ  systems  (spdaq  system  at  the
       NSCL),  processes them and sends processed information to a tclserver program.
       Given an appropriate setup script to describe a  visual  presentation  of  the
       scalers, sclclient and tclserver together create a scaler display subsystem.
     </para>
     <para>
       Command  options  (see  OPTIONS  below),  describe  how the program starts up.
       sclclient interacts with tclserver by sending it a  set  of  tcl  commands  to
       maintain  some  global  variables  (see VARIABLES below).  In addition, at key
       points, procedures are called that are assume to be loaded into the  tclserver
       program by its setup scripts (see PROCEDURES below).
     </para>

  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	<varlistentry>
	    <term><option>-h <replaceable>tclserver_host</replaceable></option></term>
	    <listitem>
		<para>
              Defines  the system on which the tcl server is running.  It is possible
              for sclclient to run in a system remote from  tclserver.   By  default,
              however the host connected to is localhost.                    
		</para>
	    </listitem>
	</varlistentry>
        <varlistentry>
            <term><option> -p <replaceable>port_number</replaceable></option></term>
            <listitem>
                <para>
              Defines  the number of the TCP/IP port on which tclserver is listening.
              By default and convention, scaler display  tclservers  listen  on  port
              2700.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-s <replaceable>spectrodaq_url</replaceable></option></term>
            <listitem>
                <para>
              Defines  the url of the spectrodaq buffer manager from which data will.
              be acquired.  This is of the  form  tap://hostname:2602/.   By  default
              this  is tcp://localhost:2602/ causing data to be taken from the system
              sclclient is running on.

                </para>
            </listitem>
        </varlistentry>
     </variablelist>
  </refsect1>
  <refsect1>
        <title>VARIABLES</title>
        <para>
       sclclient maintains several variables and arrays in the TCL server to which it
       is  connected.    Scaler  displays are therefore constructed by displaying the
       values of these variables and arrays as well as by providing procedures called
       by sclclient (see PROCEDURES below).
        </para>
        <para>
       The variables sclcient maintains are:
        </para>
        <variablelist>
            <varlistentry>
                <term>Scaler_Totals</term>
                <listitem><para>
              This is a TCL array indexed by scaler channel number (channels start at
              0.  Each element of the array is the total number  of  counts  in  that
              channel  either  since  the scaler program started up or the run began,
              whichever happened latest.
                </para></listitem>
            </varlistentry>
            <varlistentry>
                <term>Scaler_Increments</term>
                <listitem>
                    <para>
              This is a TCL array indexed by channel number. The value of  each  
              element  is  the  number of counts in that channel since the latest of the
              beginning of the run,  starting  sclclient,  and  the  previous  scaler
              buffer.
                    </para></listitem>
            </varlistentry>
            <varlistentry>
                <term>ScalerDeltaTime</term>
                <listitem>
                    <para>
              This  variable  maintains  the  number  of seconds in the most recently
              received set of scaler increments in seconds.  If no scaler  increments
              have been received, this variable is 0.  ScalerDeltaTime can be used to
              calculate scaler rates.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>ElapsedRunTime</term>
                <listitem>
                    <para>
              This variable contains the number of seconds since the start of run, or
              when the scaler client program started, whichever is latest.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>RunNumber</term>
                <listitem>
                    <para>
              This  variable contains he number of the current run. If not yet known,
              it has the value &gt;Unknown%lt; instead.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>RunState</term>
                <listitem>
                    <para>
              This variable has the known run state.  It is any of HALTED, ACTIVE, or
              PAUSED, or lastly &gt;Unknown&lt; if the run state is not yet known.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>RunTitle</term>
                <listitem>
                    <para>
              Contains  the title of the current run if known or the text
              "&gt;Unknown&lt;"
              if not.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
  </refsect1>
  <refsect1>
        <title>PROCEDURES</title>
        <para>
       In addition to maintaining the global variables described in VARIABLES  above,
       sclclient  calls  procedures at well defined points in time.  These procedures
       must be defined in the tclserver, even if only as empty procedures.
        </para>
        <para>
       Procedures are not passed any parameters.  The procedures  sclclient  requires
       are:
        </para>
        <variablelist>
            <varlistentry>
                <term>Update</term>
                <listitem>
                    <para>
              Called  whenever  variables have been updated.  The tclserver code here
              will usually refresh the display picture.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>BeginRun</term>
                <listitem>
                    <para>
              Called when a begin run is detected.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>EndRun</term>
                <listitem>
                    <para>
              Called when an end run is detected.
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>PauseRun</term>
                <listitem>
                    <para>
              Called when a pause run is detected.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>ResumeRun</term>
                <listitem>
                    <para>
              Called when a resume run is detected.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>RunInProgress</term>
                <listitem>
                    <para>
                        Called when the first data to come in is not a begin run.   This
              indicates that sclclient started while a run is in progress.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
  </refsect1>
  <refsect1>
        <title>EXAMPLES</title>
        <para>
                   The  sample below starts out sclclient taking data from spdaq22 and feeding it
       to a tclserver on u6pc2 at port 2700:
        </para>
        <example>
            <title>Starting sclclient</title>
            <programlisting>
       /usr/opt/daq/bin/sclclient -s tcp://spdaq22:2602/ -h u6pc2 -s 2700
            </programlisting>
        </example>
  </refsect1>
  <refsect1>
    <title>SEE ALSO</title>
    <para>
        <link linkend="manpage.scalerdisplay">ScalerDisplay(1tcl)</link>,
        <link linkend="manpage.tclserver">tclserver(1)</link>
    </para>
  </refsect1>

</refentry>

</reference>
<reference>
<title>1epics</title>

    <refentry id="manpage.chanlog">
    <refmeta>
        <refentrytitle>chanlog</refentrytitle>
        <manvolnum>1epics</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>chanlog</refname>
        <refpurpose>Write a set of channels to file</refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
chanlog <replaceable>channelfile</replaceable> <replaceable>outfile</replaceable>
            </command>
        </cmdsynopsis>
    </refsynopsisdiv>
    <refsect1>
        <title>DESCRIPTION</title>
        <para>
       Logs  the  names, values and units of a set of EPICS channels to file.  In the
       command invocation,
       <replaceable>channelfile</replaceable>
       is a file that contains the names of the channels
       to  lookup and log.  If
       <replaceable>channelfile</replaceable> is
        <literal>-</literal>, then the channels are taken from stdin.
       <replaceable>outfile</replaceable>
       is the name of a file to which the channels will be logged.  If
       <replaceable>outfile</replaceable>
       is <literal>-</literal>, the output is sent to stdout.
        </para>
        <para>
       The  channel  file  is  an ordinary text file that contains the names of EPICS
       channels, each channel is separated by whitespace (note that a newline  counts
       as  whitespace).   No  comments  are allowed, in contrast to the form of input
       file expected by e.g. epicsdisplay.  The following is a sample input file:
        </para>
        <programlisting>
       Z001DV Z002DH
       Z003DV
       Z004QA

       Z012QB
        </programlisting>
        <para>
       This file will output the values and units for  5  channels:
       <literal>Z001DV,  Z002DH,
       Z003DV, Z004QA</literal> and <literal>Z004QA</literal>.
        </para>
	<para>
	   Output will consist of a line of text for each channel in the input
           file.  Each line will consist of a set of white-space separated 
	   components.  The first component is the name of  a channel followed
           by a colon.  The second element is the channel value.
	   The final element is the channel engineering units.
	</para>
	<para>
	   If the value of a channel cannot be gotten, the remainder of the
	   line following the channel name will be the error message
	   generated for that channel for example:
	   <literal>Z001DH: ca_pend_io failed User specified timeout on IO
        operation expired</literal>.
        </para>
    </refsect1>
    <refsect1>
       <title>EXAMPLES</title>
       <para>
          All of the examples assume that a file named 
	  <filename>channels.txt</filename> has been created
	  that contains the set of channel names of interest, and that 
	  <application>chanlog</application> is in your path.
       </para>
       <example>
          <title>Viewing a set of channel values interactively</title>
	  <programlisting>
chanlog channels.txt -
	  </programlisting>
       </example>
       <example>
          <title>Writing a set of channels to a file</title>
	  <programlisting>
chanlog channels.txt somefile.out
          </programlisting>
        </example>
	<example>
	   <title>Appending a set of channels to a file</title>
	   <programlisting>
chanlog channels.txt - >>somefile.out
           </programlisting>
        </example>
	<example>
	   <title>Piping a set of channels to a program for processing</title>
	   <programlisting>
chanlog channels.txt - | someprogram
           </programlisting>
         </example>
    </refsect1>
    <refsect1>
       <title>DEPENDENCIES</title>
       <para>
          <itemizedlist>
	     <listitem><para>
	        Epics software must be installed and located by the installer
             </para></listitem>
             <listitem><para>
	        The Epics utility <application>caRepeater</application> should
                be in your path.  This is in the architecture specific 
		<filename>bin</filename> directory of the Epics installation.
              </para></listitem>
           </itemizedlist>
       </para>
    </refsect1>
    </refentry>


<refentry id="manpage.controlpush">
    <refmeta>
        <refentrytitle>controlpush</refentrytitle>
        <manvolnum>1epics</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>controlpush</refname>
        <refpurpose>
            Push epics data into a Tcl Server (e.g. production readout).
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
controlpush <replaceable>[options...] files...</replaceable>
            </command>
        </cmdsynopsis>

    </refsynopsisdiv>

    <refsect1>
        <title>OPTIONS</title>
        <para>
            Options that govern the actions of the program are:
            <variablelist>
                <varlistentry>
                    <term><option>-h --help</option></term>
                    <listitem>
                        <para>
                            Writes brief program help to stdout.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-V --version</option></term>
                    <listitem>
                        <para>
                            Writes the program version number to stdout.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-p<replaceable>portnum</replaceable> --port=<replaceable>portnum</replaceable></option>
                    </term>
                    <listitem>
                        <para>
                            <replaceable>portnum</replaceable> is the number of the port to which
                            controlpush will attempt to connect. See OPERATION below to know what
                            controlpush does once it has connected
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-i<replaceable>interval</replaceable> --interval=<replaceable>intervale</replaceable>
                          </option></term>
                    <listitem>
                        <para>
                            Specifies the refresh <replaceable>interval</replaceable> in seconds.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-n<replaceable>host</replaceable> --node=<replaceable>host</replaceable>
                          </option>
                    </term>
                    <listitem>
                        <para>
                            Specifies the node to which the <command>controlserver</command>
                            will connect.
                        </para>
                    </listitem>

                </varlistentry>
		<varlistentry>
		   <term><option>-a</option> (<option>--authorize</option>)</term>
		   <listitem>
		      <para>
		         Specifies that controlpush is connecting to a Tcl
   		         server that requires user authentication.  This should
   		         be used when controlpush is connecting to a tclserver at
   		         nscldaq 8.1 or later.
                      </para>
                   </listitem>
               </varlistentry>
            </variablelist>
        </para>
    </refsect1>
    <refsect1>
        <title>OPERATION</title>
        <para>
	    <application>controlpush</application>
	     reads its configuration file and  establishes 
	     epics lists that will update automatically via epics notifications.
	     <application>controlpush</application>
	     next connects to its server and periodically 
	     sends a batch of Tcl 
	     <command>set</command> commands to maintain the following
	     Tcl global arrays:
       <variablelist>
          <varlistentry>
	     <term><varname>EPICS_DATA(channelName)</varname></term>
	     <listitem><para>
	        Is the most recently received update for 
		<varname>channelName</varname>.
	     </para></listitem>
          </varlistentry>
	  <varlistentry>
	     <term><varname>EPICS_UNITS(channelName)</varname></term>
	     <listitem><para>
	        Are the engineering units for 
		<varname>channelName</varname>
             </para></listitem>
         </varlistentry>
         <varlistentry>
             <term><varname>EPICS_UPDATED(channelName)</varname></term>
	     <listitem><para>
	         Is the timestamp of the alst update received for
		 <varname>channelName</varname>.
             </para></listitem>
          </varlistentry>
       </variablelist>
        </para>
	<para>
	  <application>controlpush</application>  continues to run until the
	  socket that is connected to its server is closed, at which point it exits.
	</para>
    </refsect1>
    <refsect1>
        <title>CONFIGURATION FILES</title>
        <para>
	    <application>controlpush</application>
	    configuration files are simple text files.  Each line is either a
	    or a channel. 
         </para>
	 <para>
	    Comments consist of blank lines or lines whose first non-whitepsace
	    is the pound (<literal>#</literal>) character.
        </para>
	<para>
	   Channel lines, have as their first non-whitespace word, the name of
           an EPICS channel. All text following the channel name on a channel
	   line is ignored by this program.  Note, however that other software
	   (notably
	   <link linkend="chapter.epicsdisplay">epicsdisplay</link>) may 
	   parse additional characters for their own purposes.
	</para>
    </refsect1>
    <refsect1>
        <title>DEPENDENCIES</title>
	<itemizedlist>
	   <listitem><para>
	      The installer must be able to locate the EPICS installation.
	   </para></listitem>
	   <listitem><para>
	     The 
	     <application>caRepeater</application>,
	     normally in the architecture specific subdirectory of the
	     EPICS installation should be in the user's 
	     <varname>PATH</varname> environment variable.
	   </para></listitem>
	</itemizedlist>

    </refsect1>
</refentry>



</reference>
<reference>
<title>1tcl</title>

<refentry id="manpage.DaqPortManager">
  <refmeta>
     <refentrytitle>DaqPortManager</refentrytitle>
     <manvolnum>1tcl</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>TCP/IP service port manager.</refname>
     <refpurpose>Manage TCP/IP service ports and advertise their allocations</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
tclsh DaqPortManager <replaceable>options...</replaceable>
	</command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
       DaqPortManager  is  a  persistent  server that should be run at system startup
       time.  The program manages a block of TCP/IP ports.   Clients connect  to  the
       server  to  request  ports  as well as to ask the server to return the current
       port assignments.
     </para>
     <para>
       Command options (see OPTIONS) describe how th eprogram starts up.  The command
       options  allow  the user to define the block of ports that will be managed, to
       determine which port the port manager itself will listen  on  for  connections
       and  to define where the software will writ its log file.  Several other files
       are maintained by the program (see FILES).
	
     </para>
  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	<varlistentry>
	    <term><option>-ports</option> <replaceable>range</replaceable></term>
	    <listitem>
		<para>
                    Defines the range of ports that will be managed by the
                    port manager program.  This should be specified as a pair
                    of integer number separated by a <literal>-</literal> (dash).
                    e.g. <literal>30001-31000</literal>.  If not provided defaults
                    to <literal>30001-31000</literal>.
		</para>
	    </listitem>
	</varlistentry>
        <varlistentry>
            <term><option>-listen</option> <replaceable>port</replaceable></term>
            <listitem>
                <para>
                    Defines the port on which the port manager itself will listen for
                    connections.  This defaults to <literal>30000</literal>.  The port manager
                    is itself a server.  Most of the software that connects to it assumes the
                    default port will be used to communicate with it, therefore, changing this
                    value will most likely require other changes elsewhere in the NSCLDAQ software
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-log</option> <replaceable>logfile</replaceable></term>
            <listitem>
                <para>
                    The  <option>-log</option> switch  is followed by a path to a file
               that will be used to
              log the server&#039;s actions.  The server logs  connections,  port  allocations,
              port allocation failures, port releases and illegal requests by
              clients.  The default log file is
              <filename>/var/log/nscldaq/portmanager.log</filename>
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-usagefile</option> <replaceable>usagefilename</replaceable></term>
            <listitem>
                <para>
                    The
                    <option>-usagefile</option>
                    switch is followed by a path to a file that will be used
              to  hold  the  instantaneous  port usage.  This file can be examined to
              show the current port usage. Each line in this file is a three  element
              TCL  list of port, application and user for an allocated port.   If the
              <option>-usagefile</option> switch is not provided, the server defaults to
              <filename>/var/tmp/daqportmgr/ports.txt</filename>.
                </para>
            </listitem>
        </varlistentry>
     </variablelist>
  </refsect1>
  <refsect1>
        <title>PROTOCOL</title>
        <para>
       The server protocol is quite simple. Once connected, two transactions are recognized.
       Each transaction is requested by the client  and  fulfilled  by  the
       server.   Requests are a single line (terminated with a <literal>\n</literal>) and
       cann be one of the following:
          </para>
        <variablelist>
        <varlistentry>
            <term><command>GIMME <replaceable>appname user</replaceable></command></term>
            <listitem>
                <para>
              <command>GIMME</command>  requests the server allocate a port.  When allocated, the server
              will believe that the  port  is  allocated  to  the  application  named
              appname run by the user user. If successful, the server replies:
                </para>
            
            <variablelist>
                <varlistentry>
                    <term>OK portnum</term>
                    <listitem>
                        <para>
                            Where  the  OK  indicates  success and the
                            portnum is the number of the
                            port allocated.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>FAIL reason</term>
                    <listitem>
                        <para>
                            Indicates a failure where reason is a TCL quoted
                            item describing why the port could not  be
                            allocated.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                       Once a client has allocated a port it must hold a persistent connection to the
       server.  When a client owning ports drops this connection its ports are  freed
       by  the  server.  While  possibly inconvenient, this protocol prevents clients
       from accidently holding on to ports past exit.
            </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
            <term>LIST</term>
            <listitem>
                <para>
                  Requests that the server list port usage.  The server will issue
                  a multiline reply to this request.  The first line will be of the form:
                </para>
                <variablelist>
                    <varlistentry>
                    <term>OK n</term>
                    <listitem>
                        <para>
                Where  n  is  the number of ports that are currently allocated.   The n
              lines that follow each consists of a 3 element TCL list  containing  in
              order,  the  port number, the application name and the name of the user
              that is running the application.   Note  that  if  there  are  multiple
              instances  of  the  same application run by the same user, They will be
              qualified by appending an underscore and an application  instance  num?
              ber.
                          </para>
                      </listitem>
                    </varlistentry>
                  </variablelist>
                      </listitem>
                  </varlistentry>
    </variablelist>


  </refsect1>
  <refsect1>
        <title>EXAMPLES</title>
        <programlisting>
           tclsh8.4 /usr/opt/daq/current/bin/DaqPortManager -ports 31000-40000 &amp;    
        </programlisting>
        <para>
       Starts  the  port  manager listening on port 30000 managing ports in the range
       31000 through 40000.  The port manager is run in the background as a daemon process.
        </para>
  </refsect1>
  <refsect1>
        <title>FILES</title>
        <para>
            The server maintains:
        </para>
        <programlisting>
       /var/run/nscldaq/daqportmgr.pid  - contains the port manager#033;s process id.
       /var/log/nscldaq/portmanager.log - Default logfile
       /var/tmp/daqportmgr/listen.port  - Contains the listen port for the server.
       /var/tmp/daqportmgr/ports.txt    - Default port usage file.
        </programlisting>
  </refsect1>
  <refsect1>
        <title>KNOWN DEFECTS</title>
        <para>
       The server should be able to default to listen on the  service  daqportmgr  in
       /etc/services if present before falling back on port 30000
        </para>
        <para>
       The  &#033;uniquification&#033;  of  the  application name for the LIST command may vary
       from query to query as applications drop out.
    </para>
        <para>
       Only connections to/from "localhost" are considered local.   The  server  does
       not  bother  to  determine if any other sources are local even though they may
       be.
        </para>
        <para>
       If multiple instances of the port manager are run, only last one started  will
       be listed in <literal>/var/run/nscldaq/daqportmgr.pid</literal>
        </para>
  </refsect1>
  <refsect1>
    <title>SEE ALSO</title>
    <para>
        <link linkend="manpage.CPortManager">CPortManager(3daq)</link>
        <link linkend="manpage.CPortManagerException">CPortManagerException(3daq)</link>
        <link linkend="manpage.portAllocator">portAllocator(3tcl)</link>
    </para>
  </refsect1>
</refentry>


<refentry id="manpage.dvdburn">
  <refmeta>
     <refentrytitle>dvdburn</refentrytitle>
     <manvolnum>1tcl</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>dvdburn</refname>
     <refpurpose>Command line tool to burn NSCLDAQ data DVDs.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
dvdburn <optional>firstrun <optional>lastrun</optional></optional>
	</command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
	Burns the data associated with a set of runs to DVD.
        The <link linkend="manpage.dvdburner">DvdBurner</link>
        package is used to do the burn, so all restrictions and dependencies
        for that package apply.
     </para>
     <para>
        If no parameters are supplied, all runs are burned.  If
        <parameter>firstrun</parameter> is supplied, all runs with run numbers
        at least <parameter>firstrun</parameter> are burned.
        Finally if both <parameter>firstrun</parameter> and <parameter>lastrun</parameter>
        are supplied, all run numbers that are at least <parameter>firstrun</parameter>
        and at most <parameter>lastrun</parameter> are burned.
     </para>
  </refsect1>
    <refsect1>
        <title>Dependencies</title>
        <para>
            See
            <link linkend="manpage.dvdburner">the DvdBurner manpage</link>.
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.burngui">
  <refmeta>
     <refentrytitle>burngui</refentrytitle>
     <manvolnum>1tcl</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>burngui</refname>
     <refpurpose>Graphical front end to dvdburn</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
burngui	
	</command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
	This is a graphical user interface that runs the
        <link linkend="manpage.dvdburn">dvdbur</link> program.
        This program should be reasonably easy to use.
        If not complain and more complete documentation will be written.
     </para>
  </refsect1>
  <refsect1>
    <title>Dependencies.</title>
    <para>
        See
        <link linkend="manpage.dvdburner">the DvdBurner</link> package.  All restrictions
        apply.
    </para>
  </refsect1>
</refentry>


     
<refentry id="manpage.scalerdisplay">
  <refmeta>
     <refentrytitle>ScalerDisplay</refentrytitle>
     <manvolnum>1tcl</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>ScalerDisplay</refname>
     <refpurpose>Live Scaler Displays</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
export DAQHOST=<replaceable>datasourcecomputer</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
ScalerDisplay <replaceable>configfile</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
          This script provides a configurable scaler display for the NSCL Data
       Acquisition system.  The script requires that:
     </para>
     <itemizedlist>
        <listitem>
            <para>
                An environment variable named DAQHOST be defined to be the name of  the
              computer  that is taking data.  At the NSCL this will usually be a
              system named spdaqnn where nn is a two digit number.
            </para>
        </listitem>
        <listitem>
            <para>
             A single command parameter provides the name of a TCL  script  that  is
              used to configure the display.  The full range of TCL functionality may
              be used by this configuration script.  The display script, in  addition
              defines  several  commands  that are used to configure the display (See
              CONFIGURATION COMMANDS below).
            </para>
        </listitem>
     </itemizedlist>
     <para>
       In addition to configuring the  display  itself,  ScalerDisplay  supports  the
       invocation  of  user  written  code at well defined points of operations.  For
       more information about that see CALLOUTS below.
     </para>

  </refsect1>
  <refsect1>
    <title>CONFIGURATION COMMANDS</title>
    <para>
           The ScalerDisplay program understands the following object types:
    </para>
    <variablelist>
        <varlistentry>
            <term>channels</term>
            <listitem>
                <para>
              A channel is a scaler channel.  It has a name and an index.   The  name
              is used to refer to and label the channel. The index is the offset into
              the set of scalers (numbered from 0) that contains that channel.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>pages</term>
            <listitem>
                <para>
              A page is a set of scalers grouped together on one display page.  Pages
              have  a  title,  which is an arbitrary text string that is displayed at
              the top of the page when the page is active, and  a  Tabname  which  is
              used  to  select the page from the tabbed notebook widget that displays
              them.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>lines</term>
            <listitem>
                <para>
              A line is  a single scaler or a pair of scalers  or blank displayed  on
              a line of the scaler display.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
             <term>stripcharts</term>
             <listitem>
                <para>
              A  strip  chart is a plot of the rate of one or more scaler channels or
              their ratios with respect to time.   The strip chart part of  the  user
              interface  is  only  visible  if configured or at least one channel has
              been added to the chart.
                </para>
             </listitem>
        </varlistentry>
    </variablelist>
                <para>
              Channels are defined using the channel command.   The  format  of  this
              command is:
                </para>
                <programlisting>
                    <command>
channel <optional>?-lowalarm <replaceable>value</replaceable>?</optional> <optional>?-hialarm <replaceable>value</replaceable>?</optional> <replaceable>name index</replaceable>
                    </command>
                </programlisting>
                <para>
              The <option>-lowalarm</option> and <option>-hialarm</option> allow
              the user to set lower and  upper limits on the 'healthy count rates'.  If
              the actual count rates go outside those limits, the scaler channel will
              be in the alarm state.
                </para>
                <para>
              Channels in the low alarm state, and their counts are displayed in  the
              low alarm color which defaults to green (see CONFIGURATION below).  The
              channel is considered to be in the high alarm state.  Channels  in  the
              high alarm state and their counts are displayed in the high alarm color
              which defaults to red.  Note that in the case of a ratio where  one  is
              in  high alarm state and the other is in low alarm state, the colors of
              the names reflects the individual channel alarm states while  the  rate
              values are shown using the 'both alarm color' which defaults to orange.
                </para>
                <para>              
              Pages are defined via the page command.  The format of this command is:
                </para>
                <programlisting>
                    <command>

page <replaceable>Tabname "Some meaningful title string"</replaceable>
                    </command>
                </programlisting>
                <para>
              Note that the title string must be enclosed in quotes  if  it  contains
              whitespace  or  other TCL word-separators.  The Tabname text is used to
              label the tab of the page in the tabbed notebook widget that is used to
              display  the  scalers.  If a page that is not currently being displayed
              has alarms, its tab will be displayed using either  the  low,  high  or
              both  alarm  color  as  appropriate  to the alarm state of the channels
              within that page.
                </para>
                <para>
              Single scaler lines are defined via the display_single
              command. The format of this command is:
                </para>
                <programlisting>
                <command>
display_single <replaceable>Tabname channelname</replaceable>
                </command>
                </programlisting>
                <para>
              Where <parameter>Tabname</parameter> is the Tab name of a scaler
            page and c
            <parameter>hannelname</parameter>  is  the
              name of a scaler channel.
            </para>
            <para>
              Ratio lines are defined via the display_ratio command:
            </para>
            <programlisting>
                <code>
display_ratio  <replaceable>Tabname numerator_chanel denominator_channel</replaceable>
                </code>
            </programlisting>
            <para>
              Blank lines are defined via the blank command:
            </para>
            <programlisting>
                <code>
blank <replaceable>Tabname</replaceable>
                </code>
            </programlisting>
            <para>
              Strip  charts are defined using the stripparam stripratio and
              stripconfig commands.  The format of the stripparam command is:
            </para>
            <programlisting>
                <code>
stripparam <replaceable>channel</replaceable>
                </code>
            </programlisting>
            <para>
              The channel is the name of a channel defined by  the  channel  command.
              The  count rates of this scaler are added to the set of scaler rates on
              the strip chart using the next free line color and style (see
              CONFIGURATION below).
            </para>
            <programlisting>
                <code>
stripratio <replaceable>numerator denominator</replaceable>
                </code>
            </programlisting>
            <para>
              The  ratio  of  the rates in the two channels numerator and denominator
              are added to the seet of rates on the strip chart using the  next  free
              line   color   and   style.    The  data  set  created  will  be  named
              numerator_over_denominator.
            </para>
            <programlisting>
                <code>
stripconfig <optional>?-log 0|1?</optional>  <optional>?-timeaxis seconds?</optional>
                </code>
            </programlisting>
            <para>
              Configures either or both of the Y axis scale type and  the  length
              the  time axis of the strip chart.  If the parameter of the -log option
              is 1, the Y axis will intially be a logarithmically scaled axis.  If 0,
              the  Y  axis  will  be  linear.  The seconds parameter to the -timeaxis
              option determines the number of seconds of scaler  data  that  will  be
              displayed  on  the time axis. The default for these options is to use a
              linear Y scale and a time axis that is 3600 seconds (1 hour) long.  For
              additional  strip  chart  configuration  options, see the CONFIGURATION
              section.
            </para>
            
  </refsect1>
  <refsect1>
    <title>CONFIGURATION</title>
    <para>
       This section describes some advanced configuration  techniques.   The  key  to
       understanding  the advanced this section is to realize that the scaler display
       program is just a Tcl/Tk script that is sourced in to a TclServer interpreter,
       and  that your configuration file is also just a Tcl script that is sourced in
       after the display program script.  As such, any defaults  established  by  the
       scaler display program can be overridden by your configuration script.
    </para>
    <refsect2>
        <title>Alarm Colors</title>
        <para>
              Three  global  variables  control the three alarm colors. lowColor
              contains the color to use when displaying channels in the low alarm state.
              hiColor  contains the color to use when displaying channels in the high
              alarm state, and bothColor contains the color used when it is necessary
              to  indicate that both alarm states are present.   You may modify these
              colors within your script.  Colors may be specified  by  name  in  many
              cases  or  by  hexadecimal  values.   On  linux  systems, see the file:
              /usr/X11R6/lib/X11/rgb.txt for the list of known color names. 
              Hexdecimal  color  values  are  given  in  any  of the following forms:
              <literal>#RGB
              #RRGGBB #RRRGGGBBB</literal> or
                <literal>#RRRRGGGGBBBB</literal> where R,G,B are hexadecimal  digits
              which, when taken together, form the Red, Green and Blue intensities of
              the color respectively.  The two lines below both  set  the  low  alarm
              color to cyan (an equal mixture of Green and Blue):
        </para>
            <programlisting>
                 set lowColor cyan
                 set lowColor #0ff
            </programlisting>
    </refsect2>
    <refsect2>
        <title>Tear off pages</title>
        <para>
              The  BLT tabset widget in which the scaler pages are displayed supports
              tear-off pages.  When enabled, this feature allows you  to  tear off
              any  page  of  the  notebook into a new top level window.  When the top
              level window is deleted, it is returned to the notebook.  This  feature
              and  other  BLT tabset configuration options can be configured by using
              the fact that the notebook widget path is stored in the global variable
              Notebook.  Thus to enable the tear-off functionality the following line
              can be added to the configuration file:
        </para>
        <programlisting>
                $Notebook configure -tearoff 1
        </programlisting>
    </refsect2>
    <refsect2>
        <title>Strip chart line styles and colors</title>
        <para>
              Channels on the strip chart widget are assigned line color and style by
              iterating  over  a  list  of  colors  and  line styles.   The procedure
              selectElementStyle does this and is expected to return  a  two  element
              list.   The first element of this list is the color of the line used to
              draw the element, and the second the argument to the -dashes 
              configuration  option  for  the element.  You can modify the way in which colors
              and line styles are selected either by  modifying  the  values  in  the
              color  and  linestyle  list or by just overriding the definition of the
              selectElementStyle procedure.
        </para>
        <para>
              The default implementation of  selectElementStyle  iterates  through  a
              list  of  colors  stored  in the global variable stripColors, selecting
              linestyles from the dash specifications in the global  variable  stripStyles.
              When  colors  are  exhausted, the procedure steps to the next
              line style, resetting the index into the color list to zero.   The  two
              lines  below add the color yellow to the set of colors that can be used
              to chart rates (yellow is low contrast  relative  to  the  white  chart
              background  so  it  was left off the default list), and a new linestyle
              where every other pixel is lit with the  selected  color  or  is 
              background:
        </para>
        <programlisting>

              lappend stripColors yellow
              lappend stripStyles [list 1 1]
        </programlisting>
    </refsect2>
    <refsect2>
        <title>Strip chart configuration</title>
        <para>
              The strip chart widget path is stored in the variable stripchartWidget.
              The Widget itself  is  only  created  when  the  first  of  stripparam,
              stripratio or stripconfig command is seen.  You may therefore only 
              configure the strip chart widget directly after one of these  commnds  has
              executed   in   your   configuration   file.   You  can  then  use  the
              stripchartWidget variable to configure the strip chart widget
              arbitrarily.   The  example  below enables the display of gridlines on the plot
              surface, and moves the legend to the left side of the plot area:
        </para>
        <programlisting>
              stripconfig -timeaxis 3600;   # Trick to get the widget defined....
              $stripchartWidget grid configure -hide 0
              $stripchartWidget legend configure -position left
        </programlisting>
        <para>
              For more information about how you can configure the stripchart at  its
              elements, see the BLT stripchart widget documentation.
        </para>
    </refsect2>
  </refsect1>
  <refsect1>
    <title>CALLOUTS</title>
    <para>
       The  scaler script will invoke user written procedures defined in the
       configuration script (or scripts sourced by it) at well defined points  of  the  run.
       These callouts can be used to provide functionality not originally foreseen by
       the program.
    </para>
    <variablelist>
        <varlistentry>
            <term>UserUpdate</term>
            <listitem>
                <para>
              UserUpdate, if defined, is called by the script whenever it has updated
              the displays.  No parameters are passed in to the procedure but several
              global variables are useful (see GLOBAL VARIABLES below).
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>UserBeginRun</term>
            <listitem>
                <para>
              UserBeginRun is called at the beginning  of  a  run,  if  it  has  been
              defined. No parameters are passed.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>UserEndRun</term>
            <listitem>
                <para>
              UserEndRun,  if  defined,  is called at the end of a run. No parameters
              are passed.
                </para>
            </listitem>
        </varlistentry>
    </variablelist>
  </refsect1>
  <refsect1>
    <title>GLOBAL VARIABLES</title>
    <para>
       The following global variables are useful within user callouts.
    </para>
    <variablelist>
        <varlistentry>
            <term><varname>RunNumber</varname></term>
            <listitem>
                <para>
                 The number of the current run.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><varname>RunTitle</varname></term>
            <listitem>
                <para>
                 A string contaning the title of the current run.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><varname>Scaler_Totals</varname></term>
            <listitem>
                <para>
                 An array indexed by scaler channel number containing the total
              number of counts in each channel.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><varname>Scaler_Increments</varname></term>
            <listitem>
                <para>
                 An  array  indexed by scaler channel number containing the number of
              counts in the last time increment (see also ScalerDeltaTime)
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><varname>ScalerDletaTime</varname></term>
            <listitem>
                <para>
                 The number of seconds of counts represented by the Scaler_Increments
              array elements.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><varname>ScalerMap</varname></term>
            <listitem>
                <para>
                An  array indexed by scaler names.  Each element of this array is the
              index of the corresponding scaler.  For example, if you have defined  a
              channel  named  george,  ScalerMap(george)  will  be the scaler channel
              index associated with george.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><varname>scalerWin</varname></term>
                <listitem><para>
                This global is the name of the widget into which the  scaler  display
              will be drawn, or "" if the display is drawn into "."
                </para>
                <para>
              If  you  are  adding  more elements to the GUI you can use this to know
              where to manage these new elements.  For example:
                </para>
                <programlisting>
checkbutton $scalerWin.silence -text {Silence Alarms} -command [silence]
                </programlisting>
                <para>
              creates a checkbutton that is a child of the scaler  display  page  and
              can be packed on that page.
                </para>
                <para>
              If  you  are  using the scaler display program from within SpecTcl, you
              can set this widget to allow the scaler display program to pop up in  a
              separate top level.  For example:
                </para>
                <programlisting>
               set  scalerWin [toplevel .scaler]
               source /usr/opt/daq/current/Scripts/scaler.tcl
                </programlisting>
                <para>
              Creates the scaler display in a new top level widget called .scaler
                </para>
                </listitem>
        </varlistentry>
        <varlistentry>
            <term><varname>maxStripPoints</varname></term>
            <listitem>
                <para>
                    Sets a limit on the number of points the strip chart
                    recorder data series can have.  If this is zero (the default),
                    there is no limit.  If non zero, when more than
                    <varname>maxStripPoints</varname> time intervals have been
                    added to the data series, every other point is removed from
                    the first 1/2 of the time.  This means that:
                    <orderedlist>
                        <listitem>
                            <para> The most recent 1/2 of data is always at
                                full resolution
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                The oldest data is shown at progressively poorer
                                time resolution as successive data trims are
                                performed.
                            </para>
                        </listitem>
                    </orderedlist>
                </para>
            </listitem>
        </varlistentry>
    </variablelist>
  </refsect1>
  <refsect1>
    <title>EXAMPLE(S)</title>
    <programlisting>
       #
       #   Define the scaler channels:
       #
       #   These can be in any order, Iâm just copying the order from the original
       #   file.  my preference in fact would be to go in channel order.
       #   This is a TCL script with
       #    commands âchannelâ  - to define a chanel name/buffer position correspondence
       #             âpageâ     - To define a scaler page.
       #             âdisplay_singleâ - To define a single scaler line in a page.
       #

       #
       channel gas.PIN.cfd       0
       channel gas.qA.cfd       16
       channel gas.qB.cfd       17
       channel gas.gC.cfd       18;              # is this a typo in the original file?
       channel gas.qD.cfd       19
       channel gas.de.cfd        1
       channel gas.Ge.cfd        2
       channel gas.Ge.cfd_B-OFF 12
       channel gas.PS.cfd        5
       channel gas.PS.cfd_B-OFF 13
       channel I2.SCI.N          3
       channel I2.SCI.S          4
       channel TA.BaF2           6
       channel master.gated     11
       channel master.free      10
       channel cpu.lam.TO        7
       channel clock.gated       9
       channel clock.free        8
       channel beam.cycle.on    14
       channel beam.cycle.off   15

       #
       #  Next define the pages, their long titles and the tab name
       #  and their contents.
       #  Iâve defined the page ALL to be the original page
       #  as well as some additional pages so that you can get the
       #  idea of how you can use this to organize the display if you want to.
       #  If you donât, you can rip out the extra pages.
       #
       #

       page ALL  "Gas Cell DAQ All Scalers"
       display_single ALL gas.PIN.cfd
       display_ratio  ALL gas.qA.cfd      gas.qB.cfd
       display_ratio  ALL gas.gC.cfd      gas.qD.cfd
       display_single ALL gas.Ge.cfd
       display_ratio  ALL gas.Ge.cfd      gas.Ge.cfd_B-OFF
       display_ratio  ALL gas.PS.cfd      gas.PS.cfd_B-OFF
       display_ratio  ALL I2.SCI.N        I2.SCI.S
       display_single ALL TA.BaF2
       display_ratio  ALL master.gated        master.free
       display_ratio  ALL cpu.lam.TO          master.gated
       display_ratio  ALL clock.gated         clock.free
       display_ratio  ALL gasN4.dE.cfd        gasN4.PIN.cfd
       display_ratio  ALL beam.cycle.on       beam.cycle.off

       # If you only want the first page, then remove all lines
       #------------------------- cut below here -------------------

       #  A second page:
       #   Just showing the livetime information  mostly.

       page Livetime "Live time information"
       display_ratio Livetime  master.gated master.free
       display_ratio Livetime  clock.gated  clock.free
       display_ratio Livetime  cop.lam.TO   master.gated

       #  A third page showing only the gas cell:

       page GasCell "Gas cell scalers"

       display_single GasCell gas.PIN.cfd
       display_ratio  GasCell gas.qA.cfd      gas.qB.cfd
       display_ratio  GasCell gas.gC.cfd      gas.qD.cfd
       display_single GasCell gas.Ge.cfd
       display_ratio  GasCell gas.Ge.cfd      gas.Ge.cfd_B-OFF
       display_ratio  GasCell gas.PS.cfd      gas.PS.cfd_B-OFF

       # Do a strip chart of the live master rates and the
       # Livetime computed by clock.gated/clock.free:

       stripparam master.gated
       stripratio clock.gated clock.free
</programlisting>
    </refsect1>
    <refsect1>
        <title>BUGS AND RESTRICTIONS</title>
        <itemizedlist>
            <listitem>
                <para>
                 This software only available with release 8.0 and later of nscldaq.
                </para>
            </listitem>
            <listitem>
                <para>
                The startup script for this software requires the TCP/IP server port
              manager that made its debut with release 8.0 of the software.
                </para>
            </listitem>
            <listitem>
                <para>
        The BLT stripchart widget used to display rate strip charts requires
              that channels displayed on it have names that consist only  of  letter,
              digits,  underscores  an periods.  There are no restrictions on channel
              names that are not displayed on the  strip  chart,  however  users  are
              encouraged to maintain the BLT restrictions.
                </para>
            </listitem>
            


        </itemizedlist>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
            <link linkend="manpage.tclserver">tclserver(1)</link>,
            <link linkend="manpage.sclclient">sclclient(1)</link>
        </para>
        </refsect1>
</refentry>



<refentry id="manpage.tclserver">
  <refmeta>
     <refentrytitle>tclserver</refentrytitle>
     <manvolnum>1tcl</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>tclserver</refname>
     <refpurpose>Start a Tcl Server.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
tclserver <optional><option>-p<replaceable>port</replaceable></option> <option>-userauth</option></optional>
	</command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
	Starts a Tcl server.   The server will listen for connections.  Authorized
        connections will be allowed to 'poke' Tcl commands to the server which will
        execute them and return the result to the client.
     </para>
  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	<varlistentry>
	    <term><option>-p<replaceable>port</replaceable></option></term>
	    <listitem>
		<para>
                    Specifies the port on which the server will listen.
                    <itemizedlist>
                        <listitem>
                            <para>
                                If omitted this defaults to 2048.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                If <replaceable>port</replaceable> is the
                                text string <literal>Managed</literal>,
                                the daq port manager is contacted to allocated
                                a free port on which to listen.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                If <replaceable>port</replaceable> is an integer,
                                it is taken as th eport on which to listen.
                            </para>
                        </listitem>
                    </itemizedlist>
		</para>
	    </listitem>
                        
	</varlistentry>
        <varlistentry>
            <term><option>-userauth</option></term>
            <listitem>
                <para>
                    If present, the client must, in addition to being authorized
                    via the <command>serverauth</command> command send as the first
                    line of text the name of the user running the client.
                    This username must match the name of the uyser that is running
                    the server.
                </para>
                <para>
                    This is intended to reduce the chances that more than one user
                    on the same system might cause problems by talking with each other's
                    tclservers.
                </para>
            </listitem>
        </varlistentry>
     </variablelist>
  </refsect1>

</refentry>
<refentry id="manpage.serverauth">
  <refmeta>
     <refentrytitle>serverauth</refentrytitle>
     <manvolnum>1tcl(tclserver)</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>serverauth</refname>
     <refpurpose>Control tcl server authorization.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
serverauth add <replaceable>hostorip</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
serverauth remove <replaceable>hostorip</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
serverauth list
        </command>
    </cmdsynopsis>

  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
	Manipulates the server authorization database.  The server authorization
        database determines which nodes are allowed to connect to the tcl server.
        This command lives in the tclserver itself.  Usually a startup script
        or GUI element projected by the server sets up the appropriate authorization
        lists.
     </para>
     <para>
        <command>serverauth</command> is an ensemble of commands that has
        the following ensemble commands:
     </para>
     <variablelist>
        <varlistentry>
            <term><command>serverauth add <replaceable>hostorip</replaceable></command></term>
            <listitem>
                <para>
                    Adds <parameter>hostorip</parameter> to the set of hosts
                    that are allowed to connect to this instance of the server.
                    <parameter>hostorip</parameter> can be either a DNS hostname
                    like <literal>spdaq22.nscl.msu.edu</literal> or it can
                    be a dotted IP address like: <literal>35.8.35.123</literal>.
                    </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><command>serverauth remove <replaceable>hostorip</replaceable></command></term>
            <listitem>
                <para>
                    Removes the host <parameter>hostorip</parameter> from the set of
                    systems that are authorized to connect as clients to the tcl server.
                    <parameter>hostorip</parameter> is a DNS name or dotted IP, as for
                    the <command>serverauth add</command> command.  Matching is based on
                    the IP address so the command should work just fine in the presence of e.g. CNAMEs.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><command>serverauth list</command></term>
            <listitem>
                <para>
                    Lists the systems that are authorized to connect.  The command
                    returns as a result a Tcl list. Each element of the list is a pair.
                    The first element of the pair is the hostname of a host authorized
                    to connect (actually a hostorip provided).  The second element
                    of the list is the IP address of the associated host.
                </para>
            </listitem>
        </varlistentry>
     </variablelist>
  </refsect1>
 
</refentry>

</reference>
<reference>
<title>3daq</title>

    <refentry id="manpage.copyrightnotice">
      <refmeta>
         <refentrytitle>CopyrrightNotice</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CopyrightNotice</refname>
	 <refpurpose>Generate license/author credits.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CopyrightNotice.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CopyrightNotice</classname></ooclass>
            <methodsynopsis>
                    <modifier>static</modifier> <type>void</type>
                    <methodname>Notice</methodname>
                    <methodparam>
                        <type>std::ostream&amp;</type> <parameter>out</parameter>
                    </methodparam>
                    <methodparam>
                        <type>const char*</type> <parameter>program</parameter>
                    </methodparam>
                    <methodparam>
                        <type>const char*</type> <parameter>version</parameter>
                    </methodparam>
                    <methodparam>
                        <type>const char*</type> <parameter>year</parameter>
                    </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                    <modifier>static</modifier> <type>void</type>
                    <methodname>AuthorCredit</methodname>
                    <methodparam>
                        <type>std::ostream&amp;</type> <parameter>out</parameter>
                    </methodparam>
                    <methodparam>
                        <type>char*</type> <parameter>program</parameter>
                    </methodparam>
                    <methodparam>
                        <parameter>...</parameter>
                    </methodparam>
            </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            The <classname>CopyrightNotice</classname> class provides static
            methods for generating license notices and copyright strings
            when programs start.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <methodsynopsis>
                    <modifier>static</modifier> <type>void</type>
                    <methodname>Notice</methodname>
                    <methodparam>
                        <type>std::ostream&amp;</type> <parameter>out</parameter>
                    </methodparam>
                    <methodparam>
                        <type>const char*</type> <parameter>program</parameter>
                    </methodparam>
                    <methodparam>
                        <type>const char*</type> <parameter>version</parameter>
                    </methodparam>
                    <methodparam>
                        <type>const char*</type> <parameter>year</parameter>
                    </methodparam>
            </methodsynopsis>
            <para>
                Outputs a copyright notice to the output stream
                <parameter>out</parameter>.  <parameter>program</parameter> is the
                name of the program. <parameter>version</parameter> is a
                version string, and <parameter>year</parameter> is the
                copyright year.
            </para>

            <methodsynopsis>
                    <modifier>static</modifier> <type>void</type>
                    <methodname>AuthorCredit</methodname>
                    <methodparam>
                        <type>std::ostream&amp;</type> <parameter>out</parameter>
                    </methodparam>
                    <methodparam>
                        <type>char*</type> <parameter>program</parameter>
                    </methodparam>
                    <methodparam>
                        <parameter>...</parameter>
                    </methodparam>
            </methodsynopsis>
            <para>
                Outputs credit for the authors.  The
                <parameter>out</parameter> and <parameter>program</parameter>
                parameters have the same meaning as for <methodname>Notice</methodname>.
                These parameters are followed by a null terminated variable length
                list of arguments that must all be <type>const char*</type>
                pointer to names of the authors.
            </para>
      </refsect1>
      <refsect1>
         <title>EXAMPLES</title>
         <para>
            Create a copyright notice on stderr.  This is from the
            <function>main</function> or other function that
            has access to the <varname>argv</varname> array:
            <example>
                <title>Creating a coypright notice on stderr</title>
                <programlisting>
CopyrightNotice::Notice(cerr, argv[0], "2.1", "2004");
                </programlisting>
            </example>
         </para>
         <para>
            Create an author credit on stderr for the authors Ron and Kanayo:
            <example>
                <title>Creating an author credit on stderr</title>
                <programlisting>
CopyrightNotice::AuthorCredit(cerr, argv[0], "Kanayo", "Ron", NULL);
                </programlisting>
            </example>
         </para>

      </refsect1>
   </refentry>

<refentry id="manpage.cvt">
    <refmeta>
         <refentrytitle>cvt</refentrytitle>
         <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
       <refname>cvt</refname>
       <refpurpose>Integer byte order conversions</refpurpose>
    </refnamediv>
    
    <refsynopsisdiv>
       <programlisting>
#include &lt;cvt.h&gt;
       </programlisting>
       <funcsynopsis>
        <funcprototype>
            <funcdef><type>void</type> <function>makecvtblock</function></funcdef>
            <paramdef>
                <type>uint32_t</type> <parameter>lsig</parameter>
            </paramdef>
            <paramdef>
                <type>uint16_t</type> <parameter>ssig</parameter>
            </paramdef>
            <paramdef>
                <type>DaqConversion*</type> <parameter>conversion</parameter>
            </paramdef>
        </funcprototype>
       </funcsynopsis>
       <funcsynopsis>
            <funcprototype>
                <funcdef><type>bool</type> <function>hostsameasforeign</function></funcdef>
                <paramdef>
                    <type>DaqConversion*</type> <parameter>conversion</parameter>
                </paramdef>
            </funcprototype>
       </funcsynopsis>
       <funcsynopsis>
        <funcprototype>
            <funcdef><type>uint32_t</type> <function>ftohl</function></funcdef>
            <paramdef>
                <type>DaqConversion*</type> <parameter>convertdata</parameter>
            </paramdef>
            <paramdef>
                <type>uint32_t</type> <parameter>datum</parameter>
            </paramdef>
        </funcprototype>
       </funcsynopsis>
       <funcsynopsis>
        <funcprototype>
            <funcdef><type>uint16_t</type> <function>ftohs</function></funcdef>
            <paramdef>
                <type>DaqConversion*</type> <parameter>convertdata</parameter>
            </paramdef>
            <paramdef>
                <type>uint1y_t</type> <parameter>datum</parameter>
            </paramdef>
        </funcprototype>
       </funcsynopsis>
       <funcsynopsis>
       <funcprototype>
        <funcdef><type>uint32_t></type> <function>htofl</function></funcdef>
            <paramdef>
                <type>DaqConversion*</type> <parameter>convertdata</parameter>
            </paramdef>
            <paramdef>
                <type>uint32_t</type> <parameter>datum</parameter>
            </paramdef>
        </funcprototype>
       </funcsynopsis>
       <funcsynopsis>
       <funcprototype>
        <funcdef><type>uint16_t</type> <function>htofs</function></funcdef>
            <paramdef>
                <type>DaqConversion*</type> <parameter>convertdata</parameter>
            </paramdef>
            <paramdef>
                <type>uint16_t</type> <parameter>datum</parameter>
            </paramdef>
        </funcprototype>
       </funcsynopsis>
    </refsynopsisdiv>
    <refsect1>
       <title>Description</title>
       <para>
          This library provides a suite of functions that do integer conversions
          between the native integer formats of different systems.
          Typically systems are classified as 
          <firstterm>big-endian</firstterm> or
          <firstterm>little-endian</firstterm>.
       </para>
       <para>
        Big-endian systems store their data with the most significant bytes of
        a multi-byte integer in lower addresses, while little-endian systems
        least significant bytes in lower addresses.
        This library uses <firstterm>signature</firstterm> data in the
        data to determine the byte ordering of foreign host (the host that
        created the data), and how it differs from the local byte ordering.
       </para>
       <para>
            Signature data are data that have a known value, stored in the
            system's native byte order.  Analyzing these values byte by byte
            allows the software to determine the byte order of the foreign system.
            The code defines the values:
            <literal>CVT_WORDSIGNATURE</literal>
            and
            <literal>CVT_LONGSIGNATURE</literal>
            respectively to be <type>uint16_t</type> and
            <type>uint32_t</type>
            signatures respectively.
            Separate 16 and 32 bit signatures allows the library to deal with
            any pathalogical systems that may have word orders that differ from
            byte ordering.
	</para>
    </refsect1>
    <refsect1>
       <title>
          Public functions
       </title>
       <funcsynopsis>
        <funcprototype>
            <funcdef><type>void</type> <function>makecvtblock</function></funcdef>
            <paramdef>
                <type>uint32_t</type> <parameter>lsig</parameter>
            </paramdef>
            <paramdef>
                <type>uint16_t</type> <parameter>ssig</parameter>
            </paramdef>
            <paramdef>
                <type>DaqConversion*</type> <parameter>conversion</parameter>
            </paramdef>
        </funcprototype>
       </funcsynopsis>
       <para>
            Creates a conversion block from the foreign system signatures you've
            extracted from the data.  Note that NSCLDAQ control data includes byte
            and long signatures you can use for this purpose.
            <parameter>lsig</parameter> and
            <parameter>ssig</parameter>
            are the 32 and 16 bit signatures respectively.
        </para>
        <para>    
            <parameter>conversion</parameter>
            must point to a <type>DaqConversion</type> structure that will be
            over-written with the conversion block that describes how to
            convert from the byte order described by
            <parameter>lsig</parameter>
            and
            <parameter>ssig</parameter>
            to the host's byte order.
        </para>
       <funcsynopsis>
            <funcprototype>
                <funcdef><type>bool</type> <function>hostsameasforeign</function></funcdef>
                <paramdef>
                    <type>DaqConversion*</type> <parameter>conversion</parameter>
                </paramdef>
            </funcprototype>
       </funcsynopsis>
       <para>
        Determines if the conversion block pointed to by
        <parameter>conversion</parameter>
        describes a system with the same byte order as the host system.
        </para>
       <funcsynopsis>
        <funcprototype>
            <funcdef><type>uint32_t</type> <function>ftohl</function></funcdef>
            <paramdef>
                <type>DaqConversion*</type> <parameter>convertdata</parameter>
            </paramdef>
            <paramdef>
                <type>uint32_t</type> <parameter>datum</parameter>
            </paramdef>
        </funcprototype>
       </funcsynopsis>
        <para>
            Converts a 32 bit value
            <parameter>datum</parameter>
            from the byte order of the foreign host used to produce the
            <type>DaqConversion</type>
            structer pointed to by <parameter>convertdata</parameter> to the
            local host's byte order. The converted value is returned.
        </para>
       <funcsynopsis>
        <funcprototype>
            <funcdef><type>uint16_t</type> <function>ftohs</function></funcdef>
            <paramdef>
                <type>DaqConversion*</type> <parameter>convertdata</parameter>
            </paramdef>
            <paramdef>
                <type>uint1y_t</type> <parameter>datum</parameter>
            </paramdef>
        </funcprototype>
       </funcsynopsis>
        <para>
            Converts a 16 bit integer
            <parameter>datum</parameter> from the byte order described by
            the system used to produce the
            <type>DaqConversion</type>
            block pointed to by
            <parameter>convertdata</parameter> into the local system's byte order
            and returns that 16 bit integer.
        </para>
       <funcsynopsis>
       <funcprototype>
        <funcdef><type>uint32_t></type> <function>htofl</function></funcdef>
            <paramdef>
                <type>DaqConversion*</type> <parameter>convertdata</parameter>
            </paramdef>
            <paramdef>
                <type>uint32_t</type> <parameter>datum</parameter>
            </paramdef>
        </funcprototype>
       </funcsynopsis>
       <para>
            Converts the 32 bit integer
            <parameter>datum</parameter>
            from the local host's native byte order to the byte order described
            by the foreign host used to create the 
            <type>DaqConversion</type>
            conversion block
            <parameter>convertdata</parameter>,
            and returns the converted value.
        </para>
       <funcsynopsis>
       <funcprototype>
        <funcdef><type>uint16_t</type> <function>htofs</function></funcdef>
            <paramdef>
                <type>DaqConversion*</type> <parameter>convertdata</parameter>
            </paramdef>
            <paramdef>
                <type>uint16_t</type> <parameter>datum</parameter>
            </paramdef>
        </funcprototype>
       </funcsynopsis>
       <para>
           Converts the 16 bit integer
            <parameter>datum</parameter>
            from the local host's native byte order to the byte order described
            by the foreign host used to create the 
            <type>DaqConversion</type>
            conversion block
            <parameter>convertdata</parameter>,
            and returns the converted value.
        </para>
    </refsect1>
    <refsect1>
       <title>Types and public data</title>
       <para>
        <literal>CVT_WORDSIGNATURE</literal> is a 16 bit byte order signature you will
            need to supply in any data you originate, and
        <literal>CVT_LONGSIGNATURE</literal> is a 32 bit byte order signature you will
            need to supply in any data you originate.
       </para>
    </refsect1>
</refentry>


    <refentry id="manpage.cexception">
        
        <refmeta>
            <refentrytitle>CException</refentrytitle>
            <manvolnum>3daq</manvolnum>
        </refmeta>
        
        <refnamediv>
            <refname>CException</refname>
            <refpurpose>Abstract base class for the exception class hierarchy.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
            <programlisting>
#include &lt;Exception.h&gt;
            </programlisting>
            <classsynopsis>
                <ooclass><classname>CException</classname></ooclass>
                <constructorsynopsis><methodname>CException</methodname>
                    <methodparam><modifier>const</modifier><type>char*</type> <parameter>pszAction</parameter></methodparam>
                </constructorsynopsis>
                <constructorsynopsis><methodname>CException</methodname>
                    <methodparam><modifier>const</modifier><type>std::string&amp;</type> <parameter>rsAction</parameter></methodparam>
                </constructorsynopsis>
                <methodsynopsis>
                    <modifier>virtual const</modifier><type>char*</type> <methodname>ReasonText</methodname>
                            <void />
                            <modifier> const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <modifier>virtual</modifier><type>Int_t</type> <methodname>ReasonCode</methodname>
                        <void />
                        <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <modifier>const</modifier><type>char*</type> <methodname>WasDoing</methodname>
                        <void /> <modifier>const</modifier>
                </methodsynopsis>
            </classsynopsis>

        </refsynopsisdiv>
        
        <refsect1>
            <title>Description</title>
            <para>
                This class is the abstract base class of the exception class hierarchy.
                The class hierarchy provides textual exception descriptions (that can be displayed
                to a user), as well as support for a numerical code that can be easily processed
                by software.  The textual description is composed by the
                <methodname>ReasonText</methodname> function in an exception specific way. Usually
                the resulting message includes a description of the message along with context
                information held by this base class and retrieved via <methodname>WasDoing</methodname>.
            </para>
        </refsect1>
        <refsect1>
            <title>Public member functions</title>
            <methodsynopsis><methodname>CException</methodname>
                <methodparam><modifier>const</modifier><type>char*</type> <parameter>pszAction</parameter></methodparam>
            </methodsynopsis>
            <methodsynopsis><methodname>CException</methodname>
                <methodparam><modifier>const</modifier><type>std::string&amp;</type> <parameter>rsAction</parameter></methodparam>
            </methodsynopsis>
            <para>
                Both of the constructors described above save their parameter as the context specific
                part of the description.  This string can be retrieved via
                <methodname>WasDoing</methodname>.  Normally the string should give some indication
                of what the program was doing when the exception was thrown.
            </para>
            <methodsynopsis>
                <modifier>virtual const</modifier><type>char*</type> <methodname>ReasonText</methodname>
                        <void />
                        <modifier> const</modifier>
            </methodsynopsis>
            <para>
                A virtual function that is supposed to return the reason the exception was thrown.
                For the base class this is the string <literal>Unspecified Exception</literal>.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier><type>Int_t</type> <methodname>ReasonCode </methodname>
                    <void />
                    <modifier>const</modifier>
            </methodsynopsis>
            <para>
                Returns a number that corresponds to the exception reason within a specific
                class of exceptions (e.g. for a <classname>CErrnoException</classname> this would
                be the value of <varname>errno</varname> at the time the exception was constructed).
                For the base class this will always be -1.
            </para>
            <methodsynopsis>
                <modifier>const</modifier><type>char*</type> <methodname>WasDoing</methodname>
                    <void /> <modifier>const</modifier>
            </methodsynopsis>
            <para>
                Returns the context string that was passed to our constructor.  This will normally
                be called by a derived class's <methodname>ReasonText</methodname> function when
                constructing the text.
            </para>
        </refsect1>
    </refentry>

    <refentry id="manpage.CErrnoException">
        
        <refmeta>
            <refentrytitle>CErrnoException</refentrytitle>
            <manvolnum>3daq</manvolnum>
        </refmeta>
        
        <refnamediv>
            <refname>CErrnoException</refname>
            <refpurpose>Exceptions that wrap the Unix <varname>errno</varname></refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
            <programlisting>
#include &lt;ErrnoException.h&gt;
            </programlisting>
            <classsynopsis>
                <ooclass><classname>CErrnoException</classname></ooclass>
                <constructorsynopsis>
                    <methodname>CErrnoException</methodname>
                    <methodparam><modifier>const</modifier> <parameter>pszAction</parameter></methodparam>
                </constructorsynopsis>
                <constructorsynopsis>
                    <methodname>CErrnoException</methodname>
                    <methodparam><modifier>const</modifier> <type>std::string&amp;</type> <parameter>rsAction</parameter></methodparam>
                </constructorsynopsis>
                <methodsynopsis>
                    <modifier>virtual   const</modifier> <type>char*</type>
                            <methodname>ReasonText</methodname>
                            <void /><modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <modifier>virtual</modifier>   <type>Int_t</type> <methodname>ReasonCode</methodname>
                                <void /><modifier>const</modifier>
                </methodsynopsis>
            </classsynopsis>
               

        </refsynopsisdiv>
        
        <refsect1>
            <title>Description</title>
            <para>
                This exception class wraps the Unix <varname>errno</varname> global variable.
                <type>errno</type> is used by most Unix system calls to provide detailed status
                information.   Constructing this class saves a copy of the <varname>errno</varname>
                variable.   <methodname>ReasonCode</methodname> will return the saved errno value.
                <methodname>ReasonText</methodname> will construct a string that includes
                the text associated with the <varname>errno</varname>.
            </para>
        </refsect1>
        <refsect1>
            <title>Public member functions</title>
                <methodsynopsis>
                   <methodname>CErrnoException</methodname>
                   <methodparam><modifier>const</modifier> <parameter>pszAction</parameter></methodparam>
               </methodsynopsis>
               <methodsynopsis>
                   <methodname>CErrnoException</methodname>
                   <methodparam><modifier>const</modifier> <type>std::string&amp;</type> <parameter>rsAction</parameter></methodparam>
               </methodsynopsis>
               <para>
                These constructors save the value of the <varname>errno</varname> variable and
                construct the base class using their parameter as the exception context string
                (returned by <methodname>WasDoing</methodname>).
               </para>
               <methodsynopsis>
                   <modifier>virtual   const</modifier> <type>char*</type>
                           <methodname>ReasonText</methodname>
                           <void /><modifier>const</modifier>
               </methodsynopsis>
               <para>
                    Returns the <function>sterror</function> applied to the saved <varname>errno</varname>.
               </para>
               <methodsynopsis>
                   <modifier>virtual</modifier>   <type>Int_t</type> <methodname>ReasonCode</methodname>
                               <void /><modifier>const</modifier>
               </methodsynopsis>
               <para>
                    Returns the saved <varname>errno</varname> variable value.
               </para>
        </refsect1>
    </refentry>
    <refentry id="manpage.CRangeError">
        
        <refmeta>
            <refentrytitle>CRangeError</refentrytitle>
            <manvolnum>3daq</manvolnum>
        </refmeta>
        
        <refnamediv>
            <refname>CRangeError</refname>
            <refpurpose>Reports and exception for a value out of allowed range.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
            <programlisting>
#include &lt;CRangeError.h&gt;
            </programlisting>
            <classsynopsis>
                <ooclass><classname>CRangeError</classname></ooclass>
                <constructorsynopsis>
                    <methodname>CRangeError</methodname>
                    <methodparam><type>Int_t</type> <parameter>nLow</parameter></methodparam>
                    <methodparam><type>Int_t</type> <parameter>nHigh</parameter></methodparam>
                    <methodparam><type>Int_t</type> <parameter>nRequested</parameter></methodparam>
                    <methodparam><modifier>const</modifier> <type>char*</type> <parameter>pDoing</parameter></methodparam>
                </constructorsynopsis>
                <constructorsynopsis>
                    <methodname>CRangeError</methodname>
                    <methodparam><type>Int_t</type> <parameter>nLow</parameter></methodparam>
                    <methodparam><type>Int_t</type> <parameter>nHigh</parameter></methodparam>
                    <methodparam><type>Int_t</type> <parameter>nRequested</parameter></methodparam>
                    <methodparam><modifier>const</modifier> <type>std::string&amp;</type> <parameter>rDoing</parameter></methodparam>
                </constructorsynopsis>
                <methodsynopsis>
                    <modifier>virtual   const</modifier> <type>char*</type>
                                                         <methodname>ReasonText</methodname>
                                                         <void /><modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis><modifier>virtual</modifier> <type>Int_t</type>
                        <methodname>ReasonCode</methodname>
                        <void /> <modifier>const</modifier>
                </methodsynopsis>
            </classsynopsis>
            
            
        </refsynopsisdiv>
        
        <refsect1>
            <title>Description</title>
            <para>
                Provides an exception that can be used to report parameter range errors
                (normally for integer parameters).  The exception will construct a reason text
                that includes the erroneous value as well as the valid range of values.
            </para>
        </refsect1>
        <refsect1>
            <title>Public member functions</title>
                <methodsynopsis>
                    <methodname>CRangeError</methodname>
                    <methodparam><type>Int_t</type> <parameter>nLow</parameter></methodparam>
                    <methodparam><type>Int_t</type> <parameter>nHigh</parameter></methodparam>
                    <methodparam><type>Int_t</type> <parameter>nRequested</parameter></methodparam>
                    <methodparam><modifier>const</modifier> <type>char*</type> <parameter>pDoing</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <methodname>CRangeError</methodname>
                    <methodparam><type>Int_t</type> <parameter>nLow</parameter></methodparam>
                    <methodparam><type>Int_t</type> <parameter>nHigh</parameter></methodparam>
                    <methodparam><type>Int_t</type> <parameter>nRequested</parameter></methodparam>
                    <methodparam><modifier>const</modifier> <type>std::string&amp;</type> <parameter>rDoing</parameter></methodparam>
                </methodsynopsis>
                <para>
                    Creates a <classname>CRangeError</classname> that can be thrown.
                    The only difference between the two constructors is the way in which the
                    context information is passed.  In the first, by a standard C null terminated string.
                    In the second by a C++ <classname>std::string</classname> object.
                </para>
                <para>
                    The remaining parameters describe the actual exceptional condition:
                    <variablelist>
                        <varlistentry>
                            <term><parameter>nLow</parameter></term>
                            <listitem>
                                <para>
                                    Is the low end of the allowed range that was violated.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><parameter>nHigh</parameter></term>
                            <listitem>
                                <para>
                                    Is the high end of the allowed range that was violated.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><parameter>nRequested</parameter></term>
                            <listitem>
                                <para>
                                    Is the value that violated the range described by
                                    <parameter>nLow</parameter> and <parameter>nHigh</parameter>
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </para>
                <methodsynopsis>
                    <modifier>virtual   const</modifier> <type>char*</type>
                                                         <methodname>ReasonText</methodname>
                                                         <void /><modifier>const</modifier>
                </methodsynopsis>
                <para>
                    Returns the reason for the exception.  This will be a string of the form:
                    <literal>Range error: %v is outside the range [%l..%h]</literal> where
                    %v, %l %h are shorthands for the value, low and high limits respectively.
                </para>
                <methodsynopsis><modifier>virtual</modifier> <type>Int_t</type>
                        <methodname>ReasonCode</methodname>
                        <void /> <modifier>const</modifier>
                </methodsynopsis>
                <para>
                    Returns one of the two possible reasons for the exception:
                    <variablelist>
                        <varlistentry>
                            <term><classname>CRangeError</classname>::<varname>knTooHigh</varname></term>
                            <listitem>
                                <para>The value requested was above the upper limit of the range.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><classname>CRangeError</classname>::<varname>knTooLow</varname></term>
                            <listitem>
                                <para>The value requested was below the lower limit of the range.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                    Note that if the requested value provided to the constuctor does not satisfy
                    either of these relationships, invoking this member function will result in an
                    assertion failure.
                </para>
        </refsect1>        
    </refentry>
    <refentry id="manpage.CStateException">
        
        <refmeta>
            <refentrytitle>CStateException</refentrytitle>
            <manvolnum>3daq</manvolnum>
        </refmeta>
        
        <refnamediv>
            <refname>CStateException</refname>
            <refpurpose>Exception for invalid state transitions.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
            <programlisting>
#include &lt;CStateException.h&gt;
            </programlisting>
            <classsynopsis>
                <ooclass><classname>CStateException</classname></ooclass>
                <constructorsynopsis>
                    <methodname>CStateException</methodname>
                    <methodparam><modifier>const</modifier> <type>char*</type> <parameter>state</parameter></methodparam>
                    <methodparam><modifier>const</modifier> <type>char*</type> <parameter>allowedStates</parameter></methodparam>
                    <methodparam><modifier>const</modifier> <type>char*</type> <parameter>pAction</parameter></methodparam>
                </constructorsynopsis>
                <methodsynopsis>
                    <modifier>virtual const</modifier> <type>char*</type> <methodname>ReasonText</methodname>
                                    <void /> <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <modifier>virtual</modifier>  <type>Int_t</type> <methodname>ReasonCode</methodname>
                                        <void /><modifier>const</modifier>
                </methodsynopsis>
            </classsynopsis>
        </refsynopsisdiv>
        
        <refsect1>
            <title>Description</title>
            <para>
                Many programming problems can be solved by programming a <firstterm>state machine</firstterm>.
                A state machine, or finite state automaton, simply put, is an entity that has a well defined
                set of states it can live in.  Input stimulii may trigger well defined transitions
                from one state to another state.  For example the <emphasis>begin</emphasis> stimulus
                can force a run-state machine in the <emphasis>halted</emphasis> state to make a transition
                to the <emphasis>active</emphasis> state.
            </para>
            <para>
                When programming a state machine the programmer must take into account exceptional
                cases where stimulii that are not allowed for the current state are received or,
                in some cases, errors in implementing the state machine cause the state machine to
                enter a state that is not legal.
            </para>
            <para>
                The <classname>CStateException</classname> provides a class that can be instantiated
                and then thrown in the event one of these cases occurs.
            </para>
        </refsect1>
        <refsect1>
            <title>Public member functions</title>
               <methodsynopsis>
                    <methodname>CStateException</methodname>
                    <methodparam><modifier>const</modifier> <type>char*</type> <parameter>state</parameter></methodparam>
                    <methodparam><modifier>const</modifier> <type>char*</type> <parameter>allowedStates</parameter></methodparam>
                    <methodparam><modifier>const</modifier> <type>char*</type> <parameter>pAction</parameter></methodparam>
                </methodsynopsis>
               <para>
                    Creates a <classname>CStateException</classname> that can be thrown.
                    <variablelist>
                        <varlistentry>
                            <term><parameter>state</parameter></term>
                            <listitem>
                                <para>
                                    The state attempted.  This can be a state attemped via an illegal
                                    transition or it could be an illegal state actually entered as a result
                                    of an error in programming.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><parameter>allowedStates</parameter></term>
                            <listitem>
                                <para>
                                    The allowed states at this time.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><parameter>pAction</parameter></term>
                            <listitem>
                                <para>
                                    The context in which the error was detected and thrown.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
               </para>
                <methodsynopsis>
                    <modifier>virtual const</modifier> <type>char*</type> <methodname>ReasonText</methodname>
                                    <void /> <modifier>const</modifier>
                </methodsynopsis>
                <para>
                    As usual, this returns the textual reason for the failure.  This will be a string of
                    the form:
                    <literal>Invalid object state when: %c relevant erroneous state: %s relevant allowed state: %a</literal>
                    Where <literal>%c</literal> is the context text supplied at construction time.
                    <literal>%s</literal> is the state that caused the error.
                    <literal>%a</literal> are the allowed states prior to this error.
                </para>
                <methodsynopsis>
                    <modifier>virtual</modifier>  <type>Int_t</type> <methodname>ReasonCode</methodname>
                                        <void /><modifier>const</modifier>
                </methodsynopsis>
                <para>
                    The error code for this exception type is always -1.
                </para>
        </refsect1>
        
    </refentry>
    <refentry id="manpage.CStreamIOError">
        
        <refmeta>
            <refentrytitle>CStreamIOError</refentrytitle>
            <manvolnum>3daq</manvolnum>
        </refmeta>
        
        <refnamediv>
            <refname>CStreamIOError</refname>
            <refpurpose>I/O error on a C++ stream.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
            <programlisting>
#include &lt;CStreamIOError.h&gt;
            </programlisting>
            <classsynopsis>
                <ooclass><classname>CStreamIOError</classname></ooclass>
                <constructorsynopsis>
                    <methodname> CStreamIOError</methodname>
                    <methodparam><type>IoStreamConditions</type> <parameter>eReason</parameter></methodparam>
                    <methodparam><modifier>const</modifier>  <type>char*</type> <parameter>pDoing</parameter></methodparam>
                    <methodparam><type>std::ios&amp;</type> <parameter>rStream</parameter></methodparam>
                </constructorsynopsis>
                <constructorsynopsis>
                    <methodname>CStreamIOError</methodname>
                    <methodparam><type>IoStreamConditions</type> <parameter>eReason</parameter></methodparam>
                    <methodparam><modifier>const</modifier> <type>std::string&amp;</type>  <parameter>rDoing</parameter></methodparam>
                    <methodparam><type>std::ios&amp;</type> <parameter>rStream</parameter></methodparam>
                </constructorsynopsis>

                <methodsynopsis>
                    <modifier>virtual const</modifier> <type>char*</type> <methodname>ReasonText</methodname>
                                                                          <void />
                                                                          <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <modifier>virtual</modifier>   <type>Int_t</type> <methodname>ReasonCode</methodname>
                                        <void /><modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>IoStreamConditions</type>
                    <methodname>getReason</methodname> <void /> <modifier>const</modifier>
                </methodsynopsis>
                <methodsynopsis>
                    <type>std::ios&amp;</type> <methodname>getStream</methodname><void />
                </methodsynopsis>
                <methodsynopsis>
                    <modifier>const</modifier> <type>char*</type>
                        <methodname>getErrorMessage</methodname> <modifier>const</modifier>
                </methodsynopsis>
            </classsynopsis>
        </refsynopsisdiv>
        
        <refsect1>
            <title>Description</title>
            <para>
                Captures an error condition reading from or writing to a C++ stream (&lt;iostream&gt;).
                The errors are captured via an enumeration
                <classname>CStreamIOError</classname>::<type>IoStreamConditions</type>.
                See "Types and Pulbic Data" below for more information about the values
                this can have.
            </para>
        </refsect1>
        <refsect1>
            <title>Public member functions</title>
                <methodsynopsis>
                    <methodname> CStreamIOError</methodname>
                    <methodparam><type>IoStreamConditions</type> <parameter>eReason</parameter></methodparam>
                    <methodparam><modifier>const</modifier>  <type>char*</type> <parameter>pDoing</parameter></methodparam>
                    <methodparam><type>std::ios&amp;</type> <parameter>rStream</parameter></methodparam>
                </methodsynopsis>
                <methodsynopsis>
                    <methodname>CStreamIOError</methodname>
                    <methodparam><type>IoStreamConditions</type> <parameter>eReason</parameter></methodparam>
                    <methodparam><modifier>const</modifier> <type>std::string&amp;</type>  <parameter>rDoing</parameter></methodparam>
                    <methodparam><type>std::ios&amp;</type> <parameter>rStream</parameter></methodparam>
                </methodsynopsis>
                <para>
                    Constructs an exception object that can later be thrown.
                    <parameter>eReason</parameter> is the
                    <classname>CStreamIOError</classname>::<type>IoStreamConditions</type>
                    value that describes the error being reported.  See "Types and Public Data"
                    for more information about allowed values.
                </para>
                <para>
                    <parameter>pDoing</parameter> or <parameter>rDoing</parameter> pass in the eror
                    context string that can be reported back to the catcher.
                </para>
                <para>
                    <parameter>rStream</parameter> is a reference to the stream on which the error
                    was detected.
                </para>
                <methodsynopsis>
                    <modifier>virtual const</modifier> <type>char*</type> <methodname>ReasonText</methodname>
                                                                          <void />
                                                                          <modifier>const</modifier>
                </methodsynopsis>
                <para>
                    Returns the reason text associated with the error.  This will be a string
                    that describes the value of the <parameter>eReason</parameter> used to
                    construct the exception object.
                </para>
                <methodsynopsis>
                    <modifier>virtual</modifier>   <type>Int_t</type> <methodname>ReasonCode</methodname>
                                        <void /><modifier>const</modifier>
                </methodsynopsis>
                <para>
                    Returns the error condition cast to an int.  You can also use the
                    class specific <methodname>getReason</methodname> described below.
                </para>
                <methodsynopsis>
                    <type>IoStreamConditions</type>
                    <methodname>getReason</methodname> <void /> <modifier>const</modifier>
                </methodsynopsis>
                <para>
                    Returns the reason the error was thrown.
                </para>
                <methodsynopsis>
                    <type>std::ios&amp;</type> <methodname>getStream</methodname><void />
                </methodsynopsis>
                <para>
                    Returns a reference to the failing stream.  Note that if the catch handler
                    is far enough up the call stack the stream may have been destroyed already.
                    consider something as simple as:
                </para>
                <programlisting>
try {
    ifstream something("somefile");
    somefunction(something);       // can throw...
    ...
}
catch (CStreamIOError&amp; error) {
...
}
                </programlisting>
                <para>
                    Due to the semantics of exception handling, the stream reference
                    that would be returned would be to an already destroyed stream.
                </para>
                <methodsynopsis>
                    <modifier>const</modifier> <type>char*</type>
                        <methodname>getErrorMessage</methodname> <modifier>const</modifier>
                </methodsynopsis>
                <para>
                    Returns a full error message string that includes the reason for the
                    error and the context string as well.
                </para>  
        </refsect1>
        <refsect1>
            <title>Types and public data</title>
            <para>
                The type: <classname>CStreamIOError</classname>::<literal>IoStreamConditions</literal>
                is used to capture error information.  Calling <methodname>ReasonCode</methodname>
                and then
                casting that value to an
                <classname>CStreamIOError</classname>::<literal>IoStreamConditions</literal>
                will give you one of the following values:
                <variablelist>
                    <varlistentry>
                        <term><classname>CStreamIOError</classname>::<literal>EndFile</literal></term>
                        <listitem>
                            <para>
                                An end file condition has been detected.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>CStreamIOError</classname>::<literal>BadSet</literal></term>
                        <listitem>
                            <para>
                                The bad bit in the stream's I/O status mask is set.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><classname>CStreamIOError</classname>::<literal>FailSet</literal></term>
                        <listitem>
                            <para>
                                The fail bit is set in the stream's I/O status mask.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
        </refsect1>        
    </refentry>
    <refentry id="manpage.curiformatexception">
      <refmeta>
         <refentrytitle>CURIFormatException</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CURIFormatException</refname>
	 <refpurpose>Report errors in universal resource identifiers (uri)s.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;uriFormatException.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CURIFormatException</classname></ooclass>
            <constructorsynopsis>
                <methodname>CURIFormatException</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>uri</parameter>
                </methodparam>
                <methodparam>
                    <type>const char*</type> <parameter>file</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>line</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CURIFormatException</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>uri</parameter>
                </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>port</parameter>
                </methodparam>
                <methodparam>
                    <type>const char*</type> <parameter>file</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>line</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CURIFormatException</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>uri</parameter>
                </methodparam>
                <methodparam>
                    <type>const char*</type> <parameter>host</parameter>
                </methodparam>
                <methodparam>
                    <type>const char*</type> <parameter>file</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>line</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CURIFormatException</methodname>
                <methodparam>
                    <type>const CURIFormatException&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier>
                <methodname>~CURIFormatException</methodname> <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>CURIFormatException&amp;</type> <methodname>operator=</methodname>
                <methodparam>
                    <type>const CURIFormatException&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator==</methodname>
                <methodparam>
                    <type>const CURIFormatException&amp;</type> <parameter>rhs</parameter>
                </methodparam>
                <modifier> const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator!=</methodname>
                <methodparam>
                    <type>const CURIFormatException&amp;</type> <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>const char*</type> <methodname>ReasonText</methodname>
                                         <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>Int_t</type>
                <methodname>ReasonCode</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            This exception is a subclass of
            <link linkend="manpage.cexception"><classname>CException</classname></link>.
            It is specialized to report exceptions encountered parsing Uniform
            Resource Identifiers (uris).
            The reason text is human readable, but the reason code is always
            <literal>-1</literal>.
         </para>
         <para>
            Typcially the exception is used to either present an error message
            to the user.  Once the exception is caught, tyipical program action
            is to either prompt the user to correct the faulty uri or to
            exit, depending on the level of interactivity assumed by the application.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
         <formalpara>
            <title>Constructors.</title>
         <para>
            A rich set of constructors is provided to build the exception
            according to the actual error.  In all the constructors above, the
            current action is constructed from the
            <parameter>file</parameter> and <parameter>line</parameter> parameters
            which are the names of the constructing file and line number
            at which the construction occured.  You should use the
            preprocessor <literal>__FILE__</literal> and <literal>__LINE__</literal>
            macros for the <parameter>file</parameter> and <parameter>line</parameter>
            parameters unless you have some special needs.
         </para>
         </formalpara>
        <constructorsynopsis>
             <methodname>CURIFormatException</methodname>
             <methodparam>
                 <type>std::string</type> <parameter>uri</parameter>
             </methodparam>
             <methodparam>
                 <type>const char*</type> <parameter>file</parameter>
             </methodparam>
             <methodparam>
                 <type>int</type> <parameter>line</parameter>
             </methodparam>
         </constructorsynopsis>
        <para>
            Constructs the exception when the URI <parameter>uri</parameter>
            just can't be parsed.
         </para>
         <constructorsynopsis>
             <methodname>CURIFormatException</methodname>
             <methodparam>
                 <type>std::string</type> <parameter>uri</parameter>
             </methodparam>
             <methodparam>
                 <type>std::string</type> <parameter>port</parameter>
             </methodparam>
             <methodparam>
                 <type>const char*</type> <parameter>file</parameter>
             </methodparam>
             <methodparam>
                 <type>int</type> <parameter>line</parameter>
             </methodparam>
         </constructorsynopsis>
         <para>
            Constructs the exception when the URI <parameter>uri</parameter>
            has a string <parameter>port</parameter> which should be a port
            number but can't be properly processed as a port.
         </para>
         <constructorsynopsis>
             <methodname>CURIFormatException</methodname>
             <methodparam>
                 <type>std::string</type> <parameter>uri</parameter>
             </methodparam>
             <methodparam>
                 <type>const char*</type> <parameter>host</parameter>
             </methodparam>
             <methodparam>
                 <type>const char*</type> <parameter>file</parameter>
             </methodparam>
             <methodparam>
                 <type>int</type> <parameter>line</parameter>
             </methodparam>
         </constructorsynopsis>
         <para>
            This constructor creates the exception objects for the URI
            <parameter>uri</parameter> when the
            <parameter>host</parameter> should be a host name but cannot
            be resolved to an IP address.  The assumption is that the
            URI being constructed will actually be used.
         </para>
         <constructorsynopsis>
             <methodname>CURIFormatException</methodname>
             <methodparam>
                 <type>const CURIFormatException&amp;</type> <parameter>rhs</parameter>
             </methodparam>
         </constructorsynopsis>
        <para>
            Copy Construction
        </para>
        <formalpara>
            <title>Canonical operations</title>
            <para>
                The <classname>CURIFormatException</classname> class
                supports assignment and comparisons for equality and
                inequality such that two equal exceptions where created in
                the same place for the same reason.
            </para>
        </formalpara>
        <formalpara>
            <title><classname>CException</classname> interface</title>
	    <para>
            </para>
        </formalpara>
        <methodsynopsis>
            <modifier>virtual</modifier>
            <type>const char*</type> <methodname>ReasonText</methodname>
                                     <void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns a human readable exception string.
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier> <type>Int_t</type>
            <methodname>ReasonCode</methodname>
            <void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns <literal>-1</literal>.
        </para>
      </refsect1>
   </refentry>
         
    <refentry id="manpage.cmonitorexception">
      <refmeta>
         <refentrytitle>CMonitorException</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CMonitorException</refname>
	 <refpurpose>Exceptions for synchronization class abuse.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;MonitorException.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CMonitorException</classname></ooclass>
            <constructorsynopsis>
                <methodname>MonitorException</methodname>
                <methodparam>
                    <type>int</type> <parameter>correctOwner</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>actualOwner</parameter>
                </methodparam>
                <methodparam>
                    <type>const char*</type> <parameter>file</parameter>
                </methodparam>
                <methodparam>
                    <type>const char*</type> <parameter>line</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>MonitorException</methodname>
                <methodparam>
                    <type>const MonitorException&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~MonitorException</methodname>
                                             <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>MonitorException&amp;</type> <methodname>operator=</methodname>
                <methodparam>
                    <type>const MonitorException&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator==</methodname>
                <methodparam>
                    <type>const MonitorException&amp;</type> <parameter>rhs</parameter>
                </methodparam>
                    <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator!=</methodname>
                <methodparam>
                    <type>const MonitorException&amp;</type> <parameter>rhs</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>const char*</type> <methodname>ReasonText</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>Int_t</type>
                <methodname>ReasonCode</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            The NSCL DAQ base software includes support for an object model
            wrapped around the pthreads threading subsystem.  This allows
            NSCL DAQ software to be written that can take advantage of multiple
            threads of execution.  The threading library is described in the
            chapter;
            <link linkend="chapter.threads">NSCL DAQ Thread Library</link>.
            That chapter points to additional reference pages that provide
            reference information for the classes themselves.
         </para>
         <para>
            Any  non-trivial threaded application must synchronize at critical
            points in its operation in order to maintain consistent views of
            non-primitive data.  The NSCL DAQ thread library provides a
            <classname>Synchronizable</classname> class and associated
            <classname>SyncGuard</classname> class to support this synchronization.
            These classes attempt to detect abuse of the synchronization model
            they support. The report such abuse by throwing
            <classname>CMonitorException</classname> objects.
         </para>
         <para>
            <classname>CMonitorException</classname>
            is derived from the
            <link linkend="manpage.cexception">CException</link>
            class, and therefore supports and implements all of its
            virtual members.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
         <formalpara>
            <title>Constructors</title>
            <para>
                In the description of the methods below;
                <parameter>correctOwner</parameter>
                is a thread id that represents the thread that should be 
                holding ownership of a synchronizable object.
                <parameter>actualOwner</parameter>
                is the thread id of the thread that actually does own the
                object, and <parameter>file</parameter> and <parameter>line</parameter>
                are ordinarily the values of the
                <literal>__FILE__</literal>
                and
                <literal>__LINE__</literal>
                macros at the time the the exception is constructed.
            </para>
         </formalpara>
            <constructorsynopsis>
                <methodname>MonitorException</methodname>
                <methodparam>
                    <type>int</type> <parameter>correctOwner</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>actualOwner</parameter>
                </methodparam>
                <methodparam>
                    <type>const char*</type> <parameter>file</parameter>
                </methodparam>
                <methodparam>
                    <type>const char*</type> <parameter>line</parameter>
                </methodparam>
            </constructorsynopsis>
            <para>
                The normal constructor for this object.  The exception will
                report that the ownership of the synchronizable object should have
                been the currently executing thread but was a different thread.
            </para>
            <constructorsynopsis>
                <methodname>MonitorException</methodname>
                <methodparam>
                    <type>const MonitorException&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <para>
                Copy construction.  The object constructed will be a duplcate
                of the <parameter>rhs</parameter> object.
            </para>
            <formalpara>
                <title>Canonical methods</title>
                <para>
                    The
                    <classname>CMonitorException</classname> class supports assignment,
                    equality comparison and inequality comparison.  Assignment
                    creates a duplicate of the right hand side of the assignment
                    operator.  Two
                    <classname>CMonitorException</classname> objects are equal if
                    the Reason text they would generate are equal.  Inequality is
                    defined as the logical inverse of equality.
                </para>
            </formalpara>
            <formalpara>
                <title>Implementation of the <classname>CException</classname> interface</title>
                <para>
                </para>
            </formalpara>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>const char*</type> <methodname>ReasonText</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <para>
                Returns the reason for the exception.  This is intended to be
                human readable text that describes the error as well as where
                an why it was thrown.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>Int_t</type>
                <methodname>ReasonCode</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <para>
                Normally this returns an error code that can be processed
                by computer code.  At present, there's only one reason for
                the exception to be thrown, so this always returns
                <literal>-1</literal>.
            </para>
      </refsect1>
   </refentry>


<!-- Interactors: -->

    <refentry id="manpage.cauthenticator">
      <refmeta>
         <refentrytitle>CAuthenticator</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CAuthenticator</refname>
	 <refpurpose>Abstract base authenticator class.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;Authenticator.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CAuthenticator</classname></ooclass>
            <constructorsynopsis>
                <methodname>CAuthenticator</methodname> <void />
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CAuthenticator</methodname>
                <methodparam>
                    <type>const CAuthenticator&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~CAuthenticator</methodname>
                                             <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>CAuthenticator&amp;</type> <methodname>operator=</methodname>
                <methodparam>
                    <type>const CAuthenticator&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>Bool_t</type> <methodname>Authenticate</methodname>
                <methodparam>
                    <type>CInteractor&amp;</type> <parameter>interactor</parameter>
                </methodparam>
                <modifier> = 0</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>protected:</modifier> <type>std::string</type> <methodname>GetLine</methodname>
                <methodparam>
                    <type>CInteractor&amp;</type> <parameter>interactor</parameter>
                </methodparam>
            </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            <classname>CAuthenticator</classname> is the base class for all
            authenticators.  You can use any of the authenticators described in
            these reference pages, or you can create your own by deriving a new
            authenticator from this base class.
         </para>
         <para>
            The class provides a public interface and protected services for
            derived classes.  These will be described in
            "Member functions" below.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Member functions
         </title>
           <constructorsynopsis>
                <methodname>CAuthenticator</methodname> <void />
            </constructorsynopsis>
           <para>
                Default construtor.  This is supplied so the compiler
                won't complain if derived class constructors don't explcitly
                chain to their base class constructor.
           </para>
            <constructorsynopsis>
                <methodname>CAuthenticator</methodname>
                <methodparam>
                    <type>const CAuthenticator&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <para>
                Copy constructor this is supplied so that derived classes can
                implement a copy constructor.  In the future, if additional
                services are added to the base class that require state,
                this constructor can be chained to by derived classes to ensure
                that the appropriate deep copy is done.
            </para>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~CAuthenticator</methodname>
                                             <void />
            </destructorsynopsis>
            <para>
                Destructor is provide as virtual to ensure that destructors
                automatically chain up the class hierarchy.
            </para>
            <methodsynopsis>
                <type>CAuthenticator&amp;</type> <methodname>operator=</methodname>
                <methodparam>
                    <type>const CAuthenticator&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Assignment operator is supplied for much the same reason as the
                copy constructor.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>Bool_t</type> <methodname>Authenticate</methodname>
                <methodparam>
                    <type>CInteractor&amp;</type> <parameter>interactor</parameter>
                </methodparam>
                <modifier> = 0</modifier>
            </methodsynopsis>
            <para>
                <methodname>Authenticate</methodname> is the interface that
                derived classes must implement.  The method must obtain
                credentials from the entity that want service via the
                <parameter>interactor</parameter> object supplied.
                If the entity supplies authorized credentials, the function
                should return <literal>kfTRUE</literal>.  If the entity
                supplies bad or unauthorized credentials,
                <literal>kfFALSE</literal>
                should be returned.
            </para>
            <methodsynopsis>
                <modifier>protected:</modifier> <type>std::string</type> <methodname>GetLine</methodname>
                <methodparam>
                    <type>CInteractor&amp;</type> <parameter>interactor</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                This protected service reads a complete line of text from the
                <parameter>interactor</parameter>.  The newline at the end of
                the input line is absorbed from the interactor but silently
                discarded.
            </para>
      </refsect1>
      <refsect1>
         <title>Types and public data</title>
         <para>
            The
            <link linkend="manpage.cinteractor"><classname>CInteractor</classname></link>
            object is an object that is intended to obtain credentials from some
            source.  Other sections of this manpage describe interactors, both their
            abstract base class (<classname>CInteractor</classname>), and
            derived concrete classes.
         </para>
         <para>
            The <link linkend="chapter.security">Security chapter</link>
            of the full documentation manual describes the entire authentication
            package and how to use it as well as providing a brief listing of
            the various authenticators and interactors that are currently
            implemented.
         </para>
      </refsect1>

   </refentry>
    <refentry id="manpage.cpasswordcheck">
      <refmeta>
         <refentrytitle>CPasswordCheck</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CPasswordCheck</refname>
	 <refpurpose>Authenticate against a stored password.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;PasswordCheck.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CPasswordCheck</classname></ooclass>
            <constructorsynopsis>
                <methodname>CPasswordCheck</methodname>
                <methodparam>
                    <type>const std::string&amp;</type> <parameter>password</parameter>
                </methodparam>
                <methodparam>
                    <type>const std::string</type> <parameter>prompt = std::string("")</parameter>
                </methodparam>
                <methodparam>
                    <type>Bool_t</type> <parameter>WithPrompt = kfFALSE</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CPasswordCheck</methodname>
                <methodparam>
                    <type>const CPasswordCheck&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <methodname>~CPasswordCheck</methodname> <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>CPasswordCheck&amp;</type> <methodname>operator=</methodname>
                <methodparam>
                    <type>const CPassswordCheck&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type> <methodname>getPassword</methodname>
                                         <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type> <methodname>getPromptString</methodname>
                                         <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>Bool_t</type> <methodname>getWithPrompt</methodname>
                                    <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setPassword</methodname>
                <methodparam>
                    <type>const std::string</type> <parameter>password</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type>
                <methodname>setPromptString</methodname>
                <methodparam>
                    <type>const std::string</type> <parameter>prompt</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>Bool_t</type>
                <methodname>Authenticate</methodname>
                <methodparam>
                    <type>CInteractor&amp;</type> <parameter>interactor</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>DisablePrompt</methodname> <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>EnablePrompt</methodname> <void />
            </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            Authenticators of type <classname>CPasswordCheck</classname> assume
            that the credential is a string that must exactly match some passphrase
            string.  The passphrase can be dynamically modified if desired, according
            to the authentication policy of the application.
         </para>
         <para>
            The passphase credential is gotten via an interactor.  It is possible
            to control whether or not the credential is prompted for or not.
            If prompted, it is also possible to control the prompt string.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
           <constructorsynopsis>
                <methodname>CPasswordCheck</methodname>
                <methodparam>
                    <type>const std::string&amp;</type> <parameter>password</parameter>
                </methodparam>
                <methodparam>
                    <type>const std::string</type> <parameter>prompt = std::string("")</parameter>
                </methodparam>
                <methodparam>
                    <type>Bool_t</type> <parameter>WithPrompt = kfFALSE</parameter>
                </methodparam>
            </constructorsynopsis>
            <para>
                Constructor for the password checking authenticator.  The
                <parameter>password</parameter>
                parameter provides the initial password which can be changed
                by later calling the
                <methodname>setPassword</methodname> member function.
                The <parameter>prompt</parameter> and <parameter>WithPrompt</parameter>
                parameters control prompting on the interactor.
                If <parameter>WithPrompt</parameter> is <literal>kfFALSE</literal>,
                no prompting will be done.
                If <parameter>WithPrompt</parameter> is <literal>kfTRUE</literal>,
                <parameter>prompt</parameter> will be used as the prompt string.
            </para>
            <constructorsynopsis>
                <methodname>CPasswordCheck</methodname>
                <methodparam>
                    <type>const CPasswordCheck&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <para>
                Does a copy construction of a
                <classname>CPasswordCheck</classname> object.
                This is a deep copy.
            </para>
            <destructorsynopsis>
                <methodname>~CPasswordCheck</methodname> <void />
            </destructorsynopsis>
            <para>
                Cleans up any storage or other resources allocated by the
                object.
            </para>
            <methodsynopsis>
                <type>CPasswordCheck&amp;</type> <methodname>operator=</methodname>
                <methodparam>
                    <type>const CPassswordCheck&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Assignment operator.  The <parameter>rhs</parameter> object is
                the source (right hand side) of the assignement operator.
                When complete, the object is an identical copy of the
                <parameter>rhs</parameter>.
            </para>
            <methodsynopsis>
                <type>std::string</type> <methodname>getPassword</methodname>
                                         <void /> <modifier>const</modifier>
            </methodsynopsis>
            <para>
                Returns the current passphrase string.
            </para>
            <methodsynopsis>
                <type>std::string</type> <methodname>getPromptString</methodname>
                                         <void /> <modifier>const</modifier>
            </methodsynopsis>
            <para>
                Returns the current prompt string.
            </para>
            <methodsynopsis>
                <type>Bool_t</type> <methodname>getWithPrompt</methodname>
                                    <void /> <modifier>const</modifier>
            </methodsynopsis>
            <para>
                Returns <literal>kfTRUE</literal> if prompting for the passphrase
                is enabled.
                <literal>kfFALSE</literal>
                otherwise.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>setPassword</methodname>
                <methodparam>
                    <type>const std::string</type> <parameter>password</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Changes the passphrase.  Future calls to
                <methodname>Authenticate</methodname> must obtain a credential
                string that matches the new passphrase
                <parameter>password</parameter>
            </para>
            <methodsynopsis>
                <type>void</type>
                <methodname>setPromptString</methodname>
                <methodparam>
                    <type>const std::string</type> <parameter>prompt</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Providses a new prompt string:
                <parameter>prompt</parameter>.  This only matters if prompting
                is enabled.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>Bool_t</type>
                <methodname>Authenticate</methodname>
                <methodparam>
                    <type>CInteractor&amp;</type> <parameter>interactor</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Authenticates, using <parameter>interactor</parameter>
                to obtain the candidate passphrase from the entity
                requesting service.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>DisablePrompt</methodname> <void />
            </methodsynopsis>
            <para>
                Disables passphrase prompting.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>EnablePrompt</methodname> <void />
            </methodsynopsis>
            <para>
                Enables passphrase prompting.  The most recently set value of the
                prompt string will be used with the interactor to prompt for a
                password.
            </para>
      </refsect1>
      <refsect1>
         <title>
            SEE ALSO
         </title>
	 <para>
            <link linkend="manpage.cauthenticator">CAuthenticator(3daq)</link>,
            <link linkend="manpage.cinteractor">CInteractor(3daq)</link>
	 </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.cunixusercheck">
      <refmeta>
         <refentrytitle>CUnixUserCheck</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CUnixUserCheck</refname>
	 <refpurpose>Authenticate against a unix user name and password.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;UnixUserCheck.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CUnixUserCheck</classname></ooclass>
            <constructorsynopsis>
                <methodname>CUnixUserCheck</methodname>
                <void />
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CUnixUserCheck</methodname>
                <methodparam>
                    <type>const std::string&amp;</type> <parameter>usernamePrompt</parameter>
                </methodparam>
                <methodparam>
                    <type>const std::string&amp;</type> <parameter>passwordPrompt</parameter>
                </methodparam>
                <methodparam>
                    <type>Bool_t</type> <parameter>promptUser</parameter>
                </methodparam>
                <methodparam>
                    <type>Bool_t</type> <parameter>promptPassword</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CUnixUserCheck</methodname>
                <methodparam>
                    <type>const CUnixUserCheck&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <methodname>~CUnixUserCheck</methodname> <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>CUnixUserCheck&amp;</type> <methodname>operator=</methodname>
                <methodparam>
                    <type>const CUnixUserCheck&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type> <methodname>getUserPrompt</methodname>
                                    <void />     <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type> <methodname>getPasswordPrompt</methodname>
                                   <void/> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>Bool_t</type> <methodname>getPromptUser</methodname>
                                    <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>Bool_t</type> <methodname>getPromptPassword</methodname>
                        <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>Bool_t</type> <methodname>Authenticate</methodname>
                <methodparam>
                    <type>CInteractor&amp;</type> <parameter>interactor</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setPrompting</methodname>
                <methodparam>
                    <type>Bool_t</type> <parameter>fUserPrompt = kfTrue</parameter>
                </methodparam>
                <methodparam>
                    <type>Bool_t</type> <parameter>fPasswordPrompt = kfTrue</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>SetUserPrompt</methodname>
                <methodparam>
                    <type>const std::string&amp;</type> <parameter>rNewPrompt = std::string("Username: ")</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>SetPasswordPrompt</methodname>
		<methodparam>
                   <type>const std::string&amp;</type> 
		   <parameter>rNewPrompt = std::string("Password: ")</parameter>
	         </methodparam>
            </methodsynopsis>
            
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            Authenticates any user whose encrypted password can be retrieved by
            <function>getpwnam</function>.  The meaning of this may differ depending
            on whether or not NIS is used to do authentication, and may vary
            from operating system to operating system.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
        <constructorsynopsis>
           <methodname>CUnixUserCheck</methodname>
           <void />
       </constructorsynopsis>
        <para>
            Constructs a default
            <classname>CUnixUserCheck</classname>
            object.  The object is construted with both username and password
            prompting enabled with suitable default prompt strings.
            You may modify these prompt strings after construction, as well as
            the prompting behavior.  See below for more information.
        </para>
       <constructorsynopsis>
           <methodname>CUnixUserCheck</methodname>
           <methodparam>
               <type>const std::string&amp;</type> <parameter>usernamePrompt</parameter>
           </methodparam>
           <methodparam>
               <type>const std::string&amp;</type> <parameter>passwordPrompt</parameter>
           </methodparam>
           <methodparam>
               <type>Bool_t</type> <parameter>promptUser</parameter>
           </methodparam>
           <methodparam>
               <type>Bool_t</type> <parameter>promptPassword</parameter>
           </methodparam>
       </constructorsynopsis>
       <para>
            Full bodied construction of a
            <classname>CUnixUserCheck</classname> object.   The username and
            password prompts are provided by <parameter>usernamePrompt</parameter>
            and
            <parameter>passwordPrompt</parameter>
            respectively. While
            <parameter>promptUser</parameter>
            and
            <parameter>promptPassword</parameter>
            control which prompts are acutally emitted.
        </para>
       <constructorsynopsis>
           <methodname>CUnixUserCheck</methodname>
           <methodparam>
               <type>const CUnixUserCheck&amp;</type> <parameter>rhs</parameter>
           </methodparam>
       </constructorsynopsis>
            <para>
                Copy constructor, creates a news object that is identical to
                <parameter>rhs</parameter>
            </para>
       <destructorsynopsis>
           <methodname>~CUnixUserCheck</methodname> <void />
       </destructorsynopsis>
            <para>
                Destroys the object and release any resources that were allocated
                by the object.
            </para>
       <methodsynopsis>
           <type>CUnixUserCheck&amp;</type> <methodname>operator=</methodname>
           <methodparam>
               <type>const CUnixUserCheck&amp;</type> <parameter>rhs</parameter>
           </methodparam>
       </methodsynopsis>
            <para>
                Assigns to the object from the <parameter>rhs</parameter> object.
            </para>
       <methodsynopsis>
           <type>std::string</type> <methodname>getUserPrompt</methodname>
                               <void />     <modifier>const</modifier>
       </methodsynopsis>
            <para>
                Returns the current value of the user name prompt string.
            </para>
       <methodsynopsis>
           <type>std::string</type> <methodname>getPasswordPrompt</methodname>
                              <void/> <modifier>const</modifier>
       </methodsynopsis>
            <para>
                Returns the current value of the password prompt string.
            </para>
       <methodsynopsis>
           <type>Bool_t</type> <methodname>getPromptUser</methodname>
                               <void /> <modifier>const</modifier>
       </methodsynopsis>
            <para>
                Returns <literal>kfTRUE</literal> if the user name prompt
                is enabled, and
                <literal>kfFALSE</literal>
                if the user name prompt is disabled.
            </para>
       <methodsynopsis>
           <type>Bool_t</type> <methodname>getPromptPassword</methodname>
                   <void /> <modifier>const</modifier>
       </methodsynopsis>
            <para>
                Returns <literal>kfTRUE</literal> if the password prompt
                is enabled, and
                <literal>kfFALSE</literal>
                if the username prompt is disabled.
            </para>
       <methodsynopsis>
           <modifier>virtual</modifier> <type>Bool_t</type> <methodname>Authenticate</methodname>
           <methodparam>
               <type>CInteractor&amp;</type> <parameter>interactor</parameter>
           </methodparam>
       </methodsynopsis>
       <para>
            Authenticates the requestor using the
            <parameter>interactor</parameter>
            to obtain a username and password.  Dependig on the state of the
            prompt flags, the username and password may be prompted for with prompt
            strings.  See the constructors and the functions below for more
            on prompt strings.
        </para>
       <methodsynopsis>
           <type>void</type> <methodname>setPrompting</methodname>
           <methodparam>
               <type>Bool_t</type> <parameter>fUserPrompt = kfTrue</parameter>
           </methodparam>
           <methodparam>
               <type>Bool_t</type> <parameter>fPasswordPrompt = kfTrue</parameter>
           </methodparam>
       </methodsynopsis>
            <para>
                If
                <parameter>fUserPrompt</parameter>
                is
                <literal>kfTRUE</literal>,
                the user name is prompted for.  If
                <literal>kfFALSE</literal>,
                the username is read without prompting.
            </para>
            <para>
                If
                <parameter>fPasswordPrompt</parameter>
                is
                <literal>kfTRUE</literal>,
                authentication will prompt for a password. If
                <literal>kfFALSE</literal>,
                the password will be read without prompting.
            </para>
       <methodsynopsis>
           <type>void</type> <methodname>SetUserPrompt</methodname>
           <methodparam>
               <type>const std::string&amp;</type> <parameter>rNewPrompt = std::string("Username: ")</parameter>
           </methodparam>
       </methodsynopsis>
        <para>
            <parameter>rNewPrompt</parameter>
            replaces the user prompt string.  If username prompting is enabled,
            this string will be used as the prompt in future authentications.
        </para>
       <methodsynopsis>
           <type>void</type> <methodname>SetPasswordPrompt</methodname>
	   <methodparam>
              <type>const std::string&amp;</type> 
	      <parameter>rNewPrompt = std::string("Password: ")</parameter>
	   </methodparam>
       </methodsynopsis>
        <para>
            <parameter>rNewPrompt</parameter>
            replaces the current password prompt string.  If password prompting is
            enabled, the new string will be used to prompt for passwords
            in future authentications.
        </para>
      </refsect1>
   </refentry>
    <refentry id="manpage.ctclaccesslistcheck">
      <refmeta>
         <refentrytitle>CTclAccessListCheck</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CTclAccessListCheck</refname>
	 <refpurpose>Authenticate against a Tcl List.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;TclAccessListCheck.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CTclAccessListCheck</classname></ooclass>
            <constructorsynopsis>
                <methodname>CTclAccessListCheck </methodname>
                <methodparam>
                    <type>Tcl_Interp*</type> <parameter>pInterp</parameter>
                </methodparam>
                <methodparam>
                    <type>const std::string&amp;</type> <parameter>rName</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <methodname>~CTclAccessListCheck</methodname>
            </destructorsynopsis>
            <methodsynopsis>
                <type>CTCLVariable*</type> <methodname>getVariable</methodname>
                                           <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>CTCLInterpreter*</type> <methodname>getInterpreter</methodname>
                                              <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>Bool_t</type> <methodname>Authenticate</methodname>
                <methodparam>
                    <type>CInteractor&amp;</type> <parameter>rInteractor</parameter>
                </methodparam>
            </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            This authenticator is intended to be used in conjunction with
            Tcl scripts and Tcl servers.  The authenticator uses a Tcl variable
            that contains a list of  values.  The entity that desires service
            must present one of the values in that list as its credential.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
           <constructorsynopsis>
                <methodname>CTclAccessListCheck </methodname>
                <methodparam>
                    <type>Tcl_Interp*</type> <parameter>pInterp</parameter>
                </methodparam>
                <methodparam>
                    <type>const std::string&amp;</type> <parameter>rName</parameter>
                </methodparam>
            </constructorsynopsis>
            <para>
                Constructs a Tcl Access list authenticator.
                <parameter>pInterp</parameter>
                is the interpreter handle pointer.  This will be wrapped
                in a
                <classname>CTCLInterpreter</classname>
                object.  For more information about
                <classname>CTCLInterpreter</classname>,
                See the
                <link linkend="chapter.tclplus">Tcl++ chapter</link>
                and the
                <link linkend="manpage.CTCLInterpreter">CTCLInterpreter reference page</link>.
            </para>
            <para>
                The <parameter>rName</parameter> parameter is the name of the
                TCL variable that contains the list of allowed credentials. Note that
                the list does not yet need to have been created and, in fact, the
                variable
                <parameter>rName</parameter>
                need not yet exist.  The variable and list only need to exist
                at authentication time.
            </para>
            <destructorsynopsis>
                <methodname>~CTclAccessListCheck</methodname>
            </destructorsynopsis>
            <para>
                Releases any resources allocatd by the authenticator as it's destroyed.
            </para>
            <methodsynopsis>
                <type>CTCLVariable*</type> <methodname>getVariable</methodname>
                                           <void /> <modifier>const</modifier>
            </methodsynopsis>
            <para>
                Returns a pointer to the
                <classname>CTCLVariable</classname>
                that wraps the Tcl variable.  For more information about
                <classname>CTCLVariable</classname>
                objects, see
               <link linkend="chapter.tclplus">Tcl++ chapter</link> and the
                <link linkend="manpage.CTCLVariable">CTCLVariable reference page</link>.
            </para>
            <methodsynopsis>
                <type>CTCLInterpreter*</type> <methodname>getInterpreter</methodname>
                                              <void /> <modifier>const</modifier>
            </methodsynopsis>
            <para>
                Retrieves a pointer to the Tcl Interpreter wrapped in a
                <classname>CTCLInterpreter</classname>
                object.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>Bool_t</type> <methodname>Authenticate</methodname>
                <methodparam>
                    <type>CInteractor&amp;</type> <parameter>rInteractor</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Uses the
                <parameter>rInteractor</parameter>
                to fetch a credential from the requestor.  If the credential is
                a member of the list in the Tcl variable with which the authenticator
                was constructed, this method will return
                <literal>kfTRUE</literal>
                If not,
                <literal>kfFALSE</literal>
            </para>
      </refsect1>
      <refsect1>
         <title>Types and public data</title>
         <para>
            <classname>CTCLInterpreter</classname>
            and
            <classname>CTCLVariable</classname>
            are objects that are part of the Tcl++ library. See the
            <link linkend="chapter.tclplus">Tcl++ chapter</link> of the
            documentation for more information about them.
         </para>
      </refsect1>
   </refentry>
    <refentry id="manpage.caccesslistcheck">
      <refmeta>
         <refentrytitle>CAccessListCheck</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CAccessListCheck</refname>
	 <refpurpose>Authenticate against a list of allowed credentials.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;AccessListCheck.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CAccessListCheck</classname></ooclass>
            <constructorsynopsis>
                <methodname>CAccessListCheck</methodname>
                <void />
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname> CAccessListCheck</methodname>
                <methodparam>
                    <type>const CAccessListCheck::StringMap&amp;</type>
                    <parameter>rSourceMap</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CAccessListCheck</methodname>
                <methodparam>
                    <type>const CAccessListCheck&amp;</type> <parameter>aCAccessListCheck</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <methodname>~CAccessListCheck</methodname>
                <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>CAccessListCheck&amp;</type> <methodname>operator=</methodname>
                <methodparam>
                    <type>const CAccessListCheck&amp;</type> <parameter>aCAccessListCheck</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>StringMap</type> <methodname>getAccessList</methodname>
                                       <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier> virtual</modifier> <type>Bool_t</type> <methodname>Authenticate</methodname>
                <methodparam>
                    <type>CInteractor&amp;</type> <parameter>rInteractor</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>AddAclEntry</methodname>
                <methodparam>
                    <type>const std::string&amp;</type> <parameter>rEntry</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>DeleteAclEntry</methodname>
                <methodparam>
                    <type>const std::string&amp;</type> <parameter>rEntry</parameter>
                </methodparam>
            </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            The
            <classname>CAccessListCheck</classname>
            class implements authentication against one of a set of legal
            credentials.  This is simlar in nature to the
            <link linkend="manpage.ctclaccesslistcheck">CTclAccessListCheck</link>
            class, however the list is stored internally in the class rather than
            in a Tcl variable.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
        <constructorsynopsis>
            <methodname>CAccessListCheck</methodname>
            <void />
        </constructorsynopsis>
        <para>
            Constructs an access listchecking authenticator with an empty
            access control list.  The functions
            <methodname>AddAclEntry</methodname> and
            <methodname>DeleteAclEntry</methodname>
            can be used to maintaint the contents of the access list.
        </para>
        <constructorsynopsis>
            <methodname> CAccessListCheck</methodname>
            <methodparam>
                <type>const CAccessListCheck::StringMap&amp;</type>
                <parameter>rSourceMap</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Creates an access list checking authenticator.
            The initial contents of the access control list are
            <parameter>rSourceMap</parameter>.
            See "Types and public data" below for information about the
            <type>StringMap</type> data tpe.
        </para>
        <constructorsynopsis>
            <methodname>CAccessListCheck</methodname>
            <methodparam>
                <type>const CAccessListCheck&amp;</type> <parameter>aCAccessListCheck</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructs an access list chekcing authenticator. The
            access list is a copy of the one from
            <parameter>aCAccessListCheck</parameter>
        </para>
        <destructorsynopsis>
            <methodname>~CAccessListCheck</methodname>
            <void />
        </destructorsynopsis>
        <para>
            Releases any storage or resources that were allocated by the
            object.
        </para>
        <methodsynopsis>
            <type>CAccessListCheck&amp;</type> <methodname>operator=</methodname>
            <methodparam>
                <type>const CAccessListCheck&amp;</type> <parameter>aCAccessListCheck</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Assigns the current access list authenticator from <parameter>aCAccessListCheck</parameter>
        </para>
        <methodsynopsis>
            <type>CAccessListCheck::StringMap</type> <methodname>getAccessList</methodname>
                                   <void /> <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns a copy of the current access list.  See
            "Types and public data" below for a description of the
            <type>StringMap</type> data type.
        </para>
        <methodsynopsis>
            <modifier> virtual</modifier> <type>Bool_t</type> <methodname>Authenticate</methodname>
            <methodparam>
                <type>CInteractor&amp;</type> <parameter>rInteractor</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Obtains the credentials string from the
            <parameter>rInteractor</parameter>
            and determines if there is match for it in the current
            access control list.
            If there is,
            <literal>kfTRUE</literal>
            is returned.
            If not,
            <literal>kfFALSE</literal>
            is returned.
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier> <type>void</type> <methodname>AddAclEntry</methodname>
            <methodparam>
                <type>const std::string&amp;</type> <parameter>rEntry</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Adds an access control entry to he list.  This is virtual to
            allow derived classes to override how this is done.
            the
            <parameter>rEntry</parameter>
            string is added to the access control list.
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier> <type>void</type> <methodname>DeleteAclEntry</methodname>
            <methodparam>
                <type>const std::string&amp;</type> <parameter>rEntry</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Removes the access control entry
            <parameter>rEntry</parameter>
            from the access control list.
        </para>
      </refsect1>
      <refsect1>
         <title>Types and public data</title>
         <para>
            <type>CAccessListCheck::StringMap</type> contains the access control
            list entries.  This is a type that is defined in the
            <filename>AccessListCheck.h</filename> header as:
            <programlisting>
class CAccessListCheck  : public CAuthenticator        
{                       
public:
  typedef std::set&lt;std::string&gt; StringMap;
...
};
            </programlisting>
         </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.chostlistcheck">
      <refmeta>
         <refentrytitle>CHostListCheck</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CHostListCheck</refname>
	 <refpurpose>Authenticate from a list of TCP/IP hosts</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;HostListCheck.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CHostListCheck</classname></ooclass>
            <constructorsynopsis>
                <methodname>CHostListCheck</methodname>
                <void/>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname> CHostListCheck </methodname>
                 <methodparam>
                     <type>const CHostListCheck&amp;</type> <parameter>aCHostListCheck</parameter>
                 </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <methodname>~CHostListCheck</methodname>
                <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type> CHostListCheck&amp;</type> <methodname>operator=</methodname>
                <methodparam>
                    <type>const CHostListCheck&amp;</type> <parameter>aCHostListCheck</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>Bool_t</type> <methodname>Authenticate</methodname>
                <methodparam>
                    <type>CInteractor&amp;</type> <parameter>rInteractor</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type> Bool_t</type> <methodname>Authenticate</methodname>
                <methodparam>
                    <type>const std::string&amp;</type> <parameter>rHostname</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier> virtual</modifier> <type>void</type> <methodname>AddAclEntry</methodname>
                <methodparam>
                    <type>const std::string&amp;</type> <parameter>rHostname</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>DeleteAclEntry</methodname>
                <methodparam>
                    <type>const std::string&amp;</type> <parameter>rHostname</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>Bool_t</type> <methodname>Authenticate</methodname>
                <methodparam>
                    <type>in_addr</type> <parameter>Address</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>AddIpAddress</methodname>
                <methodparam>
                    <type>in_addr</type> <parameter>Address</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>DeleteIpAddress</methodname>
                <methodparam>
                    <type>in_addr</type> <parameter>address</parameter>
                </methodparam>
            </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            <classname>CHostListCheck</classname> is derived from the
            <link linkend="manpage.caccesslistcheck"><classname>CAccessListCheck</classname></link>.
            The difference between the two classes is that
            <classname>CHostListCheck</classname> maintains an access control list
            made up of internet IP addresses.  The credentials fetched from the
            interactor must be a host name that translates to an IP address, or
            a dotted IP address string that matches an address in the access
            control list.
         </para>
         <para>
            Note that while the class allows users to invoke the
            original set of ACL Maintenance functions, calling these
            produces a warning on stderr.  The preferred way to maintain
            the access control list is via the
            <methodname>AddIpAddress</methodname> and
            <methodname>DeleteIpAddress</methodname> member functions.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
        <constructorsynopsis>
            <methodname>CHostListCheck</methodname>
            <void/>
        </constructorsynopsis>
        <para>
            Creates a
            <classname>CHostListCheck</classname>
            object with an empty access control list.
        </para>
        <constructorsynopsis>
            <methodname> CHostListCheck </methodname>
             <methodparam>
                 <type>const CHostListCheck&amp;</type> <parameter>aCHostListCheck</parameter>
             </methodparam>
        </constructorsynopsis>
        <para>
            Constructs a
            <classname>CHostListCheck</classname>
            object that is an exact copy of
            <parameter>aCHostListCheck</parameter>.
        </para>
        <destructorsynopsis>
            <methodname>~CHostListCheck</methodname>
            <void />
        </destructorsynopsis>
        <para>
            Releases all storage and any other resources that have been allocated
            by the object.
        </para>
        <methodsynopsis>
            <type> CHostListCheck&amp;</type> <methodname>operator=</methodname>
            <methodparam>
                <type>const CHostListCheck&amp;</type> <parameter>aCHostListCheck</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Assigns
            <parameter>aCHostListCheck</parameter>
            to the object. This currently implies a deep copy of all member data.
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier> <type>Bool_t</type> <methodname>Authenticate</methodname>
            <methodparam>
                <type>CInteractor&amp;</type> <parameter>rInteractor</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Fetches a host name or dotted IP address string from
            <parameter>rInteractor</parameter>.
            If the host fetched translates to an IP address that is in the
            access control list, the method returns
            <literal>kfTRUE</literal>
            otherwise,
            <literal>kfFALSE</literal>
            is returned.
            Host names, or addresses that cannot map to IP addresses will naturally
            return
            <literal>kfFALSE</literal>.
        </para>
        <methodsynopsis>
            <type> Bool_t</type> <methodname>Authenticate</methodname>
            <methodparam>
                <type>const std::string&amp;</type> <parameter>rHostname</parameter>
            </methodparam>
        </methodsynopsis>
            <para>
                Same as above, however authentication is done with a host string
                <parameter>rHostname</parameter>
                that is already available to the application.
            </para>
        <methodsynopsis>
            <modifier> virtual</modifier> <type>void</type> <methodname>AddAclEntry</methodname>
            <methodparam>
                <type>const std::string&amp;</type> <parameter>rHostname</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Warns via stderr, that this is not the preferred way to add an IP
            address to the host list, and then adds the string
            <parameter>rHostname</parameter>
            without interpretation to the access control list.
            To fit in with the rest of the class,
            <parameter>rHostname</parameter>
            should be a string of the form
            <literal>0xaaaaaaaa</literal>
            where
            <literal>aaaaaaaa</literal>
            is the IP address in network byte order, with sufficient leading
            zeroes to ensure that there are eight digits.
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier> <type>void</type> <methodname>DeleteAclEntry</methodname>
            <methodparam>
                <type>const std::string&amp;</type> <parameter>rHostname</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Warns the user that this is not the preferred way to manage the
            acdess control list and then deletes
            <parameter>rHostname</parameter>
            from the list if it exists.
            See <methodname>AddAclEntry</methodname> for a discussion of the
            correct form of Acl entries.
        </para>
        <methodsynopsis>
            <type>Bool_t</type> <methodname>Authenticate</methodname>
            <methodparam>
                <type>in_addr</type> <parameter>Address</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Authenticates given the IP address
            <parameter>Address</parameter>
            in network byte order.
        </para>    
        <methodsynopsis>
            <type>void</type> <methodname>AddIpAddress</methodname>
            <methodparam>
                <type>in_addr</type> <parameter>Address</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Adds an IP address to the access control list.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>DeleteIpAddress</methodname>
            <methodparam>
                <type>in_addr</type> <parameter>address</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Removes an IP address from the access control list.
        </para>
      </refsect1>
      <refsect1>
         <title>Types and public data</title>
         <para>
            In all cases <type>in_addr</type> is the IP address in
            <firstterm>network byte order</firstterm>.
         </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.cinteractor">
      <refmeta>
         <refentrytitle>CInteractor</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CInteractor</refname>
	 <refpurpose>Base class for security interactions.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;Interactor.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CInteractor</classname></ooclass>
            <constructorsynopsis>
                <methodname>CInteractor</methodname>
                <void />
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CInteractor</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CInteractor&amp;</type> <parameter>aCInteractor</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~CInteractor</methodname>
                    <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>CInteractor&amp;</type>
                <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>CInteractor&amp;</type>
                    <parameter>aCInteractor</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>int</type>
                <methodname>Read</methodname>
                <methodparam>
                    <type>UInt_t</type> <parameter>nBytes</parameter>
                </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>pData</parameter>
                </methodparam>
                <modifier> = 0</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>int</type> <methodname>Write</methodname>
                <methodparam>
                    <type>UInt_t</type> <parameter>nbytes</parameter>
                </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>pData</parameter>
                </methodparam>
                <modifier> = 0 </modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>int</type> <methodname>ReadWithPrompt</methodname>
                <methodparam>
                    <type>UInt_t</type> <parameter>nPromptSize</parameter>
                </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>pPrompt</parameter>
                </methodparam>
                <methodparam>
                    <type>UInt_t</type> <parameter>nReadSize</parameter>
                </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>pReadData</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type> <methodname>Flush</methodname>
                                    <void />
            </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            <classname>CInteractor</classname> is an abstract base class for the
            objects that authentication objects use to acquire credentials
            from clients.  The class provides a set of interfaces
            that all concrete interactor classes must implement.
         </para>
         <para>
            In one sense, the
            <classname>CInteractor</classname> hierarchy models obtaining
            credentials from a client as operations on a bi-directional byte stream.
            <methodname>Read</methodname>, and <methodname>Write</methodname> methods
            allow the application to read and write data from the credential.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
        <constructorsynopsis>
            <methodname>CInteractor</methodname>
            <void />
        </constructorsynopsis>
        <para>
            Place holder for constructors.
        </para>
        <constructorsynopsis>
            <methodname>CInteractor</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CInteractor&amp;</type> <parameter>aCInteractor</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Place holder for copy constructors.
        </para>
        <destructorsynopsis>
            <modifier>virtual</modifier> <methodname>~CInteractor</methodname>
                <void />
        </destructorsynopsis>
        <para>
            Establishes destructor chaining through the class hierarchy.
        </para>
        <methodsynopsis>
            <type>CInteractor&amp;</type>
            <methodname>operator=</methodname>
            <methodparam>
                <modifier>const</modifier>
                <type>CInteractor&amp;</type>
                <parameter>aCInteractor</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Declares the intent of the class hierarchy to offer an assignment
            operator.
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier>
            <type>int</type>
            <methodname>Read</methodname>
            <methodparam>
                <type>UInt_t</type> <parameter>nBytes</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>pData</parameter>
            </methodparam>
            <modifier> = 0</modifier>
        </methodsynopsis>
        <para>
            Interface declaration for reading data from the interactor.
            <parameter>nBytes</parameter>
            is the number of bytes to attempt to read.
            <parameter>pData</parameter>
            Is a pointer to an output buffer into which the data will be read.
            The method is supposed to return the number of bytes that were
            actually read into <parameter>pData</parameter>.
            This may be no more than
            <parameter>nBytes</parameter>.
            In general, negative values indicate an error, and
            zero indicates that there is no data to read.
        </para>
            
        <methodsynopsis>
            <modifier>virtual</modifier> <type>int</type> <methodname>Write</methodname>
            <methodparam>
                <type>UInt_t</type> <parameter>nbytes</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>pData</parameter>
            </methodparam>
            <modifier> = 0 </modifier>
        </methodsynopsis>
        <para>
            Provides the interface for a method to write data to the interactor.
            <parameter>nbytes</parameter> is the number of bytes to write, while
            <parameter>pData</parameter> points to a buffer from which the
            data are written.
            The return value is the number of bytes actually written.
            This will be negative for errors, zero if no data could be written,
            and some number that is at most
            <parameter>nbytes</parameter>
            if data transfer took place.
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier> <type>int</type> <methodname>ReadWithPrompt</methodname>
            <methodparam>
                <type>UInt_t</type> <parameter>nPromptSize</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>pPrompt</parameter>
            </methodparam>
            <methodparam>
                <type>UInt_t</type> <parameter>nReadSize</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>pReadData</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            A convenienece method for first writing a prompt string and then
            reading a response from the interactor.
            <parameter>nPromptSize</parameter>
            and <parameter>pPrompt</parameter>
            describe the prompt string and
            <parameter>nReadSize</parameter>
            and
            <parameter>pReadData</parameter>
            the input buffer for the response.
            The method is supposed to return the number of bytes read from the
            interactor.  This will be have values like those of
            the
            <methodname>Read</methodname> method.
        </para>
        <para>
            The default implementation is a write followed by a read.
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier> <type>void</type> <methodname>Flush</methodname>
                                <void />
        </methodsynopsis>
        <para>
            This member function supports flushing any output buffered in the
            interactor.  The default implementation does nothing which is suitable
            for unbuffered interactors.
        </para>
      </refsect1>
   </refentry>
    <refentry id="manpage.cstringinteractor">
      <refmeta>
         <refentrytitle>CStringInteractor</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CStringInteractor</refname>
	 <refpurpose>Provide an interactor that processes strings.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CStringInteractor.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CStringInteractor</classname></ooclass>
            <constructorsynopsis>
                <methodname>CStringInteractor</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>std::string&amp;</type> <parameter>am_sString</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CStringInteractor</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CStringInteractor&amp;</type> <parameter>aCStringInteractor</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <methodname>~CStringInteractor</methodname>
                <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CStringInteractor&amp;</type> <parameter>aCStringInteractor</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type> <methodname>getString</methodname>
                                         <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>getReadCursor</methodname>
                                 <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>Rewind</methodname>
                                  <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>int</type> <methodname>Read</methodname>
                <methodparam>
                    <type>UInt_t</type> <parameter>nBytes</parameter>
                </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>pBuffer</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>int</type> <methodname>Write</methodname>
                <methodparam>
                    <type>UInt_t</type> <parameter>nBytes</parameter>
                </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>pBuffer</parameter>
                </methodparam>
            </methodsynopsis>
 
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            String interactors allow you to treat strings gotten by whatever means
            as sources for interactors.  Note that writes to a string interactor
            are not errors, they just don't do anything.  This makes string interactors
            behave consistently if used as interactive entitites.
         </para>
	 <para>
	    While string interactors behave exactly like any other interactor,
	    they have additional member functions that recognize their string
	    nature.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <constructorsynopsis>
                <methodname>CStringInteractor</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>std::string&amp;</type> <parameter>am_sString</parameter>
                </methodparam>

            </constructorsynopsis>
		<para>
		   Constructs a string interactor given a string
		   <parameter>am_sString</parameter>. The string
                   will be the data 'read' by the interactor.
		</para>
            <constructorsynopsis>
                <methodname>CStringInteractor</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CStringInteractor&amp;</type> <parameter>aCStringInteractor</parameter>
                </methodparam>
	
            </constructorsynopsis>
		<para>
		   Constructs a string interactor that is an exact state
		   duplicate of 
		   <parameter>aCStringInteractor</parameter>.
		   The duplication extends not only to the string but to the
		   position within the string from which data will be returned
		   to satisfy read operations (the cursor).
		</para>	
            <destructorsynopsis>
                <methodname>~CStringInteractor</methodname>
                <void />
            </destructorsynopsis>
	    <para>
	       Releases all storage and resources required by the
	       interactor prior to its finaly destruction.
	    </para>
            <methodsynopsis>
                <type>int</type> <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CStringInteractor&amp;</type> <parameter>aCStringInteractor</parameter>
                </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
	    <para>
	       Assignment operator.  The object will become an exact duplicate
	       of the <parameter>aCStringInteractor</parameter>.
	       This duplication extends to the cursor.
	    </para>
            <methodsynopsis>
                <type>std::string</type> <methodname>getString</methodname>
                                         <void /> <modifier>const</modifier>
            </methodsynopsis>
	    <para>
	       Informational method that returns the full string managed by
	       the interactor.
            </para>
            <methodsynopsis>
                <type>int</type> <methodname>getReadCursor</methodname>
                                 <void /> <modifier>const</modifier>
            </methodsynopsis>
	    <para>
	       Informational method that returns the read cursor.  The read
	       is the offset into the string managed by the interactor from
	       which the next read will be satisfied.  If, for example,
	       an interactor <varname>*interactor</varname>
	       was constructed on the string
		   <varname>astring</varname>,
	       the first character of the next read will be
               <varname>astring[interactor->getReadCursor()]</varname>
	    </para>
            <methodsynopsis>
                <type>void</type> <methodname>Rewind</methodname>
                                  <void />
            </methodsynopsis>
	    <para>
	       Resets the read  cursor to zero, allowing the string to be
		   re-read.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>int</type> <methodname>Read</methodname>
                <methodparam>
                    <type>UInt_t</type> <parameter>nBytes</parameter>
                </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>pBuffer</parameter>
                </methodparam>
            </methodsynopsis>
	    <para>
	       Returns data from the string.  At most
		   <parameter>nBytes</parameter>
	       of data are read beginning at the read cursor.  If there are
		   fewer, than <parameter>nBytes</parameter> of data left in
		   the string, the entire remainder of the string is read.
		   The data is copied from the string to 
		   <parameter>pBuffer</parameter>.
		   The number of bytes actually read is returned as the
		   method's function value.
	    </para>
	    <para>
	       After the read has been completed, the read cursor is advanced
	       by the number of bytes returned.  If there are no more bytes
		   available in the string, the function will return
		   <literal>0</literal> and no data will be transfered to 
		   <parameter>pBuffer</parameter>
	    </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>int</type> <methodname>Write</methodname>
                <methodparam>
                    <type>UInt_t</type> <parameter>nBytes</parameter>
                </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>pBuffer</parameter>
                </methodparam>
            </methodsynopsis>
	    <para>
	       This function simply returns the value of
	       <parameter>nBytes</parameter>.  This simulates successful
	       completion of the write, although no data will actually be
		   transferred.
	   </para>
 
      </refsect1>
      <refsect1>
         <title>EXAMPLES</title>
         <para>
	    This example shows how to determine that an interactor is a string
	    interactor and if so, rewind it:
         </para>
	 <example>
	    <title>Calling <classname>CStringInteractor</classname> specific
         members</title>
	     <programlisting>
CInteractor*       pAnInteractor = getInteractor();
...
CStringIteractor*  pString       =
         dynamic_cast&lt;CStringInteractor*&gt;(pAnInteractor);
if (pString) {
   pString->Rewind(); 
}
	     </programlisting>
	  </example>
      </refsect1>
   </refentry>
   <refentry id="manpage.cfdinteractor">
      <refmeta>
         <refentrytitle>CFdInteractor</refentrytitle>
	 <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CFdInteractor</refname>
	 <refpurpose>Interact with  file descriptor</refpurpose>
      </refnamediv>
      <refsynopsisdiv>
         <programlisting>
#include &lt;FdInteractor.h&gt;
         </programlisting>
	 <classsynopsis>
	   <ooclass><classname>CFdInteractor</classname></ooclass>
	   <constructorsynopsis>
	      <methodname>CFdInteractor</methodname>
	      <methodparam>
	         <type>int</type> <parameter>fd</parameter>
	      </methodparam>
           </constructorsynopsis>
	   <constructorsynopsis>
	      <methodname>CFdInteractor</methodname>
	      <methodparam>
	         <modifier>const</modifier> <type>CFdInteractor&amp;</type>
		 <parameter>rhs</parameter>
	      </methodparam>
           </constructorsynopsis>
	   <methodsynopsis>
	      <type>CFdInteractor&amp;</type>
                   <methodname>operator=</methodname>
	      <methodparam>
	         <modifier>const</modifier>
		 <type>CFdInteractor&amp;</type> <parameter>rhs</parameter>
               </methodparam>
           </methodsynopsis>
	   <methodsynopsis>
	      <type>int</type> <methodname>getFd</methodname>
	      <void /> <modifier>const</modifier>
	   </methodsynopsis>
	   <methodsynopsis>
	      <type>int</type> <methodname>Read</methodname>
	      <methodparam>
	         <type>UInt_t</type> <parameter>nBytes</parameter>
              </methodparam>
	      <methodparam>
	         <type>void*</type> <parameter>pBuffer</parameter>
             </methodparam>
           </methodsynopsis>
	   <methodsynopsis>
	      <type>int</type> <methodname>Write</methodname>
	      <methodparam>
	         <type>UInt_t</type> <parameter>nBytes</parameter>
             </methodparam>
	     <methodparam>
                 <type>void*</type> <parameter>pData</parameter>
             </methodparam>
           </methodsynopsis>
	   <methodsynopsis>
	      <type>void</type> <methodname>Flush</methodname>
	      <void />
           </methodsynopsis>
	</classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>DESCRIPTION</title>
	 <para>
	    The <classname>CFdInteractor</classname> is an interactor that
	    accepts and, if requested, provides data to anything that can be
	    represented by a file descriptor.   Reads and writes 
	    go directly to the file descriptor, the only buffering that is
	    done is what is done by whatever handles the file descriptor at the
	    operating system level.
         </para>
      </refsect1>
      <refsect1>
         <title>PUBLIC MEMBER FUNCTIONS</title>
	   <constructorsynopsis>
	      <methodname>CFdInteractor</methodname>
	      <methodparam>
	         <type>int</type> <parameter>fd</parameter>
	      </methodparam>
           </constructorsynopsis>
	   <para>
	     Construct an object of this class connected to the
	     file descriptor <parameter>fd</parameter>.
           </para>
	   <constructorsynopsis>
	      <methodname>CFdInteractor</methodname>
	      <methodparam>
	         <modifier>const</modifier> <type>CFdInteractor&amp;</type>
		 <parameter>rhs</parameter>
	      </methodparam>
           </constructorsynopsis>
	   <para>
	      Constructs a copy of the file descriptor
	      <parameter>rhs</parameter>.  The underlying file descriptor
	      is duped so that the original one can be closed without 
	      affecting the copy.
	   </para>
	   <methodsynopsis>
	      <type>CFdInteractor&amp;</type>
                   <methodname>operator=</methodname>
	      <methodparam>
	         <modifier>const</modifier>
		 <type>CFdInteractor&amp;</type> <parameter>rhs</parameter>
               </methodparam>
           </methodsynopsis>
	   <para>
	      Assigns to this from the <parameter>rhs</parameter>.
	      The existing file descriptor is closed, and the file descriptor
	      associted with <parameter>rhs</parameter> is duped so that
	      actions by this object will be independent of those of the 
	      <parameter>rhs</parameter>
           </para>
	   <methodsynopsis>
	      <type>int</type> <methodname>getFd</methodname>
	      <void /> <modifier>const</modifier>
	   </methodsynopsis>
	   <para>
	       This informational member returns the file descriptor associated
	       with the object.
	   </para>
	   <methodsynopsis>
	      <type>int</type> <methodname>Read</methodname>
	      <methodparam>
	         <type>UInt_t</type> <parameter>nBytes</parameter>
              </methodparam>
	      <methodparam>
	         <type>void*</type> <parameter>pBuffer</parameter>
             </methodparam>
           </methodsynopsis>
            <para>
              Attempts to read
              <parameter>nBytes</parameter> of data from the file into
              <parameter>pBuffer</parameter>.  The actual number of bytes read
                is returned as the value of the method.  If <literal>0</literal>
                is returned, the fd has hit an eof or is in non-blocking mode with
                no data ready to be read.  If negative, an error condition
                exists and the reason for the error will be in the global
                variable/macro <varname>errno</varname>
            </para>
	   <methodsynopsis>
	      <type>int</type> <methodname>Write</methodname>
	      <methodparam>
	         <type>UInt_t</type> <parameter>nBytes</parameter>
             </methodparam>
	     <methodparam>
                 <type>void*</type> <parameter>pData</parameter>
             </methodparam>
           </methodsynopsis>
           <para>
                Attempts to write
                <parameter>nBytes</parameter>
                of data from <parameter>pData</parameter>
                to the file.  The actual number of bytes of data written are
                returned to the caller.  If an error has occured, the result will
                be negative.  If the result is zero, likely the file descriptor
                is open in non=blocking mode,  but cannot now be written to
                (e.g. it's a pipe without a reader).
            </para>
	   <methodsynopsis>
	      <type>void</type> <methodname>Flush</methodname>
	      <void />
           </methodsynopsis>
           <para>
                Flushes any buffered output to the file.  In practice this
                does nothing for file descriptors.
           </para>
       </refsect1>
   </refentry>
    <refentry id="manpage.ciointeractor">
      <refmeta>
         <refentrytitle>CIOInteractor</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CIOInteractor</refname>
	 <refpurpose>Separate prompt and input interactors.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;IOInteractor.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CIOInteractor</classname></ooclass>
            <constructorsynopsis>
                <methodname>CIOInteractor</methodname>
                <methodparam>
                    <type>CInteractor&amp;</type> <parameter>rInput</parameter>
                </methodparam>
                <methodparam>
                    <type>CInteractor&amp;</type> <parameter>rOutput</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier>
                <methodname>~CIOInteractor</methodname> <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>CInteractor*</type>
                <methodname>getOutput</methodname>
                <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>CInteractor*</type>
                <methodname>getInput</methodname>
                <void />
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>int</type> <methodname>Read</methodname>
                <methodparam>
                    <type>UInt_t</type> <parameter>nBytes</parameter>
                </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>pBuffer</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>int</type> <methodname>Write</methodname>
                <methodparam>
                    <type>UInt_t</type> <parameter>nBytes</parameter>
                </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>pBuffer</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type>
                <methodname>Flush</methodname> <void />
            </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            This class models an interactor that is made up of a read-only and
            a write-only interactor.  Prompt/written data goes to the write-only
            interactor while reads go to the read-only interactor.
            A sample usage would be for an interactive application where
            the output interactor would be a
            <classname>CFdInteractor</classname>
            connected to <literal>stdout</literal>,
            and the input interactor
            <classname>CFdInteractor</classname>
            connected to <literal>stdin</literal>
         </para>
         <para>
            Note that this class has no copy constructor as it is not possible
            to ensure that all iteractor classes now and in the future will
            have copy constructors.  In most cases, this is not a restriction.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <constructorsynopsis>
                <methodname>CIOInteractor</methodname>
                <methodparam>
                    <type>CInteractor&amp;</type> <parameter>rInput</parameter>
                </methodparam>
                <methodparam>
                    <type>CInteractor&amp;</type> <parameter>rOutput</parameter>
                </methodparam>
            </constructorsynopsis>
            <para>
                Constructs the interactor,
                <parameter>rInput</parameter>
                is the interactor that will be used to get the input credentials.
                <parameter>rOutput</parameter>
                the interator to which prompts will be sent.
            </para>
            <methodsynopsis>
                <type>CInteractor*</type>
                <methodname>getOutput</methodname>
                <void /> <modifier>const</modifier>
            </methodsynopsis>
            <para>
                Informational function that returns a pointer to the output
                interactor used to construct this object.
            </para>
            <methodsynopsis>
                <type>CInteractor*</type>
                <methodname>getInput</methodname>
                <void />
                <modifier>const</modifier>
            </methodsynopsis>
            <para>
                Informational function that returns a pointer to the input
                interactor used to construct this object.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>int</type> <methodname>Read</methodname>
                <methodparam>
                    <type>UInt_t</type> <parameter>nBytes</parameter>
                </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>pBuffer</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Attempts to read
                <parameter>nBytes</parameter>
                from the input interactor into the buffer pointed to by
                <parameter>pBuffer</parameter>.  The return value is determined
                by the type of the actual interactor, but generally is the actual
                number of bytes read.  Usually a negative value indicates an error
                condition of some sort, and a zero indicates there is no data
                to be read, either because the end of the data source has been
                reached or because the input source is a non-blocking entity.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>int</type> <methodname>Write</methodname>
                <methodparam>
                    <type>UInt_t</type> <parameter>nBytes</parameter>
                </methodparam>
                <methodparam>
                    <type>void*</type> <parameter>pBuffer</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Writes
                <parameter>nBytes</parameter> of data from
                <parameter>pBuffer</parameter>
                to the output interactor.
                The return value depends on the actual interactor.
                Usually negative values indicate an error,
                zero usually indicates output to a non-blocking entity that
                is not able to accept output at that time, and values
                less than
                <parameter>nBytes</parameter>
                represent devices with some blocking/buffering
                factor that has been
                exceeded by the write.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type>
                <methodname>Flush</methodname> <void />
            </methodsynopsis>
            <para>
                Flushes data in output buffes the output interactor may have.
            </para>

      </refsect1>
   </refentry>


<refentry id="manpage.CTCLApplication">
    <refmeta>
        <refentrytitle>CTCLApplication 3</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLApplication</refname>
        <refpurpose>
            Base class for TCL/Tk applications.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <programlisting>
#include &lt;tcl.h&gt;
#include &lt;TCLApplication.h&gt;
...
class CTCLApplication  : public CTCLInterpreterObject
{
public:
  CTCLApplication ();
  ~CTCLApplication ( );
  virtual   int operator() ()  =0;
};
        </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <classname>CTCLApplication</classname> is an abstract base class
            that facilitates the creation of applications that extend the
            Tcl interpreter.  The `main program' of SpecTcl is derived from
            this class, for example.
        </para>
        <para>
            Initializing a Tcl application generallly consists of a bunch
            of boilerplate that initializes the interpreter, and then a bunch
            of application specific code to register extensions to the interpreter.
            <classname>CTCLApplication</classname>
            provides the main boilerplate.  It is expected that you
            derive a class from
            <classname>CTCLApplication</classname>
            Implement <function>operator()</function> to register
            application specific commands, and then create exactly one
            instance of your application class named, and a global pointer
            to that object named gpTCLApplication.
        </para>
        <para>
            For example, suppose you have created a class named MyTclApp:
            <programlisting>
// This code is at the global level:
...
MyTclApp app;                              // Makes an instance of this
CTCLApplication* gpTCLApplication = &amp;app;  // Pointer expected by framework.
...
            </programlisting>
            Will ensure that the <function>operator()</function> of your
            application object will be called with the interpreter already
            initialized.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            <type>int</type> <function>operator()</function>()
        </para>
        <para>
            This function is pure virtual and must be overridden by your
            derived class.  <function>operator()</function> is expected to
            install all required extensions to the interprter and return to it
            to start the main event loop.  The return value from this should be
            <literal>TCL_OK</literal> if the application was successfully initialized
            or <literal>TCL_ERROR</literal> if the program encountered an error that
            should prevent the interpreter main loop from starting
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
        CTCLInterpreter, CTCLInterpreterObject, CTCLObjectProcessor, CTCLVariable
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLException">
    <refmeta>
        <refentrytitle>CTCLException</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLException</refname>
        <refpurpose>
            Class for reporting exceptional conditions in Tcl applications
            via the C++ try/catch mechanism.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLException.h&gt;
...
class CTCLException  : public CTCLInterpreterObject ,public CException
{
public:
  CTCLException (CTCLInterpreter&amp; am_rInterpreter,
                 Int_t am_nReason,
                 const char* pString);
  CTCLException(CTCLInterpreter&amp; am_rInterpreter,
                Int_t am_nReason,
                const std::string&amp; rString);
  CTCLException (const CTCLException&amp; aCTCLException );
  virtual ~CTCLException ( );

  CTCLException operator= (const CTCLException&amp; aCTCLException);
  int operator== (const CTCLException&amp; aCTCLException);

  void AddErrorInfo (const char* pMessage)  ;
  void AddErrorInfo(const std::string&amp; rMessage);
  void AddErrorInfo(const CTCLString&amp; rMessage);

  void SetErrorCode (const char* pMessage,
                     const char* pMnemonic="???",
                     const char* pFacility="TCL",
                     const char* pSeverity="FATAL")  ;
  void SetErrorCode(const std::string rMessage,
                    const std::string &amp;rMnemonic=std::string("???"),
                    const std::string &amp;rFacility=std::string("TCL"),
                    const std::string &amp;rSeverity=std::string("FATAL"));

  virtual   const char* ReasonText () const;
  virtual   Int_t ReasonCode () const  ;
};

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The <classname>CTCLException</classname> class allows you to
            instantiate and throw exceptions that are distinguishable as coming
            from the TCL library and its extensions.   In most cases the
            TclPlus library itself will convert error conditions detected by the
            Tcl API and intantiate and throw an appropriate exception.
        </para>
        <para>
            The following example shows how to execute code that is aware of
            these exceptions.  In this case, the code just reports the error
            message and continues.
            <programlisting>
    try {
        // In here is TclPlus invoking code.
    }
    catch (CTCLException&amp; e) {
        cerr &lt;&lt; "TclPlus error caught: " &lt;&lt; e.ReasonText() &lt;&lt; endl;
    }
            </programlisting>
        </para>
        <para>
            The following example shows a typical code segment that throws a
            <classname>CTCLException</classname>:
                <programlisting>
    int status = Tcl_xxxxxxx(pInterp-&gt;getInterpreter()....); // Some Tcl call.
    if (status != TCL_OK) {
        throw CTCLException(*pInterp, status,
                            "Call to Tcl_xxxxxx returned an error");
    }
                </programlisting>
        </para>
        <para>
            Note that constructing a <classname>CTCLException</classname> object
            incorporates the Tcl result string at the time into the
            text returned by the <function>ReasonText()</function> member function.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLException</function> (<type>CTCLInterpreter</type>&amp; <parameter>rInterpreter</parameter>,
                 <type>Int_t</type> <parameter>nReason</parameter>,
                 const <type>char</type>* <parameter>pString</parameter>);
  <function>CTCLException</function>(<type>CTCLInterpreter</type>&amp; <parameter>rInterpreter</parameter>,
                <type>Int_t</type> <parameter>nReason</parameter>,
                const <type>std::string</type>&amp; <parameter>rString</parameter>);
  <function>CTCLException</function> (const <type>CTCLException</type>&amp; <parameter>aCTCLException</parameter> );
        </programlisting>
        </para>
        <para>
            These construct a <classname>CTCLException</classname>.
            <parameter>rInterpreter</parameter> is a reference to the intepreter that was
            used in the operation that resulted in the error.  The result string of that
            interpreter will be saved as part of the text returned by the
            <function>ReasonText</function> member function.
        </para>
        <para>
            The <parameter>nReason</parameter> is a reason for the exception.  Typically
            this will be <literal>TCL_ERROR</literal> however other error codes can be
            created and used for application specific problems.  This is the value that will
            be returned by the <function>ReasonCode</function> member function.
        </para>
        <para>
            <parameter>rString</parameter> and <parameter>pString</parameter> are intended to provide
            information about the context of the error, and will be incorporated into the
            text strin greturned from <function>ReasonText</function>.
        </para>
        <para>
            <parameter>aCTCLException</parameter> is a reference for the sourc object of
            the copy constructor.
        </para>
        <para>
        <programlisting>
  <type>CTCLException</type> <function>operator=</function> (const <type>CTCLException</type>&amp; <parameter>rhs</parameter>);
  <type>int</type> <function>operator==</function>(const <type>CTCLException</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            These two functions provide a mechanism to assign exceptions and to compare
            them for equality.  <parameter>rhs</parameter> is the object that is the source
            of the assignment or the object to which <varname>this</varname> is being compared.
            Equality is defined as the two exceptions having the same underlying interpreter,
            and same reason text.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>AddErrorInfo</function> (const <type>char</type>* <parameter>pMessage</parameter>)  ;
  <type>void</type> <function>AddErrorInfo</function>(const <type>std::string</type>&amp; <parameter>rMessage</parameter>);
  <type>void</type> <function>AddErrorInfo</function>(const <type>CTCLString</type>&amp; <parameter>rMessage</parameter>);
        </programlisting>
        </para>
        <para>
            These functions are wrapperf ro the API function <function>Tcl_AddErrorInfo</function>
            the <parameter>pMessage</parameter>, and <parameter>rMessage</parameter>
            parameters provide the message that is added to the <parameter>errorInfo</parameter>
            variable.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>SetErrorCode</function> (const <type>char</type>* <parameter>pMessage,</parameter>
                     const <type>char</type>* <parameter>pMnemonic</parameter>=<literal>"???"</literal>,
                     const <type>char</type>* <parameter>pFacility</parameter>=<literal>"TCL"</literal>,
                     const <type>char</type>* <parameter>pSeverity</parameter>=<literal>"FATAL"</literal>)  ;
  <type>void</type> <function>SetErrorCode</function>(const <type>std::string</type> <parameter>rMessage</parameter>,
                    const <type>std::string</type>&amp; <parameter>rMnemonic</parameter>=<type>std::string</type>(<literal>"???"</literal>),
                    const <type>std::string</type>&amp; <parameter>rFacility</parameter>=<type>std::string</type>(<literal>"TCL"</literal>),
                    const <type>std::string</type>&amp; <parameter>rSeverity</parameter>=<type>std::string</type>(<literal>"FATAL</literal>"));
        </programlisting>
        </para>
        <para>
            These function set the <varname>errorCode</varname> Tcl interpreter variable.
            The convention these function support is to set the error code to a list that
            consists of a message (<parameter>pMessage</parameter> and <parameter>rMessage</parameter>,
            mnemonic for the message (<parameter>pMnemonic</parameter> or <parameter>rMnemonic</parameter>, the
            Facility (<parameter>pFacility</parameter> or <parameter>rFacility</parameter>)that is throwing
            the error and the severity (<parameter>pSeverity</parameter> or <parameter>rSeverity</parameter>)
            of the error.
        </para>
        <para>
            <programlisting>
virtual   const <type>char</type>* <function>ReasonText</function> () const;
virtual   <type>Int_t</type> <function>ReasonCode</function> () const  ;
        </programlisting>
        </para>
        <para>
            These two functions are intended for use by exception catch blocks.
            <function>ReasonText</function> provides human readable text that
            describes the exception.  <function>ReasonCode</function> provides a
            numerical code that describes the exception.  Often this just has the
            value <literal>TCL_ERROR</literal>
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
Tcl_AddErrorInfo(3tcl),
Tcl_SetErrorCode(3tcl)
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLInterpreter">
    <refmeta>
        <refentrytitle>CTCLInterpreter</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLInterpreter</refname>
        <refpurpose>
            Encapsulate a Tcl interpreter.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;string&gt;
#include &lt;vector&gt;
#include &lt;TCLInterpreter.h&gt;

class CTCLInterpreter
{
public:
  CTCLInterpreter ();
  CTCLInterpreter (Tcl_Interp* am_pInterpreter  );

  Tcl_Interp* getInterpreter()
  std::string Eval (const char* pScript) ;
  std::string Eval(const CTCLString&amp; rScript);
  std::string Eval(const std::string&amp; rScript);
  std::string EvalFile (const char* pFilename)   ;
  std::string EvalFile(const CTCLString&amp; rFilename);
  std::string EvalFile(const std::string&amp; rFilename);

  std::string GlobalEval (const char* pScript)   ;
  std::string GlobalEval (const CTCLString&amp; rScript) ;
  std::string GlobalEval(const std::string&amp; rScript) ;

  std::string RecordAndEval (const char* pScript, Bool_t fEval=kfFALSE);
  std::string RecordAndEval(const CTCLString&amp; rScript,
                            Bool_t fEval=kfFALSE);
  std::string RecordAndEval(const std::string&amp; rScript,
                            Bool_t fEval = kfFALSE);

  std::string ExprString (const char* pExpression)   ;
  std::string ExprString(const CTCLString&amp; rExpr);
  std::string ExprString(const std::string&amp; rExpr);

  Long_t ExprLong (const char* pExpression)   ;
  Long_t ExprLong (std::string&amp; rExpression);
  Long_t ExprLong (const CTCLString&amp; rExpr);

  DFloat_t ExprDouble (const char* pExpression)   ;
  DFloat_t ExprDouble (const CTCLString&amp; rExpression);
  DFloat_t ExprDouble(const std::string&amp; rExpression);

  Bool_t ExprBoolean (const char*  pExpression)   ;
  Bool_t ExprBoolean (const CTCLString&amp; rExpression);
  Bool_t ExprBoolean(const std::string&amp; rExpression);

  std::string TildeSubst (const char* pFilename) const  ;
  std::string TildeSubst (const CTCLString&amp; rName) const;
  std::string TildeSubst (const std::string&amp; rName) const;
  std::string EvalFile (const char* pFilename)   ;
  std::string EvalFile(const CTCLString&amp; rFilename);
  std::string EvalFile(const std::string&amp; rFilename);

  std::string GlobalEval (const char* pScript)   ;
  std::string GlobalEval (const CTCLString&amp; rScript) ;
  std::string GlobalEval(const std::string&amp; rScript) ;

  std::string RecordAndEval (const char* pScript, Bool_t fEval=kfFALSE);
  std::string RecordAndEval(const CTCLString&amp; rScript,
                            Bool_t fEval=kfFALSE);
  std::string RecordAndEval(const std::string&amp; rScript,
                            Bool_t fEval = kfFALSE);

  std::string ExprString (const char* pExpression)   ;
  std::string ExprString(const CTCLString&amp; rExpr);
  std::string ExprString(const std::string&amp; rExpr);

  Long_t ExprLong (const char* pExpression)   ;
  Long_t ExprLong (std::string&amp; rExpression);
  Long_t ExprLong (const CTCLString&amp; rExpr);

  DFloat_t ExprDouble (const char* pExpression)   ;
  DFloat_t ExprDouble (const CTCLString&amp; rExpression);
  DFloat_t ExprDouble(const std::string&amp; rExpression);

  Bool_t ExprBoolean (const char*  pExpression)   ;
  Bool_t ExprBoolean (const CTCLString&amp; rExpression);
  Bool_t ExprBoolean(const std::string&amp; rExpression);

  std::string TildeSubst (const char* pFilename) const  ;
  std::string TildeSubst (const CTCLString&amp; rName) const;
  std::string TildeSubst (const std::string&amp; rName) const;
  Tcl_Interp* operator-&gt; ();
  operator Tcl_Interp* ();
};



    </programlisting>
    </refsynopsisdiv>


    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <classname>CTCLInterpreter</classname>
            encapsulates a <type>Tcl_Interp*</type> in an object.
            Method invocations on that object provide access to many of the
            Tcl interpreter. See METHODS below for more information about htis.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            <function>CTCLInterpreter () </function>
        </para>
        <para>
            <function>CTCLInterpreter</function> (
                <type>Tcl_Interp</type>* <parameter>pInterp</parameter>)
        </para>
        <para>
            Constructs an interpreter object.  The first form of this
            constructor creates a new <type>Tcl_Interp*</type> using
            <function>Tcl_CreateInterp()</function> and wraps the object
            around it.  All members of the object will operate on that
            newly created interpreter.  The second form, wraps an object
            around <parameter>pInterp</parameter>,
            a previously created <type>Tcl_Interp*</type>.
            Note that in either case on destruction, <function>Tcl_DeleteInterp()</function>
            is called on the wrapped interpreter.
        </para>
        <para>
            <type>Tcl_Interp</type>* <function>getInterpreter</function>()
        </para>
        <para>
            Returns the interpreter that is being wrapped by this object.
            This interpreter can be used as an <parameter>interp</parameter>
            parameter for any <function>Tcl_xxxxxx</function> call in the Tcl
            API.
        </para>
        <para>
            <programlisting>
<type>std::string</type> <function>Eval</function>(<type>const char</type>* <parameter>pScript</parameter>) ;
<type>std::string</type> <function>Eval</function>(<type>const CTCLString</type>&amp; <parameter>rScript</parameter>);
<type>std::string</type> <function>Eval</function>(<type>const std::string</type>&amp; <parameter>rScript</parameter>);
            </programlisting>
        </para>
        <para>
            Evaluates the script passed as a parameter.  The only differences between
            these functions is the form of the script parameter.  Each function will
            return the result of the script.  If there is an error in the script,
            a <classname>CTCLException</classname> will be thrown that will describe
            what happened.  For example:
            <programlisting>
    std::string commands;
    CTCLInterpreter interp;     // New intepreter.
    ...
    // after commands has been built up:

    string result
    try {
        result = interp.Eval(commands);
        cout &lt;&lt; "Eval of " &lt;&lt; commands &lt;&lt; " was "
             &lt;&lt;  result &lt;&lt; endl;
    }
    catch (CTCLException &amp;e) {
        cerr &lt;&lt; "Eval of " &lt;&lt; commands &lt;&lt; " failed: "
             &lt;&lt; e.ReasonText() &lt;&lt; endl;
    }
    // If no exception, result is usable as the output of the eval.

            </programlisting>
        </para>
        <para>
        <programlisting>
  <type>std::string</type> <function>EvalFile</function>(<type>const char</type>* <parameter>pFilename</parameter>)   ;
  <type>std::string</type> <function>EvalFile</function>(<type>const CTCLString</type>&amp; <parameter>rFilename</parameter>);
  <type>std::string</type> <function>EvalFile</function>(<type>const std::string</type>&amp; <parameter>rFilename</parameter>);
        </programlisting>
        </para>
        <para>
            Sources the specified file in and executes it as a script in the interpreter that
            is wrapped by the object.  The only difference between these functions is
            how the name of the file is passed.  The return value is the script result.
            A <classname>CTCLException</classname> will be thrown in the event the script
            reports an error.  See the example in
            <classname>CTCLInterpreter</classname>::<function>Eval</function>
            to see how to catch and report this kind of exception.
        </para>
        <para>
            <programlisting>
  <type>std::string</type> <function>GlobalEval</function>(<type>const char</type>* <parameter>pScript</parameter>);
  <type>std::string</type> <function>GlobalEval</function>(<type>const CTCLString</type>&amp; <parameter>rScript</parameter>);
  <type>std::string</type> <function>GlobalEval</function>(<type>const std::string</type>&amp; <parameter>rScript</parameter>);
            </programlisting>
        </para>
        <para>
            This function evaluates a script at the global level.  Note that
            <classname>CTCLInterpreter</classname>::<function>Eval</function>,
            and <classname>CTCLInterpreter></classname>::<function>EvalFile</function>
            evaluates the script at whatever call level the interpreter is currently
            executing at.
            The only difference between the methods above is how the script is passed.
            The functions all return the interpreter result after the script executes.
            If the script reports an error, a <classname>CTCLException</classname> will
            be thrown.
        </para>
        <para>
            <programlisting>
  <type>std::string</type> <function>RecordAndEval</function> (<type>const char</type>* <parameter>pScript</parameter>,
                       <type>Bool_t</type> <parameter>fEval</parameter>=<literal>kfFALSE</literal>);
  <type>std::string</type> <function>RecordAndEval</function>(<type>const CTCLString</type>&amp; <parameter>rScript</parameter>,
                       <type>Bool_t</type> <parameter>fEval</parameter>=<literal>kfFALSE</literal>);
  <type>std::string</type> <function>RecordAndEval</function>(<type>const std::string</type>&amp; <parameter>rScript</parameter>,
                      <type>Bool_t</type> <parameter>fEval</parameter>=<literal>kfFALSE</literal>);
            </programlisting>
        </para>
        <para>
            Records a script in the Tcl interpreter history and, if <parameter>fEval</parameter>
            is <literal>kfTRUE</literal>, evaluates it as well.  The
            return value is the interpreter result, which is only meaningful if the
            script was evalutated.  If the script reports an error, a
            <classname>CTCLException</classname> is thrown.
        </para>
        <para>
            <programlisting>
  <type>std::string</type> <function>ExprString</function>(<type>const char</type>* <parameter>pExpression</parameter>);
  <type>std::string</type> <function>ExprString</function>(<type>const CTCLString</type>&amp; <parameter>rExpr</parameter>);
  <type>std::string</type> <function>ExprString</function>(<type>const std::string</type>&amp; <parameter>rExpr</parameter>);
            </programlisting>
        </para>
        <para>
            Evaluates an expression (as if with the <command>expr</command>
            Tcl command), and returns the result
            of the evaluation as a string.  If the expression has an error,
            a <classname>CTCLException</classname> will be thrown.
            The only difference between these functions is how the expression is passed.
        </para>
        <para>
            <programlisting>
  <type>Long_t</type> <function>ExprLong</function>(<type>const char</type>* <parameter>pExpression</parameter>)   ;
  <type>Long_t</type> <function>ExprLong</function>(<type>std::string</type>&amp; <parameter>rExpression</parameter>);
  <type>Long_t</type> <function>ExprLong</function>(<type>const CTCLString</type>&amp; <parameter>rExpr</parameter>);
            </programlisting>
        </para>
        <para>
            Evaluates an expression (as if with the <command>expr</command>
            Tcl command).  If the result
            can be converted into an integer, it is returned as a <type>Long_t</type>.
            If the expression either cannot be converted to an integer (e.g. it's a non-numerical
            expression), or if the expression contains an error, a <classname>CTCLException</classname>
            will be
            thrown.
        </para>
        <para>
            <programlisting>
  <type>DFloat_t</type> <function>ExprDouble</function>(<type>const char</type>* <parameter>pExpression</parameter>)   ;
  <type>DFloat_t</type> <function>ExprDouble</function>(<type>const CTCLString</type>&amp; <parameter>rExpression</parameter>);
  <type>DFloat_t</type> <function>ExprDouble</function>(<type>const std::string</type>&amp; <parameter>rExpression</parameter>);
            </programlisting>
        </para>
        <para>
            Evaluates the parameter as an expression (as if with the <command>expr</command> Tcl command).
            If the result can be converted to a floating point value it is returned as
            the function value.  If not, or if there is an error in the expression,
            a <classname>CTCLException</classname> is thrown.
        </para>
        <para>
            <programlisting>
  <type>Bool_t</type> <function>ExprBoolean</function>(<type>const char</type>*  <parameter>pExpression</parameter>)   ;
  <type>Bool_t</type> <function>ExprBoolean</function>(<type>const CTCLString</type>&amp; <parameter>rExpression</parameter>);
  <type>Bool_t</type> <function>ExprBoolean</function>(<type>const std::string</type>&amp; <parameter>rExpression</parameter>);
            </programlisting>
        </para>
        <para>
            Evaluates the parameter as an expression (as if with the <command>expr</command>
            Tcl command).  If the result can be interpreted as a boolean, it is returned
            as the function value.  If not, or if there is an error in the expression,
            a <classname>CTCLException</classname> is thrown.
        </para>
        <para>
            <programlisting>
  <type>std::string</type> <function>TildeSubst</function>(<type>const char</type>* <parameter>pFilename</parameter>) const  ;
  <type>std::string</type> <function>TildeSubst</function>(<type>const CTCLString</type>&amp; <parameter>rName</parameter>) const;
  <type>std::string</type> <function>TildeSubst</function>(<type>const std::string</type>&amp; <parameter>rName</parameter>) const;
            </programlisting>
        </para>
        <para>
            Performs tilde substitution on its parameter.   Tilde substitution means that leading
            &#152; characters are expanded to the current user's home directory path, while
            a leading &#152; followed by a word that is a username will be expanded to the
            home directory path of that user.  The expanded value is returned.
            Note thatthe use of this member is deprecated as the underlying Tcl library
            function is also deprecated.
        </para>
        <para>
        <programlisting>
  <type>Tcl_Interp</type>* <function>operator-&gt;</function>();
  <function>operator Tcl_Interp* </function>();
        </programlisting>
        </para>
        <para>
            These two functions allow objects that are <classname>CTCLInterpreter</classname>
            objects to be treated as if they were <type>Tcl_Interp*</type>'s.
            <function>operator-&gt;</function> supports dereferncing to fields of the
            wrapped interpreter (note that this is now deprecated within Tcl itself).
            <function>operator Tcl_Interp*</function> supports dynamic type conversion from
            a <classname>CTCLInterpreteter</classname> object and a <type>Tcl_Interp*</type>
            pointer.
        </para>
    </refsect1>
    <refsect1>
        <title>DEFECTS</title>
        <para>
            It is not possible to avoid destroying the interpreter when the
            object is destroyed.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
        CTCLException, CTCLApplication, CTCLChannel, CTCLCommandPackage,
        CTCLFileHandler, CTCLList, CTCLObject, CTCLObjectProcessor, CTCLTimer,
        CTCLVariable
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLInterpreterObject">
    <refmeta>
        <refentrytitle>CTCLInterpreterObject  3 </refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLInterpreterObject</refname>
        <refpurpose>
            Base class for objects that are associated with a Tcl Interpreter.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <programlisting>
#include &lt;CTCLInterpreterObject.h&gt;
...
class CTCLInterpreterObject
{
public:
  CTCLInterpreterObject ();
  CTCLInterpreterObject (CTCLInterpreter* pInterp );
  CTCLInterpreterObject (const CTCLInterpreterObject&amp; src );

  CTCLInterpreterObject&amp; operator=
                        (const CTCLInterpreterObject&amp; rhs);
  int operator== (const CTCLInterpreterObject&amp; rhs) const;


  CTCLInterpreter* getInterpreter() const;
  CTCLInterpreter* Bind (CTCLInterpreter&amp; rBinding);
  CTCLInterpreter* Bind (CTCLInterpreter* pBinding);

};


        </programlisting>

    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <classname>CTCLInterpreterObject</classname>
            is a base class for any object that requires a <type>CTCLInterpreter</type>
            (Tcl interpreter) to operate.  Almost  all objects in the Tcl++ library are
            derived from this base class.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            <function>CTCLInterpreterObject()</function>
        </para>
        <para>
            Constructor for an interpreter object that will be bound to an underlying
            interpreter at a later time.  See the <function>Bind</function> functions
            for more information about binding interpreters. More normally, if you
            already have an interpreter you will construct using that interpreter.
        </para>
        <para>
            <function>CTCLInterpreterObject</function>
                       (<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>)
        </para>
        <para>
            Constructs a <classname>CTCLInterpreterObject</classname> given
            that <parameter>pInterp</parameter> is an existing
            interpreter encapsulated in a <classname>CTCLInterpreter</classname>.
        </para>
        <para>
            <function>CTCLInterpreterObject</function>
                    (<type>const CTCLObject</type>&amp; <parameter>src</parameter>)
        </para>
        <para>
            Constructs a new <classname>CTCLInterpreterObject</classname>
            that is an exact copy of <parameter>src</parameter>.
        </para>
        <para>
            <classname>CTCLInterpreterObject</classname>&amp;
            <function>operator=</function>
                (const <type>CTCLInterpreterObjectd</type>&amp; <parameter>rhs</parameter>)
        </para>
        <para>
            Provides a mechanism for assigning a <classname>CTCLInterpreterObject</classname>
            a copy of the <parameter>rhs</parameter> <classname>CTCLInterpreterObject</classname>.
            The return value is just a reference to the left hand side of the assignment.  This
            permits operator chaining.
        </para>
        <para>
            <type>int</type> <function>operator==</function>(
                            const <type>CTCLInterpreterObject</type>&amp; rhs)
        </para>
        <para>
            Compares a <classname>CTCLInterpreterObject</classname> to another
            (<parameter>rhs</parameter>).  If the underlying interpreters are the
            same, the objects are said to be equal and <literal>1</literal> is
            returned.  If not, <literal>0</literal> is returned.
        </para>
        <para>
            <type>CTCLInterpreter</type>* <function>getInterpreter</function>() const
        </para>
        <para>
            Returns a pointer to the underlying <classname>CTCLInterpreter</classname>
            object.  See the <classname>CTCLInterpreter</classname>(3) manpage for
            more information about the services offered by that class.
        </para>
        <para>
            <type>CTCLInterpreter</type>* <function>Bind</function>(
                        <type>CTCLInterpreter</type>&amp; <parameter>rBinding</parameter>
                                                          )
        </para>
        <para>
            <type>CTCLInterpeter</type>* <function>Bind</function>(
                        <type>CTCLInterpreter</type>* <parameter>pBinding</parameter>)
        </para>
        <para>
            Binds the object to a new interpreter.  Typically this will only be
            called when the object was constructed without an initial interpreter.
            This is because most objects really are related to some interpreter and cannot
            be willy-nilly rebound.  The return value is  a pointer to the
            <classname>CTCLInterpreter</classname> the object was previously
            bound to.  This will be <literal>NULL</literal> if the object was not
            initially bound.
        </para>
    </refsect1>
    <refsect1>
        <title>DEFECTS</title>
        <para>
            No <function>operator!=</function> was defined.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
        CTCLInterpreter, CTCLApplication, CTCLChannel, CTCLCommandPackage,
        CTCLFileHandler, CTCLList, CTCLObject, CTCLObjectProcessor, CTCLTimer,
        CTCLVariable
        </para>
    </refsect1>
</refentry>
<refentry id="manpage.CTCLList">
    <refmeta>
        <refentrytitle>CTCLList</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLList</refname>
        <refpurpose>
            Provide access to Tcl List parsing.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <programlisting>
#include &lt;TCLList.h&gt;
...
class CTCLList  : public CTCLInterpreterObject
{

public:
  CTCLList (CTCLInterpreter* pInterp);
  CTCLList (CTCLInterpreter* pInterp, const  char* am_pList  );
  CTCLList (CTCLInterpreter* pInterp, const std::string&amp; rList);
  CTCLList (const CTCLList&amp; aCTCLList );

  CTCLList&amp; operator= (const CTCLList&amp; aCTCLList);
  int operator== (const CTCLList&amp; aCTCLList);
  int operator!= (const CTCLList&amp; aCTCLList);

  const char* getList() const;

  int Split (StringArray&amp; rElements)  ;
  int Split (int&amp; argc, char*** argv);

  const char* Merge (const StringArray&amp; rElements)  ;
  const char* Merge(int argc, char** argv);

};


        </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Tcl Lists are white space separated words.  It is definition of
            words and quoting issues that makes the parsing of lists less than
            straightforward.
        </para>
        <para>
            Fortunately, Tcl provides several list processing functions.  The
            concept of a list and access to list processing functions are
            encapsulated in the <classname>CTCLList</classname> class.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>

<type>CTCLList</type> (<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>);
<type>CTCLList</type> (<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
          const  <type>char</type>* <parameter>pList</parameter>  );
<type>CTCLList</type> (<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
          const <type>std::string</type>&amp; <parameter>rList</parameter>);
<type>CTCLList</type> (const <type>CTCLList</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            These four functions provide various ways to create a <classname>CTCLList</classname>
            object.  The first constructor creates an empty list.  The next two, create a list
            that has an initial value given by either the <literal>NULL</literal>
            terminated string <parameter>pList</parameter>, or the <type>std::string</type>
            object <parameter>rList</parameter>.
            The final constructor creates a list that is a duplicate of the list
            described by the object <parameter>rhs</parameter>.
        </para>
        <para>
            <programlisting>

  <type>CTCLList</type>&amp; <function>operator=</function> (const <type>CTCLList</type>&amp; <parameter>rhs</parameter>);
  <type>int</type> <function>operator==</function> (const <type>CTCLList</type>&amp; <parameter>rhs</parameter>);
  <type>int</type> <function>operator!=</function> (const <type>CTCLList</type>&amp; <parameter>rhs</parameter>);
            </programlisting>
        </para>
        <para>
            These function provide assignment (<function>operator=</function>),
            equality comparison (<function>operator==</function>), and
            inequality comparison (<function>operator!=</function>) with another
            <classname>CTCLList</classname> object, <parameter>rhs</parameter>.
            Assignment is defined as copying the string format of the list.
            Equality comparison is defined as the both interpreter and strings being equal.
            Inequality is defined as !operator==.
        </para>
        <para>
            <programlisting>
  const <type>char</type>* <function>getList()</function> const;
            </programlisting>
        </para>
        <para>
            <function>getList</function> returns an immutable pointer to
            the string rerpesentation of the list.  Note that the const qualfier
            on the pointer means that attempts to dereference the pointer which
            would modify the list result in error messages.  For Example:
            <programlisting>
        CTCLList aList(pInterp, "some list");
        const char* pData = aList.getList();
        *pData = 'S';         // Compiler error!!!!
            </programlisting>
        </para>
        <para>
            <programlisting>
<type>int</type> <function>Split</function> (<type>StringArray</type>&amp; <parameter>rElements</parameter>)  ;
<type>int</type> <function>Split</function> (<type>int</type>&amp; <parameter>argc</parameter>,
           <type>char</type>*** <parameter>argv</parameter>);
            </programlisting>
        </para>
        <para>
            Splits a list up into its component words.   <parameter>relements</parameter>
            is a <type>std::vector&lt;std::string&gt;</type> into which the elements will be split.
            <parameter>argc</parameter> is a reference to an integer into which the
            number of elements will be put. <parameter>argv</parameter> is a pointer to a
            <type>char</type>** into which will be placed a pointer to dynamically
            allocated storage containing a list of <parameter>argc</parameter> pointers
            to the words in the string.  This storage must be released by the caller
            with  <function>Tcl_Free</function>.
            For example:
            <programlisting>
                CTCLList someList(pInterp, someInitialContents);
                ...
                int argc;
                char** argv;
                someList.Split(argc, &amp;argv);
                //
                //  ... do something with the data
                //
                ...
                //
                // Done with the list elements.
                //
                Tcl_Free((char*)argv);
            </programlisting>
        </para>
        <para>
            <programlisting>
const <type>char</type>* <function>Merge</function> (const <type>StringArray</type>&amp; <parameter>rElements</parameter>)  ;
const <type>char</type>* <function>Merge</function>(<type>int</type> argc,
                 <type>char</type>** <parameter>argv</parameter>);
        </programlisting>
        </para>
        <para>
            Merges a bunch of words in to a list.  If necessary, quoting is performed to
            ensure that words that have whitespace or other special characters will be
            correctly formatted into the list. <parameter>rElements</parameter> is a
            <type>std::vector&lt;std::string&gt;</type> of words that will be merged into the
            string.  <parameter>argc</parameter> is a count of the number of words,
            and <parameter>argv</parameter> is a pointer to an array of pointers to the
            words stored as <literal>NULL</literal> terminated strings.
            The return value is the final string representation of the list after the
            merge operation has been performed.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLInterpreter(3),
CTCLInterpreterObject(3),
Tcl_Free(3tcl)
        </para>
    </refsect1>
</refentry>
<refentry id="manpage.CTCLObject">
    <refmeta>
        <refentrytitle>CTCLObject</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLObject</refname>
        <refpurpose>
            Encapsulate Tcl Dual ported objects.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <programlisting>
#include &lt;TCLObject.h&gt;
...
class CTCLObject : public CTCLInterpreterObject
{

public:
  CTCLObject ();
  CTCLObject (Tcl_Obj* am_pObject);
  CTCLObject (const CTCLObject&amp; aCTCLObject );
  virtual  ~CTCLObject ( );

  CTCLObject&amp; operator= (const CTCLObject&amp; aCTCLObject);
  int operator== (const CTCLObject&amp; aCTCLObject) const;

  Tcl_Obj* getObject();
  const Tcl_Obj* getObject() const;

   CTCLObject&amp; operator= (const std::string&amp; rSource)    ;
   CTCLObject&amp; operator= (const char* pSource)    ;
   CTCLObject&amp; operator= (int nSource)    ;
   CTCLObject&amp; operator= (const CTCLList&amp; rList)    ;
   CTCLObject&amp; operator= (double dSource)     ;
   CTCLObject&amp;  operator=(Tcl_Obj* rhs);

  operator std::string ()    ;
  operator int ()    ;
  operator CTCLList ()    ;
  operator double ()    ;

  CTCLObject&amp; operator+= (const CTCLObject&amp; rObject)    ;
  CTCLObject&amp; operator+= (int nItem)    ;
  CTCLObject&amp; operator+= (const std::string&amp; rItem)    ;
  CTCLObject&amp; operator+= (const char* pItem)    ;
  CTCLObject&amp; operator+= (double  Item)    ;

  CTCLObject clone ()    ;

  CTCLObject operator() ()    ;

  CTCLObject   getRange(int first, int last);

  CTCLObject&amp;  concat(CTCLObject&amp; rhs); // Concat lists.
  std::vector&lt;CTCLObject&gt;  getListElements();
  CTCLObject&amp;  setList(std::vector&lt;CTCLObject&gt; elements);
  int          llength();
  CTCLObject   lindex(int index);
  CTCLObject&amp;  lreplace(int first, int count, std::vector&lt;CTCLObject&gt; newElements);

};

        </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Tcl as a scripting language carries a deeply embedded philosophy that
            everything can be treated as a string.  Nonetheless, in many cases,
            entities manipulated by the interpreter are more efficiently manipulated
            when they have other types of internal representations.  For example strings
            which represent floating point numbers in extended computations are more
            efficiently represented directly as <type>float</type> or <type>double</type>
            variables.
        </para>
        <para>
            Tcl uses <firstterm>dual ported</firstterm> objects to capture this efficiently.
            A Tcl object is a thing that has a string representation and at most one
            other typed representation (e.g. list, integer, floating point).  Conversions
            from string to this representation are done once and cached as long as possible,
            so that when an object has been used as a particular type there is essentially
            no additional conversion cost to use it as that type again.
        </para>
        <para>
            While a <type>Tcl_Obj</type> and therefore a <classname>CTCLObject</classname>
            can exist independent of an interpreter, many member functions require the
            object be bound to an interpreter, or they will fail with an assertion failure
            causing the program to abort.  Use the base class <function>Bind</function>
            (<classname>CTCLInterpreterObject</classname>::<function>Bind</function>)
            member to bind the object to an existing interpreter, usually as soon as
            possible.
        </para>
        <para>
            Tcl objects also can be shared with a lazy copy on write scheme so that
            overhead associated with duplicating objects (e.g. when using them as
            parameters to Tcl commands) is minimized.
        </para>
        <para>
            <classname>CTCLObject</classname> exposes an object oriented interface to the
            Tcl dual ported object.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            <programlisting>
  <function>CTCLObject</function> ();
  <function>CTCLObject</function> (<type>Tcl_Obj</type>* <parameter>pObject</parameter>);
  <function>CTCLObject</function> (const <type>CTCLObject</type>&amp; <parameter>rhs</parameter> );
            </programlisting>
        </para>
        <para>
            Constructs a Tcl object wrapped in a <classname>CTCLObject</classname>.
            <parameter>pObject</parameter> is an existing <type>Tcl_Obj</type> pointer that will be wrapped.
            <parameter>rhs</parameter> is an existing <classname>CTCLObject</classname>
            that will be used to create another reference to the same underlying
            object.  Note that in the last two of these forms, a new <type>Tcl_Obj</type>
            is not created.  Instead, <function>Tcl_IncrRefCount</function> is used
            on the previously existing object to mark it as shared.
            All member functions which  modify the underlying object will create a new
            object (copy on write semantics), and decrement the reference count of the
            original object.  Destroying a <classname>CTCLObject</classname> invokes
            <function>Tcl_DecrRefCount</function> on the underlying <type>Tcl_Obj</type>
            object.  This may or may not result in destruction of that underlying object
            depending on the resulting reference count.
        </para>
        <para>
            <programlisting>

  <type>CTCLObject</type>&amp; <function>operator</function>= (const <type>CTCLObject</type>&amp; <parameter>rhs</parameter>);
  <type>int</type> <function>operator==</function> (const <type>CTCLObject</type>&amp; <parameter>rhs</parameter>) const;
            </programlisting>
        </para>
        <para>
            These two members provide assignment and equality comparison for <classname>CTCLObject</classname>
            instances with another object <parameter>rhs</parameter>.  Assignment operates
            efficiently by decrementing the reference count on the prior object,
            incrementing the reference count for <parameter>rhs</parameter>, and
            copying its <type>Tcl_Obj*</type> only.
            Equality comparision is true if the underlying objects have the same string
            representation.
        </para>
        <para>
            <programlisting>
  <type>Tcl_Obj</type>* <function>getObject</function>();
  const <type>Tcl_Obj</type>* <function>getObject</function>() const;
            </programlisting>
        </para>
        <para>
            Retrieves a mutable or immutable pointer to the underlying object.
            If you intend to retain this pointer for longer than the lifetime of the
            <classname>CTCLObject</classname> object from which it comes or longer
            than the lifetime of the execution of the calling function you should
            invoke <function>Tcl_IncrRefCount</function> to mark the object shared
            and prevent its destruction until you no longer need it, at which point
            you should invoke <function>Tcl_DecrRefCount</function>.
        </para>
        <para>
            You should not modify the underlying object as that violates the
            copy on write semantics expected of <type>Tcl_Obj</type> objects.
            Instead, use <function>Tcl_DuplicateObj</function> to create a new
            object (decrementing the reference count of the previous object), and
            modify that one instead.  The following code snippet shows this:
            <programlisting>
        int      len;
        Tcl_Obj* pObject = someObject.getObject();
        string   value   = string(Tcl_GetStringFromObj(pObject, &amp;len));
        value           += "new text";
        pObject          = Tcl_DuplicateObj(pObject); // Split off a new object.
        Tcl_SetStringObj(pObject, (char*)value.c_str(), -1);
            </programlisting>
        </para>
        <para>
            <programlisting>
   <type>CTCLObject</type>&amp; <function>operator=</function> (const <type>std::string</type>&amp; <parameter>rSource</parameter>)    ;
   <type>CTCLObject</type>&amp; <function>operator=</function> (const <type>char</type>* <parameter>pSource</parameter>)    ;
   <type>CTCLObject</type>&amp; <function>operator=</function> (<type>int</type> <parameter>nSource</parameter>)    ;
   <type>CTCLObject</type>&amp; <function>operator=</function> (const <type>CTCLList</type>&amp; <parameter>rList</parameter>)    ;
   <type>CTCLObject</type>&amp; <function>operator=</function> (<type>double</type> <parameter>dSource</parameter>)     ;
   <type>CTCLObject</type>&amp; <function>operator=</function>(<type>Tcl_Obj</type>* <parameter>rhs</parameter>);
            </programlisting>
        </para>
        <para>
            Assigns a new value to the object.  The reference count of the previously
            encapsulated object is decremented and a new object is created into
            which the right hand side value is loaded.  This preserves copy on write
            semantics.  <parameter>rSource</parameter> and <parameter>pSource</parameter> load
            the new object with a string valued entity.  No attempt is made to create another
            representation for the object (yet).
            <parameter>nSource</parameter> loads the object with an integer value and its
            string representation.
            <parameter>rList</parameter> loads the object with a list representation and
            its string representation.
            <parameter>dSource</parameter> loads the object with a double precision floating
            point value and its string representation.  <parameter>rhs</parameter> simply
            copies in the new object pointer and increments its reference count.
        </para>
        <para>
            <programlisting>

  <function>operator std::string</function> ()    ;
  <function>operator int</function> ()    ;
  <function>operator CTCLList</function> ()    ;
  <function>operator double</function> ()    ;
            </programlisting>
        </para>
        <para>
            These function provide implicit and explicit type conversions between
            a <classname>CTCLObject</classname> instance and other types.
            The type conversions attempt to extract the appropriately typed value
            from the underlying object.  If successful, the value is returned.
            On failure, a <classname>CTCLException</classname> is thrown.
            For example:
            <programlisting>
        CTCLObject object = "3.14159";  // String rep.
        object.Bind(pInterp);           // Some of these need an interp.
        double     pi     = object      // (operator double()).
        object            = "george";   // string rep.
        try {
           int trash = object;          // fails.
        }
        catch (CTCLException&amp; e) {
            // this catch block will execute.
        }
            </programlisting>
        </para>
        <para>
            <programlisting>

<type>CTCLObject</type>&amp; <function>operator+=</function> (const <type>CTCLObject</type>&amp; <parameter>rObject</parameter>)    ;
<type>CTCLObject</type>&amp; <function>operator+=</function> (<type>int</type> <parameter>nItem</parameter>)    ;
<type>CTCLObject</type>&amp; <function>operator+=</function> (const <type>std::string</type>&amp; <parameter>rItem</parameter>)    ;
<type>CTCLObject</type>&amp; <function>operator+=</function> (const <type>char</type>* <parameter>pItem</parameter>)    ;
<type>CTCLObject</type>&amp; <function>operator+=</function> (<type>double</type>  <parameter>Item</parameter>)    ;
            </programlisting>
        </para>
        <para>
            Creates the list representation of the underlying object, converts either
            <parameter>rObject</parameter>,
            <parameter>nItem</parameter>,
            <parameter>rItem</parameter>,
            <parameter>pItem</parameter>,
            <parameter>Item</parameter> to its string representation and appends
            it as a list entry to the object.
        </para>
        <para>
            <programlisting>

  <type>CTCLObject</type> <function>clone</function> ()    ;
            </programlisting>
        </para>
        <para>
            A wrapper for <function>Tcl_DuplicateObj</function>.  The object is
            duplicated and its duplicate is returned wrapped by a
            <classname>CTCLOjbect</classname>.
        </para>
        <para>
            <programlisting>

<type>CTCLObject</type> <function>operator()</function> ()    ;
            </programlisting>
        </para>
        <para>
            The object's string representation is compiled by its bound
            interpreter to Tcl byte code and executed as a script by that
            bound interpreter.  Note that the byte code compilation is cached
            so that subsequent invocations of the script will not require
            recompilation unless other references force a different second
            representation on the object (e.g. fetching it as a list).
            The result of the script execution is returned as a new <classname>CTCLObject</classname>
            If script compilation failed, or script execution resulted in an error,
            a <classname>CTCLException</classname> will be thrown describing this.
        </para>
        <para>
            <programlisting>

<type>CTCLObject</type> <function>getRange</function>(<type>int</type> <parameter>first</parameter>,
                   <type>int</type> <parameter>last</parameter>);
            </programlisting>
        </para>
        <para>
            Returns a new object that consists of a subrange of the string representation of
            the original object. <parameter>first</parameter> is the index of the first
            character of the substring returned. <parameter>last</parameter> is the
            index of the last character of the substring. See <function>Tcl_GetRange</function>
            for more information, note however that some values of <parameter>first</parameter>
            or <parameter>last</parameter> will be treated specially, and that the
            underlying string representation operated on is a <firstterm>Unicode</firstterm> string
            for which some characters in some languages may require more than one byte.
        </para>
        <para>
            <programlisting>
<type>CTCLObject</type>&amp;  <function>concat</function>(<type>CTCLObject</type>&amp; <parameter>rhs</parameter>); // Concat lists.
            </programlisting>
        </para>
        <para>
            Concatenates the <parameter>rhs</parameter> as a list element to the object.
            A refrence to the new object is returned.  Copy on write semantics are maintained.
        </para>
        <para>
            <programlisting>
<type>std::vector&lt;CTCLObject&gt;</type>  <function>getListElements</function>();
            </programlisting>
        </para>
        <para>
            Converts the object into its underlying list representation.  The
            elements of the list are loaded into a vector of <classname>CTCLObject</classname>
            objects and returned.  If the underlying string representation does not have
            a valid list representation, (e.g. "{this cannot be converted") a
            <classname>CTCLException</classname> is thrown.
        </para>
        <para>
            <programlisting>
CTCLObject&amp;  setList(std::vector&lt;CTCLObject&gt; elements);
            </programlisting>
        </para>
        <para>
            Loads the object with a string and list representation whose words are
            the appropriately quoted string representation of <parameter>elements</parameter>.
            A reference to the new object is returned.  Copy on write semantics are
            maintained.
        </para>
        <para>
            <programlisting>
<type>int</type> <function>llength()</function>;
            </programlisting>
        </para>
        <para>
            If necessary, converts the object to its list representation and returns the
            number of elements in that list.  If it is not possible to convert the
            string represenation of the object into a valid list, a <classname>CTCLException</classname>
            is thrown.
        </para>
        <para>
            <programlisting>
<type>CTCLObject</type> <function>lindex</function>(<type>int</type> <parameter>index</parameter>);
            </programlisting>
        </para>
        <para>
            If necessary, creates the list representation of the object and returns a
            new object that is element number <parameter>index</parameter> of that list.
            If the object cannot be converted into a list, a <classname>CTCLException</classname>
            is thrown.
        </para>
        <para>
            <programlisting>
<type>CTCLObject</type>&amp; <function>lreplace</function>(<type>int</type> <parameter>first</parameter>,
                    <type>int</type> <parameter>count</parameter>,
                    <type>std::vector&lt;CTCLObject&gt;</type> <parameter>newElements</parameter>);
            </programlisting>
        </para>
        <para>
            If necessary, converts the object to its list representation.  If that conversion
            fails a <classname>CTCLException</classname> is thrown.  The set of elements
            specified by <parameter>first</parameter> and <parameter>count</parameter>,
            are replaced by the words held in the vector <parameter>newElements</parameter>.
            <parameter>newElements</parameter> can, of course, be an empty vector in order
            to remove <parameter>count</parameter> elements starting at <parameter>first</parameter>
            from the list.  A reference to the resulting object is returned.
            Copy on write semantics are enforced.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLException(3),
CTCLInterpreter(3),
CTCLInterpreterObject(3),
Tcl_DecrRefCount(3tcl),
Tcl_DuplicateObj(3tcl),
Tcl_GetRange(3tcl),
Tcl_IncrRefCount(3tcl),
Tcl_NewObj(3tcl),
Tcl_SetStringObj(3tcl)

        </para>
    </refsect1>
</refentry>


<refentry id="manpage.CTCLObjectProcessor">
    <refmeta>
        <refentrytitle>CTCLObjectProcessor</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLObjectProcessor</refname>
        <refpurpose>
            Abstract base class to encapsulate the Tcl object command interface exposed by
            <function>Tcl_CreateObjCommand</function>.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLObjectProcessor.h&gt;
...
class CTCLObjectProcessor : public CTCLInterpreterObject
{
public:
  CTCLObjectProcessor(CTCLInterpreter&amp; interp,
                      std::string      name,
                      bool             registerMe=true);
  virtual ~CTCLObjectProcessor();

  void Register();              // Register command on the interpreter.
  void unregister();            // Unregister command from the interp.
  std::string getName() const;  // Return the name of the object.
  Tcl_CmdInfo getInfo() const;  // Return info about the command.

  virtual int operator()(CTCLInterpreter&amp; interp,
                         std::vector&lt;CTCLObject&gt;&amp; objv) = 0;
  virtual void onUnregister();

};

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Tcl supports the addition of commands to the interpreter.  <classname>CTCLObjectProcessor</classname>
            supports an object oriented encapsulation of this part of the API.
            To add a command to an interpreter, write a subclass of
            <classname>CTCLObjectProcessor</classname>.  This subclass should override
            <function>operator()</function>, and optionally <function>onUnregister</function>.
            to implement the desired behavior for the new command.
        </para>
        <para>
            Create an instance of this new class and invoke its
            <function>Register</function>
            member to add it to the interpreter onto which it is bound.  Whenever a
            script executes the new command that object's
            <function>operator()</function> is invoked to process the command.
            If the interpreter is destroyed, or if the command is ever unregistered,
            the <function>onUnregister</function> function is called to perform any
            required global cleanup.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
<function>CTCLObjectProcessor</function>(<type>CTCLInterpreter</type>&amp; <parameter>interp</parameter>,
                    <type>std::string</type>      <parameter>name</parameter>,
                    <type>bool</type>             <parameter>registerMe</parameter>=<literal>true</literal>);

        </programlisting>
        </para>
        <para>
            Constructs a new command processor.  <parameter>interp</parameter> is the
            interpreter on which the command will be registered when the
            <function>Register</function> member is invoked.
            <parameter>name</parameter> is the name of the command.
            If <parameter>registerMe</parameter> is not supplied or is supplied but is
            <literal>true</literal>, the command will be registered as part of the construction process.
            If <parameter>registerMe</parameter> is supplied and is <literal>false</literal>,
            the command is not immediately added, and <function>Register</function> must
            be called later to incorporate it into the interpreter.
        </para>
        <para>
        <programlisting>
<type>void</type> <function>Register</function>();
<type>void</type> <function>unregister</function>();
        </programlisting>
        </para>
        <para>
            <function>Register</function> incorporates the command into the
            interpreter.  If the command is already registered, a
            <classname>CStateException</classname> is thrown.
        </para>
        <para>
            <function>unRegister</function> removes the command from the interpreter.
            This causes <function>onUnregister</function> to be called.
            if the command is registered at destruction time, destruction implies a call
            to <function>unRegister</function> (and therefore <function>onUnregister</function>).
        </para>
        <para>
        <programlisting>
<type>std::string</type> <function>getName</function>() const;
<type>Tcl_CmdInfo</type> <function>getInfo</function>() const;
        </programlisting>
        </para>
        <para>
            <function>getName</function> returns the name of the command
            that will invoke this object's <function>operator()</function>.
            If the command has been registered, and subsequently renamed at the
            script level, this function will reflect the rename.
        </para>
        <para>
            <function>getInfo</function> returns information about the command
            see <function>Tcl_GetCommandInfo</function> for more information about
            what is returned and what it means.
        </para>
        <para>
        <programlisting>
virtual <type>int</type> <function>operator()</function>(<type>CTCLInterpreter</type>&amp; <parameter>interp</parameter>,
                       <type>std::vector&lt;CTCLObject&gt;</type>&amp; <parameter>objv</parameter>) = 0;
        </programlisting>
        </para>
        <para>
            This pure virtual function must be overridden in concrete object command processors.
            The function is called to execute the command that this object is performing.
            <parameter>interp</parameter> provides a reference to the interpreter on which
            the command is being run. <parameter>objv</parameter> is a reference to a
            <type>std::vector&lt;CTCLObject&gt;</type>.
            Each element of <parameter>objv</parameter> is a <classname>CTCLObject</classname>
            containing a word of the command line that invoked us.
        </para>
        <para>
            The function should return <literal>TCL_OK</literal> on success and
            <literal>TCL_ERROR</literal> on failure.  Other return values are possible
            for e.g. commands that implement new control structures however this is beyond
            the scope of this manpage.  If the command processor wants to make a result
            available to the interpreter, it can create a <classname>CTCLResult</classname>
            object, fill it in and commit it.
        </para>
        <para>
        <programlisting>
virtual void onUnregister();
        </programlisting>
        </para>
        <para>
            This function is called when the interpreter is being destroyed or if the
            command is being unregistered either due to object destruction or a call to
            <function>unregister</function>.  The default behavior is to do nothing, but
            this can be overidden in your derived class if desired.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLCompatibilityProcessor(3),
CTCLInterpreter(3),
CTCLInterpreterObject(3),
CTCLObject(3),
CTCLProcessor(3),
CTCLResult(3),
Tcl_CreateObjCommand(3tcl),
Tcl_GetCommandInfo(3tcl)
        </para>
    </refsect1>
</refentry>


<refentry id="manpage.CTCLVariable">
    <refmeta>
        <refentrytitle>CTCLVariable</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLVariable</refname>
        <refpurpose>
            Encapsulate Tcl interpreter variables.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLVariable.h&gt;

class CTCLVariable  : public CTCLInterpreterObject
{
public:
  CTCLVariable (std::string am_sVariable,  Bool_t am_fTracing  );
  CTCLVariable (CTCLInterpreter* pInterp,
                std::string am_sVariable,  Bool_t am_fTracing  );
  CTCLVariable (const CTCLVariable&amp; aCTCLVariable );

  CTCLVariable&amp; operator= (const CTCLVariable&amp; aCTCLVariable);
  int operator== (const CTCLVariable&amp; aCTCLVariable) const;

  std::string getVariableName() const;
  Bool_t IsTracing() const;

  void setVariableName (const std::string am_sVariable);
  virtual   char*  operator() (char* pName,
                               char* pSubscript,
                               int Flags)  ;

   static  char* TraceRelay (ClientData pObject, Tcl_Interp* pInterpreter,
                             tclConstCharPtr  pName,
                             tclConstCharPtr pIndex,
                             int flags)  ;

  const char* Set (const char* pValue, int flags=TCL_LEAVE_ERR_MSG |
                                                 TCL_GLOBAL_ONLY)  ;
  const char* Set (const char* pSubscript, char* pValue,
                   int flags=TCL_LEAVE_ERR_MSG | TCL_GLOBAL_ONLY)  ;
  const char* Get (int flags=TCL_LEAVE_ERR_MSG | TCL_GLOBAL_ONLY,
                   char* pIndex=0)  ;
  int Link (void* pVariable, int Type)  ;
  void Unlink ()  ;
  int Trace (int flags=TCL_TRACE_READS | TCL_TRACE_WRITES | TCL_TRACE_UNSETS,
             char* pIndex = (char*)kpNULL)  ;

  void UnTrace ()  ;

};
</programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <classname>CTCLVariable</classname> allows an existing or new Tcl interpreter
            variable to be encapsulated so that it can be accessed, traced or linked
            in C++ code.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            <programlisting>
  <function>CTCLVariable</function>(<type>std::string</type> <parameter>sName</parameter>,
             <type>Bool_t</type> <parameter>fTracing</parameter>  );
  <function>CTCLVariable</function> (<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
             <type>std::string</type> <parameter>sName</parameter>,
             <type>Bool_t</type> <parameter>fTracing</parameter>  );
  <function>CTCLVariable</function> (<type>const CTCLVariable</type>&amp; <parameter>aCTCLVariable</parameter> );
            </programlisting>
        </para>
        <para>
            In the first two cases, <parameter>sName</parameter> is the name of the variable
            that will be wrapped by this object.  The variable name can contain namespace
            qualifications as well as indices.  If <parameter>fTracing</parameter> is true,
            the object is set to record that it is tracing the variable.  Normally
            this parameter should be allowed to default to <literal>kfFALSE</literal>,
            and the trace member functions used to set explicit traces.
            For the final form of the constructor (copy constructor),
            <parameter>aCTCLVariable</parameter> is a <classname>CTCLVariable</classname> that
            will be copied into this object.
        </para>
        <para>
            In the first form of the constructor, one must later call the
            <function>Bind</function> function (see CTCLInterpreterObject), to bind
            the variable to a specific interpreter prior to accessing it.
        </para>
        <para>
            <programlisting>
  <type>CTCLVariable</type>&amp; <function>operator=</function>(<type>const CTCLVariable</type>&amp; <parameter>rhs</parameter>);
            </programlisting>
        </para>
        <para>
            Assigns the <parameter>rhs</parameter> object to this one.  A reference to the
            left hand side of the assignment is returned.  The semantics of assignment are
            not that the variable values are assigned, but that the left side of the
            assignment becomes a functional equivalent of <parameter>rhs</parameter>,
            that is it stands for the same object and has the same traces (if any) set.
            Thus, if <parameter>rhs</parameter> wraps the interpreter variable <varname>a</varname>
            and the object on the left side wraps interpreter variable <varname>b</varname>
            after the assignment executes, the left side object will be wrapping
            <varname>a</varname>.
            A reference to the object on the left hand side of the assignment is returned.
        </para>
        <para>
            <programlisting>
  <type>int</type> <function>operator==</function>(<type>const CTCLVariable</type>&amp; <parameter>rhs</parameter>) const;
            </programlisting>
        </para>
        <para>
            Compares this object for functional equality with <parameter>rhs</parameter>.
            Functional equality is defined as the two objects referring to the same
            variable, in the same interpreter, and having traces set on the same
            operations.
        </para>
        <para>
            <programlisting>
  <type>std::string</type> <function>getVariableName</function>() const;
            </programlisting>
        </para>
        <para>
            Returns the name of the Tcl variable that is wrapped by this object.
        </para>
        <para>
            <programlisting>
<type>int</type> <function>Trace</function>(<type>int</type> <parameter>flags</parameter>=<literal>TCL_TRACE_READS | TCL_TRACE_WRITES | TCL_TRACE_UNSETS</literal>,
          <type>char</type>* <parameter>pIndex</parameter> = (<type>char</type>*)<literal>kpNULL</literal>)  ;
<type>void</type> <function>UnTrace</function> ()  ;
<type>Bool_t</type> <function>IsTracing</function>() const;
virtual <type>char</type>*  <function>operator()</function> (<type>char</type>* <parameter>pName</parameter>,
                        <type>char</type>* <parameter>pSubscript</parameter>,
                        <type>int</type> <parameter>Flags</parameter>)  ;
            </programlisting>
        </para>
        <para>
            This set of functions supports variable tracing.  In Tcl, a trace is a function
            that is called when some event of interest occurs on a varialbe.  The possible
            events are read, write, and unset.  To effectively use variable tracing, you
            must create a subclass of <classname>CTCLVariable</classname>, override its
            <function>operator()</function> member to handle the trace and call
            <function>Trace</function> to initiate tracing.
        </para>
        <para>
            The <function>Trace</function> member initiates tracing on the variable.
            <parameter>flags</parameter> describes when the trace should fire.
            See the manpage for <function>Tcl_TraceVar</function> for information about
            the legal flag values.
        </para>
        <para>
            <function>Untrace</function> cancels all traces on the variable represented by
            this object.
        </para>
        <para>
            <function>IsTracing</function> returns <literal>kfTRUE</literal> if tracing
            is being performed on the variable.
        </para>
        <para>
            When a trace fires, the <function>operator()</function> member will be called.
            This is why you must override the <classname>CTCLVariable</classname> base
            class to do anything useful with a trace.  The parameters to the
            call are; <parameter>pName</parameter> is the name of the variable that
            has been traced. <parameter>pSubscript</parameter> is the array subscript in the
            event the trace fires on an array or element of an array, and is
            <literal>NULL</literal> otherwise.  <parameter>Flag</parameter> describes
            why the trace fired.  Again, see the <function>Tcl_TraceVar</function>
            manpage for more information.
            Note that for write traces, the variable has already been set.  Modifying
            the value of the traced variable within a trace function will not fire any
            additional traces.
            The <function>operator()</function> function must return a <literal>NULL</literal>
            pointer if the trace is successful.  It must return a pointer to an error message
            if the trace is not successful.  An example of an unsuccessful trace might be
            a write trace that ensures that only particular values are assigned to the
            variable.
        </para>
        <para>
            <programlisting>
const <type>char</type>* <function>Set</function>(const <type>char</type>* <parameter>pValue</parameter>,
                <type>int</type> <parameter>flags</parameter>=<literal>TCL_LEAVE_ERR_MSG</literal> |
                          <literal>TCL_GLOBAL_ONLY</literal>)  ;
const <type>char</type>* <function>Set</function>(const <type>char</type>* <parameter>pSubscript</parameter>,
               <type>char</type>* <parameter>pValue</parameter>,
               <type>int</type> <parameter>flags</parameter>=<literal>TCL_LEAVE_ERR_MSG</literal> | <literal>TCL_GLOBAL_ONLY</literal>)  ;
            </programlisting>
        </para>
        <para>
            Sets the value of the variable to the string pointed to by <parameter>pValue</parameter>
            The second form of this assumes that the <classname>CTCLVariable</classname>
            represents an array and the <parameter>pSubscript</parameter> parameter
            specifies the subscript of the array that is being set.  The <parameter>flags</parameter>
            parameter is fully documented in the Tcl manpage for Tcl_SetVar
        </para>
        <para>
            <programlisting>
const <type>char</type>* <function>Get</function>(<type>int</type> <parameter>flags</parameter>=<literal>TCL_LEAVE_ERR_MSG</literal> | <literal>TCL_GLOBAL_ONLY</literal>,
              <type>char</type>* <parameter>pIndex</parameter>=<literal>0</literal>)  ;
            </programlisting>
        </para>
        <para>
            Retrieves the current value of a variable.  If the <parameter>pIndex</parameter>
            parameter is supplied, the variable wrapped by <classname>CTCLVariable</classname>
            is assumed to be an array and <parameter>pIndex</parameter> points to the subscript of the
            element to retrieve.  The <parameter>flags</parameter> parameter is fully
            documented in the Tcl_GetVar manpage.  The return value of the function is
            a null terminated character string that is the current value of the variable.
            If the variable does not exist, then a <literal>NULL</literal> is returned.
        </para>
        <para>
            <programlisting>
<type>int</type> <function>Link</function>(<type>void</type>* <parameter>pVariable</parameter>,
         <type>int</type> <parameter>Type</parameter>)  ;
<type>void</type> <function>Unlink</function>()  ;
            </programlisting>
        </para>
        <para>
            <function>Link</function> and <function>Unlink</function> support variable
            linking.  Variable linking is when a Tcl variable is made to track the value
            of a C/C++ variable or C++ member variable of an object.
            <function>Link</function> establishes the link.  <parameter>pVariable</parameter>
            points to the C or C++ variable or member variable to link to this
            <classname>CTCLVariable</classname>.  The <parameter>Type</parameter>
            parameter is one of following values:
            <literal>TCL_LINK_INT</literal>,
            <literal>TCL_LINK_DOUBLE</literal>,
            <literal>TCL_LINK_BOOLEAN</literal>,
            <literal>TCL_LINK_WIDE_INT</literal>, or
            <literal>TCL_LINK_STRING</literal> indicating the type of the variable
            to which <parameter>pVariable</parameter> points.  For all but
            <literal>TCL_LINK_STRING</literal>, <parameter>pVariable</parameter> points
            to a variable of the type indicated, and that variable will be linked.
            for <literal>TCL_LINK_STRING</literal>, <parameter>pVariable</parameter> points
            to a <type>char*</type> which should be initialized to point to <literal>NULL</literal>.
            The Tcl interpreter will use <function>Tcl_Alloc</function> and <function>Tcl_Free</function>
            to maintain a dynamically allocated string pointed to by that pointer which
            reflects the value of the variable.  If the C/C++ program modifies this string,
            it must <function>Tcl_Free</function> the prior value and <function>Tcl_Alloc</function>
            a new value with the new variable value.
        </para>
    </refsect1>
    <refsect1>
        <title>DEFECTS</title>
        <para>
            No <function>operator!=</function> has been defined.
        </para>
        <para>
            There is no protection against multiple links... the most recent link
            for an underlying Tcl variable is the one effective.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
        CTCLInterpreter(3), CTCLInterpreterObject(3),
        Tcl_GetVar(3tcl), Tcl_LinkVar(3tcl), Tcl_SetVar(3tcl), Tcl_TraceVar(3tcl)
        </para>
    </refsect1>
</refentry>
<refentry id="manpage.CTCLProcessor">
    <refmeta>
        <refentrytitle>CTCLProcessor</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLProcessor</refname>
        <refpurpose>
            Provide <parameter>argc</parameter>, <parameter>argv</parameter>
            extension commands to Tcl.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLProcessor.h&gt;
...
class CTCLProcessor : public CTCLInterpreterObject
{
public:
  CTCLProcessor(const std::string sCommand, CTCLInterpreter* pInterp);
  CTCLProcessor(const char*       pCommand, CTCLInterpreter* pInterp);
  virtual ~CTCLProcessor();

  std::string getCommandName() const;

  virtual int operator()(CTCLInterpreter&amp; rInterpreter,
                         CTCLResult&amp;      rResult,
                         int argc, char** argv) = 0;
  virtual void OnDelete();

  void Register();
  void Unregister();

  static  std::string ConcatenateParameters (int nArguments,
                                              char* pArguments[])  ;
  int ParseInt (const char* pString, int* pInteger)  ;
  int ParseInt (const std::string&amp; rString, int* pInteger)

  int ParseDouble (const char* pString, double* pDouble)  ;
  int ParseDouble (const std::string&amp; rString, double* pDouble)

  int ParseBoolean (const char* pString, Bool_t* pBoolean)  ;
  int ParseBoolean (const std::string&amp; rString, Bool_t* pBoolean)

  static int MatchKeyword(std::vector&lt;std::string&gt;&amp; MatchTable,
                          const std::string&amp; rValue,
                          int NoMatch = -1);


};

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <parameter>Do not use this for new commands</parameter>
        </para>
        <para>
            The <classname>CTCLProcessor</classname> provides a compatibility
            interface to the old Tcl style <parameter>argc</parameter>,
            <parameter>argv</parameter> style of command extension.
            New commands should be written using the
            <classname>CTCLObjectProcessor</classname> class instead.
        </para>
        <para>
            To extend the interpreter using this mechanism, you must
            derive a class from <classname>CTCLProcessor</classname> and
            minimally override and implement its
            <function>operator()</function> pure virtual function.  You may optionally
            overrid its <function>OnDelete</function> member as well.
            Having written the class, you must create an object of that class and
            register it on an interpreter.  Once the class is registered,
            invocations of the command under which it was registered will
            invoke your <function>operator()</function>.
        </para>
        <para>
            If the interpreter is destroyed or the object destroyed, or unregistered,
            the <function>OnDelete</function> member will be called.
            <classname>CTCLProcessor</classname> defines and implements this function
            with an empty body, so it is only necessary for you to override and implement
            this if you have some cleanup actions that must be done when the command is
            deleted.
        </para>
        <para>
            This class is now implemented in terms of a <classname>CTCLObjectProcessor</classname>
            derived class called a <classname>CTCLCompatibilityProcessor</classname>. It is
            less efficient to use this class than to use a class derived directly from a
            <classname>CTCLObjectProcessor</classname>.  This class is therefore not
            recommended for use with new extensions, but is only provided for
            compatibility with existing extensions written before
            <classname>CTCLObjectProcessor</classname> was developed.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
<function>CTCLProcessor</function>(const <type>std::string</type> <command>sCommand</command>,
             <type>CTCLInterpreter</type>* <parameter>pInterp</parameter>);
<function>CTCLProcessor</function>(const <type>char</type>*       <parameter>pCommand</parameter>,
             <type>CTCLInterpreter</type>* <parameter>pInterp</parameter>);
        </programlisting>
        </para>
        <para>
            Constructs a <classname>CTCLProcessor</classname>.  <parameter>sCommand</parameter>
            or <parameter>pCommand</parameter> are the initial name of the command.
            Note that the Tcl interpreter supports command renaming at the script level,
            so there is no gaurentee that this will always be the name of the command.
            <parameter>pInterp</parameter> is the interpreter on which the command
            will be registered when the <function>Register</function> function is called.
        </para>
        <para>
        <programlisting>

<type>std::string</type> <function>getCommandName</function>() const;
        </programlisting>
        </para>
        <para>
            Returns the initial name of the command.  Unlike
            <classname>CTCLObjectCommand</classname>::<function>getName</function>()
            this function does not track changes in the command name.
        </para>
        <para>
        <programlisting>

virtual <type>int</type> <function>operator</function>()(<type>CTCLInterpreter</type>&amp; <parameter>rInterpreter</parameter>,
                       <type>CTCLResult</type>&amp; <parameter>rResult</parameter>,
                       <type>int</type> <parameter>argc</parameter>,
                       <type>char</type>** <parameter>argv</parameter>) = 0;
virtual <type>void</type> <function>OnDelete</function>();
        </programlisting>
        </para>
        <para>
            <function>operator()</function> is a pure virtual function and therefore must
            be overidden and implemented in concrete command implementations.
            <parameter>rInterpreter</parameter> is a reference to the interpreter that is
            executing this command. <parameter>rResult</parameter> is a reference to
            a <classname>CTCLResult</classname> object that represents the result of the
            interpreter.  Any text stored into this object will be made available to the
            interpreter as the result of the command. <parameter>argc</parameter>
            and <parameter>argv</parameter> are the number of words on the command line and
            a pointer to an array of pointers to the command words respectively.
        </para>
        <para>
            <function>operator()</function> should be written to return
            <literal>TCL_OK</literal>
            if it is successful and
            <literal>TCL_ERROR</literal>
            if it encounters an error.   Other return values are possible and meaningful
            for commands that implement flow of control structures, but documenting these
            is beyond the scope of this manpage.   See the return(3tcl) manpage for
            more information about these.
        </para>
        <para>
            <function>OnDelete</function> is called whenever the interpreter
            or the object is being
            destroyed, or the object's <function>Unregister</function> function has been
            called.  <classname>CTCLProcessor</classname> provides a default implementation
            for <function>OnDelete</function> which does nothing.  It is only necessary
            to override and implement this function if you require specific action when
            the command is being unregistered.
        </para>
        <para>
        <programlisting>
<type>void</type> <function>Register</function>();
<type>void</type> <function>Unregister</function>();
        </programlisting>
        </para>
        <para>
            These functions register and unregister the command with the intepreter
            respectively.
        </para>
        <para>
        <programlisting>
static  <type>std::string</type> <function>ConcatenateParameters</function>(<type>int</type> <parameter>nArguments</parameter>,
                                           <type>char</type>* <parameter>pArguments</parameter>[])  ;
        </programlisting>
        </para>
        <para>
            Concatenates all of the <parameter>nArguments</parameter>
            words in the <parameter>pArguments</parameter> array into a <type>std::string</type>
            and returns it.  The words are space separated.
        </para>
        <para>
        <programlisting>
<type>int</type> <function>ParseInt</function>(const <type>char</type>* <parameter>pString</parameter>,
             <type>int</type>* <parameter>pInteger</parameter>)  ;
<type>int</type> <function>ParseInt</function>(const <type>std::string</type>&amp; <parameter>rString</parameter>,
             <type>int</type>* <parameter>pInteger</parameter>)
        </programlisting>
        </para>
        <para>
            Parses the character string <parameter>pString</parameter> or <parameter>rString</parameter>
            as a 32 bit signed integer into <parameter>pInteger</parameter>.  Returns
            <literal>TCL_OK</literal>
            if successful, or
            <literal>TCL_ERROR</literal>
            if the string coult no be parsed.  In that case, the result string
            of the interpreter will report why the string could not be parsed.
        </para>
        <para>
        <programlisting>
<type>int</type> <parameter>ParseDouble</parameter>(const <type>char</type>* <parameter>pString</parameter>,
                <type>double</type>* <parameter>pDouble</parameter>)  ;
<type>int</type> <function>ParseDouble</function>(const <type>std::string</type>&amp; <parameter>rString</parameter>,
                <type>double</type>* <parameter>pDouble</parameter>)
        </programlisting>
        </para>
        <para>
            Parses the input string, either <parameter>pString</parameter> or
            <parameter>rString</parameter>
            as a double precision floating point value, storing the result in the
            double pointed to by <parameter>pDouble</parameter>.
            On success,
            <literal>TCL_OK</literal>
            is returned.  On failure,
            <literal>TCL_ERROR</literal> and the interpreter result is
            a textual reason for the failure.
        </para>
        <para>
        <programlisting>
<type>int</type> <function>ParseBoolean</function>(const <type>char</type>* <parameter>pString</parameter>,
                 <type>Bool_t</type>* <parameter>pBoolean</parameter>)  ;
<type>int</type> <function>ParseBoolean</function>(const <type>std::string</type>&amp; <parameter>rString</parameter>,
                 <type>Bool_t</type>* <function>pBoolean</function>)
        </programlisting>
        </para>
        <para>
            Parses either <parameter>pString</parameter>
            or <parameter>rString</parameter> as a boolean value.  The result
            is stored in boolean pointed to by <parameter>pBoolean</parameter>.
            <literal>TCL_OK</literal>
            is returned on success,
            <literal>TCL_ERROR</literal>
            on error.  If <literal>TCL_ERROR</literal> was returned, the interpreter
            result is the textual reason for the failure.
        </para>
        <para>
        <programlisting>
static <type>int</type> <function>MatchKeyword</function>(<type>std::vector&lt;std::string&gt;</type>&amp; <parameter>MatchTable</parameter>,
                        const <type>std::string</type>&amp; <parameter>rValue</parameter>,
                        <type>int</type> <parameter>NoMatch</parameter> = <literal>-1</literal>);
        </programlisting>
        </para>
        <para>
            Searches for the string <parameter>rValue</parameter> in the vector of strings
            <parameter>MatchTable</parameter>, and returns the index in the vector at which
            the match occured.  If no match could be found, the value
            <parameter>NoMatch</parameter> is returned.
        </para>
        <para>
            Within SpecTcl, this is often used to match command switches.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLCompatibilityProcessor(3),
CTCLObjectProcessor(3),
CTCLPackagedCommand(3),
CTCLResult(3),
return(3tcl)
        </para>
    </refsect1>
</refentry>



<refentry id="manpage.CTCLChannel">
    <refmeta>
        <refentrytitle>CTCLChannel</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLChannel</refname>
        <refpurpose>
            Provide a C++ abstraction wrapper for Tcl Channels.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLChannel.h&gt;
...
class CTCLChannel : public CTCLInterpreterObject
{
public:

  CTCLChannel(CTCLInterpreter* pInterp,
              std::string      Filename,
              const char*      pMode,
              int              permissions);
  CTCLChannel(CTCLInterpreter* pInterp,
              int              argc,
              const char**           pargv,
              int              flags);
  CTCLChannel(CTCLInterpreter* pInterp,
              int              port,
              std::string      host)
  CTCLChannel(CTCLInterpreter* pInterp,
              int              port,
              Tcl_TcpAcceptProc* proc,
              ClientData       AppData);
  CTCLChannel(CTCLInterpreter* pInterp,
              Tcl_Channel      Channel);
  CTCLChannel(const CTCLChannel&amp; rhs);
  virtual ~CTCLChannel();

  Tcl_Channel getChannel() const;
  bool ClosesOnDestroy() const;

  int Read( void** pData, int nChars);
  int Write(const void* pData, int nBytes);

  bool atEof();
  void Flush();
  void Close();
  void Register();
  void SetEncoding(std::string Name);
  std::string GetEncoding();

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The Tcl API supplies an I/O abstraction layer on top of the
            operating systems I/O subsystem.  This layer makes use of what Tcl documentation
            refers to a s <firstterm>channels</firstterm>. A channel represents a connection
            to an I/O endpoint (source or sink of data or both).  The <classname>CTCLChannel</classname>
            class allows you to wrap a C++ class around a Tcl channel.
        </para>
        <para>
            Using a <classname>CTCLChannel</classname>, rather than direct operating system
            I/O allows you to improve the portability of your program, as well as allowing
            I/O from the TCL scripting level to be cleanly mixed with I/O at the C/C++ level.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLChannel</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
              <type>std::string</type>      <parameter>Filename</parameter>,
              <type>const char</type>*      <parameter>pMode</parameter>,
              <type>int</type>              <parameter>permissions</parameter>);
  <function>CTCLChannel</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
              <type>int</type>              <parameter>argc</parameter>,
              <type>const char</type>**           <parameter>pargv</parameter>,
              <type>int</type>              <parameter>flags</parameter>);
  <function>CTCLChannel</function>(<type>CTCLInterpreter</type>  * <parameter>pInterp</parameter>,
              <type>int</type>              <parameter>port</parameter>,
              <type>std::string</type>      <parameter>host</parameter>);
  <function>CTCLChannel</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
              <type>int</type>              <parameter>port</parameter>,
              <type>Tcl_TcpAcceptProc</type>* <parameter>proc</parameter>,
              <type>ClientData</type>      <parameter>AppData</parameter>);
  <function>CTCLChannel</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
              <type>Tcl_Channel</type>      <parameter>Channel</parameter>);
  <function>CTCLChannel</function>(<type>const CTCLChannel</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            These constructors wrap a <classname>CTCLChannel</classname>
            object around a Tcl channel.  The variety of constructors reflects the
            variety of endpoints around which a <type>Tcl_Channel</type> can be
            wrapped.
        </para>
        <para>
            The first of the constructors attaches the object to a file via
            <function>Tcl_OpenFileChannel</function>.  <parameter>pInterp</parameter>
            is the channel the file is associated.  <parameter>Filename</parameter>
            is the name of the file the channel is connected to. <parameter>pMode</parameter>
            is the connection mode which can be any of of the mode values for the
            Tcl <command>open</command> scripting command.   <parameter>permissions</parameter>
            represents the permissions mask fo rthe file in POSIX format.  See
            open(2) for information about the possible mode bit values.
        </para>
        <para>
            The second form of the constructor connects a channel that is a pipe to a
            program.  The program and its command line arguments are specified
            via the <parameter>argc</parameter> and <parameter>pargv</parameter>
            parameters. The <parameter>flags</parameter> parameter specifies
            how the stdio channels of the program are or are not disposed into the
            channel.   Valid bits are:
            <literal>TCL_STDIN</literal>,
            <literal>TCL_STDOUT</literal>,
            <literal>TCL_STDERR</literal>,
            <literal>TCL_ENFORCE_MODE</literal>.  See the <function>Tcl_OpenCommandChannel</function>
            manpage for information about the meaning of these bits.
        </para>
        <para>
            The third form of the constructor constructs a channel that connects to a
            TCP/IP server, via <function>Tcl_OpenTcpClient</function>.  The
            <parameter>port</parameter> parameter specifies the port number on which the
            server is listening, while <parameter>host</parameter> is the name of the
            host to which the connection should be formed.  The host name can either be a
            DNS resolvable host name or the textual encoding of the TCP/IP address of the
            host (e.g. string("spdaq22.nscl.msu.edu") or string("35.9.56.56").
            This function will block until the connection is accepted by the server.
        </para>
        <para>
            The fourth form of the constructor creates a channel that is a Tcp/IP server.
            <parameter>port</parameter> is the port number on which the server listens
            for connections.
            <parameter>proc</parameter> is a function that will be called when a
            connection has been accepted by the Tcl event loop.
            <parameter>AppData</parameter> is application data that is passed, without
            interpretation to <parameter>proc</parameter>.  See the <function>Tcl_OpenTcpServer</function>
            manpage for more information about how the <parameter>proc</parameter> is
            called.
        </para>
        <para>
            The fifth form of the constructor creates a <classname>CTCLChannel</classname>
            object by wrapping an existing <type>Tcl_Channel</type>; <parameter>Channel</parameter>
            which has been obtained
            directly from the Tcl application programming interface.
        </para>
        <para>
            The final form of the constructor copies an existing <classname>CTCLChannel</classname>
            object so that the two objects refer to the same channel.  The object is created
            so that it will not close the channel on destruction.  Note however that the
            source channel may, depending on how it was constructed.  It is up to the
            application programmer to ensure that channels are closed at appropriate times.
        </para>
        <para>
        <programlisting>
  <type>Tcl_Channel</type> <function>getChannel</function>() const;
        </programlisting>
        </para>
        <para>
            Returns the underlying <type>Tcl_Channel</type> this object is
            wrapped around.  Once this is obtained, it can be usd in any
            Tcl API call that requires a channel.
        </para>
        <para>
        <programlisting>
  <type>bool</type> <function>ClosesOnDestroy</function>() const;
        </programlisting>
        </para>
        <para>
            When a <classname>CTCLChannel</classname> is copy constructed into
            being it is flagged such that destruction will not close the underlying channel.
            the return value from this function is <literal>true</literal> if the
            object will close the underlying channel on destruction and <literal>false</literal>
            if the object will not close the underlying channel on destruction.
        </para>
        <para>
        <programlisting>
  <type>int</type> <function>Read</function>( <type>void</type>** <parameter>pData</parameter>,
           <type>int</type> <parameter>nChars</parameter>);
  <type>int</type> <function>Write</function>(<type>const void</type>* <parameter>pData</parameter>,
           <type>int</type> <parameter>nBytes</parameter>);
        </programlisting>
        </para>
        <para>
            <function>Read</function> transfers data from the channel to the users's buffer;
            <parameter>pData</parameter>.  <parameter>nChars</parameter> is the number
            of characters of data that will be transferred.
            <function>Write</function> transfers <parameter>nBytes</parameter>
            <firstterm>bytes</firstterm> data to the chnnel from <parameter>pData</parameter>.
            Both function return the number of characters actually transferred.
            An important note about the <parameter>nChars</parameter> parameter:  If the
            channel is not opened as a binary channel, this parameter is the number of
            UTF-8 characters transferred.  Depending on the characters actually transmitted,
            this may  not be the same as the number of bytes transmitted.
            The return value is the number of units (bytes or characters) actually transferred.
        </para>
        <para>
        <programlisting>

  <type>bool</type> <function>atEof</function>();
        </programlisting>
        </para>
        <para>
            Returns <literal>true</literal> if the underlying channel is at the end of file.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>Flush</function>();
        </programlisting>
        </para>
        <para>
            Tcl channels are internally buffered. The <function>Flush</function> member
            flushes internal output buffers to the underlying I/O endpoint.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>Close</function>();
        </programlisting>
        </para>
        <para>
            Closes the underlying channel. Note that this is normally done on
            destruction unless the channel object was created via copy construction.
            If the channel was registered to be visible to the interpreter, it is
            unregistered as well.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>Register</function>();
        </programlisting>
        </para>
        <para>
            Makes the channel visible to the interpreter.  This allows the user
            to return the channel name to the script level at which point it can be
            used in Tcl script commands that operate on channels.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>SetEncoding</function>(<type>std::string</type> <parameter>Name</parameter>);
  <type>std::string</type> <function>GetEncoding</function>();
        </programlisting>
        </para>
        <para>
            These functions allow the user to get and set the encoding for the channel.
            See the <command>fconfigure</command> Tcl man page for more information about this.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
close(3tcl),
fconfigure(3tcl),
open(2),
Tcl_OpenCommandChannel(3tcl),
Tcl_OpenFileChannel(3tcl),
Tcl_OpenTcpClient(3tcl),
Tcl_OpenTcpServer(3tcl)
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLCommandPacakge">
    <refmeta>
        <refentrytitle>CTCLCommandPackage</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLCommandPackage</refname>
        <refpurpose>
            Group several related Tcl command extensions and common services they
            may require together.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLCommandPackage.h&gt;
...
typedef std::list &lt;CTCLProcessor*&gt;   CommandList;
typedef CommandList::iterator  CommandListIterator;

class CTCLCommandPackage  : public CTCLInterpreterObject
{

public:
  CTCLCommandPackage (CTCLInterpreter* pInterp,
                      const std::string&amp; rSignon=std::string("Unnamed pkg"));
  CTCLCommandPackage(CTCLInterpreter* pInterp,
                     const char* pSignon = "Unnamed pkg");
  virtual ~ CTCLCommandPackage ( );
  CTCLCommandPackage (const CTCLCommandPackage&amp; aCTCLCommandPackage );
  CTCLCommandPackage&amp; operator= (const CTCLCommandPackage&amp; aCTCLCommandPackage);
  int operator== (const CTCLCommandPackage&amp; aCTCLCommandPackage);

  std::string getSignon() const;
  CommandList getCommandList() const;
protected:
  void setSignon (std::string am_sSignon);

public:
  void Register ()  ;
  void Unregister ()  ;
  void AddProcessor (CTCLProcessor* pProcessor);
  void AddProcessors(CommandList&amp; rList);
  CommandListIterator begin ();
  CommandListIterator end ();
};
    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Extensions to Tcl often come in a set of related commands.  These commands
            may require access to a common set of services.  The <classname>CTCLCommandPackage</classname>
            along with the <classname>CTCLPackagedCommand</classname> provide a pair of base
            classes that facilitate the construction of such commands.
        </para>
        <para>
            The pattern to follow to derive class from <classname>CTCLCommandPackage</classname>
            This class defines and implements common services for the related commands.
            The constructor of the derived class will also create instances of
            classes derived from <classname>CTCLPackagedCommand</classname>.  These objects
            define and implement the related commands.  These command processors will be
            added to the package via <function>AddProcessor</function>, and
            <function>AddProcessors</function>.
        </para>
        <para>
            When the <classname>CTCLCommandPackage</classname>::<function>Register</function>
            function is called, all of the commands added to the package will be
            registered as well.  When a command processor is invoked, it can call its
            <function>getMyPackage</function> member function to obtain a pointer to the
            owning package and therefore access to the services this package provides.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLCommandPackage</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
                      <type>const std::string</type>&amp; <parameter>rSignon</parameter>=<type>std::string</type>(<literal>"Unnamed pkg"</literal>));
  <function>CTCLCommandPackage</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
                     <type>const char</type>* <parameter>pSignon</parameter> = <literal>"Unnamed pkg"</literal>);
  <function>CTCLCommandPackage</function> (<type>const CTCLCommandPackage</type>&amp; <parameter>aCTCLCommandPackage</parameter> );
        </programlisting>
        </para>
        <para>
            Constructs instances of the package.  <parameter>pInterp</parameter> is a pointer
            to the interpreter object on which these commands will be registered.
            <parameter>signon</parameter> is a text string that will be emitted to
            <literal>stderr</literal> when the package is asked to register its commands.
            This string is typically a credit or copyright notice for the package.  It can
            be empty if the user desires.
        </para>
        <para>
            The first and second form of the constructor only differ in how the signon message
            is passed.  The final form of the constructor is a copy constructor.  While
            copy construction is legal it is anticipated that this will not normally be used
            as command packages are usually <firstterm>singleton</firstterm> objects.
        </para>
        <para>
        <programlisting>
  <type>std::string</type> <function>getSignon</function>() const;
        </programlisting>
        </para>
        <para>
            Retrieves the signon string from the current object.
        </para>
        <para>
            <programlisting>
  <type>CommandList</type> <function>getCommandList</function>() const;
            </programlisting>
        </para>
        <para>
            Retrieves the list of commands that are managed by this package.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>setSignon</function> (<type>std::string</type> <parameter>am_sSignon</parameter>);
        </programlisting>
        </para>
        <para>
            Allows derived classes to set the signon string after construction is complete.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>Register</function> ()  ;
  <type>void</type> <function>Unregister</function> ()  ;
        </programlisting>
        </para>
        <para>
            <function>Regsiter</function> registers all of the commands in the package
            with the package's interpreter.  <function>Unregister</function> unregisters
            these commands.  It is therefore not advisable to change the set of commands in
            the package between registration and unregistration.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>AddProcessor</function>(<type>CTCLProcessor</type>* <parameter>pProcessor</parameter>);
  <type>void</type> <function>AddProcessors</function>(<type>CommandList</type>&amp; <parameter>rList</parameter>);
        </programlisting>
        </para>
        <para>
            These functions add command processors to the package.  Any type of processor
            can be added to the package, however usually <classname>CTCLPackagedCommand</classname>
            derived objects are in order to provide a mechanism to access the package services.
            <parameter>pProcessor</parameter> is a pointer to a single processor while
            <parameter>rList</parameter> is a reference to a list of such processors.
        </para>
        <para>
        <programlisting>
  <type>CommandListIterator</type> <function>begin</function> ();
  <type>CommandListIterator</type> <function>end</function> ();
        </programlisting>
        </para>
        <para>
            Returns STL list iterators to the beginning and off the end of the
            set of command packages.
            List iterators behave roughly like pointers.  In this case, pointers
            to <classname>CTCLProcessor*</classname>.   Incrementing an interator
            'points' it to the next item in the list.  A full discussion of STL iterators
            is well beyond the scope of this man page.  See references below.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLProcessor(3), CTCLPackagedCommand(3)
        </para>
    </refsect1>
    <refsect1>
        <title>References</title>
        <para>
        <programlisting>
Musser, Derge, Saini: <parameter>STL Tutorial and Reference Guide</parameter>
Addison-Wesley Professional Computing Series; 2001 ISBN 0-201-37923-6
        </programlisting>
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLCompatibilityProcessor">
    <refmeta>
        <refentrytitle>CTCLCompatibiltyProcessor</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLCompatibilityProcessor</refname>
        <refpurpose>
            Adaptor between <classname>CTCLOjbectProcessor</classname>
            and <classname>CTCLProcessor</classname>.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLCompatibilityProcessor.h&gt;
...
class CTCLCompatibilityProcessor : public CTCLObjectProcessor
{

public:

  CTCLCompatibilityProcessor(CTCLProcessor&amp; actualCommand);
  virtual ~CTCLCompatibilityProcessor();

  virtual int operator()(CTCLInterpreter&amp; interp,
                         std::vector&lt;CTCLObject&gt;&amp; objv);
  virtual void onUnregister();
};

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Note that the information on this page is only to be used to
            "grandfather" old <classname>CTCLProcessor</classname> objects
            into Tcl.  New command processors should be based on the
            CTCLObjectProcessor.
        </para>
        <para>
            A rewrite of the TCL++ library in March 2006 eliminated the use of
            Tcl functions that are scheduled to be deprecated in the known future
            of Tcl.    One set of functions scheduled for deprecation are those
            that revolve around direct access to the Tcl interpreter result, and
            command processors that use the <parameter>argc</parameter>,
            <parameter>argv</parameter> interfaces.
        </para>
        <para>
            Since a number of existing command extensions are, no doubt built on
            top of the <classname>CTCLProcessor</classname> <parameter>argc</parameter>
                                                            <parameter>argv</parameter>
            interface, a mechanism that allows the use of existing commands was built
            as well.
        </para>
        <para>
            The current implementation of a <classname>CTCLProcessor</classname> includes
            as member data a <classname>CTCLCompatibilityProcessor</classname> object.
            This object registers itself as a <classname>CTCLObjectProcessor</classname>
            for the command intended by the <classname>CTCLProcessor</classname> and
            serves as an adaptor between these two command types, marshalling command
            objects into an <parameter>argc</parameter>, <parameter>argv</parameter> pair,
            creating and committing a <classname>CTCLResult</classname> object.
        </para>
        <para>
            For most users of this library, this is completely transparent, this documentation
            is provided for completeness, however.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
<function>CTCLCompatibilityProcessor</function>(<type>CTCLProcessor</type>&amp; <parameter>actualCommand</parameter>);
        </programlisting>
        </para>
        <para>
            Constructs a  compatibility processor that adapts the object based command
            interface for <parameter>actualCommand</parameter>.  <parameter>actualCommand</parameter>
            must already be bound to an interpreter.
        </para>
        <para>
        <programlisting>
virtual <type>int</type> <function>operator()</function>(<type>CTCLInterpreter</type>&amp; <parameter>interp</parameter>,
                       <type>std::vector&lt;CTCLObject&gt;</type>&amp; <parameter>objv</parameter>);
        </programlisting>
        </para>
        <para>
            Called when the command is executed.  <parameter>objv</parameter> is marshalled
            into an argc, argv pair.  A <classname>CTCLResult</classname> is created and the
            actual command's <function>operator()</function> is called to execute the command.
            On return, the result is committed, and all dynamic storage released prior to
            returning the status from the command processor.
        </para>
        <para>
        <programlisting>
virtual <type>void</type> <function>onUnregister</function>();
        </programlisting>
        </para>
        <para>
            Called when the command is unregistered.  The actual command's <function>OnDelete</function>
            member is called.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLObject(3),
CTCLObjectProcessor(3),
CTCLProcessor(3),
CTCLResult(3),
        </para>
    </refsect1>
    <refsect1>
        <title>REFERENCES</title>
        <para>
            <programlisting>
Gamma, Helm, Johnson, Vlissides <parameter>Design Patterns Elements of Reusable
Object-Oriented Software</parameter>
Addison-Wesley Professional Computing Series 1995 ISBN 0-0201-63361-2
See Chapter 4 the Adapter pattern.
            </programlisting>
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLFileHandler">
    <refmeta>
        <refentrytitle>CTCLFileHandler</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLFileHandler</refname>
        <refpurpose>
            Base class for building object oriented Tcl File event handlers.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLFileHandler.h&gt;
...

class CTCLFileHandler  : public CTCLInterpreterObject
{
  CTCLFileHandler(CTCLInterpreter* pInterp,
                   UInt_t am_nFid = STDIN_FILENO);
  CTCLFileHandler(CTCLInterpreter* pInterp,
                  FILE* pFile);
  CTCLFileHandler (const CTCLFileHandler&amp; aCTCLFileHandler );
  ~CTCLFileHandler ( );
  CTCLFileHandler&amp; operator= (const CTCLFileHandler&amp; aCTCLFileHandler);
  int operator== (const CTCLFileHandler&amp; aCTCLFileHandler) const;

  UInt_t getFid() const;

  virtual   void operator() (int mask)   = 0;

  void Set (int mask)  ;
  void Clear ()  ;
};

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Tcl supplies an event loop.  It is possible to add events specifications
            to this loop.  One very useful event type is based on readability or writability
            of a file descriptor.   The <classname>CTCLFileHandler</classname> allows you
            to create an object oriented file handler, and register it with the event
            loop so that you can gain control when, for example, a file becomes readable.
        </para>
        <para>
            As <classname>CTCLFileHandler</classname> is an abstract base class,
            it is necessary to create a derived class.  The derived class should
            implement the <function>operator()</function> which will be called
            when the specific event is fired.  An instance of this derived class should
            be created, and then the <function>Set</function> and <function>Clear</function>
            members used to establish and remove the event handler.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLFileHandler</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
                   <type>UInt_t</type> <parameter>nFid</parameter> = <literal>STDIN_FILENO</literal>);
  <function>CTCLFileHandler</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
                  <type>FILE</type>* <parameter>pFile</parameter>);
  <function>CTCLFileHandler</function> (const <type>CTCLFileHandler</type>&amp; <parameter>aCTCLFileHandler</parameter> );
        </programlisting>
        </para>
        <para>
            Constructs a file handler object.  <parameter>pInterp</parameter> is a
            pointer to the interpreter on which the file handler will be registered.
            The file can be specified either by <parameter>nFid</parameter>, a file
            descriptor, or <parameter>pFile</parameter> an stdio File stream pointer.
        </para>
        <para>
            A copy constructor allows the creation of a copy of the file handler object
            given <parameter>aCTCLFileHandler</parameter> an existing one.  This is normally
            not useful.
        </para>
        <para>
            <programlisting>
  <type>CTCLFileHandler</type>&amp; <function>operator=</function> (const <type>CTCLFileHandler</type>&amp; <parameter>aCTCLFileHandler</parameter>);
  <type>int</type> <function>operator==</function> (const <type>CTCLFileHandler</type>&amp; <parameter>aCTCLFileHandler</parameter>) const;
            </programlisting>
        </para>
        <para>
            These functions support assignment and equality comparison.  Note that these functions
            are usually not very useful for file handlers.
        </para>
        <para>
        <programlisting>
  <type>UInt_t</type> <function>getFid()</function> const;
        </programlisting>
        </para>
        <para>
            Returns the file id that is associated with the event.
        </para>
        <para>
            <programlisting>
  virtual   <type>void</type> <function>operator</function>() (<type>int</type> <parameter>mask</parameter>)   = 0;
            </programlisting>
        </para>
        <para>
            The user's derived class must override this to provide the desired
            funtionality when event fires.  <parameter>mask</parameter>
            indicates which event fired the function and can be an or of the following:
            <literal>TCL_READABLE</literal> if the file can be read without blocking,
            <literal>TCL_WRITABLE</literal> if the file can be written without blocking,
            or <literal>TCL_EXCEPTION</literal> if some exceptional condition occured on the
            file.
        </para>
        <para>
            <programlisting>
  <type>void</type> <function>Set</function> (<type>int</type> <parameter>mask</parameter>)  ;
  <type>void</type> <function>Clear</function> ()  ;
        </programlisting>
        </para>
        <para>
            <function>Set</function> establishes the event handler for the set of conditions
            described in <parameter>mask</parameter>.  The valid bits for <parameter>mask</parameter>,
            are described in the documentation for the <parameter>mask</parameter>
            parameter to <function>operator()</function>.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLObject(3),
CTCLInterpreter(3)
Tcl_CreateFileHandler(3tcl),
Tcl_DeleteFileHandler(3tcl)
        </para>
    </refsect1>
</refentry>


<refentry id="manpage.CTCLHashTable">
    <refmeta>
        <refentrytitle>CTCLHashTable</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLHashTable</refname>
        <refpurpose>
            Object oriented interface to Tcl's hash table functions.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLHashTable.h&gt;

template &lt;class T&gt;
class CTCLHashTable
{
public:
  CTCLHashTable () ;
  CTCLHashTable (  Tcl_HashTable am_HashTable  );
  CTCLHashTable (const CTCLHashTable&amp; aCTCLHashTable );
  virtual ~CTCLHashTable ( );

  CTCLHashTable operator= (const CTCLHashTable&amp; aCTCLHashTable);

  int operator== (const CTCLHashTable&amp; aCTCLHashTable);

  Tcl_HashTable* getHashTable() const;

  void Enter (const std::string&amp; rKey, rCTCLTHashTableItem rValue);
  const CTCLTHashTableItem* Find (const std::string&amp; rsKeyword) const;
  CTCLTHashTableItem* Delete (const std::string&amp; rsKeyword);
  CTCLTHashTableIterator begin ();
  CTCLTHashTableIterator end ();
  std::string Statistics ();
};

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Hash tables are tables of keyword value pairs that are organized
            such that the lookup time for any key in the table is <firstterm>amortized
            constant</firstterm>.  Hash tables operate by running the key through a
            function called the <firstterm>hash function</firstterm>, and storing the
            key/value pair as an element of an array indexed by the result of that hash
            function (<firstterm>hash index</firstterm>).  Depending on the implementation of the hash table, different
            methods are used to resolve cases where two keys result in the same
            hash index.
        </para>
        <para>
            Tcl includes support libraries for hash tables with string keys and
            arbitrary value types (e.g. structures, pointers etc. etc.).  One example
            of the use of this sort of data structure is Tcl's storage of array variables.
            Each array is a hash table indexed by the hash index of the array subscripts.
            In this way Tcl supports subscripts that are arbitrary strings without
            any search overhead when referencing an element of the array.
        </para>
        <para>
            The <classname>CTCLHashTable</classname> and related classes provide an object oriented
            interface to the Tcl API for hash tables.  This class is a <firstterm>template class</firstterm>.
            The template parameter is the type of data that will be associated with each
            hash key.  For example, to create a has key of <classname>CSpectrum*</classname>
            (pointers to SpecTcl Spectra):
            <programlisting>
        CTCLHashTable&lt;CSpectrum*&gt; spectrumHashTable;
            </programlisting>
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLHashTable</function> () ;
  <function>CTCLHashTable</function> (  <type>Tcl_HashTable</type> <parameter>aHashTable</parameter>  );
  <function>CTCLHashTable</function> (const <type>CTCLHashTable</type>&amp; <parameter>aCTCLHashTable</parameter> );
        </programlisting>
        </para>
        <para>
            Three methods for creating <classname>CTCLHashTable</classname> objects
            are defined.   The first of these creates a new, empty hash table.
            The second, takes the handle to an existing hash table;
            <type>Tcl_HashTable</type> <parameter>aHashTable</parameter> and wraps
            a <classname>CTCLHashTable</classname> around this existing hash table
            providing an object oriented interface to that hash table.
            The final constructor, a copy constructor, creates a
            <classname>CTCLHashTable</classname> that refers to the same underlying
            <type>Tcl_HashTable</type> as the <parameter>aCTCLHashTable</parameter> parameter.
        </para>
        <para>
        <programlisting>
  <type>CTCLHashTable</type> <function>operator</function>= (const <type>CTCLHashTable</type>&amp; <parameter>rhs</parameter>);
  <type>int</type> <function>operator==</function> (const <type>CTCLHashTable</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            <function>operator=</function>  assigns <parameter>rhs</parameter> to an existing
            object.  The semantics of assignment are that
            followingt assignment, <varname>*this</varname> and <parameter>rhs</parameter>
            will refer to the same underlying hash table.
        </para>
        <para>
            <function>operator==</function> compares two hash tables, <varname>*this</varname>
            and <parameter>rhs</parameter> for equality.  The semantics of equality are
            that the two <classname>CTCLHashTable</classname> objects refer to the same
            underlying Tcl hash tables.
        </para>
        <para>
        <programlisting>
  <type>Tcl_HashTable</type>* <function>getHashTable</function>() const;
        </programlisting>
        </para>
        <para>
            Gets the underlying <type>Tcl_HashTable</type> that is wrapped by
            a <classname>CTCLHashTable</classname> object.
        </para>
        <para>
            <programlisting>
<type>void</type> <function>Enter</function> (const <type>std::string</type>&amp; <parameter>rKey</parameter>,
            <type>CTCLTHashTableItem&lt;T&gt;</type> <parameter>rValue</parameter>);
            </programlisting>
            </para>
            <para>
            Adds an entry to a hash table.  <parameter>rKey</parameter> is the
            lookup key that will be associated with the entry.  <parameter>rValue</parameter>
            is the data that is associated with that key.  Note that <type>T</type>
            is the template type that was used to create the hashtable.  E.g. if the
            hash table is a <classname>CTCLHashTable&lt;float&gt;</classname>,
            <parameter>rValue</parameter> must be a <classname>CTCLHashTableItem&lt;float&gt;</classname>.
            Note that Tcl hash tables do not support duplicate keys.  If a hash table
            entry with the key <parameter>rKey</parameter> already is in the table it is
            replaced.
            </para>
            <para>
                <programlisting>
  const <type>CTCLTHashTableItem</type>* <function>Find</function> (const <type>std::string</type>&amp; <parameter>rsKeyword</parameter>) const;
                </programlisting>
            </para>
            <para>
                Looks up a hash table item by key.  If a hash table item with
                the key <parameter>rsKeyword</parameter> exists, a pointer to its
                entry is returned.   If <parameter>rsKeyword</parameter> has not
                yet been <function>Enter</function>ed in the hash table, a
                <literal>NULL</literal> pointer is returned.
            </para>
            <para>
                <programlisting>
  <type>CTCLTHashTableItem</type>* <function>Delete</function> (const <type>std::string</type>&amp; <parameter>rsKeyword</parameter>);
                </programlisting>
            </para>
            <para>
                Removes the hash table entry with the key <parameter>rsKeyword</parameter>.
                If the item existed, a pointer to it is returned.  If the item does not
                exist in the hash table a <literal>NULL</literal> pointer is returned.
            </para>
            <para>
                <programlisting>
  <type>CTCLTHashTableIterator</type> <function>begin</function> ();
  <type>CTCLTHashTableIterator</type> <function>end</function> ();
                </programlisting>
            </para>
            <para>
                <function>begin</function> returns an <firstterm>iterator</firstterm> that
                "points" to the first entry in the hash table.  dereferencing the
                iterator yields the pointer to a HashTableItem.  The iterator can be
                incremented via ++ so that it advances to the next item in the table.
            </para>
            <para>
                <function>end</function>returns an iterator that points past the end of the
                table and can be used to determine when iteration is complete.
            </para>
            <para>
                Iterators are pointer like objects.  See the STL reference below for more
                information about them.  The following example Takes a Hash table and
                counts up the number of elements it contains.
                <programlisting>
        CTCLHashTableIterator i = table.begin();    // Table a CTCLHashTable
        int                   n = 0;
        while (i != table.end()) {
            n++;
        }
        // N is a count of elements in the table.

            </programlisting>
            </para>
            <para>
                <programlisting>
  <type>std::string</type> <function>Statistics</function> ();
                </programlisting>
        </para>
        <para>
            Returns a string that contains statistics about the hash table.
            This is a wrapper for <function>Tcl_HashStats</function>
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLHashTableItem(3),
CTCLHashTableIterator(3),
Tcl_HashStats(3tcl)
        </para>
    </refsect1>
    <refsect1>
        <title>REFERENCES</title>
        <para>
        <programlisting>
Niklaus Wirth <parameter>Algorithms + Data Structures = Programs</parameter>
Prentice Hall Series in Automatic Computation 1976 See section 4.6

Musser, Derge, Saini: <parameter>STL Tutorial and Reference Guide</parameter>
Addison-Wesley Professional Computing Series; 2001 ISBN 0-201-37923-6
        </programlisting>
        </para>
    </refsect1>
</refentry>


<refentry id="manpage.CTCLHashTableItem">
    <refmeta>
        <refentrytitle>CTCLHashTableItem</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLHashTableItem</refname>
        <refpurpose>
            Encapsulation of an entry in a Tcl Hash table as encapsulated
            in <classname>CTCLHashTable</classname>
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <programlisting>
#include &lt;TCLHashTableItem.h&gt;
...

template &lt;class T&gt;              // T Must have copy ctor &amp; Assignment defined.
class CTCLHashTableItem
{
  CTCLHashTableItem (T am_Item );
  CTCLHashTableItem (const CTCLHashTableItem&amp; aCTCLHashTableItem );
  virtual ~CTCLHashTableItem ( );

  CTCLHashTableItem operator= (const CTCLHashTableItem&amp; aCTCLHashTableItem);
   int operator== (const CTCLHashTableItem&amp; aCTCLHashTableItem);
  T getItem() const;
  T* operator-&gt; ();
}
        </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title></title>
        <para>
            Provides an object oriented interface to elements of a hash table.
            See CTCLHashTable(3), and the first REFERENCE below for more information
            about hash tables.
        </para>
        <para>
            Note that this is a templated class.  The template parameter is
            the type of the item to be stored in the hash table.  Suppose,
            for example, we have a bunch of named calibration parameters
            (floating point) that are stored in a hash table.  A calibration
            The following code creates the calibration table, and inserts an
            element named george in it with the initial value of 0.0:
            <programlisting>
        CTCLHashTable&lt;float&gt;  calibrationTable;
        CTCLHashTableItem&lt;float&gt; entry(0.0);
        calibrationTable.Enter(std::string("george"), entry);
            </programlisting>
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
<function>CTCLHashTableItem</function> (<type>T</type> <parameter>Item</parameter> );
<function>CTCLHashTableItem</function> (const <type>CTCLHashTableItem</type>&amp; <parameter>hashItem</parameter> );
        </programlisting>
        </para>
        <para>
            Constructs a <classname>CTCLHashTableItem</classname> either from the underlying
            type (<parameter>Item</parameter>) or from an existing <classname>CTCLHashTableItem</classname>
            (<parameter>hashItem</parameter>).
        </para>
        <para>
        <programlisting>
<type>CTCLHashTableItem</type> <function>operator=</function>(const <type>CTCLHashTableItem</type>&amp; <parameter>rhs</parameter>);
<type>int</type> <parameter>operator==</parameter> (const <type>CTCLHashTableItem</type>&amp; <type>rhs</type>);
        </programlisting>
        </para>
        <para>
            <function>operator=</function> allows you to assign the value of one
            <classname>CTCLHashTableItem</classname> to another.  The underlying
            templated type must be capable of assignment.
        </para>
        <para>
            <function>operator==</function> allows you to compare two
            <classname>CTCLHashTableItem</classname>s to each other.  The underlying
            templated type must be capable of equality comparison.
        </para>
        <para>
            <programlisting>
<type>T</type> <function>getItem</function>() const;
            </programlisting>
        </para>
        <para>
            Returns the value of the item wrapped by the <classname>CTCLHashTableItem</classname>
            The underlying type must be capable of copy construction.
        </para>
        <para>
            <programlisting>
<type>T</type>* <function>operator-&gt;</function> ();       </programlisting>
        </para>
        <para>
            Returns the address of the contents of the <classname>CTCLHashTableItem</classname>.
            This is most useful if <classname>T</classname> is a structure or class as it can be
            used to dereference member (data or functions) of the structure or class.
            For example:
            <programlisting>
                struct complex {
                                 double real;
                                 double imaginary;
                                 complex(double r, double i) :
                                    real(r), imaginary(i) {}
                                } complex;
                CTCLHashTableItem&lt;complex&gt; v(1.0, 2.0);
                double real = v-&gt;real;             // real = 1.0
                double imag = v-&gt;imaginary;        // imag = 2.0
            </programlisting>
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLHashTable(3),
CTCLHashTableIterator(3)
        </para>
    </refsect1>
    <refsect1>
        <title>REFERENCES</title>
        <para>
            <programlisting>
Niklaus Wirth <parameter>Algorithms + Data Structures = Programs</parameter>
Prentice Hall Series in Automatic Computation 1976 See section 4.6
            </programlisting>
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLHashTableIterator">
    <refmeta>
        <refentrytitle>CTCLHashTableIterator</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLHashTableIterator</refname>
        <refpurpose>
            Iterator for visiting all elements of a <classname>CTCLHashTable</classname>
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>

#include &gt;TCLHashTableIterator.h&gt;
...
template &lt;class T&gt;
class CTCLHashTableIterator
{

public:
  CTCLHashTableIterator (Tcl_HashTable*   pTable);
  CTCLHashTableIterator (const CTCLHashTableIterator&amp; aCTCLHashTableIterator );
  virtual ~ CTCLHashTableIterator ( );

  CTCLHashTableIterator operator=
                     (const CTCLHashTableIterator&amp; aCTCLHashTableIterator);
  int operator== (const CTCLHashTableIterator&amp; aCTCLHashTableIterator);
  CTCLHashTableItem&lt;T&gt;* getCurrentEntry() const;
  Tcl_HashTable* getHashTable() const;

  CTCLHashTableIterator&amp; operator++ ();
  CTCLHashTableIterator operator++ (int i);
  CTCLHashTableItem&lt;T&gt;&amp; operator* ();
  CTCLHashTableItem&lt;T&gt;* operator-&gt;();

};



    </programlisting>

    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            <classname>CTCLHashTableIterator</classname> objects are created and returned
        by <classname>CTCLHashTableIterator</classname>::<function>begin</function>
        and <classname>CTCLHashTableIterator</classname>::<function>end</function>.
        These objects are pointer like objects to <classname>CTCLHashTableItem</classname>
        objects within the hash table.
        </para>
        <para>
            If you imagine that all containers can have an ordering defined on them,
            iterators are like pointers to elements of this ordering.
            Dereference operators yield an element of the container, and increment operators
            make the iterator 'point' to the next element in the container according to the
            ordering.
        </para>
        <para>
            For more information on both hash tables and iterators see the
            REFERENCES.  For information about the classes that are related to this,
            consult manpages pointed to by the SEE ALSO section.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLHashTableIterator</function> (<type>Tcl_HashTable</type>* <parameter>pTable</parameter>);
  <function>CTCLHashTableIterator</function>(const <type>CTCLHashTableIterator</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            Construct a hash table iterator.  Normally you will not need to use these
            constructors directly.  They will be created, instead by
            <classname>CTCLHashTable</classname>::<function>begin()</function>
            or <classname>CTCLHashTable</classname>::<function>end()</function>.
            <parameter>pTable</parameter> is a pointer to an existing <type>Tcl_HashTable</type>
            created via <function>Tcl_InitHashTable</function>.  <parameter>rhs</parameter>
            is an existing <classname>CTCLHashTableIterator</classname> object whose state
            will be used to initialize the object under construction.
        </para>
        <para>
        <programlisting>
  <type>CTCLHashTableIterator</type> <function>operator=</function>
                     (const <type>CTCLHashTableIterator</type>&amp; <parameter>rhs</parameter>);
  <type>int</type> <function>operator==</function>(const <type>CTCLHashTableIterator</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            <function>operator=</function> allows you to assign the state of one <classname>CTCLHashTableIterator</classname>
            to another.  When the assignment is complete, the left hand side object will
            be 'pointing' to the same object as the right hand side object but be separately
            incrementable.
        </para>
        <para>
            <function>operator==</function> allows you to compare two iterators for equality.
            equality is defined as the two iterators being defined on the same underlying
            hash table, pointing to the same element, and having the same increment context
            (e.g. an increment of both iterators will leave them both pointing to the
            same hash table item (different from the one prior to the increment).
        </para>
        <para>
        <programlisting>
<type>CTCLHashTableItem&lt;T&gt;</type>* <function>getCurrentEntry</function>() const;
<type>Tcl_HashTable</type>* <function>getHashTable</function>() const;
        </programlisting>
        </para>
        <para>
            These two functions get at the information the iterator is encapsulating.
            <function>getCurrentEntry</function> returns a pointer to the entry that
            the iterator si currently 'pointing' at.  This is identical to the
            <function>operator-&gt;</function> function.
            <function>getHashTable</function> returns a pointer to the underlying
            <type>Tcl_HashTable</type> created by <function>Tcl_InitHashTable</function>.
        </para>
        <para>
            <programlisting>
CTCLHashTableIterator&amp; operator++ ();
CTCLHashTableIterator operator++ (int i);
            </programlisting>
        </para>
        <para>
            These two function support both pre and post increment operations on an
            iterator.  There are slight differences in semantics between these
            operators best illustrated with a sample code fragment.  In the fragment
            below, i is an <classname>CTCLHashTableIterator</classname>
            <programlisting>
CTCLHashTableItem item1 = *i++;   // item 1 is the item pointed to prior to increment
CTCLHashTableItem item2 = *++i;   // item 2 is the item pointed to after increment.
            </programlisting>
        </para>
        <para>
            <programlisting>
<type>CTCLHashTableItem&lt;T&gt;</type>&amp; <function>operator*</function> ();
<type>CTCLHashTableItem&lt;T&gt;</type>* <function>operator-&gt;</function>();
        </programlisting>
        </para>
        <para>
            These operators allow <classname>CTCLHashTableIterator</classname> objects
            to be treated like pointers to <classname>CTCLHashTableItem</classname> objects.
            <function>operator*</function> provides 'pointer' dereferencing that allows
            code like:
            <programlisting>
                (*i).getItem();
            </programlisting>
        </para>
        <para>
            <function>operator-&gt;</function> provides a pointer to struct like semantics
            allowing code like:
            <programlisting>
                i->getItem();
            </programlisting>
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLHashTable(3),
CTCLHashTableItem(3),
Tcl_InitHashTable(3tcl),
Tcl_FirstHashEntry(3tcl),
Tcl_NextHashEntry(3tcl)
        </para>
    </refsect1>
    <refsect1>
        <title>REFERENCES</title>
        <para>
        <programlisting>
Niklaus Wirth <parameter>Algorithms + Data Structures = Programs</parameter>
Prentice Hall Series in Automatic Computation 1976 See section 4.6

Musser, Derge, Saini: <parameter>STL Tutorial and Reference Guide</parameter>
Addison-Wesley Professional Computing Series; 2001 ISBN 0-201-37923-6
        </programlisting>
        </para>
    </refsect1>
</refentry>


<refentry id="manpage.CTCLIdleProcess">
    <refmeta>
        <refentrytitle>CTCLIdleProcess</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLIdleProcess</refname>
        <refpurpose>
            Allows the establishment of an executable object that
            can be scheduled to be invoked when the Tcl/Tk intperpreter
            has no events that require processing.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLIdleProcess.h&gt;

class CTCLIdleProcess : protected CTCLTimer
{
public:
  CTCLIdleProcess(CTCLInterpreterObject* pObject);
  CTCLIdleProcess(CTCLInterpreter* pInterp);
  virtual ~CTCLIdleProcess();

  void Set();
  void Clear();
  virtual void operator()() = 0;
};
    </programlisting>

    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            While Tcl provides a mechanism for scheduling the execution of
            a function when the interpreter main loop is idle (no pending events),
            this is not suitable for processes that may need to be rescheduled.
            Therefore, <classname>CTCLIdleProcess</classname> is actually based on a
            timer dispatch where the delay interval is 0ms.
        </para>
        <para>
        <classname>CTCLIdleProcess</classname>
        provides an abstract base class for creating function like classes that
        are 'called' to run interleaved with the interpreter.
        A function like class is one that implements <classname>operator()</classname>
        (see REFERENCES) below.  You can create an idle processor by creating
        a subclass of <classname>CTCLIdleProcess</classname> overriding
        <classname>operator()</classname>, creating an instance of that new class,
        and invoking the <function>Set()</function> function to schedule the
        execution of the <function>operator()</function>.  Note that
        It is possible for the code in your <function>operator()</function> to
        reschedule itself by calling <function>Set()</function>.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLIdleProcess</function>(<type>CTCLInterpreterObject</type>* <parameter>pObject</parameter>);
  <function>CTCLIdleProcess</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>);
        </programlisting>
        </para>
        <para>
            Creates a <classname>CTCLIdleProcess</classname> and initializes the timer on which this
            is based. <parameter>pInterp</parameter> is the interpreter that will schedule
            the object's <function>operator()</function>.  <parameter>pObject</parameter>
            points to an interpreter object who's interpreter will schedule the
            <function>operator()</function> to run.
        </para>
        <para>
            <programlisting>
  <type>void</type> <function>Set</function>();
  <type>void</type> <function>Clear</function>();
            </programlisting>
        </para>
        <para>
            These function control the scheduling of the <function>operator()</function>
            call. <function>Set</function> schedules the function to be called pretty much
            the next time the interpreter loop is intered, while <function>Clear</function>
            cancels a pending schedule.
        </para>
        <para>
            <programlisting>
  virtual <type>void</type> <function>operator()</function>() = 0;
        </programlisting>
        </para>
        <para>
            This pure virtual function is overridden by your idle processor to
            provide the behavior of the idle processor.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLTimer(3),
Tcl_CreateTimerHandler(3tcl),
Tcl_DoWhenIdle(3tcl),

        </para>
    </refsect1>
    <refsect1>
        <title>REFERENCES</title>
        <para>
            <programlisting>
Musser, Derge, Saini: <parameter>STL Tutorial and Reference Guide</parameter>
Addison-Wesley Professional Computing Series; 2001 ISBN 0-201-37923-6
See section 2.4 for a description and discussion of function objects.
            </programlisting>
        </para>
    </refsect1>
</refentry>


<refentry id="manpage.CTCLPackagedCommand">
    <refmeta>
        <refentrytitle>CTCLPackagedCommand</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLPackagedCommand</refname>
        <refpurpose>
            Base class for a command that lives in a <classname>CTCLCommandPackage</classname>
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLPackagedCommand.h&gt;
...
class CTCLPackagedCommand   : public CTCLProcessor
{

  CTCLPackagedCommand (const std::string&amp; sCommand, CTCLInterpreter* pInterp,
                       CTCLCommandPackage&amp; rPackage);
  CTCLPackagedCommand (const char* pCommand, CTCLInterpreter* pInterp,
                       CTCLCommandPackage&amp; rPackage);
   ~ CTCLPackagedCommand ( );

  CTCLCommandPackage&amp; getMyPackage();

  void setMyPackage (CTCLCommandPackage&amp; am_rMyPackage);

};
    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Command packages (see CTCLCommandPackage(3)), provide a way to organize
            a set of related Tcl command processors  around a set of shared services.
            Objects derived from <classname>CTCLPackagedCommand</classname> are added
            to an object derived from <classname>CTCLCommandPackage</classname>.
            The <classname>CTCLCommandPackage</classname> manages bulk registration of
            all of the commands added to it.  Construcint a
            <classname>CTCLPackagedCommand</classname> object provides it a
            reference to its package so
            that public members of the package can be invoked when the package commands
            are executing.
        </para>
        <para>
            Note that since <classname>CTCLPackagedCommand</classname> is derived from
            <classname>CTCLProcessor</classname>, and does not supply a <function>operator()</function>
            You must derive concrete classes from this class implementing
            <function>operator()</function> to provide the desired command functionality.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
  <function>CTCLPackagedCommand</function> (const <type>std::string</type>&amp; <parameter>sCommand</parameter>,
                       <type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
                       <type>CTCLCommandPackage</type>&amp; <parameter>rPackage</parameter>);
  <function>CTCLPackagedCommand></function> (const <type>char</type>* <parameter>pCommand</parameter>,
                       <type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
                       <type>CTCLCommandPackage</type>&amp; <parameter>rPackage</parameter>);
        </programlisting>
        </para>
        <para>
            Constructs a packaged command.
            <parameter>sCommand</parameter> or
            <parameter>pCommand</parameter>
            provide the command name.  <parameter>pInterp</parameter> is a pointer to the
            interpreter on which the command will be registered.
            <parameter>rPackage</parameter> is a reference to the package this object will
            be a member of.
        </para>
        <para>
            <programlisting>

<type>CTCLCommandPackage</type>&amp; <function>getMyPackage()</function>;
            </programlisting>
        </para>
        <para>
            Returns a reference to the object's package.  This can be cast to the
            actual type of the package at which point package public members can be
            accessed.
        </para>
        <para>
            <programlisting>
  <type>void</type> <function>setMyPackage</function> (<type>CTCLCommandPackage</type>&amp; <parameter>rMyPackage</parameter>);
        </programlisting>
        </para>
        <para>
            Provides a new package for the command.
        </para>
        <para>
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLCommandPackage(3),
CTCLProcessor(3)
        </para>
    </refsect1>
</refentry>


<refentry id="manpage.CTCLResult">
    <refmeta>
        <refentrytitle>CTCLResult</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLResult</refname>
        <refpurpose>
            Provide an object oriented interace to the Tcl interpreter result.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLResult.h&gt;
...
class CTCLResult  : public CTCLObject
{
  CTCLResult (CTCLInterpreter* pInterp, bool reset=true );
  CTCLResult (const CTCLResult&amp; aCTCLResult );
  virtual ~CTCLResult ( );

  CTCLResult&amp; operator= (const CTCLResult&amp; aCTCLResult);
  CTCLResult&amp; operator= (const char* rhs);
  CTCLResult&amp; operator=(std::string    rhs);

  int operator== (const CTCLResult&amp; aCTCLResult) ;
  int operator!= (const CTCLResult&amp; rhs);

  CTCLResult&amp; operator+= (const char* pString);
  CTCLResult&amp; operator+= (const std::string&amp; rString);

  void Clear ()  ;
  void AppendElement (const char* pString)  ;
  void AppendElement (const std::string&amp; rString);
  void commit() const;
  std::string getString();
};

    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Each Tcl command can return <firstterm>result string</firstterm>
            the result string can be used by subsequent commands in the event
            the command operated successfully, or by <command>catch</command>
            commands if the command failed.  <classname>CTCLResult</classname>
            provides an extension of the <classname>CTCLObject</classname>
            class that builds up a string which can then be comitted to the
            result.
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
<function>CTCLResult</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
           <type>bool</type> <parameter>reset</parameter>=<literal>true</literal> );
<function>CTCLResult</function>(const <type>CTCLResult</type>&amp; <parameter>aCTCLResult</parameter>);
          </programlisting>
          </para>
          <para>
            Constructs a Tcl interpreter result string.  <parameter>pInterp</parameter> is the interpeter
            that will be associated with this result. <parameter>reset</parameter> controls
            whether or not the result string is reset when constructed, or if it is loaded
            with the current value of the result string.  In the case of copy construction,
            the interpreter associated with <parameter>aCTCLResult</parameter> is used.
            <parameter>aCTCLResult</parameter> is committed to the interpreter result, and
            the object under construction is then loaded from that interpreter's result.
          </para>
          <para>
          <programlisting>
  <type>CTCLResult</type>&amp; <function>operator=</function> (const <type>CTCLResult</type>&amp; <parameter>rhs</parameter>);
  <type>CTCLResult</type>&amp; <function>operator=</function> (const <type>char</type>* <parameter>rhs</parameter>);
  <type>CTCLResult</type>&amp; <function>operator=</function>(<type>std::string</type>    <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            Assigns a value to the result from <parameter>rhs</parameter>.
            If the <parameter>rhs</parameter> is a <classname>CTCLResult</classname>, then the
            <parameter>rhs</parameter> is first committed to its interpreter result,
            the left hand object is then bound to the same interpreter as <parameter>rhs</parameter>
            and loaded with the result string of that interpreter.
        </para>
        <para>
        <programlisting>
  <type>int</type> <function>operator==</function> (const <type>CTCLResult</type>&amp; <parameter>rhs</parameter>) ;
  <type>int</type> <function>operator!=</function> (const <type>CTCLResult</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            These functions suport comparison. Equality comparison is true
            (<function>operator==</function>) if the interpreters match as the assumption
            is that the user is working to maintain coherency if several <classname>CTCLResult</classname>
            objects are simultaneously live on a single interpreter.
            Inequality (<function>operator!=</function>) is defined as true when
            <function>operator==</function> is false.
        </para>
        <para>
        <programlisting>
<type>CTCLResult</type>&amp; <function>operator+=</function> (const <type>char</type>* <parameter>rhs</parameter>);
<type>CTCLResult</type>&amp; <function>operator+=</function>(const <type>std::string</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            <parameter>rhs</parameter> is textually appended to the result string being built
            up.   Note that the semantics of this are different than for the base class
            where <function>operator+=</function> is a list append.
        </para>
        <para>
        <programlisting>
  <type>void</type> <function>Clear</function>()  ;
          </programlisting>
          </para>
          <para>
            Clears the result string being built up as well as clearing the
            underlying interpreter's result.
          </para>
          <para>
          <programlisting>
  <type>void</type> <function>AppendElement</function>(const <type>char</type>* <parameter>item</parameter>)  ;
  <type>void</type> <function>AppendElement</function>(const <type>std::string</type>&amp; <parameter>item</parameter>);
          </programlisting>
          </para>
          <para>
            Appends <parameter>item</parameter> to the result string being built up as a
            list element.  This means that under some circumstances extra quoting may be
            done to ensure that the result will be maintained as a valid list.
          </para>
          <para>
          <programlisting>
  <type>void</type> <function>commit</function>() const;
  <type>std::string</type> <function>getString</function>();
        </programlisting>
        </para>
        <para>
            <function>commit</function> sets the interpreter result string equal
            to the string being built up in the object.  <function>getString</function>
            does a commit and then returns the string.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLObject(3)
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.CTCLString">
    <refmeta>
        <refentrytitle>CTCLString</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLString</refname>
        <refpurpose>
            Provide a wrapper for the <type>Tcl_DString</type> data type
            and its API
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLString.h&gt;
...
class CTCLString
{
public:
  CTCLString ();
  CTCLString (const char* pString  ) ;
  CTCLString(const std::string&amp; rString);
  CTCLString(const Tcl_DString&amp; rString);
  CTCLString (const CTCLString&amp; aCTCLString );
  ~ CTCLString ();

  CTCLString&amp; operator= (const CTCLString&amp; aCTCLString);
  int operator== (const CTCLString&amp; aCTCLString);
  int operator!= (const CTCLString&amp; aCTCLString);
  int operator&gt; (const CTCLString&amp; aCTCLString);
  int operator&lt; (const CTCLString&amp; aCTCLString);
  int operator&gt;=(const CTCLString&amp; aCTCLString);
  int operator&lt;=(const CTCLString&amp; aCTCLString);

  Tcl_DString&amp; getString();
  CTCLString&amp; Append (const std::string&amp; rString, Int_t nLength=-1);
  CTCLString&amp; Append (const CTCLString&amp;  rString, Int_t nLength=-1);
  CTCLString&amp; Append (Tcl_DString&amp;       pString, Int_t nLength=-1);
  CTCLString&amp; Append (const char*        pString, Int_t nLength=-1);
  CTCLString&amp; AppendElement (const Tcl_DString*      pRhs);
  CTCLString&amp; AppendElement (const CTCLString&amp;       rRhs);
  CTCLString&amp; AppendElement (const std::string&amp;      rRhs);
  CTCLString&amp; AppendElement (const char*             pRhs);
  CTCLString&amp; AppendElement(DFloat_t value, const char* pFormat = "%f");
  CTCLString&amp; AppendElement(long value, const char* pFormat = "%i");

  CTCLString&amp; StartSublist ()  ;
  CTCLString&amp; EndSublist ()  ;
  UInt_t  Length () const ;
  CTCLString&amp; Truncate (UInt_t nNewLength)  ;
  Bool_t isCommand () const  ;

  Bool_t Match (const char*       pPattern) const;
  Bool_t Match (std::string&amp;      rPattern) const;
  Bool_t Match (const CTCLString&amp; rPattern) const;

  operator const char* () const;
  operator std::string () const;
  operator Tcl_DString* ();
};
    </programlisting>


    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The Tcl API provides a dynamic string type <type>Tcl_DString</type>.
            For many purposes, the C++ <type>std::string</type> is sufficient, however
            the <type>Tcl_DString</type> list building functions are unmatched in
            <type>std::string</type>.  <classname>CTCLString</classname> is an object oriented
            wrapping of a <type>Tcl_DString</type>
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
            <programlisting>
<type>CTCLString</type> ();
<type>CTCLString</type> (const <type>char</type>* <parameter>pString</parameter>) ;
<type>CTCLString</type>(const <type>std::string</type>&amp; <parameter>rString</parameter>);
<type>CTCLString</type>(const <type>Tcl_DString</type>&amp; <parameter>rString</parameter>);
<type>CTCLString</type> (const <type>CTCLString</type>&amp; <type>aCTCLString</type> );
            </programlisting>
            </para>
            <para>
                Constructs a <classname>CTCLString</classname> object.  With the exception
                of the first constructor, which produces an empty string, all of these
                constructors initialize the contents of the underlying
                <classname>Tcl_DString</classname> with the string representation of their
                parameter.
            </para>
            <para>
            <programlisting>
<type>CTCLString</type>&amp; <function>operator=</function> (const <type>CTCLString</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            Supports assignment to a <classname>CTCLString</classname> from another;
            <parameter>rhs</parameter>.
        </para>
        <para>
        <programlisting>
<type>int</type> <function>operator==</function> (const <type>CTCLString</type>&amp; <parameter>rhs</parameter>);
<type>int</type> <function>operator!=</function> (const <type>CTCLString</type>&amp; <parameter>rhs</parameter>);
<type>int</type> <function>operator&gt;</function> (const <type>CTCLString</type>&amp; <parameter>rhs</parameter>);
<type>int</type> <function>operator&lt;</function> (const <type>CTCLString</type>&amp; <parameter>rhs</parameter>);
<type>int</type> <function>operator&gt;=</function>(const <type>CTCLString</type>&amp; <parameter>rhs</parameter>);
<type>int</type> <function>operator&lt;=</function>(const <type>CTCLString</type>&amp; <parameter>rhs</parameter>);
        </programlisting>
        </para>
        <para>
            Relational operators provide for lexicographic copmarisons between the object
            and <parameter>rhs</parameter> which is another <classname>CTCLString</classname>.
        </para>
        <para>
        <programlisting>
<type>Tcl_DString</type>&amp; <function>getString</function>();
        </programlisting>
        </para>
        <para>
            Returns a reference tothe underlying <type>Tcl_DString</type> of the
            object.
        </para>
        <para>
        <programlisting>
<type>CTCLString</type>&amp; <function>Append</function> (const <type>std::string</type>&amp; <parameter>String</parameter>,
                  <type>Int_t</type> <parameter>nLength</parameter>=<literal>-1</literal>);
<type>CTCLString</type>&amp; <function>Append</function> (const <type>CTCLString</type>&amp; <parameter>String</parameter>,
                  <type>Int_t</type> <parameter>nLength</parameter>=<literal>-1</literal>);
<type>CTCLString</type>&amp; <function>Append</function> (<type>Tcl_DString</type>&amp;       <parameter>String</parameter>,
                  <type>Int_t</type> <parameter>nLength</parameter>=<literal>-1</literal>);
<type>CTCLString</type>&amp; <function>Append</function> (const <type>char</type>*            <parameter>String</parameter>,
                  <type>Int_t</type> <parameter>nLength</parameter>=<literal>-1</literal>);
        </programlisting>
        </para>
        <para>
            Appends a section of <parameter>String</parameter> to the
            <classname>CTCLString</classname> that is being built up.
            The first <parameter>nLength</parameter> characters are appended.
            if <parameter>nLength</parameter> is <literal>-1</literal> then
            all <parameter>String</parameter> is appended.
        </para>
        <para>
        <programlisting>
<type>CTCLString</type>&amp; <function>AppendElement</function> (const <type>Tcl_DString</type>*  <parameter>item</parameter>);
<type>CTCLString</type>&amp; <function>AppendElement</function> (const <type>CTCLString</type>&amp;   <parameter>item</parameter>);
<type>CTCLString</type>&amp; <function>AppendElement</function> (const <type>std::string</type>&amp;  <parameter>item</parameter>);
<type>CTCLString</type>&amp; <function>AppendElement</function> (const <type>char*</type>         <parameter>item</parameter>);
<type>CTCLString</type>&amp; <function>AppendElement</function>(<type>DFloat_t</type> <parameter>item</parameter>,
                         const <type>char*</type> <parameter>pFormat</parameter> = <literal>"%f"</literal>);
<type>CTCLString</type>&amp; <function>AppendElement</function>(<type>long</type>     <parameter>item</parameter>,
                         const <type>char*</type> <parameter>pFormat</parameter> = <literal>"%i"</literal>);
        </programlisting>
        </para>
        <para>
            Appends <parameter>item</parameter> as a list element to the end of the
            string.  If necessary quotation is performed to ensure the item is treated as a
            single list element.  The <parameter>pFormat</parameter> parameter
            controls the conversion of non string data types to a string and is of the form
            of any control sequence used by sprintf.  For example
            <literal>"i = %d"</literal> could be used to convert an integer to a label
            and its value which would be appended to the string as e.g.
            <literal>{i = 1234}</literal>
        </para>
        <para>
        <programlisting>
<type>CTCLString</type>&amp; <function>StartSublist</function> ()  ;
<type>CTCLString</type>&amp; <function>EndSublist</function> ()  ;
        </programlisting>
        </para>
        <para>
            Used in conjuntion with <function>AppendElement</function> these
            start and end sublists which are list elements that consist of lists.
            Sublists can be nested to any depth.
            For example:
            <programlisting>
    CTCLString s;
    s.AppendElement("a");
    s.StartSublist();
    s.AppendElement("b");
    s.AppendElement("c");
    s.StartSublist();
    s.AppendElement("d");
    s.AppendElement("e");
    s.EndSublist();
    s.AppendElement("f");
    s.EndSublist();
    s.AppendElement("g");
            </programlisting>
        Would make the <varname>s</varname> contain the string
        <literal>"a {b c {d e} f} g"</literal>
        </para>
        <para>
        <programlisting>
<type>UInt_t</type>  <function>Length</function>() const ;
        </programlisting>
        </para>
        <para>
            Returns the number of characters in the string.
        </para>
        <para>
        <programlisting>
CTCLString&amp; Truncate (UInt_t nNewLength)  ;
        </programlisting>
        </para>
        <para>
            Truncates the string to the first <parameter>nNewLength</parameter>
            characters.
        </para>
        <para>
        <programlisting>
<type>Bool_t</type> <function>isCommand</function> () const  ;
        </programlisting>
        </para>
        <para>
            Analyzes the string and returns <literal>kfTRUE</literal> if the
            string is a 'well formed command'.  Note that a well formed command
            may still have syntax and execution errors.  This just ensures that
            a string has a balanced set of quoting characters.
        </para>
        <para>
        <programlisting>
<type>Bool_t</type> <function>Match</function> (const <type>char</type>*           <parameter>Pattern</parameter>) const;
<type>Bool_t</type> <function>Match</function> (<type>std::string</type>&amp;      <parameter>Pattern</parameter>) const;
<type>Bool_t</type> <function>Match</function> (const <type>CTCLString</type>&amp; <parameter>Pattern</parameter>) const;
        </programlisting>
        </para>
        <para>
            Returns <literal>kfTRUE</literal> if the contents of the string matches the
            <parameter>Pattern</parameter>
            parameter.  The <parameter>Pattern</parameter> parameter can contain all of the
            wildcards in <firstterm>glob</firstterm> style pattern matching.  See
            REFERENCES below for moer information about glob style matching.
        </para>
        <para>
        <programlisting>
operator const char* () const;
operator std::string () const;
operator Tcl_DString* ();
    </programlisting>
        </para>
        <para>
            These operators are implicit and explicit type conversion operators that
            allow a <classname>CTCLString</classname> object to be treated as a
            <type>char*</type> pointing to a null terminated string, a
            <type>std::string</type> object, or a <type>Tcl_DString</type> pointer.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
Tcl_DStringAppend(3tcl),
Tcl_DStringAppendElement(3tcl),
Tcl_DStringEndSublist(3tcl),
Tcl_DStringFree(3tcl),
Tcl_DStringGetResult(3tcl),
Tcl_DStringInit(3tcl),
Tcl_DStringLength(3tcl),
Tcl_DStringResult(3tcl),
Tcl_DStringSetLength(3tcl),
Tcl_DStringStartSublist(3tcl)
        </para>
    </refsect1>
    <refsect1>
        <title>REFERENCES</title>
        <para>
            <programlisting>
J.K. Ousterhout <parameter>Tcl and the Tk Toolkit</parameter>
Addison-Wesley Professional Computing Series 1994 see section 9.2
            </programlisting>
        </para>
    </refsect1>
</refentry>



<refentry id="manpage.CTCLTimer">
    <refmeta>
        <refentrytitle>CTCLTimer</refentrytitle>
        <manvolnum>3daq</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>CTCLTimer</refname>
        <refpurpose>
            Abstract base class for C++ objects attached to timer events.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
    <programlisting>
#include &lt;TCLTimer.h&gt;
...
class CTCLTimer  : public CTCLInterpreterObject
{
public:
  CTCLTimer ();
  CTCLTimer(CTCLInterpreter* pInterp, UInt_t nMsec = 0);
  virtual ~CTCLTimer ( );


  Tk_TimerToken getToken() const;
  UInt_t getMsec() const;
  Bool_t IsSet() const;

  virtual   void operator() ()   = 0;

  void Set ()  ;
  void Set(UInt_t nms);
  void Clear ()  ;
};


    </programlisting>
    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            Tcl/Tk provide a mechanism for scheduling functions to be executed
            after a time delay specified in milliseconds.   The <classname>CTCLTimer</classname>
            class is an abstract base class that provides an interface into the API
            for that facility.  To use <classname>CTCLTimer</classname> you must
            create a class derived from <classname>CTCLTimer</classname> that
            overrides and implement the <function>operator()</function> function.
            Create an object from the resulting function class.  Use the object's
            <function>Set</function> and <function>Clear</function> members to schedule
            or cancel a scheduled execution.  The code fragment
            example below shows how to do this
            to create a class that periodically emits the text "Tick" to stderr.
            Many #include directives are missing for brevity.
            <programlisting>
// Interface to <classname>Ticker</classname> normally goes in a header.
class Ticker : public CTCLTimer
{
public:
    Ticker(CTCLInterpreter* pInterp, int seconds);
    virtual ~Ticker();

    virtual void operator()();
};
...
// Implementation of <classname>Ticker</classname> normally goes in a .cpp

// Constructor of Ticker:

Ticker::Ticker(int seconds) :
    CTCLTimer(pInterp, seconds*1000)
{
    Set();                   // Schedule first one.
}
// Destructor.. chain to base class.
Ticker::~Ticker() {}

// called when timer goes off:
void
Ticker::operator()() {
    cerr &lt;&lt; "Tick\n";
    Set();                 // Schedule next one.
}
...


Ticker Tick(pInterp, 1);  // Tick every second.

            </programlisting>
        </para>
    </refsect1>
    <refsect1>
        <title>METHODS</title>
        <para>
        <programlisting>
<function>CTCLTimer</function> ();
<function>CTCLTimer</function>(<type>CTCLInterpreter</type>* <parameter>pInterp</parameter>,
          <type>UInt_t</type> <parameter>nMsec</parameter> = <literal>0</literal>);
          </programlisting>
          </para>
          <para>
            Construct timer objects.  The first form of the constructor creates a timer
            object that must be later bound into an interpreter via a call to
            <classname>CTCLInterpreterObject</classname>::<function>Bind</function>.
            The seconf form of the contructor creates a timer object that is already
            bound to <parameter>pInterp</parameter> and has an initial schedule delay
            of <parameter>nMsec</parameter>.
          </para>
          <para>
          <programlisting>
  Tk_TimerToken getToken() const;
  UInt_t getMsec() const;
          </programlisting>
          </para>
          <para>
            These two members access internal state of the object.
            <function>getToken</function> returns the <type>Tk_TimerToken</type>
            associated with the timer object.  This is the Tcl/Tk token that
            identifies the timer request to the interpreter.
            <function>getMsec</function> retrieves the current value of the delay parameter
            in milliseconds.
          </para>
          <para>
          <programlisting>
  virtual   void operator() ()   = 0;
        </programlisting>
        </para>
        <para>
            This function must be overidden and implemented in concrete timer classes.
            See the example in DESCRIPTION above.
        </para>
        <para>
        <programlisting>

  void Set ()  ;
  void Set(UInt_t nms);
  Bool_t IsSet() const;
        </programlisting>
        </para>
        <para>
            <function>Set</function> schedules the object for execution.  If
            <parameter>nms</parameter> is provided it is saved as the scheduling
            parameter and determines the delay
            in milliseconds before <function>operator()</function> is
            next called.  If not provided, the most recently used delay will be
            used again.
        </para>
        <para>
            <function>IsSet</function> returns <literal>kfTRUE</literal> if the
            timer is currently pending, or <literal>kfFALSE</literal> if no pending
            timer request is active.
        </para>
        <para>
        <programlisting>
  void Clear ()  ;
        </programlisting>
        </para>
        <para>
           If a Timer request is pending, cancels it.  If no timer request is pending,
            this function does nothing, and does not report an error.
        </para>
    </refsect1>
    <refsect1>
        <title>SEE ALSO</title>
        <para>
CTCLInterpreterObject(3)
        </para>
    </refsect1>
    <refsect1>
        <title>REFERENCES</title>
        <para>
            <programlisting>
Musser, Derge, Saini: <parameter>STL Tutorial and Reference Guide</parameter>
Addison-Wesley Professional Computing Series; 2001 ISBN 0-201-37923-6
See section 2.4 for a description and discussion of function objects.
            </programlisting>
        </para>
    </refsect1>
</refentry>




    <refentry id="manpage.thread">
      <refmeta>
         <refentrytitle>Thread</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>Thread</refname>
	 <refpurpose>Abstract base class for thread objects.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;Thread.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>Thread</classname></ooclass>
            <constructorsynopsis>
                <methodname>Thread()</methodname>
                <void />
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>Thread</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~Thread</methodname>
                                             <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>detach</methodname>
                                 <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>unsigned long</type> <methodname>getId</methodname>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>start</methodname>
                                  <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setName</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>join</methodname>
                                  <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type> <methodname>getName</methodname>
                                         <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>run</methodname>
                                             <void /> <modifier>= 0</modifier>
            </methodsynopsis>

         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            <classname>Thread</classname>
            is an abstract base class that can be used to create threads.
            To make a thread you will normally derive a class from
            <classname>Thread</classname>
            and write the
            <methodname>run</methodname>
            method to implement the thread's code.
         </para>
         <para>
            A thread can then be created like any other object.
            The
            <methodname>start</methodname>
            method schedules the thread's
            <methodname>run</methodname>
            member for execution
         </para>
         <para>
            Threads can block on the completion of a thread via the
            <methodname>join</methodname> method.  
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
         <formalpara>
            <title>Constructors</title>
            <para>
                Constructors create a thread.  The thread is not scheduled
                for execution until the
                <methodname>start</methodname>
                method is called.
                Threads can have an optional thread name.
            </para>
         </formalpara>
        <constructorsynopsis>
            <methodname>Thread()</methodname>
            <void />
        </constructorsynopsis>
        <para>
            Constructs an anonymous thread.
        </para>
        <constructorsynopsis>
            <methodname>Thread</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructs a named thread.
        </para>
        <formalpara>
            <title>Thread identification</title>
            <para>
                Threads are identified by an optional name, which need not
                be unique, and a unique identifier (thread id), that is
                assigned by the underlying operating systemn.
            </para>
        </formalpara>
        <methodsynopsis>
            <type>unsigned long</type> <methodname>getId</methodname>
        </methodsynopsis>
        <para>
            Returns the thread id.  If the thread has not yet been started,
            <literal>-1</literal>
            is returned regardless of the thread.  A thread only gets an id
            when it has been started.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>start</methodname>
                              <void />
        </methodsynopsis>
        <para>
            Starts a thread.             
            A thread id is allocated and the
            <methodname>run</methodname>
            method is scheduled for execution.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>setName</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Modifies the name of the thread.
        </para>
        <methodsynopsis>
            <type>int</type> <methodname>detach</methodname>
                             <void />
        </methodsynopsis>
        <para>
            Detaches an executing thread.   If the thread has not
            started, this returns
            <literal>-1</literal>.
            Detaching a thread indicates that any operating system storage
            (not object storage) associated with a thread can be released when
            the thread exits.  If the thread does not
            detach, it is necessary to
            <methodname>join</methodname>
            the thread to fully release its storage.
        </para>
        <para>
            On success,
            <literal>0</literal>
            should be returned, otherwise a value that is one of the values
            in
            <filename>errno.h</filename> is returned to describe why
            the call failed.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>join</methodname>
                              <void />
        </methodsynopsis>
        <para>
            <methodname>join</methodname>
            blocks until the thread exits.   When the thread does exit,
            thread specific storage is reclaimed.  Note that if a thread
            has calledis 
            <methodname>detach</methodname>
            it is not clear clear wht clear what this member will do.
        </para>
        <methodsynopsis>
            <type>std::string</type> <methodname>getName</methodname>
                                     <void /><modifier>const</modifier>
        </methodsynopsis>
        <methodsynopsis>
            <modifier>virtual</modifier> <type>void</type>
                                         <methodname>run</methodname>
                                         <void /> <modifier>= 0</modifier>
        </methodsynopsis>
        <para>
            You must implement this function to provide a concrete
            <classname>Thread</classname>
            run-time behavior.
        </para>
      </refsect1>

   </refentry>

    <refentry id="manpage.synchronizable">
      <refmeta>
         <refentrytitle>Synchronizable</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>Synchronizable</refname>
	 <refpurpose>Wait queue for threads</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;Synchronizable.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>Synchronizable</classname></ooclass>
            <constructorsynopsis>
                <methodname>Synchronizable</methodname><void />
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~Synchronizable()</methodname>
                                             <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>waitFor</methodname>
                                  <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>waitFor</methodname>
                <methodparam>
                    <type>long</type> <parameter>timeout</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>waitFor</methodname>
                <methodparam>
                    <type>long</type> <parameter>seconds</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>nanoseconds</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>notify</methodname>
                                  <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>notifyAll</methodname>
                                  <void />
            </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            This class implements a wait queue for threads.  A thread can
            place itself in a wait queue and then be awakened by another thread,
            or by a timeout on the wait itself.
         </para>
         <para>
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
        <constructorsynopsis>
            <methodname>Synchronizable</methodname><void />
        </constructorsynopsis>
        <para>
            Creates a thread wait queue.
        </para>
        <destructorsynopsis>
            <modifier>virtual</modifier> <methodname>~Synchronizable()</methodname>
                                         <void />
        </destructorsynopsis>
        <para>
            Destroys a thread wait queue.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>waitFor</methodname>
                              <void />
        </methodsynopsis>
        <para>
            Waits for an unbounded length of time.  The method completes
            when either the calling thread is at the head of the wait queue
            and another thread invokes the
            <methodname>notify</methodname>, member or another thread invokes
            the
            <methodname>notifyAll</methodname> member function.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>waitFor</methodname>
            <methodparam>
                <type>long</type> <parameter>timeout</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Waits as above, but for at most
            <parameter>timeout</parameter> seconds.  In the current implementation,
            it is not possible to distinguish between a wait that times out
            and one that completes due to notification.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>waitFor</methodname>
            <methodparam>
                <type>long</type> <parameter>seconds</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>nanoseconds</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Waits as above, but for <parameter>seconds</parameter> seconds and
            at least an additional <parameter>nanoseconds</parameter> nanoseconds,
            or until notification awakens the thread.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>notify</methodname>
                              <void />
        </methodsynopsis>
        <para>
            Wakes up the thread that least recently entered one of the wait
            functions and has not yet timed out.
        </para>
        <methodsynopsis>
            <type>void</type> <methodname>notifyAll</methodname>
                              <void />
        </methodsynopsis>
        <para>
            Awakens all of the threads that are currently blocked on this
            object.
        </para>
      </refsect1>
   </refentry>


    <refentry id="manpage.syncguard">
      <refmeta>
         <refentrytitle>SyncGuard</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>SyncGuard</refname>
	 <refpurpose>Provide Critical Regions, Monitors</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;SyncGuard.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>SyncGuard</classname></ooclass>
            <constructorsynopsis>
                <methodname>SyncGuard()</methodname>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>SyncGuard</methodname>
                <methodparam>
                    <type>Synchronizable&amp;</type> <parameter>syncer</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>SyncGuard</methodname>
                <methodparam>
                    <type>Synchronizable&amp;</type> <parameter>syncer</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type> <parameter>tryonly</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~SyncGuard</methodname>
                                             <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>dshwrapthread_t</type> <methodname>getOwner</methodname>
                                             <void />
            </methodsynopsis>

         </classsynopsis>
        <programlisting>
Macros:
#define sync_self
#define sync_begin(s)
#define sync_begin2(t,s)
#define sync_end


#define sync_trybegin(s)
#define sync_trybegin2(t,s)
#define sync_tryend

#define sync_global_begin(t)
#define sync_global_end

        </programlisting>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            The
            <classname>SyncGuard</classname> class uses a
            <classname>Synchronizable</classname> object to create
            a critical region, or monitor.  Both of these synchronization
            primitives are mechanisms that ensure that only one thread can
            execute a guarded code segment at a time.
         </para>
         <para>
            Creating a
            <classname>SynchGuard</classname>
            on a synchronizable object locks the guard.  Destroying the
            object releases the guard.  You can create more than one
            <classname>SyncGuard</classname> on a single
            <classname>Synchronizable</classname> object, and typically will.
         </para>
         <para>
            The simplest use of
            <classname>SynchGuard</classname> is via its macros.
         </para>
         <para>
            The NSCLDAQ threading system creates a global
            <classname>Synchronizable</classname>
            object that is used by all of the locking macros and constructors that
            don't take an explicit parameter.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <constructorsynopsis>
                <methodname>SyncGuard()</methodname>
            </constructorsynopsis>
            <para>
                Constructs a synchronization guard that uses the global
                <classname>Syncrhonizable</classname> to perform
                the synchronization.
            </para>
            <constructorsynopsis>
                <methodname>SyncGuard</methodname>
                <methodparam>
                    <type>Synchronizable&amp;</type> <parameter>syncer</parameter>
                </methodparam>
            </constructorsynopsis>
            <para>
                Creates a
                <classname>SyncGuard</classname>
                that uses <parameter>syncer</parameter>
                as its synchronization object.
            </para>
            <constructorsynopsis>
                <methodname>SyncGuard</methodname>
                <methodparam>
                    <type>Synchronizable&amp;</type> <parameter>syncer</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type> <parameter>tryonly</parameter>
                </methodparam>
            </constructorsynopsis>
            <para>
                Same as above, however if <parameter>tryonly</parameter> is
                true, and <parameter>syncer</parameter> is already locked, the thread continues
                execution.
            </para>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~SyncGuard</methodname>
                                             <void />
            </destructorsynopsis>
            <para>
                Destroys the guard, releasing the synchronization object.
            </para>
            <methodsynopsis>
                <type>dshwrapthread_t</type> <methodname>getOwner</methodname>
                                             <void />
            </methodsynopsis>
            <para>
                Returns the id of the thread that owns the synchronization
                object used by a synchronization guard.  One use of this is to
                do a tryonly creation and then check to see if the running thread
                owns the object (indicating the try succeeded).
            </para>
         <formalpara>
            <title>
                Macros
            </title>
            <para>
                The macros below simplify the creation of critical segments
                of code.
            </para>
         </formalpara>
         <funcsynopsis>
            <funcprototype><funcdef>void <function>sync_self</function></funcdef>
                           <void />
            </funcprototype>
         </funcsynopsis>
         <para>
            This macro is intended for use within an object that is
            derived from a
            <classname>Synchronizable</classname>.  It locks the
            current object.
         </para>
         <funcsynopsis>
            <funcprototype><funcdef>void <function>sync_begin</function></funcdef>
                <paramdef>
                    <parameter>Synchronizable&amp; s</parameter>
                </paramdef>
            </funcprototype>
         </funcsynopsis>
         <para>
            Starts a a critical region that uses
            <parameter>s</parameter>
            to synchronize access.
        </para>
        <funcsynopsis>
            <funcprototype><funcdef>void<function>sync_begin2</function></funcdef>
            <paramdef>
                <parameter>t</parameter>
            </paramdef>
            <paramdef>
                <parameter>Synchronizable&amp; s</parameter>
            </paramdef>
            </funcprototype>
        </funcsynopsis>
        <para>
            Same as <function>sync_begin</function> but
            <parameter>t</parameter> is appended to the name of the temporary
            <classname>Syncrhonizable</classname> the macro creates.
        </para>
        <funcsynopsis>
            <funcprototype><funcdef>void <function>sync_end</function></funcdef>
                                         <void />
            </funcprototype>
        </funcsynopsis>
        <para>
            Marks the end of a critical section that was begun with
            one of the sync macros above.
        </para>
        <funcsynopsis>
            <funcprototype><funcdef> void <function>sync_trybegin</function></funcdef>
            <paramdef><parameter>Synchronizable&amp; s</parameter></paramdef>
            </funcprototype>
        </funcsynopsis>
        <para>
            This macro creates a temporary
            <classname>SynchGuard</classname> object constructed on
            <parameter>s</parameter>.
            Non-blocking access is to the guard is attempted.  If successful,
            the code that follows the macro up until the next
            <function>sync_tryend</function> macro invocation is executed.
            If access to the guard could not be gotten without blocking, the
            code will not be executed.
        </para>
        <funcsynopsis>
            <funcprototype><funcdef> void <function>sync_trybegin2</function></funcdef>
            <paramdef>
                <parameter>t</parameter>
            </paramdef>
            <paramdef>
                <parameter>Synchronizable&amp; s</parameter>
            </paramdef>
            </funcprototype>
        </funcsynopsis>
        <para>
            This macro behaves the same as
            <function>sync_trybegin2</function>, however the parameter
            <parameter>t</parameter> is used to construct the name of the
            <classname>SyncGuard</classname> object used by the macro.
        </para>
        <funcsynopsis>
            <funcprototype><funcdef>void <function>sync_tryend</function></funcdef>
                        <void />
            </funcprototype>
        </funcsynopsis>
        <para>
           Marks the end of a block of code that was synchronized using the
           <function>sync_trybegin*</function> macros.
        </para>
        <funcsynopsis>
            <funcprototype><funcdef>void <function>sync_global_begin</function></funcdef>
            <paramdef>
                <parameter>t</parameter>
            </paramdef>
	    </funcprototype>
        </funcsynopsis>
        <para>
            The NSCLDAQ thread synchronization library creates a global
            <classname>Synchronizable</classname>
            object.  This can do process wide synchronization on  a coarse grained
            level.
            <function>sync_global_begin</function> constructs a
            temporary
            <classname>SyncGuard</classname> on that object and locks it.
            The <parameter>t</parameter> paramter is used to construct the name
            of the guard object.
        </para>
        <funcsynopsis>
            <funcprototype><funcdef>void sync_global_end</funcdef>
            <void />
	    </funcprototype>
        </funcsynopsis>
        <para>
            Destroys the
            <classname>SyncGuard</classname> created by lexically most recent
            <function>sync_global_begin</function> macro.  This releases the
            synchronization object for other threads.
        </para>
      </refsect1>
   </refentry>




<refentry id="manpage.url">
  <refmeta>
     <refentrytitle>URL</refentrytitle>
     <manvolnum>3daq</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>URL</refname>
 <refpurpose>Parse Uniform Resource Identifiers (URI)</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
     <programlisting>
#include &lt;URL.h&gt;
     </programlisting>
     <classsynopsis>
        <ooclass><classname>URL</classname></ooclass>
        <constructorsynopsis>
            <methodname>URL</methodname>
            <methodparam>
                <type>std::string</type> <parameter>uri</parameter>
            </methodparam>
        </constructorsynopsis>
        <constructorsynopsis>
            <methodname>URL</methodname>
            <methodparam>
                <modifier>const</modifier> <type>URL&amp;</type> <parameter>rhs</parameter>
            </methodparam>
        </constructorsynopsis>
        <methodsynopsis>
            <type>URL&amp;</type> <methodname>operator=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>URL&amp;</type> <parameter>url</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>bool</type>
            <methodname>operator==</methodname>
            <methodparam>
                <modifier>const</modifier> <type>URL&amp;</type> <parameter>rhs</parameter>
            </methodparam>
            <modifier> const</modifier>
        </methodsynopsis>
        <methodsynopsis>
            <type>bool</type>
            <methodname>operator!=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>URL&amp;</type> <parameter>rhs</parameter>
            </methodparam>
            <modifier> const</modifier>
        </methodsynopsis>
        <methodsynopsis>
            <type>std::string</type> <methodname>getProto</methodname>
                                     <void /> <modifier>const</modifier>
        </methodsynopsis>
        <methodsynopsis>
            <type>std::string</type>
            <methodname>getHostName</methodname>
            <void /> <modifier>const</modifier>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>getPort</methodname>
                             <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>std::string</type> <methodname>getPath</methodname>
                    <void /><modifier>const</modifier>
        </methodsynopsis>
        <methodsynopsis>
            <type>std::string</type> <methodname>operator std::string</methodname>
                                     <void /> <modifier>const</modifier>
        </methodsynopsis>
     </classsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>Description</title>
     <para>
        Objects of this class parse Universal Resource Identifiers (URIs).
        Methods of this class return the components of a URI.
     </para>
  </refsect1>
  <refsect1>
     <title>
        Public member functions
     </title>
        <formalpara>
            <title>Constructors</title>
            <para>
            </para>
        </formalpara>
        <constructorsynopsis>
            <methodname>URL</methodname>
            <methodparam>
                <type>std::string</type> <parameter>uri</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructs a
            <classname>URL</classname>
            object by parsing <parameter>uri</parameter>.
            The constructor may throw a
            <classname>CURIFormatException</classname> exception.
            see Exceptions below for more information.
        </para>
        <constructorsynopsis>
            <methodname>URL</methodname>
            <methodparam>
                <modifier>const</modifier> <type>URL&amp;</type> <parameter>rhs</parameter>
            </methodparam>
        </constructorsynopsis>
        <para>
            Constructs a
            <classname>URL</classname>
            object that is an exact duplicate of the
            <parameter>rhs</parameter>
            object.  
        </para>
        <formalpara>
            <title>Other canonical functions.</title>
            <para>
                The
                <classname>URL</classname>
                class implements assignment, and comparison for equality and
                inequality.  Equality holds if all the components of the parsed
                URI are identical.
                Inequality holds if equality does not hold.
            </para>
        </formalpara>
        <formalpara>
            <title>Other methods</title>
            <para>
            </para>
        </formalpara>
        <methodsynopsis>
            <type>std::string</type> <methodname>getProto</methodname>
                                     <void /> <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the protocol component of the URI. The protocol
            component describes the mechanism  used to access the resource.
        </para>
        <methodsynopsis>
            <type>std::string</type>
            <methodname>getHostName</methodname>
            <void /> <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the hostname component of the URI.  The hostname describes
            where in the network the resource described by the URI is located.
        </para>
        <methodsynopsis>
            <type>int</type> <methodname>getPort</methodname>
                             <void />
        </methodsynopsis>
        <para>
            Returns the port number part of the URI.  While port numbers are
            optional on real URI's they are not optional for NSCL URIs.
            The port determines where the server for the resource is listening
            for connections.
        </para>
        <methodsynopsis>
            <type>std::string</type> <methodname>getPath</methodname>
                    <void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the path component of the URI.  The path component tells
            the client and server where within the namespaces for the protocol
            the component is located.  The path component is optional.  If not
            provided, it defaults to <literal>/</literal>.
        </para>
        <methodsynopsis>
            <type>std::string</type> <methodname>operator std::string</methodname>
                                     <void /> <modifier>const</modifier>
        </methodsynopsis>
        <para>
            Re-constructs and returns the stringified URL.  This should be very
            close to the string that was used to construct this object, or the
            object from which the object was copied.
        </para>
  </refsect1>
  <refsect1>
     <title>Exceptions</title>
     <para>
        Not all strings are valid URIs.  If a <classname>URL</classname> object
        is constructed with a string that is not a valid URI, the constructor
        will throw a
        <classname>CURIFormatException</classname>.
        <classname>CURIFormatException</classname> is derived from the
        <classname>CExeption</classname> common exception base class.
     </para>
     <para>
        <link linkend="chapter.exception">The NSCL Exception class library</link>
        chapter describes the exception class hierarchy, how to use it and
        its common set of interfaces.
        <link linkend="manpage.cexception">The <classname>CException</classname></link> reference
        page describes the <classname>CException</classname> class.
        <link linkend="manpage.curiformatexception">The <classname>CURIFormatException</classname></link>
        reference page describes the
        <classname>CUIRFormatException</classname>
        class.
     </para>
  </refsect1>
</refentry>
    
            

    <refentry id="manpage.CPortManager">
      <refmeta>
         <refentrytitle>CPortManager</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CPortManager</refname>
	 <refpurpose>Provide a C++ interface to the server port manager daemon.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;config.h&gt;
#include &lt;CPortManager.h&gt;
#include &lt;CPortManagerException.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CPortManager</classname></ooclass>
            <constructorsynopsis>
                <methodname>CPortManager</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>host</parameter>
                                             <initializer>string("localhost")</initializer>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CPortManager</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>host</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>Port</parameter>
                </methodparam>
            </constructorsynopsis>
            <methodsynopsis>
                <type>int</type>
                <methodname>allocatePort</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>application</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                    <type>std::vector&lt;portInfo&gt;</type> <methodname>getPortUsage</methodname>
                    <void />
            </methodsynopsis>

         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
             
       <classname>CPortManager</classname>
       provides  a  C++ application programming interface into the NSCL
       port manager server.  This class serves as a proxy for communication with port
       management  servers.  Once you have created a
       <classname>CPortManager</classname> object, you can use
       it to allocate ports (if the server is local), and to list port usage  of  any
       server on the network.
         </para>
         <para>
       Note  that  members of this class can throw exceptions of type
       <classname>CPortManagerException</classname>.
        See the <link linkend="manpage.CPortManagerException">CPortManagerException(3)</link> for
        more informationa bout that.
         </para>
         <para>
            To include the headers required you, or the Makefile skeleton you are using must
            have added the <filename>include</filename> subdirectory ofthe NSCLDAQ installation
            directory tree to the include paths for the compile e.g.:
            <literal>-I/usr/opt/daq/current/include</literal>.
         </para>
         <para>
            To link you must include the NSCL DAQ lib subdirectory in the library search path,
            link in the library and ensure that the shared library can be found at load time.
            For example:
            <programlisting>
-L/usr/opt/daq/current/lib \
-lPortManager \
-Wl,"-rpath=/usr/opt/daq/current/lib"
            </programlisting>
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
           <methodsynopsis>
                <methodname>CPortManager</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>host</parameter>
                                             <initializer>string("localhost")</initializer>
                </methodparam>
            </methodsynopsis>
           <para>
              Constructs a port manager interface object.  The object connects to the
              port manager running on the host <parameter>host</parameter>, using the
                default port (<literal>30000</literal>) to form the connection.  If the
                <parameter>host</parameter> parameter is omitted, it defaults to
                <literal>localhost</literal>
            </para>
            <methodsynopsis>
                <methodname>CPortManager</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>host</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>Port</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Constructs a port manager interfaceobject.  The object connects
                to the host manager running on <parameter>host</parameter> via the
                connection port <parameter>Port</parameter>.
            </para>
            <methodsynopsis>
                <type>int</type>
                <methodname>allocatePort</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>application</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Allocates a port from the port manager.  On success the return value is the
                port number allocated in local machine byte order.  Note that when interacting
                with the network functions, in general, this will have to be converted to network
                byte ordering.
            </para>
            <para>
                Once the port is allocated, it remains allocated until the program exits.
                This is because a connection will be held with the port manager and cannot
                be closed by the user.
            </para>
            <para>
                If a port could not be allocated (e.g. all are in use or the port manager could
                not be contacted, a <classname>CPortManagerException</classname> described
                in "Types and public data" below and completely in
                <link linkend="manpage.CPortManagerException">CPortManagerException</link>.
            </para>
            <methodsynopsis>
                    <type>std::vector&lt;portInfo&gt;</type> <methodname>getPortUsage</methodname>
                    <void />
            </methodsynopsis>
            <para>
                Returns a vector of <type>portInfo</type> structs that describes
                the current port allocations of the port allocator.  The most common use case
                for this is to locate a specific service offered by a remote port manager.
            </para>
            <para>
                If the interaction with the server failed,
                a <classname>CPortManagerException</classname> described
                in "Types and public data" below and completely in
                <link linkend="manpage.CPortManagerException">CPortManagerException</link>.
            </para>
      </refsect1>
      <refsect1>
         <title>Types and public data</title>
         <para>
            The set of port allocations is described by an STL vector of
            <type>portInfo</type> structs.  The <classname>std::vector</classname>
            is described in any C++ reference that contains a description of the Standard
            Template Library (STL).
         </para>
         <para>
            <type>portInfo</type> structs have the following fields:
            <segmentedlist>
                <segtitle>Type</segtitle>
                <segtitle>Name</segtitle>
                <segtitle>Description</segtitle>
                <seglistitem>
                    <seg><type>int</type></seg><seg><varname>s_Port</varname></seg>
                    <seg>
                        
                            The port number that this object describes. The port number is
                            provided in the byte order of the local system.   Note that when used
                            to provide a port number to Unix/Linux network functions in general
                            this number will have to be converted to network byte order.
                        
                    </seg>
                </seglistitem>
                <seglistitem>
                    <seg><type>std::string</type></seg><seg><varname>s_Application</varname></seg>
                    <seg>
                        
                            The name of the application that requested this port.  The application
                            name represents some service that is being offered.  Usually (but not
                            always), the application name and the <varname>s_User</varname> fields
                            together are unique  system wide.
                        
                    </seg>
                </seglistitem>
                <seglistitem>
                    <seg><type>std::string</type></seg><seg><varname>s_User</varname></seg>
                    <seg>
                        
                            The name of the user that was running the application that reserved
                            this port.  In the event that several users have run the same
                            application on a single system, this identifies which user ran
                            the application that requested this port.
                        
                    </seg>
                </seglistitem>
            </segmentedlist>
        </para>
        <para>
            <classname>CPortManagerException</classname> objects are thrown in most cases
            the library encounters an exception.
         </para>
      </refsect1>
      <refsect1>
         <title>Exceptions</title>
         <para>
            The <classname>CPortManagerException</classname> is thrown to inform the
            program of most errors dected by this API.  For more information about
            this exception, see:  <link linkend="manpage.CPortManagerException">CPortManagerException(3)</link>.
         </para>
      </refsect1>
      <refsect1>
         <title>EXAMPLES</title>
         <para>
            Allocates a port to <application>MyApplication</application>
         </para>
         <example>
            <title>Allocating a port with the port manager</title>
            <programlisting>
&hellip;
CPortManager pm;
int port;
try {
 port = pm.allocatePort("MyApplication");
 ListenOnPort(port);                      // Not shown for brevity
}
catch (CPortManagerException&amp; error) {
 cerr &lt;&lt; "Could not allocate a port: " &lt;&lt; error &lt;&lt; endl;
 exit(-1);
}
&hellip;

            </programlisting>
         </example>
         <para>
            Lists to cout the  port allocations on the system:
            ahost.nscl.msuedu
            
         </para>
         <example>
            <title>Listing the port allocatiosn on a system.</title>
            <programlisting>
    &hellip;
   CPortManager pm("ahost.nscl.msu.edu");
   vector&lt;CPortManager::portInfo&gt; info = pm.getPortUsage();
   for(int i =0; i &lt; info.size(); i++) {
      cout &lt;&lt; "Port " &lt;&lt; info.s_Port
           &lt;&lt; " allocated to " &lt;&lt; info.s_Application
           &lt;&lt; " run by " &lt;&lt; info.s_User &lt;&lt; endl;
   }
    &hellip;

            </programlisting>
         </example>
      </refsect1>
      <refsect1>
         <title>
            SEE ALSO
         </title>
	 <para>
            <link linkend="manpage.portAllocator">portAllocator(3tcl)</link>,
            <link linkend="manpage.CPortManagerException">CPortManagerException(3daq)</link>,
            <link linkend="manpage.DaqPortManager">DaqPortManager(1tcl)</link>
	 </para>
      </refsect1>
   </refentry>

    <refentry id="manpage.CPortManagerException">
      <refmeta>
         <refentrytitle>CPortManagerException</refentrytitle>
         <manvolnum>3daq</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CPortManagerException</refname>
	 <refpurpose>Report errors conditions in port manager transactions</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;config.h&lt;
#include &lt;histotypes.h&lt;
#include &lt;CPortManagerException.h&lt;


         </programlisting>
         <classsynopsis>
            <ooclass><classname>CPortManagerException</classname></ooclass>
            <constructorsynopsis>
                <methodname>CPortManagerException</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>host</parameter>
                </methodparam>
                <methodparam>
                    <type>Reason</type> <parameter>why</parameter>
                </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>doing</parameter>
                </methodparam>
            </constructorsynopsis>
            <methodsynopsis>
                <modifier>virtual const</modifier>
                <type>char*</type> <methodname>ReasonText</methodname>
                                   <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>Int_t</type>
                <methodname>ReasonCode</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier> <type>string</type>
                    <methodname>ReasonCodeToText</methodname>
                <methodparam>
                    <type>int</type> <parameter>code</parameter>
                </methodparam>
            </methodsynopsis>




         </classsynopsis>
         <funcsynopsis>
            <funcprototype>
                <funcdef><type>ostream&amp;</type>
                    <function>operator&lt;&lt;</function>
                </funcdef>
                <paramdef>
                    <type>ostream&amp;</type> <parameter>f</parameter>
                </paramdef>
                <paramdef>
                    
                    <type>const CPortManagerException&amp;</type> <parameter>e</parameter>
                </paramdef>
            </funcprototype>
         </funcsynopsis>

      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
       <classname>CPortManagerException</classname>
       is  an exception that can be thrown by the port manager
       class <classname>CPortManager</classname>
        see <link linkend="manpage.CPortManager">the man page for that class</link>).
        Since it  is  derived
       from
       <classname>CException</classname>,
       it can be caught as a generic error.  In addition to the base
       class members, the class supports insertion into an output stream.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
           <methodsynopsis>
                <methodname>CPortManagerException</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>host</parameter>
                </methodparam>
                <methodparam>
                    <type>Reason</type> <parameter>why</parameter>
                </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>doing</parameter>
                </methodparam>
            </methodsynopsis>
           <para>
                Constructs the exception.  <parameter>host</parameter> is the host that
                the object was connected to, or attempted to connect to when the
                error was detected.  <parameter>why</parameter>Is the reason for
                the exception. See "Types and public data" below for more information
                about the possible values the <type>Reason</type> type can take.
                <parameter>doing</parameter> provides context information that describes
                what the object was attempting to do when the error was detected.
            </para>
            <methodsynopsis>
                <modifier>virtual const</modifier>
                <type>char*</type> <methodname>ReasonText</methodname>
                                   <void /><modifier>const</modifier>
            </methodsynopsis>
            <para>
                Returns comprehensive human readable text that describes the
                reason this operation failed.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>Int_t</type>
                <methodname>ReasonCode</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <para>
                Returns the reason code.  The reason code is just the <type>Reason</type>
                cast to an integer.
            </para>
            <methodsynopsis>
                <modifier>static</modifier> <type>string</type>
                    <methodname>ReasonCodeToText</methodname>
                <methodparam>
                    <type>int</type> <parameter>code</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Converts a reason code into a text string that describes the reason.
            </para>
         <funcsynopsis>
            <funcprototype>
                <funcdef><type>ostream&amp;</type>
                    <function>operator&lt;&lt;</function>
                </funcdef>
                <paramdef>
                    <type>ostream&amp;</type> <parameter>f</parameter>
                </paramdef>
                <paramdef>
                     
                    <type>const CPortManagerException&amp;</type> <parameter>e</parameter>
                </paramdef>
            </funcprototype>
         </funcsynopsis>
         <para>
            Formats the exception object <parameter>e</parameter> and writes it to the
            output stream <parameter>f</parameter>. A reference to the output stream
            is returned allowing the normal sorts of cascading of the
            <function>operator&lt;&lt;</function> function.
         </para>
      </refsect1>
      <refsect1>
         <title>Types and public data</title>
         <para>
            <type>Reason</type>
            is an enumerated type that describes the actual error condition that
            was detected:
            <variablelist>
                <varlistentry>
                    <term>NoPorts</term>
                    <listitem>
                        <para>
                            When attempting to allocate a service port, thee daemon reported
                            that all available service ports in the block it is managing
                            are in use.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>NotLocal</term>
                    <listitem>
                        <para>
                            You are attempting to allocate a port on a remote
                            system.  Service ports can only be allocated by programs
                            running on the same system as the port manager daemon.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>ConnectionFailed</term>
                    <listitem>
                        <para>
                            An attempt to connect to the daemon failed.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
         </para>
      </refsect1>
      <refsect1>
         <title>EXAMPLES</title>
         <para>
       The  example  below catches an exception.  If the exception was thrown because
       of a Connection failure. it is just printed to cerr.   Otherwise,  The  reason
       text  is printed along with a message idicating that a port allocation failed.
         </para>
         <example>
            <title>Catching a CPortManagerException</title>
            <programlisting>
&hellip;
try {
&hellip;
}
catch (CPortManagerException&amp; e) {
  int why = e.ReasonCode();
  if((CPortManagerException::Reason)why ==
                  CPortManagerException::ConnectionFailed) {
     cerr &lt;&lt; e &lt;&lt; endl;
  }
  else {
     cerr &lt;&lt; "Port Allocation Failed: " &lt;&lt; e.ReasonText() &lt;&lt; endl;
  }
}

&hellip;
                
            </programlisting>
         </example>
      </refsect1>
      <refsect1>
         <title>
            SEE ALSO
         </title>
	 <para>
            <link linkend="manpage.portAllocator">portAllocator(3tcl)</link>,
            <link linkend="manpage.CPortManager">CPortManager(3daq)</link>,
            <link linkend="manpage.DaqPortManager">DaqPortManager(1tcl)</link>
            <link linkend="manpage.cexception">CException(3tcl)</link>
	 </para>
      </refsect1>
   </refentry>


</reference>
<reference>
<title>3tcl</title>

<refentry id="manpage.portAllocator">
  <refmeta>
     <refentrytitle>portAllocator</refentrytitle>
     <manvolnum>3tcl</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>portAllocator</refname>
     <refpurpose>Tcl API for the DaqPortManager daemon.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
package require portAllocator
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
::portAllocator create name <replaceable>?-hostname host? ?-port port</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
<replaceable>::name</replaceable> listPorts
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
<replaceable>::name</replaceable> allocatePort <replaceable>application</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
<replaceable>::name</replaceable> destroy
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        The
        <command>portAllocator</command>
        package provides access to the NSCL TCP/IP port management
       server.  It can be used by TCP/IP server applications t obtain a server listen
       port.   The package follows an object oriented model.  The application creates
       a
       <classname>portAllocator</classname>
       object, which stands as a proxy between the application and  a
       port  manager  server.   Using  this  object the application can allocated and
       deallocate ports, as well as request port allocation information.
     </para>
     <para>
       Once your application has finished interacting with a
       <classname>portAllocator</classname> object, it
       can  destroy  it.   If the application must hold a connection to the server in
       order to maintain one or more allocated ports, destruction of  the  requesting
       object will not result in that connection being closed, ensuring that the port will
       remain allocated.
     </para>
  </refsect1>
  <refsect1>
     <title>
	COMMANDS
     </title>
     <variablelist>
        <varlistentry>
            <term><command>::portAllocator create</command>
                  <replaceable>name ?-hostname host? ?-port port</replaceable></term>
            <listitem>
                <para>
              Creates  a port allocator with the specified name.  The optional
              <option>-hostname</option>
              option allows you to specify with which host you want the
              allocator  to communicate.
              If not supplied, this defaults to localhost.  The
              optional <option>-port</option>
                switch allows you to specify a port on which to connect.
              If not specified,the allocator will first attempt to read the port
              number from the file
              <filename>/var/tmp/daqportmgr/listen.port</filename>
              before  falling  back
              to port number 30000.
                </para>
                <para>
              The  command  returns  the fully qualified name of the allocator.  This
              name can be stored in a variable for later use (see EXAMPLES).
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><command><replaceable>::name</replaceable> listPorts</command></term>
            <listitem>
                <para>
              Returns a TCL formatted list that describes the  ports  that  are  cur?
              rently  allocated  by  the server.  Each element of the list is a three
              element sublist containing in order, the allocated port,  the  name  of
              the application holding the port, and the name of the user that is run?
              ning the application.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><command><replaceable>::name</replaceable> allocatePort
                <replaceable>application</replaceable></command></term>
            <listitem>
                <para>
              Attempts to allocate a port from the server.  Note  that  the  protocol
              only  allows  you to allocate ports from a server running on localhost.
              application is the name of the application under which you  would  like
              to register port ownership.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><command><replaceable>::name</replaceable> destroy</command></term>
            <listitem>
                <para>
              Destroys  a portAllocator.  If the portAllocator is holding open a
              connection to the server because the application  has  allocated  a  port,
              this connection will remain open.
                </para>
            </listitem>
        </varlistentry>
     </variablelist>
  </refsect1>
  <refsect1>
     <title>EXAMPLES</title>
     <para>
        The  example  below allocates a port from the localhost, and starts listening
       for connections.
     </para>
     <example>
        <title>Allocating a service port in Tcl</title>
        <programlisting>
package require portAllocator
set p [::portAllocator create local]
set port [$p allocatePort]
socket -server handleConnections $port
        </programlisting>
     </example>
     <para>
       The example below requests that the host somehost.nscl.msu.edu return  a  list
       of the ports in use.  The port usage is then printed at stdout:
     </para>
     <example>
        <title>Listing allocated ports in Tcl</title>
        <programlisting>
package require portAllocator
set p [::portAllocator create remote -hostname somehost.nscl.msu.edu]
set usage [$p listPorts]
foreach allocation $usage {
  set port        [lindex $allocation 0]
  set application [lindex $allocation 1]
  set user        [lindex $allocation 2]
  puts "Port $port allocated to $application run by $user"
}
        </programlisting>
     </example>
  </refsect1>
  <refsect1>
        <title>SEE ALSO</title>
        <para>
            <link linkend="manpage.CPortManager">CPortManager(3daq)</link>,
            <link linkend="manpage.CPortManagerException">CPortManagerException(3daq)</link>,
            <link linkend="manpage.DaqPortManager">DaqPortManager(1tcl)</link>
        </para>
    </refsect1>
</refentry>

<refentry id="manpage.dvdburner">
  <refmeta>
     <refentrytitle>DvdBurner</refentrytitle>
     <manvolnum>1tcl</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>DvdBurner package</refname>
     <refpurpose>Burn NSCL Data to DVD</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
package require DvdBurner
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
    <command>
DvdBurner::CreateDvds ?range?
    </command>
</cmdsynopsis>
<cmdsynopsis>
    <command>
DvdBurner::BurnDVD iso
    </command>
</cmdsynopsis>

  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
	The
        <application>DvdBurner</application> package provides the capability to
        burn an arbitary ISO image or set of NSCL data acquisition systsem
        event data and associated data to DVD. 
     </para>
    <cmdsynopsis>
    <command>
DvdBurner::CreateDvds ?range?
    </command>
    </cmdsynopsis>
    <para>
        creates DVDs from a set of recorded data taking runs.  The data and
        run meta-data are recorded to DVD.  If necessary, several DVDs are
        created.  Data are split so that all of the data associated with a run
        is on a single DVD (not split across more than one DVD.
        See, however "Dependencies and Restrictions" below.
    </para>
<cmdsynopsis>
    <command>
DvdBurner::BurnDVD isofile
    </command>
</cmdsynopsis>
    <para>
        Burns the pre-built ISO image in the file <parameter>isofile</parameter>
        to DVD.
     </para>
  </refsect1>
  <refsect1>
     <title>Dependencies and Restrictions</title>
     <itemizedlist>
        <listitem><para>
            <application>growisofs</application> must be isntalled and in
                the user's path.
        </para></listitem>
        <listitem><para>
            The DVD must either be named <filename>/dev/cdrom</filename> or
            the environment variable <literal>DVDROM</literal> must be
            defined to be the name of the DVD burner to use.
        </para></listitem>
        <listitem><para>
            The variable DvdBurner::DVD holds the path to the DVD burner
            device and can be modified at run time any time after the package
            has been <command>require</command>ed.
        </para></listitem>
        <listitem><para>
            The DVD device must be writable by <application>growisofs</application>.
        </para></listitem>
        <listitem><para>
            The variable DvdBurner::DVDSize holds the number of megabytes
            a DVD can hold  It can be modified from its default value of
            <literal>4000</literal> if necessary.
        </para></listitem>
        <listitem><para>
            The <function>DvdBurner::CreateDvds</function> command will fail
            if there are runs that won't fit on single DVDS.  Errors in the
            NSCL file structure can also cause failures.
        </para></listitem>
        <listitem><para>
            The variable <varname>DvdBurner::ISOFSroot</varname> holds the
            directory in which the run data will be marshalled and the
            ISO images built.  The initial value is
            <filename>/scratch/$tcl_platform(user)/isos</filename>
            where <varname>tcl_platform(user)</varname> is your username.
         </para></listitem>    
     </itemizedlist>
  </refsect1>

</refentry>



<refentry id="manpage.sequencer">
    <refmeta>
        <refentrytitle>sequencer</refentrytitle>
        <manvolnum>3tcl</manvolnum>
    </refmeta>
    <refnamediv>
        <refname>sequencer</refname>
        <refpurpose>
            Provide a ReadoutGui plugin for nscldaq 8.1 and later that can
            automate several data taking runs.
        </refpurpose>
    </refnamediv>
    <refsynopsisdiv>
        <cmdsynopsis>
            <command>
 package require runSequencer               
            </command>
        </cmdsynopsis>

    </refsynopsisdiv>

    <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The <command>runSequencer</command> package provides
            support for automating data taking runs of fixed duration.
            <command>runSequencer</command> is a ReadoutGui plugin that
            is compatible with nscldaq-8.1 and later.
        </para>
        <para>
            To operate, you must use the ReadoutGUI from nscldaq-8.1 or later.
            At the NSCL, you can do this by using
            <command>/usr/opt/daq/8.1/bin/ReadoutShell</command>.
            See USING for more information on how to use this plugin.
        </para>
        <para>
            For each run you can define a set of run parameters that are
            set through custom actions just prior to the start of the run.
            See CUSTOMIZING below for more information about how to setup
            these actions and how to specify the parameters.
        </para>
        <para>
            Run sequences are called <firstterm>Run plans</firstterm>.
            Run plans are files that can be loaded into the sequencer,
            edited, saved, and executed.  A run plan provides values for
            all of the parameters for each run in the sequence. 
        </para>
    </refsect1>
    <refsect1>
        <title>USING</title>
        <para>
            This section desribes using in two senses of the word:
            Incorporating the sequencerGui into ReadoutGUI, and
            operating the sequencer once it is installed. Setting up
            the parameter definitions and actions used by the sequencer
            are described in CUSTOMIZING below
        </para>
        <refsect2>
            <title>Incorporating SequencerGui into ReadoutGUI</title>
            <para>
                To incorporate the sequencer into ReadoutGUI you must use a
                <filename>ReadoutCallouts.tcl</filename> file to extend
                ReadoutGui.  This file must contain the line:
                <programlisting>
package require runSequencer
                </programlisting>
                Furthermore you must run a Readout GUI from nscldaq version 8.1 or later.
                At the NSCL, you can run the 8.1 version of the ReadoutGUI as follows:
                <command>/usr/opt/daq/8.1/bin/ReadoutShell</command>
                Note that when you run the Readout GUI, the <filename>sequencer.config</filename> and
                <filename>sequencerActions.tcl</filename> files are expected to exist.
                See CUSTOMIZING below for information about the contents of these files.
                see "FILES and ENVIRONMENT" for where they belong.
            </para>
        </refsect2>
        <refsect2>
            <title>Operating the sequencer GUI</title>
            <para>
                The sequencer creates a second window associated with the Readout GUI.
                This window consists mainly of a table with column labels defined by
                the <filename>sequencer.config</filename> file.  Each row of the
                table represents a run in the sequence of runs in a <firstterm>run plan</firstterm>
            </para>
            <para>
                You can edit the table to provide values for each of the parameters (columns)
                for each step in the run sequence.  Navigate in the table by using the arrow
                keys, the mouse or the tab and shift tab keys.  Once you are happy with your
                run plan you can save it using the
                <menuchoice><guimenu>File</guimenu><guimenuitem>Save...</guimenuitem></menuchoice>
                menu command.
            </para>
            <para>The <menuchoice><guimenu>File</guimenu><guimenuitem>Open...</guimenuitem></menuchoice>
                menu command allows you to read in a plan from file.  This plan can be edited, and
                saved. <menuchoice><guimenu>File</guimenu><guimenuitem>Clear...</guimenuitem></menuchoice>
                clears the table.
            </para>
            <para>
                To execute a run plan, use the ReadoutGUIPanel to set the length of each run.
                (The sequencer will turn on timed runs when you start the sequence).  Then
                click the <guibutton>Execute Plan</guibutton> button to start the sequence.
                The button is relabeled <guibutton>Abort Plan</guibutton> while the plan is running.
                Clicking it while the plan is running ends the active run and stops the sequence.
                If event recording was enabled for an aborted run plan you are given the option
                to discard all the event data that was taken for the sequence.
            </para>
        </refsect2>
            
    </refsect1>
    <refsect1>
        <title>CUSTOMIZING</title>
        <para>
            The sequencer is completely customizable.  The label for each column and actions to
            take to set each column are defined by the <filename>sequencer.config</filename> file.  This file is a text
            file.  Each line in the file describes a column.  Blank lines are ignored as are
            lines for which the first non-blank character is a hash (#) character.
            Fields in a line are separated by whitespace. Whitespace can be incorporated
            into a field either by quoting the field with double quotes (") or curly
            brackets (for example {this has spaces}).
        </para>
        <para>
            Each column definition line of <filename>sequencer.config</filename> has fields in the
            following order.
            <variablelist>
                <varlistentry>
                    <term>Column Name</term>
                    <listitem>
                        <para>
                            The text that labels the column in the run plan.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>set action</term>
                    <listitem>
                        <para>
                            A tcl command that is executed when it is time to change the value
                            of the item in the column. The column name and the value of that
                            cell of the table are appended to the command.  If the
                            set action is blank, no action is taken.  The
                            action function must return 0 on success or else
                            the run plan will be aborted prior to starting the
                            run for the failing step.  Note that if an action
                            can return and error it should indicate to the user
                            what the error was.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>initialize action</term>
                    <listitem>
                        <para>A tcl command that is executed when the sequencer is set up, before
                            executing any run plan.  This is intended to be used for any
                            one-time intialization required to access the item controlled by
                            the table.   The column name is appended to this command when it is
                            called.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            See EXAMPLES for examples of the sequencer.config file.  See "FILES and ENVIRONMENT"
            for information about where this file belongs.
        </para>
        <para>
            The actions defined in the <filename>sequencer.config</filename> file must come
            from somewhere.   During initialization, the sequencer sources the
            file <filename>sequencerActions.tcl</filename> this file is a Tcl script that
            can include procedure definitions, data definitions, etc.   Normally it provides
            the tcl commands that are specified as actions in the <filename>sequencer.config</filename>
            file.  For a sample <filename>sequencerActions.tcl</filename> file see
            EXAMPLES.  For information about how the sequender finds this file, see
            "FILES and ENVIRONMENT"
        </para>
    </refsect1>
    <refsect1>
        <title>FILES and ENVIRONMENT</title>
        <para>
            The sequencer must locate a column configuration file and a script that defines
            the actions used by that file. By default, these files are:
            <variablelist>
                <varlistentry>
                    <term><filename>./sequencer.config</filename></term>
                    <listitem>
                        <para>
                            The column configuration file.  By default this is located in the
                            current working directory of the sequencer when it is started.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>./sequencerActions.tcl</filename></term>
                    <listitem>
                    <para>
                        A script that defines actions used by the column configuration file.
                        By default, this is sourced from the current working directory of the
                        sequencer when it is started.
                    </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </para>
        <para>
            Environment variables can alter the location and names of these files:
            <variablelist>
                <varlistentry>
                    <term><envar>SEQCONFIGDIR</envar></term>
                    <listitem>
                        <para>
                            If defined, this environment variable is the directory from which
                            the two configuration files are loaded for example:
                            <command>export SEQCONFIGDIR=~/config</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><envar>SEQCONFIGFILE</envar></term>
                    <listitem>
                        <para>
                            If defined, this environment variable is the name of the file
                            used to configure the columns.  If, for example, you:
                            <command>export SEQCONFIGDIR=~/config</command>
                            and
                            <command>export SEQCONFIGFILE=columns.def</command>
                            The column configuration file loaded will be
                            <filename>~/config/columns.def</filename>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><envar>SEQACTIONFILE</envar></term>
                    <listitem>
                        <para>
                            If defined, this environment variable is the name of the
                            action script file that defines the actions referenced in the
                            column configurationfile.
                            If, you have
                            <command>export SEQCONFIGDIR=~/config</command>
                            and
                            <command>export SEQACTIONFILE=actions.tcl</command>,
                            The action script file will be sourced from
                            <filename>~/config/actions.tcl</filename>.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </para>
    </refsect1>
    <refsect1>
        <title>EXAMPLES</title>
            <example>
                <title>Action script example</title>
                <para>
                    This example shows part of an action script that defines the actions
                    <function>epicsAccess</function> and <function>epicsSet</function> that
                    provide actions to access epics channels.
                    <programlisting>
package require epics
proc epicsSet {name value} {
  set status [catch  {$name set $value}] msg
  if {$status != 0} {
     tk_msgBox -message $msg -icon error -title {Epics channel set error}
  } 
  return $status
  
}
proc epicsAccess name {
    epicschannel $name
}

                    </programlisting>
                </para>
            </example>
            <example>
                <title>Sequencer column configuration file</title>
                <para>
                    The sequencer file below defines a set of columns that are all
                    epics channels:
                    <programlisting>
# Column         set_action  init_action

P222ET_TARGET    epicsSet    epicsAccess
P222ER           epicsSet    epicsAccess
FLTCHAN73        epicsSet    epicsAccess
P#5:406353       epicsSet    epicsAccess

                    </programlisting>
                Not the use of blank lines and comment lines.
                </para>
            </example>
            <para>
                The directory <filename>examples/sequencer</filename> under the
                installation directory of the nscl daq includes several sample files.
            </para>
    </refsect1>
</refentry>


</reference>
</part>
</book>
