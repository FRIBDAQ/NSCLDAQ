# keeplistDialog.tcl --
#
# UI generated by GUI Builder Build 107673 on 2005-08-02 17:06:20 from:
#    //homedir/home2/fox/My Documents/DAQDocs/2005a/daq/DirectoryStructure/code/keeplistDialog.ui
# This file is auto-generated.  Only the code within
#    '# BEGIN USER CODE'
#    '# END USER CODE'
# and code inside the callback subroutines will be round-tripped.
# The proc names 'ui' and 'init' are reserved.
#

package require Tk 8.4

# Declare the namespace for this dialog
namespace eval keeplistDialog {}

# Source the ui file, which must exist
source [file join [file dirname [info script]] keeplistDialog_ui.tcl]

# BEGIN USER CODE
package provide keeplistDialog 1.0

#  This code ensures that pkg_mkIndex does not choke
# on this.

if {[info var ::argv0] == ""} {
    set ::argv0 ""
}
if {[info var ::argv] == ""} {
    set ::argv ""
}
#
#  Compare two run files.
#  The run numbers of the runs are compared.
#  The tail of each run file is assumed to be of the
#  form runmmm-ssss.evt
#
proc keeplistDialog::compareRunFiles {run1 run2} {
    scan [file tail $run1] run%d-%d.evt r1 buffer
    scan [file tail $run2] run%d-%d.evt r2 buffer
    if {$r1 < $r2} {
        return -1
    }
    if {$r1 > $r2} {
        return 1
    }
    return 0
}

# keeplistDialog::moveSelected
#    Move the selected entries from one list box
#    to another.  The list boxes are
#    considered, in this case, to be runs
#    which are maintained in sorted order.
#
#  Parameters:
#      from   - The widget of the source dialog.
#      to     - The widget of the destination dialog.
proc keeplistDialog::moveSelected {from to} {
    set selectionIndices [$from curselection]

    #  Just do nothing if no items are selected.

    if {[llength $selectionIndices] == 0} {
        return
    }
    #  Build the list of runs to move:

    foreach index $selectionIndices {
        lappend runs [$from get $index]
    }
    # Remove from source listbox (in reverse index order
    # so removing does not spoil the indices:
    #
    set selectionIndices [lsort -integer -decreasing $selectionIndices]
    foreach index $selectionIndices {
        $from delete $index
    }
    # Join the two list box contents together and sort by run number.

    set fullList [concat [$to get 0 end] $runs]
    $to delete 0 end
    set fullList [lsort -command keeplistDialog::compareRunFiles $fullList]
    foreach run $fullList {
        $to insert end $run
    }
}
# END USER CODE

# BEGIN CALLBACK CODE
# ONLY EDIT CODE INSIDE THE PROCS.

# keeplistDialog::_ArrowButton_1_armcommand --
#
# Callback to handle _ArrowButton_1 widget option -armcommand
#
# ARGS:
#    <NONE>
#
proc keeplistDialog::_ArrowButton_1_armcommand args {}

# keeplistDialog::_ArrowButton_1_command --
#
# Callback to handle _ArrowButton_1 widget option -command
#
# ARGS:
#    <NONE>
#
proc keeplistDialog::_ArrowButton_1_command args {
    append from $keeplistDialog::BASE .unkeptruns
    append to   $keeplistDialog::BASE .scheduledforkeep

    keeplistDialog::moveSelected  $from $to
}

# keeplistDialog::_ArrowButton_1_disarmcommand --
#
# Callback to handle _ArrowButton_1 widget option -disarmcommand
#
# ARGS:
#    <NONE>
#
proc keeplistDialog::_ArrowButton_1_disarmcommand args {}

# keeplistDialog::_ArrowButton_2_armcommand --
#
# Callback to handle _ArrowButton_2 widget option -armcommand
#
# ARGS:
#    <NONE>
#
proc keeplistDialog::_ArrowButton_2_armcommand args {}

# keeplistDialog::_ArrowButton_2_command --
#
# Callback to handle _ArrowButton_2 widget option -command
#
# ARGS:
#    <NONE>
#
proc keeplistDialog::_ArrowButton_2_command args {
    append from $keeplistDialog::BASE .scheduledforkeep
    append to   $keeplistDialog::BASE .unkeptruns

    keeplistDialog::moveSelected $from $to
}

# keeplistDialog::_ArrowButton_2_disarmcommand --
#
# Callback to handle _ArrowButton_2 widget option -disarmcommand
#
# ARGS:
#    <NONE>
#
proc keeplistDialog::_ArrowButton_2_disarmcommand args {}

# keeplistDialog::cancel_command --
#
# Callback to handle cancel widget option -command
#
# ARGS:
#    <NONE>
#
proc keeplistDialog::cancel_command args {}

# keeplistDialog::keptruns_xscrollcommand --
#
# Callback to handle keptruns widget option -xscrollcommand
#
# ARGS:
#    <NONE>
#
proc keeplistDialog::keptruns_xscrollcommand args {}

# keeplistDialog::ok_command --
#
# Callback to handle ok widget option -command
#
# ARGS:
#    <NONE>
#
proc keeplistDialog::ok_command args {}

# keeplistDialog::scheduledforkeep_xscrollcommand --
#
# Callback to handle scheduledforkeep widget option -xscrollcommand
#
# ARGS:
#    <NONE>
#
proc keeplistDialog::scheduledforkeep_xscrollcommand args {}

# keeplistDialog::unkeptruns_xscrollcommand --
#
# Callback to handle unkeptruns widget option -xscrollcommand
#
# ARGS:
#    <NONE>
#
proc keeplistDialog::unkeptruns_xscrollcommand args {}

# END CALLBACK CODE

# keeplistDialog::init --
#
#   Call the optional userinit and initialize the dialog.
#   DO NOT EDIT THIS PROCEDURE.
#
# Arguments:
#   root   the root window to load this dialog into
#
# Results:
#   dialog will be created, or a background error will be thrown
#
proc keeplistDialog::init {root args} {
    # Catch this in case the user didn't define it
    catch {keeplistDialog::userinit}
    if {[info exists embed_args]} {
	# we are running in the plugin
	keeplistDialog::ui $root
    } elseif {$::argv0 == [info script]} {
	# we are running in stand-alone mode
	wm title $root keeplistDialog
	if {[catch {
	    # Create the UI
	    keeplistDialog::ui  $root
	} err]} {
	    bgerror $err ; exit 1
	}
    }
    catch {keeplistDialog::run $root}
}
keeplistDialog::init .

