/*
		    GNU GENERAL PUBLIC LICENSE
		       Version 2, June 1991

 Copyright (C) 1989, 1991 Free Software Foundation, Inc.
                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 Everyone is permitted to copy and distribute verbatim copies
 of this license document, but changing it is not allowed.

			    Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
License is intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

  When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it
in new free programs; and that you know you can do these things.

  To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

  For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

  We protect your rights with two steps: (1) copyright the software, and
(2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

  Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

  Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

  The precise terms and conditions for copying, distribution and
modification follow.

		    GNU GENERAL PUBLIC LICENSE
   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION

  0. This License applies to any program or other work which contains
a notice placed by the copyright holder saying it may be distributed
under the terms of this General Public License.  The "Program", below,
refers to any such program or work, and a "work based on the Program"
means either the Program or any derivative work under copyright law:
that is to say, a work containing the Program or a portion of it,
either verbatim or with modifications and/or translated into another
language.  (Hereinafter, translation is included without limitation in
the term "modification".)  Each licensee is addressed as "you".

Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running the Program is not restricted, and the output from the Program
is covered only if its contents constitute a work based on the
Program (independent of having been made by running the Program).
Whether that is true depends on what the Program does.

  1. You may copy and distribute verbatim copies of the Program's
source code as you receive it, in any medium, provided that you
conspicuously and appropriately publish on each copy an appropriate
copyright notice and disclaimer of warranty; keep intact all the
notices that refer to this License and to the absence of any warranty;
and give any other recipients of the Program a copy of this License
along with the Program.

You may charge a fee for the physical act of transferring a copy, and
you may at your option offer warranty protection in exchange for a fee.

  2. You may modify your copy or copies of the Program or any portion
of it, thus forming a work based on the Program, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

    a) You must cause the modified files to carry prominent notices
    stating that you changed the files and the date of any change.

    b) You must cause any work that you distribute or publish, that in
    whole or in part contains or is derived from the Program or any
    part thereof, to be licensed as a whole at no charge to all third
    parties under the terms of this License.

    c) If the modified program normally reads commands interactively
    when run, you must cause it, when started running for such
    interactive use in the most ordinary way, to print or display an
    announcement including an appropriate copyright notice and a
    notice that there is no warranty (or else, saying that you provide
    a warranty) and that users may redistribute the program under
    these conditions, and telling the user how to view a copy of this
    License.  (Exception: if the Program itself is interactive but
    does not normally print such an announcement, your work based on
    the Program is not required to print an announcement.)

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Program,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Program, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Program.

In addition, mere aggregation of another work not based on the Program
with the Program (or with a work based on the Program) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

  3. You may copy and distribute the Program (or a work based on it,
under Section 2) in object code or executable form under the terms of
Sections 1 and 2 above provided that you also do one of the following:

    a) Accompany it with the complete corresponding machine-readable
    source code, which must be distributed under the terms of Sections
    1 and 2 above on a medium customarily used for software interchange; or,

    b) Accompany it with a written offer, valid for at least three
    years, to give any third party, for a charge no more than your
    cost of physically performing source distribution, a complete
    machine-readable copy of the corresponding source code, to be
    distributed under the terms of Sections 1 and 2 above on a medium
    customarily used for software interchange; or,

    c) Accompany it with the information you received as to the offer
    to distribute corresponding source code.  (This alternative is
    allowed only for noncommercial distribution and only if you
    received the program in object code or executable form with such
    an offer, in accord with Subsection b above.)

The source code for a work means the preferred form of the work for
making modifications to it.  For an executable work, complete source
code means all the source code for all modules it contains, plus any
associated interface definition files, plus the scripts used to
control compilation and installation of the executable.  However, as a
special exception, the source code distributed need not include
anything that is normally distributed (in either source or binary
form) with the major components (compiler, kernel, and so on) of the
operating system on which the executable runs, unless that component
itself accompanies the executable.

If distribution of executable or object code is made by offering
access to copy from a designated place, then offering equivalent
access to copy the source code from the same place counts as
distribution of the source code, even though third parties are not
compelled to copy the source along with the object code.

  4. You may not copy, modify, sublicense, or distribute the Program
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense or distribute the Program is
void, and will automatically terminate your rights under this License.
However, parties who have received copies, or rights, from you under
this License will not have their licenses terminated so long as such
parties remain in full compliance.

  5. You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Program or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Program (or any work based on the
Program), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Program or works based on it.

  6. Each time you redistribute the Program (or any work based on the
Program), the recipient automatically receives a license from the
original licensor to copy, distribute or modify the Program subject to
these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties to
this License.

  7. If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Program at all.  For example, if a patent
license would not permit royalty-free redistribution of the Program by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Program.

If any portion of this section is held invalid or unenforceable under
any particular circumstance, the balance of the section is intended to
apply and the section as a whole is intended to apply in other
circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system, which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

  8. If the distribution and/or use of the Program is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Program under this License
may add an explicit geographical distribution limitation excluding
those countries, so that distribution is permitted only in or among
countries not thus excluded.  In such case, this License incorporates
the limitation as if written in the body of this License.

  9. The Free Software Foundation may publish revised and/or new versions of the General Public License from time to time.  Such new versions will be similar in spirit to the present version, but may differ in detail to address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies a version number of this License which applies to it and "any
later version", you have the option of following the terms and conditions 
either of that version or of any later version published by the Free Software 
Foundation.  If the Program does not specify a version number of this License,
 you may choose any version ever published by the Free Software Foundation.

  10. If you wish to incorporate parts of the Program into other free
programs whose distribution conditions are different, write to the author to 
ask for permission.  For software which is copyrighted by the Free Software 
Foundation, write to the Free Software Foundation; we sometimes make 
exceptions for this.  Our decision will be guided by the two goals of 
preserving the free status of all derivatives of our free software and of 
promoting the sharing and reuse of software generally.

			    NO WARRANTY

  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY FOR
THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN 
OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES PROVIDE 
THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, 
INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND 
FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND 
PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE DEFECTIVE, 
YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING 
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR 
REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES, 
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING 
OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO 
LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR 
THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER PROGRAMS), 
EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH 
DAMAGES.

		     END OF TERMS AND CONDITIONS
*/
static const char* Copyright= "(C) Copyright Michigan State University 2002, All rights reserved";

#ifndef CAENCARD_CPP
#define CAENCARD_CPP

#ifndef CAENCARD_H
#include "CAENcard.h"
#endif

#ifndef __STL_STRING
#include <string>
#define __STL_STRING
#endif

struct CAENcard::CAENcrate CAENcard::crate[VME_CRATE_SIZE + 1];

/*!
  \param slotNum  This specifies the slot in the VME crate in which the module resides.
    This value will be the first five bits of every 32-bit word in the output buffer.

  \param crateNum An optional value that the module will write into the header of each
     event/block of data.  May be useful to differential between different cards.
     The Default value is zero.
     
 \param Geo  bool [in] defaulst to true:
	 - true if the slot supports geographical addressing
	 - false if the slot requires 'thumbwheel addressing'
	 
 \param nBase long [in] the base address of the module if Geo is false.
 
\note  The Geo parameter has been added to allow support for:
- crates without the CERN j3 connector, (many mfgs make these).
- modules that don't have the j3 connector (CAEN makes these).
 

  If slotNum is not specified, or if it is outside the range of valid values then the
  function returns a "NULL" card.  If the card
  cannot be initialized (wrong version of card, no card in slot) then the function
  returns a card which will be recognized as invalid by the other functions.

  Once the card is verified to be in the slot, one of the supported types, and if it
  is not currently referenced by another instance then it is reset to clear any
  previous settings.  Also, the thresholds are also set to default values and the TDC
  is set to common-start mode.
 */
CAENcard::CAENcard(int slotNum, int crateNum , 
			     bool Geo, long nBase)
{
  if(slotInit(slotNum, crateNum, Geo, nBase) < 0)
    slot = 0;
  ++(crate[slot].refCount);
};

/*!
  \param card The card to copy.

  The new CAENcard object will not cause the module to be reset, as this only happens
  the first time that a CAENcard object is created that refers to a given slot.  This
  means that any settings that you have set on the card in that slot will not be
  lost.  Also understand that the destination argument now points to the same card
  in the crate, and therefore any changes to either instance will be reflected in
  all other instances referring to the same card.
  */
CAENcard::CAENcard(const CAENcard& card)
{
  slot = card.slot;
  ++(crate[slot].refCount);
};

/*!
  \param card The CAENcard value to assign to the destination argument.
  \return The value placed into the destination argument.

  The new CAENcard object will not cause the module to be reset, as this only happens
  the first time that a CAENcard object is created that refers to a given slot.  This
  means that any settings that you have set on the card in that slot will not be
  lost.  Also understand that the destination argument now points to the same card
  in the crate, and therefore any changes to either instance will be reflected in
  all other instances referring to the same card.
  */
CAENcard& CAENcard::operator=(const CAENcard& card)
{
  --(crate[slot].refCount);
  destruct();  //free the resources associated with the first argument
  slot = card.slot;
  ++(crate[slot].refCount);
  return(*this);
};

/*!
  \param slotNum  This specifies the slot in the VME crate in which the module resides.  This value will be the first five bits of every 32-bit word in the output buffer.
  \param crateNum An optional value that the module will write into the header of each event/block of data.  May be useful to differential between different cards.
  \param fGeo - true if the slot is a geographical address, false if slotNum is actually
            an A32 base address.
   \param nBase long base address of the module if fGeo is false.

  \return Failure to initialize the card is indicated by a return value less than zero.  Each failure returns a different value and are numbered sequentially through the function.

  The calling function must increment the value of
  CAENcard::crate[#slot].\link CAENcrate#refCount refCount\endlink after calling
  this function (if appropriate).  The memory map and file descriptor associated
  with this slot will be allocated and opened, respectively, if not already present.
  The status of the slot is then set to be CAEN_MODE_A32D16 if successful.
*/
int CAENcard::slotInit(int slotNum, int crateNum, bool fGeo, long nBase)
{

  //ensure that the slot and crate specified stay within bounds
   crateNum = crateNum & 0xff;  //not important enough to give an error for, just discard the extra
   slot = slotNum;
   if( slot == 0 )	//nothing to do... dummy card created by empty constructor
   {
      return(0);
   }

   if(slot > VME_CRATE_SIZE)
   {
      perror("Invalid slot number specified to slotInit(). ");
      return(-1);
   }

  //check to see if the card in this slot is already being referenced
   if(crate[slot].refCount > 0 && (crate[slot].status & CAEN_MODE_A32D16))
   {
      //set the crate number as requested by the calling program (defaults to zero)
      setCrate(crateNum);

      return(0);
   }

     //the card is not mapped yet, so do it
   if( fGeo) {                                  // Geographical addressing...
     crate[slot].status = CAEN_MODE_UNINIT;

     crate[slot].fd   = CVMEInterface::Open(CVMEInterface::GEO, crateNum);
     crate[slot].mbuf = (unsigned short int*)
				      CVMEInterface::Map(crate[slot].fd, 
								  slot << 19, 
								  CAEN_CARD_MMAP_LEN);

   }
   else {                                    // A32 addressing.
      crate[slot].fd = CVMEInterface::Open(CVMEInterface::A32, crateNum);
      crate[slot].mbuf = (unsigned short int*) 
				       CVMEInterface::Map(crate[slot].fd,
							            nBase,
								    CAEN_CARD_MMAP_LEN);
								    
	    // for non geo modules. .it's necesasry to program the geo register:
	    
      *(crate[slot].mbuf + (0x1002/sizeof(short))) = slot;
      reset();                      // This only takes effect after a reset.
   }
   /* 
      To determine that the experimenter is not lying to us
      about how the VME is stuffed, we require that the module
      identifier be of a supported module type:
      V775, V785, V792, V862 and that, for good measure,
      it's geographical address register match the slot
      the module is in.  For random data this should
      make a pretty miniscule chance that we'll be fooled
      by an empty slot. 1/32 * (1/2&24)
   */
   volatile unsigned short int* pModule = crate[slot].mbuf; // Base of module.
   unsigned int boardid      = (*(pModule + 0x803e/sizeof(short)) & 0xff)        |
     ((*(pModule + 0x803a/sizeof(short)) & 0xff) << 8)  |
     ((*(pModule + 0x8036/sizeof(short)) & 0xff) << 16);
   unsigned int geo          = (*(pModule + 0x1002/sizeof(short)) & 0xff) & 0x1f;
   if(!(
	( (short int)slot == geo )   &&		//check geo address
	( (boardid == 775) || 
	  (boardid == 785) || 
	  (boardid == 792) ||
	  (boardid == 862) ) // and board type
	))   {   //either an invalid board or no board is present in this slot
     printf("\nCard is not inserted or is of an incompatable type!\n");
     CVMEInterface::Unmap(crate[slot].fd, (void*)crate[slot].mbuf, CAEN_CARD_MMAP_LEN);
     
     CVMEInterface::Close(crate[slot].fd);
     crate[slot].fd = 0;
     return(-7);
   }
   
   

   //card access and initialization was successful
   
   if(fGeo) {                              // Transition to A32...
     crate[slot].status = CAEN_MODE_GEO24;
     
     //end of slot initialization, begin address initialization
     
     //set the address in the registers based upon the slot number
     //the 32bit address becomes (slot<<24)
     *(crate[slot].mbuf+0x0809) = slot;
     *(crate[slot].mbuf+0x080A) = 0;
     //set "bit set 1" register to use address in registers for addressing
     *(crate[slot].mbuf+0x0803) = 0x0010;
     
     //destroy GEO24 mmap and file descriptor
     
     CVMEInterface::Unmap(crate[slot].fd, (void*)crate[slot].mbuf, CAEN_CARD_MMAP_LEN);
     CVMEInterface::Close(crate[slot].fd);
     crate[slot].fd = 0;
     try {
       crate[slot].fd = CVMEInterface::Open(CVMEInterface::A32, crateNum);
     }
     catch(string& emsg) {
       cerr << "Failed to change the card access mode from GEO24 to A32D16\n";
       cerr << emsg <<endl;
       crate[slot].status = CAEN_MODE_UNINIT;
       return(-10);
     }
     
     //create A32D16 mmap
     
     try {
       crate[slot].mbuf = (volatile unsigned short int*)CVMEInterface::Map(crate[slot].fd, slot << 24, CAEN_CARD_MMAP_LEN);
     }
     catch (string& error) {
       cerr << " Unable to map the card for base addressing\n";
       cerr << error << endl;
       crate[slot].mbuf = 0;
       CVMEInterface::Close(crate[slot].fd);
       crate[slot].fd = 0;
       crate[slot].status = CAEN_MODE_UNINIT;
       return(-11);  
     }
  }                                 // All set if not doing GEO addressing.
  
  crate[slot].status = CAEN_MODE_A32D16;
  reset();  //puts almost all settings back to default value
  //clears the event count and buffer
  channelOn(-1);  //make sure that no kill bits are set
  //set the crate number as requested by the calling program (defaults to zero)
  setCrate(crateNum);
  
  if(cardType() == 775)
    {
      //set use common start mode and the thresholds to 14ns if a TDC
      commonStart();
      setRange(0xFF);
      setThreshold(-1, 0x19);
    }
  else if(cardType() == 785)
    {
      //set all of the thresholds to ~15mV if this card is an ADC
      setThreshold(-1, 0x01);
    }
  else if(cardType() == 792)
    {
      //set default operation for the QDC
      
      //is a default pedestal current value desired??
      
      //don't know if this is appropriate as I don't have access to this type of card.
      //documentation simply says "resolution : 12 bit" and "Gain : 100 fC/count".
    //a good threshold likely depends upon the gate width...
      setThreshold(-1, 0);
    }
  
  return(0);
};

/*! The reference count of the slot number is decreased and then the destruct()
    function is called.  If the reference count is less than one then the items
    in CAENcard::crate[#slot] are destroyed. (memory map unmapped, file descriptor
    closed, status set to uninitialized)
*/
CAENcard::~CAENcard()
{
  --(crate[slot].refCount);
  destruct();
};

/*! The calling function for this function must decrement value of
    CAENcard::crate[#slot].\link CAENcrate#refCount refCount\endlink before calling
    this function (if appropriate).  The memory map and file descriptor associated
    with this slot will be released and closed, respectively. The status of the
    slot is then set to be uninitialized.
*/
void CAENcard::destruct()
{
  int temp[2];
  if( crate[slot].refCount < 1)
  {
    crate[slot].refCount = 0;
    if(slot > 0 )
    {
      if (crate[slot].mbuf)
      {
	CVMEInterface::Unmap(crate[slot].fd, (void*)crate[slot].mbuf, CAEN_CARD_MMAP_LEN);
      }
      crate[slot].mbuf = 0;
      if(crate[slot].fd != 0)
      {
        CVMEInterface::Close(crate[slot].fd);
      }
      crate[slot].fd = 0;
      crate[slot].status = CAEN_MODE_UNINIT;
    }
  }
};

/*! \return \li If the call succeeds then either 775, 785, or 792 will be returned as an integer.
            \li If the call fails (if it is called on an uninitialized card) then -1 will be returned.
 */
int CAENcard::cardType()
{
  if(crate[slot].status & CAEN_MODE_A32D16)
  {
    return( 768 + (*(crate[slot].mbuf+0x401F) & 0x00FF) );
  }
  else
  {
//    printf("Attempted to determine the card type of an uninitialized card.\n");
    return(-1);
  }
};

/*!
  This eight-bit value is set when the board is initialized (default value is zero).  The value
  appears in the header of each event sent back from the card and is only useful to differentiate
  between the data from different cards. This value is cleared by a call to reset().
*/
void CAENcard::setCrate(int crateNum)
{
  if(crate[slot].status & CAEN_MODE_A32D16)
  {
    *(crate[slot].mbuf+0x081E) = crateNum & 0x00FF;
  }
};

/*!
  \return \li The current crate number is returned if the value is successfully read from the card.
          \li If the card is not in CAEN_MODE_A32D16 then the call will fail and return -1.

  This eight-bit value is set when the board is initialized (default value is zero).  The value
  appears in the header of each event sent back from the card and is only useful to differentiate
  between the data from different cards.

  This value is not cleared by a call to dataClear(), but is cleared by a call to reset().
*/
int CAENcard::getCrate()
{
  if(crate[slot].status & CAEN_MODE_A32D16)
  {
    return *(crate[slot].mbuf+0x081E) & 0x00FF;
  }
  else
  {
//    printf("Attempted to retrieve the crate value from an uninitialized card.\n");
    return(-1);
  }
}

/*!
  \param ch The channel on which to set the threshold.  Use a value of -1 to set the
    threshold of all channels on the card.
  \param threshold The low 12-bits of this value are used to set the threshold on the
    desired channels.

  The threshold value is compared against each converted value.  If the converted value
  is less than the threshold then it is either discarded or, if the card is set to
  keepUnderThresholdData() then the underflow bit in the data word is set and it is
  stored in the event buffer.

  This function preserves the state of the kill bit in threshold memory so that it does
  not "turn on" any channels that have had channelOff() called on them.  Thresholds are
  not cleared by clearData() or reset(). Performing a hardware reset will clear the
  thresholds, but there are no default values defined. The constructor does set all
  thresholds to reasonable defaults, however.
*/
void CAENcard::setThreshold(int ch, int threshold)
{
  if((crate[slot].status & CAEN_MODE_A32D16) && ch < 32)
  {
    //make sure that the kill bit won't accidentally be set
    threshold = threshold & 0x00FF;
    //don't turn the channel on or off, but change the threshold
    if( ch < 0 )
      for(int i = 0; i < 32; i++)
        *(crate[slot].mbuf+0x0840+i) = (short int)threshold + ((*(crate[slot].mbuf+0x0840+i)) & 0x0100);
    else
      *(crate[slot].mbuf+0x0840+ch) = (short int)threshold + ((*(crate[slot].mbuf+0x0840+ch)) & 0x0100);
  }
};

/*!
  \param ch The channel on which to set the threshold.  Use a value of -1 to set the
    threshold of all channels on the card.
  \param voltage The approximate voltage to which the threshold is to be set.  The
    conversion has a resolution of approximately 0.016 volts.

  This function only works if the card is a V785 ADC since it does not make sense to
  speak in terms of voltage thresholds with the TDC or QDC.
*/
int CAENcard::setThresholdVoltage(int ch, double voltage)
{
  //make sure that the card is the peak-sensing ADC
  if(cardType() == 785)
  {
    setThreshold(ch,(int)(voltage*64));
    return(0);
  }
  else
  {
    printf("Attempted to set threshold by voltage on a card other than the V785 or an uninitialized card.\n");
    return(-1);
  }
};

/*!
  Any under threshold data that is kept in the event buffer has the under-threshold bit
  set in the channel data.  This setting is cleared when reset() is called.
*/
void CAENcard::keepUnderThresholdData()
{
  if(crate[slot].status & CAEN_MODE_A32D16)
    *(crate[slot].mbuf+0x0819) = 1<<4;
};

/*!
  This setting is cleared if reset() is called. The default value is to dicard the
  under threshold conversions.
*/
void CAENcard::discardUnderThresholdData()
{
  if(crate[slot].status & CAEN_MODE_A32D16)
    *(crate[slot].mbuf+0x081A) = 1<<4;
};

/*!
  Any conversions that result in an overflow condition cause the overflow bit to be
  set in the channel data. This setting is cleared when reset() is called.
*/
void CAENcard::keepOverflowData()
{
  if(crate[slot].status & CAEN_MODE_A32D16)
    *(crate[slot].mbuf+0x0819) = 1<<3;
};

/*!
  This setting is cleared if reset() is called. The default value is to dicard the
  conversions that result in an overflow.
*/
void CAENcard::discardOverflowData()
{
  if(crate[slot].status & CAEN_MODE_A32D16)
    *(crate[slot].mbuf+0x081A) = 1<<3;
};

/*!
  \return Zero indicates a successful write while -1 indicates that either the card
    is not a TDC or it is not yet initialized.

  The invalid data bit is set when a stop signal is received while the TDC
  is reseting (it takes 700ns to reset) after the maximum conversion time das
  been hit. This setting is cleared when reset() is called.
*/
int CAENcard::keepInvalidData() { if(cardType() == 775) {
  *(crate[slot].mbuf+0x0819) = 1<<5; return(0); } else { printf("Attempted to
  keep invalid data on a card that is not a TDC or not initialized.\n");
  return(-1); } };

/*!
  \return Zero indicates a successful write while -1 indicates that either the card
    is not a TDC or it is not yet initialized.

  This setting is cleared if reset() is called. The default behavior is for the TDC
  to discard the invalid data.
*/
int CAENcard::discardInvalidData()
{
  if(cardType() == 775)
  {
    *(crate[slot].mbuf+0x081A) = 1<<5;
    return(0);
  }
  else
  {
    printf("Attempted to keep invalid data on a card that is not a TDC or not not initialized.\n");
    return(-1);
  }
};

/*!
  \return Zero indicates a successful write while -1 indicates that either the card
    is not a TDC or it is not yet initialized.

  This setting is cleared by a call to reset(). When the card is first created it
  is set to use common start mode.
*/
int CAENcard::commonStart()
{
  //make sure that the card is a TDC and initialized
  if(cardType() == 775)
  {
    *(crate[slot].mbuf+0x081A) = 1<<10;
    return(0);
  }
  else
  {
    printf("Attempt to set common start on a card that is not a TDC or not initialized.\n");
    return(-1);
  }
};

/*!
  \return Zero indicates a successful write while -1 indicates that either the card
    is not a TDC or it is not yet initialized.

  This setting is cleared by a call to reset(). The TDC has slightly better minimum
  detectable signal in this mode.
*/
int CAENcard::commonStop()
{
  //make sure that the card is a TDC and initialized
  if(cardType() == 775)
  {
    *(crate[slot].mbuf+0x0819) = 1<<10;
    return(0);
  }
  else
  {
    printf("Attempt to set common start on a card that is not a TDC or not initialized.\n");
    return(-1);
  }
};

/*!
  \param range A raw value used to set the range on the TDC with.
    -0x1E (30) sets the range to 1200ns
    -0xFF (255) sets the range to 140ns
    -Use linear iterpolation for intermediate values.

  \return Zero indicates a successful write while -1 indicates that either the card
    is not a TDC or it is not yet initialized and -2 indicates that an invalid value
    was passed.

  This setting is cleared by a call to reset(). The constructor defaults the range to 
  140ns.
*/
int CAENcard::setRange(int range)
{
  //make sure that the card is a TDC
  if(cardType() == 775)
  {
    if(range > 0x001D && range < 0x0100)
    {
      *(crate[slot].mbuf+0x0830) = (short int)range;
      return(0);
    }
    else
    {
      printf("Passed invalid value to the setRange function.\n");
      return(-2);
    }
  }
  else
  {
    printf("Attempt to set range on a card that is not a TDC or not initialized.\n");
    return(-1);
  }
};

/*!
  \param ped A raw value to set the pedestal current on the QDC with. I do not have a
    QDC to test and the documentation is unclear to me.  For larger values, however,
    the gate width also affects the channels' offsets.

  \return Zero indicates a successful write while -1 indicates that either the card
    is not a QDC or it is not yet initialized.

  This setting is cleared when reset() is called. No default value is set when the
  card is initialized.
*/
int CAENcard::setPedestalCurrent(int ped)
{
  //make sure that the card is a QDC
  if(cardType() == 792)
  {
    *(crate[slot].mbuf+0x0830) = ped & 0x00FF;
    return(0);
  }
  else
  {
    printf("Attempt to set range on a card that is not a TDC.\n");
    return(-1);
  }
};

/*!
  This function forces the module into offline mode so that no new data is produced.
  Data may still be present in the event buffer, however. This setting is cleared
  when reset() is called.
*/
void CAENcard::cardOff()
{
  if(crate[slot].status & CAEN_MODE_A32D16 )
    *(crate[slot].mbuf+0x0819) = 1<<1;
};

/*!
  The event buffer may still have data in it from events that were converted before
  cardOff() was called. This setting is cleared when reset() is called.
*/
void CAENcard::cardOn()
{
  if(crate[slot].status & CAEN_MODE_A32D16 )
    *(crate[slot].mbuf+0x081A) = 1<<1;
};

/*!
  \param ch The channel to suppress.  A value of -1 indicates that all channels will
    be supressed.

  The kill bit in the threshold memory for the channel is set without
  destroying the threshold values. Call clearData() to ensure that all data in
  the event buffer reflects this change.

  The kill bit is not cleared by clearData() or reset(). Performing a hardware reset
  will clear the values, but there is no default value defined. The constructor does
  ensure that all channels are on, however.
*/
void CAENcard::channelOff(int ch)
{
  if (crate[slot].status & CAEN_MODE_A32D16)
  {
    if( ch < 0 )
    {
      //set kill bits for every channel without destroying the threshold
      for( int i = 0; i < 32; ++i )
        *(crate[slot].mbuf + 0x840 + i) = 0x0100 + (*(crate[slot].mbuf + 0x0840 + i ) & 0x00FF);
    }
    else
    {
      ch &= 0x001F;
      //set kill bit for requested channel without destroying the threshold
      *(crate[slot].mbuf+0x840+ch) = 0x0100 + (*(crate[slot].mbuf + 0x0840 + ch ) & 0x00FF);
    }
  }
};

/*!
  \param ch The channel to unsuppress.  A value of -1 indicates that all channels will
    be unsupressed.

  The kill bit in the threshold memory for the channel is cleared without
  destroying the threshold values. Call clearData() to ensure that all data in
  the event buffer reflects this change. An overflow, under threshold, or invalid
  data condition can still cause the channel to be supressed.

  The kill bit is not cleared by clearData() or reset(). Performing a hardware reset
  will clear the values, but there is no default value defined. The constructor does
  ensure that all channels are on, however.
*/
void CAENcard::channelOn(int ch)
{
  if (crate[slot].status & CAEN_MODE_A32D16)
  {
    if( ch < 0 )
    {
      //set kill bits for every channel without destroying the threshold
      for( int i = 0; i < 32; ++i )
        *(crate[slot].mbuf + 0x840 + i) = *(crate[slot].mbuf + 0x0840 + i ) & 0x00FF;
    }
    else
    {
      ch &= 0x001F;
      //set kill bit for requested channel without destroying the threshold
      *(crate[slot].mbuf+0x840+ch) = *(crate[slot].mbuf + 0x0840 + ch ) & 0x00FF;
    }
  }
};

/*!
  Only the event counter (present in the End Of Block of every event) is affected by
  this call.
*/
void CAENcard::resetEventCounter()
{
  if (crate[slot].status & CAEN_MODE_A32D16)
    *(crate[slot].mbuf+0x0820) = 1;
  //the value written doesn't matter, it is a dummy register.
  //the VME write access is what triggers the counter reset.
};

/*!
  No settings on the module are altered by this call.
*/
void CAENcard::clearData()
{
  if (crate[slot].status & CAEN_MODE_A32D16)
  {
    *(crate[slot].mbuf+0x0819) = 1<<2;
    *(crate[slot].mbuf+0x081a) = 1<<2;
  }
};

/*!
  This call does not change the threshold values or any of the settings that might
  disrupt communication with the module. This call does set the module to discard
  under threshold, overflow, and invalid data. Also the crate value is set to zero.
  Finally, the range, pedestal current, and start mode are all set to default values
  which are, unfortunately, not specified by the documentation.
*/
void CAENcard::reset()
{
  if (crate[slot].status & CAEN_MODE_A32D16)
  {
    *(crate[slot].mbuf+0x0803) = 1<<7;  //put board into reset mode
    *(crate[slot].mbuf+0x0804) = 1<<7;  //take board out of reset mode
  }
};

/*!
  \return \li 1 indicates that there is data in the event buffer
          \li 0 indicates that the event buffer is empty
          \li -1 is returned when the card has not been initialized

  This function is called by all of the readEvent functions before they read any data.
*/
int CAENcard::dataPresent()
{
  if(crate[slot].status & CAEN_MODE_A32D16)
  {
    return (*(crate[slot].mbuf+0x0807) & 0x0001);
  }
  else
  {
    return(-1);
  }
};

/*!
  \param buf A pointer to local memory that has already been allocated.
      Should be at least 34 * 4 = 136 bytes to hold the header, footer, and 32
      channels of data.

  \return \li \> 0 indicates the number of BYTES of data placed in buf
          \li 0 indicates that no data was placed in the buffer
          \li -1 is returned if the card is not properly initialized

  Be careful about putting this function into a loop because it can return a negative
  value.
*/
int CAENcard::readEvent(void* buf)
{
  int n = dataPresent();
  if(n > 0)
  {
    *(int*)buf = *(int*)(crate[slot].mbuf);
    n = (((*(int*)buf) >> 8) & 0x003F) + 1;
    for(int i = 0; i<n; ++i)
      *(((int*)buf) + i + 1) = *(int *)(crate[slot].mbuf);
    n = (n+1)*4;
  }
  return(n);
};

/*!
  \param wbuf A DAQWordBuffer object to put data in. When using the standard readout
      skeleton this object is created for you.
  \param offset The position that the data should be written to.  This is necessary
      to avoid overwriting other data in the DAQWordBuffer.

  \return \li \> 0 indicates the number of 16-BIT WORDS of data placed in wbuf
          \li 0 indicates that no data was placed in the buffer
          \li -1 is returned if the card is not properly initialized

  Be careful about putting this function into a loop because it can return a negative
  value.
*/
int CAENcard::readEvent(DAQWordBuffer& wbuf, int offset)
{
  int n = dataPresent();
  union{
    int dword;
    struct{
      short int low;
      short int high;
    } word;
  } temp;

  if(n > 0)
  {
    temp.dword = *(int *)(crate[slot].mbuf);
    wbuf[offset] = temp.word.high;
    wbuf[offset+1] = temp.word.low;
    n = ((temp.word.low >> 8) & 0x003f) + 1;  //count of data words plus EOB word
    for(int i = 0; i < n; i++)
    {
      temp.dword = *(int *)(crate[slot].mbuf);
      wbuf[offset + 2*(i+1)] = temp.word.high;
      wbuf[offset + 2*(i+1) + 1] = temp.word.low;
    }
    n = (n+1)*2;
  }
  return(n);
};

/*!
  \param wp A DAQWordBufferPtr object.

  \return \li \> 0 indicates the number of 16-BIT WORDS of data placed in buf
          \li 0 indicates that no data was placed in the buffer
          \li -1 is returned if the card is not properly initialized

  Be careful about putting this function into a loop because it can return a negative
  value. Also make sure that the pointer does not point to a location that already
  contains data.

  Under normal conditions the readEvent(DAQWordBuffer& wbuf, int offset) fuction is
  much easier and intuitive to use.
*/
int CAENcard::readEvent(DAQWordBufferPtr& wp)
{
  int n;
  union{
    int dword;
    struct{
      short int low;
      short int high;
    } word;
  } temp;

  n = dataPresent();
  if(n > 0)
  {
    temp.dword = *(int *)(crate[slot].mbuf);
    *wp = temp.word.high;
    ++wp;			// preincrement is faster.
    *wp = temp.word.low;
    n = (((*wp) >> 8) & 0x003f) + 1;  //count of data words plus EOB word
    ++wp;
    for(int i = 0; i < n; i++)
    {
      temp.dword = *(int *)(crate[slot].mbuf);
      *wp = temp.word.high;
      ++wp;
      *wp = temp.word.low;
      ++wp;
    }
    n = (n+1)*2;
  }
  return(n);
};

/*!
  \param dwbuf A DAQDWordBuffer object to put data in.
  \param offset The position that the data should be written to.  This is necessary
      to avoid overwriting other data in the DAQDWordBuffer.

  \return \li \> 0 indicates the number of 32-BIT DWORDS of data placed in dwbuf
          \li 0 indicates that no data was placed in the buffer
          \li -1 is returned if the card is not properly initialized

  Be careful about putting this function into a loop because it can return a negative
  value. Note that the standard readout skeleton does not provide you with a
  DAQDWordBuffer.
*/
int CAENcard::readEvent(DAQDWordBuffer& dwbuf, int offset)
{
  int temp = dataPresent();
  if(temp > 0)
  {
    dwbuf[offset] = *(int*)(crate[slot].mbuf);
    int n = ((dwbuf[offset] >> 8) & 0x0000003F) + 1;

    for(int i=0; i<n; ++i)
      dwbuf[offset + i + 1] = *(int*)(crate[slot].mbuf);

    return(n+1);
  }
  return(temp);
};

/*!
  \param wp A pointer to a DAQDWordBuffer object.

  \return \li \> 0 indicates the number of 32-BIT WORDS of data placed in buf
          \li 0 indicates that no data was placed in the buffer
          \li -1 is returned if the card is not properly initialized

  Be careful about putting this function into a loop because it can return a negative
  value. Note that the standard readout skeleton does not provide you with a
  DAQDWordBuffer. Also make sure that the pointer does not point to a location that
  already contains data.

  Under normal conditions the readEvent(DAQDWordBuffer& dwbuf, int offset) fuction is
  much easier and intuitive to use.
*/
int CAENcard::readEvent(DAQDWordBufferPtr& dwp)
{
  int temp = dataPresent();
  if(temp > 0)
  {
    *dwp = *(int *)(crate[slot].mbuf);
    int n = (((*dwp) >> 8) & 0x0000003f) + 1;  //count of data words plus EOB word
    dwp++;
    for(int i = 0; i < n; ++i)
    {
      *dwp = *(int *)(crate[slot].mbuf);
      dwp++;
    }
    return(n+1);
  }
  return(temp);
};

/*!
  Not likely to be of any use except to allow the cards to be used in an STL class.
*/
bool operator< (const CAENcard& card1, const CAENcard& card2)
{
  return card1.slot < card2.slot;
};

/*!
   Set an iped value.
   \param channel - Channel to set.
   \param value   - New value for pedestal only bottom 8 bits are used.

*/
void CAENcard::setIped(int channel, int value)
{
  if(crate[slot].status & CAEN_MODE_A32D16) {
    *(crate[slot].mbuf+(0x1080)/sizeof(short) + channel) = value;
  }
}
/*!
   Return the value of an Iped register.
   \param channel - Channel to get.
*/
int CAENcard::getIped(int channel)
{
  if(crate[slot].status & CAEN_MODE_A32D16) {
    return *(crate[slot].mbuf+(0x1080)/sizeof(short) + channel);
  }
}

#endif
