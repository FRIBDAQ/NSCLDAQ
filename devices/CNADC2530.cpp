/*
    This software is Copyright by the Board of Trustees of Michigan
    State University (c) Copyright 2005.

    You may use this software under the terms of the GNU public license
    (GPL).  The terms of this license are described at:

     http://www.gnu.org/licenses/gpl.txt

     Author:
             Ron Fox
	     NSCL
	     Michigan State University
	     East Lansing, MI 48824-1321
*/
#include <config.h>
#include "CNADC2530.h"
#include <CReadoutModule.h>
#include <CVMUSB.h>
#include <CVMUSBReadoutList.h>

using namespace std;

#define Const(name) static const int name = 

////////////////////////////////////////////////////////////////////////
//
//                  Constants:

//  Register offsets for the NADC2530 module
//  (I've only bothered with the registers I may need).
//
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::maxVector(0xffff);
static CConfigurableObject::VectorLimits(zero, maxVector);

// For now we won't accept more than 
Const(REG_ID)        0;		// Manufacturer's id.
Const(REG_TYPE)      2;		// Module model number.
Const(REG_CSR)       4;		// Control and status register.
Const(REG_MEM)       6;		// Memory offset for list mode memory.
Const(REG_LISTWL)    8;           // Low order number of words in list memory.
Const(REG_LISTWH)    0xa;         // High order number of words in list memory.
Const(REG_VECTOR)    0xc;         // Interrupt vector
Const(REG_EVENTSREQ) 0x12;        // Requested event count
Const(REG_IRQMASK)   0x12;        // or could be interrupt mask depending on csr
Const(REG_LLD)       0x14;        // Lower level discriminator value.
Const(REG_HLD)       0x16;        // Upper level discrminator value.
Const(REG_EVENTSL)   0x18;        // Low 16 bits of number of events acquired.
Const(REG_EVENTSH)   0x1a;        // High 8 bits of number of events acquired.

// Identification Register values:

Const(ID_VALUE)      0x8063;      // Manufacturer code.
Const(TYPE_VALUE)    2530;        // Model number.

// CSR bits (we're really only going to set them).

Const(CSR_HE)       0x8000;       // 1 Enables histogram mode 0 list mode.
Const(CSR_GE)       0x4000;       // 1 Enables gate mode 0 auto trigger.
Const(CSR_ZE)       0x2000;       // 1 Disables zero supresssion 0 Enables zero supression.
Const(CSR_IT)       0x1000;       // 1 Interrupt on event count 0 Interrupt on full/half full.
Const(CSR_IPLMASK)  0x0e00;       // Interrupt priority level mask.
Const(CSR_IPLSHIFT) 9;            // Lowest bit position for IPL mask.
Const(CSR_ARM)      0x0100;       // 1 ARM Cleared automatically when full in list mode.
Const(CSR_IE)       0x0080;      // 1 Enable ineterrupts 0 disable.
Const(CSR_IS)       0x0040;       // 1 if an interrupt condition is set.
Const(CSR_FFCLR)    0x0010;       // Force a fast clear
Const(CSR_SC)       0x0008;       // 1 Set in calibration mode.
Const(CSR_iDR)      0x0004;       // 1 Data ready when event count hit else on fullness flags.
Const(CSR_SS)       0x0002;       // 1 Disables sliding scale (should never be set!).
Const(CSR_RESET)    0x0001;       // Resets the csr.


// Address modifiers we will use to access the module:

Const(initamod)  CVMUSBReadoutList::a24UserData;
Const(readamod)   CVMUSBReadoutList::a32UserBlock;

// Parameter limits:

// The register base addresss is in A24 space so it must  live between
// 0x00000000 and 0x00ffffff.
//

static CConfigurableObject::limit zero(0);
static CConfigurableObject::limit maxCsr(0x00ffffff);
static CConfigurableObject::Limits CsrLimits(zero, maxCsr);


// The IPL must be in the range [0..7]

static CConfigurableObject::limit maxIPL(7);
static CConfigurableObject::Limits IPLLimits(zero, maxIPL);

// The 16 bit vector must be in the range [0..7].

static CConfigurableObject::limit maxVector(0xffff);
static CConfigurableObject::Limits VectorLimits(zero, maxVector);

// For now we won't accept more than 10 events at a time...

static CConfigurableObject::limit maxEvents(10);
static CConfigurableObject::Limits EventLimits(zero, maxEvents);


// Limits on the thresholds...these are set in V/mv or V and converted so these
// are floating point limits.


CConfigurableObject::flimit fzero(0.0);
CConfigurableObject::flimit lldhigh(819.1);
CConfigurableObject::flimit hldhigh(8.191);

///////////////////////////////////////////////////////////////
//   Constructors and other canonical methods

/*!
  Construction is largely a no-op.  The realwork is done
  in the onAttach method when the object gets a configuration
  and sets up the parameters it recognizes.
*/
CNADC2530::CNADC2530() : 
  m_pConfiguration(0),
  m_reArmCsrValue(CSR_ARM)
{
}
/*!
  Copy construction snapshots  the configuration

*/
CNADC2530::CNADC2530(const CNADC2530& rhs) :
  m_pConfiguration(0),
  m_reArmCsrValue(CSR_ARM)
{
 if (rhs.m_pConfiguration) {
    m_pConfiguration = new CReadoutModule(*(rhs.m_pConfiguration));
  }
}
/*!
   
Destructor leaks for now... if copy constructed.
*/
CNADC2530::~CNADC2530()
{
}

/*!
  Assignment is also bogus for now due to danger of recursion loops.
*/
CNADC2530&
CNADC2530::operator=(const CNADC2530& rhs)
{
  return *this;
}

/////////////////////////////////////////////////////////////////////////////
// Implementing the base class interface:
//


/*!
  Attach a configuration to this object.  We create the
  configuration parameters, set them to default values, and provide limits where
  appropriate.  
  
  See the class header for a description of the configuration parameters.

*/
