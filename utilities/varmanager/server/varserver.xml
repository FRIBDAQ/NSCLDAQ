<!-- chapter servers -->
<chapter id='chapter.vardbserver'>
    <title id='chapter.vardbserver.title'>Variable Database Server</title>
    <para>
        The variable database server is a TCP/IP server that:
    </para>
    <itemizedlist>
        <listitem><para>
            Provides the ability for clients to manipulate a variable database.
            Centralizing accesses to the underlying SQLite database ensures
            that proper multi-acces synchronization is done.  It further more
            allows the database to live on NFS shares where the locking needed
            by SQLite to properly manage access by multiple programs often is not
            implemented correctly.
        </para></listitem>
        <listitem><para>
            Publishes changes in the database for programs that can subscribe
            to changes in directory trees within the database. 
        </para></listitem>
    </itemizedlist>
    <para>
        The server uses the <ulink url='http://zeromq.org/'>0mq</ulink>
        communications library to manage communications between clients and server.
        The server creates a REQ/REP port that handles requests to modify or
        query the database. It also creates a PUB/SUB port through which database
        changes are published.
    </para>
    <para>
        On startup, the port manager is used to allocated server ports for the
        REP and PUB sockets, and to publish service names that allow clients
        to locate it.  By default the REP service is named <literal>vardb-request</literal>
        and the PUB service is named <literal>vardb-changes</literal>.
    </para>
    <para>
        These defaults can be overidden via command line parameters.
        See <link linkend='daq1_vardbserver' endterm='daq1_vardbserver_title' /> for
        the command line options supported by the server.
    </para>    
</chapter>
<!-- /chapter -->

<!-- chapter libraries -->

<chapter>
    <title>High level variable database API.</title>
    <para>
        The variable database can be accessed by a pair of API's. The low level
        API directly accesses the database file and is intended for use by NSCLDAQ
        utilities.  The high level API described in this chapter can operate either
        directly on a database file, or through a database file server.
    </para>
    <para>
        When you operate through the database file server described in
        <link linkend='chapter.vardbserver' endterm='chapter.vardbserver.title' />,
        changes to the database are published to clients that have subscribed
        to them.  Your programs should generally use the high level API
        described here.
    </para>
    <para>
        The API consists of a hierarchy of classes that allow the
        concrete API classes to be polymorphic, and a factory that, given
        a URI can generate an appropriate concrete API object.  This
        design allows you to write an application that accepts a URI and
        can work interchangeably with direct file access (such as when
        setting up an experiment), or via a server (such as when an
        experiment is running).
    </para>
    <para>
        To use the API your program will need to:
    </para>
    <itemizedlist>
        <listitem><para>
            Include the <literal>&lt;CVarMgrApi.h&gt;</literal> header which
            defines the interface concrete API's define
        </para></listitem>
        <listitem><para>
            Inlude the <literal>&lt;CVarMgrApiFactory.h&gt;</literal> header
            which defines the interface provide by the factory
        </para></listitem>
        <listitem><para>
            Use one of the factory creation methods to create an instance
            of an API object (usually via an URI).
        </para></listitem>
        <listitem><para>
            Use the methods of the API object to interact with the variable database
        </para></listitem>
        <listitem><para>
            delete the API object when you are done.
        </para></listitem>
    </itemizedlist>
    <note>
        <title>NOTE</title>
        <para>
            The API assumes you are operating on existing database files.  You must
            an NSCLDAQ utility such as vardbsh or the low level interface to create
            a new database file.
        </para>
    </note>
    <para>
        Below is  simple program that uses the API.  It creates a new directory,
        an integer variable in the directory and, every second, increments that
        variable. 
    </para>
    <example>
        <title>Using the High level variable database API.</title>
        <programlisting>
#include &lt;CVarMgrApi.h>&gt;                    <co id='vmapiex_apiinclude' />
#include &lt;CVarMgrApiFactory.h&gt;              <co id='vmapiex_apifactinclude' />
#include &lt;string&gt;
#include &lt;stdio.h&gt;             
#include &lt;unistd.h&gt;

int main(int argc, char** argv)
{
  std::string uri = argv[1];                     <co id='vmapiex_uri' />
  CVarMgrApi*  api = CVarMgrApiFactory::create(uri); <co id='vmapiex_apimake' />
  api-&gt;mkdir("/mydir");                           <co id='vmapiex_mkdir' />
  api-&gt;cd("/mydir");                              <co id='vmapiex_cd' />
  api-&gt;declare("counter", "integer");             <co id='vmapiex_declare' />

  int value(0);

  while(1) {
    char strCounter[100];
    sleep(1);
    value++;
    sprintf(strCounter, "%d", value);
    api-&gt;set("counter", strCounter);            <co id='vmapiex_inc' />

  }
}
// Compile with:                                  <co id='vmapiex_compile' />
//g++ -std=c++11 -I$DAQROOT/include -o hlapiExample hlapiExample.cpp \
//               -L$DAQLIB -lvarmgr -Wl,"-rpath=$DAQLIB"
        </programlisting>
    </example>
    <calloutlist>
        <callout arearefs='vmapiex_apiinclude'>
            <para>
                This header defines the <classname>CVarMgrApi</classname>
                class which is the abstract base class that defines
                the high level API. 
            </para>
        </callout>
        <callout arearefs='vmapiex_apifactinclude'>
            <para>
                This header defines the <classname>CVarMgrApiFactory</classname>.
                That class has several static methods which are
                responsible for generating
                objects that are derived from, and polymorphic with
                the <classname>CVarMgarApi</classname> class.
            </para>
        </callout>
        <callout arearefs='vmapiex_uri'>
            <para>
                The program's first command line parameter is expected to be the
                URI of a variable database.  In a production quality application,
                clearly you need to ensure this parameter is present or else, if
                omitted, the application will segfault.
            </para>
            <para>
                The URI's protocol (the part before the first <literal>:</literal>)
                will be used to determine which of the concrete subclasses
                of the <classname>CVarMgrApi</classname> class will be created.
                If the URI uses the <literal>file</literal> protocol, the database
                will be directly accessed, and the path of the URI will be used
                to determine the filename e.g. <literal>file:///users/fox/test.db</literal>
                will directly access the file <filename>/users/fox/test.db</filename>.
            </para>
            <para>
                If the <literal>tcp</literal> protocol is used an api that attempts
                to connect to a variable database server will be created.
                In this case the host part of the URI determines the system while
                the port is selected as follows:
                <itemizedlist>
                    <listitem><para>
                        If the port is specified it is used e.g.
                        <literal>tcp:/localhost:1234</literal> connects to a
                        server in the same host as the client who's REQ/REP
                        service is listening for connections on port
                        <literal>1234</literal>.
                    </para></listitem>
                    <listitem><para>
                        If the port is not specified, but there is a path,
                        the path is assumed to be the service name
                        advertised by the server with the NSCLDAQ
                        port manager. E.g.:
                        <literal>tcp://localhost/myvarmgr-req</literal>
                        translates the servicename <literal>myvarmgr-req</literal>
                        to determine on which port the REQ/REP server is listening.
                    </para></listitem>
                    <listitem><para>
                        If neither the port nor the path is specified
                        (e.g. <literal>tcp://localhost</literal>), a default
                        service name; <literal>vardb-request</literal> is translated
                        using the NSCLDAQ port manager to determine on which port
                        to connect.
                    </para></listitem>
                </itemizedlist>
            </para>
            <para>
                Note that URI's that have both ports and paths are illegal in
                this application (e.g. <literal>tcp://localhost:1234/myserver-req</literal>).
            </para>
        </callout>
        <callout arearefs='vmapiex_apimake'>
            <para>
                The <methodname>create</methodname> static method of the factory
                creates an appropriate API object connected to the database
                in a manner specified by the URI it is passed.  The result
                of <methodname>create</methodname> is a pointer to a dynamically
                allocated object that should be <literal>delete</literal>ed
                when your application is done using it.
            </para>
        </callout>
        <callout arearefs='vmapiex_mkdir' >
            <para>
                The <methodname>mkdir</methodname> method of the API creates
                a new directory as specified by its parameter.
            </para>
        </callout>
        <callout arearefs='vmapiex_cd'>
            <para>
                The variable API has a concept of a current working directory.
                Any paths that are specified as relative paths (paths not
                staring with <literal>/</literal>), are computed relative
                to the current working directory.
            </para>
            <para>
                When created an API object's current working directory is
                <literal>/</literal>.  The <methodname>cd</methodname>
                API method changes the current working directory to a
                directory specified by its parameter. 
            </para>
        </callout>
        <callout arearefs='vmapiex_declare'>
            <para>
                The <methodname>declare</methodname> method of the API
                creates a new variable.  The first parameter is the
                path to the variable.  This can be an absolute path or, as in
                the case of the example, a path relative to the current
                working directory.  The second parameter is the variable
                type, in this case an integer.  If an optional third
                parameter is supplied it is the initial value of the variable.
                If not supplied, the default value for that variable type
                is used (<literal>0</literal> for integers).
            </para>
            <para>
                Note that in order to accomodate values for all variables,
                variable values are always specified as strings.
            </para>
        </callout>
        <callout arearefs='vmapiex_inc'>
            <para>
                The <methodname>set</methodname> method modifies the value
                of a variable.  This set is done in a loop that waits for
                about
                a second, increments the integer value for the variable,
                computes the string value of the variable and then performs
                the <methodname>set</methodname> operation to change
                the variable.
            </para>
        </callout>
    </calloutlist>
    <para>
        For reference information on the variable manager high level API and
        factory, see:
        <link linkend='daq3_cvarmgrapi' endterm='daq3_cvarmgrapi_title' />
        and
        <link linkend='daq3_cvarmgrapifactory'
              endterm='daq3_cvarmgrapifactory_title' />.
    </para>
    <para>
        In addtion to the C++ bindings, 
        <link linkend='tcl3_varmgr'>Tcl bindings</link>
        and
        <link linkend='python3_varmgr'>Python bindings</link>
        are also available.
    </para>
</chapter>
<chapter>
    <title>Variable database server subscriptions</title>
    <para>
        The variable database server features a publish/subscribe service as
        well as a request service.  This service allows clients to get selective
        notification of changes in the database.  Selectivity is based on path
        prefixes.
    </para>
    <para>
        A path prefix is simply a text string that is part of a path specification.
        A subscription to a path prefix will cause the application to be notified
        of all changes to the database where the path matches that path prefix.
        Note that the path prefix is just a string so a prefix like:
        <filename>/this/test</filename> will match not only:
        <filename>this/test/variable</filename> but <filename>/this/testing</filename>.
    </para>
    <para>
        To lock a path prefix to a specific directory hierarchy you must include
        the trailing <literal>/</literal>.  In the example above:
        <filename>/this/test/</filename> would be a path prefix that would exclude
        <filename>/this/testing</filename> while accepting
        <filename>this/test/variable</filename>.
    </para>
    <para>
        The varmgr library includes the
        <link linkend='daq3_cvarmgrsubscriptions'
              endterm='daq3_cvarmgrsubscriptions_title' /> class, which implements
        the subscription API.
    </para>
    <para>
        Here's a sample application that just outputs all changes to the
        database that match the path prefix it accepts as a parameter.
    </para>
    <example>
        <title>Simple subscription example</title>
        <programlisting>
#include &lt;iostream&gt;
#include &lt;CVarMgrSubscriptions.h&gt;   <co id='subex_include' />
#include &lt;stdlib.h&gt;

static std::string service="vardb-changes";  <co id='subex_svcname' />

// Usage:
//   programname host path

int main(int argc, char** argv)
{
  const char* host = argv[1];              <co id='subex_parameters' />
  const char* path = argv[2];


  CVarMgrSubscriptions sub(host, service);   <co id='subex_subobj' />
  sub.subscribe(path);                    <co id='subex_subscribe' />

  while (1) {
    CVarMgrSubscriptions::Message msg = sub.read();  <co id='subex_read' />

    std::cout &lt;&lt; "Path: " &lt;&lt; msg.s_path &lt;&lt; std::endl;
    std::cout &lt;&lt; "Op  : " &lt;&lt; msg.s_operation &lt;&lt; std::endl;
    std::cout &lt;&lt; "Data: " &lt;&lt; msg.s_data &lt;&lt; std::endl &lt;&lt; std::endl;
  }

}
/* Compile with:
    g++ -o testsub testsub.cpp -I$DAQROOT/include -L$DAQLIB -lvarmgr -lPortManager \
          -lException -std=c++11  -Wl,"-rpath=$DAQLIB"
*/

        </programlisting>
    </example>
    <calloutlist>
        <callout arearefs='subex_include'>
            <para>
                This header file provides the definition for the
                <classname>CVarMgrSubscriptions</classname> class
                and must be included in all programs that make use of that
                class.
            </para>
        </callout>
        <callout arearefs='subex_svcname'>
            <para>
                This defines a string that contains the default service
                advertised by the variable database manager as the
                publish/subscribe port.  In this example we are assuming
                that the variable database server default service names have
                not been overidden.
            </para>
        </callout>
        <callout arearefs='subex_parameters'>
            <para>
                Our program is written to take a pair of command line
                parameters.  The first of these is the host in which we have
                started the variable database server.  The second is the
                path prefix we want to subscribe to.
            </para>
            <para>
                A production quality program should be verifying that the
                correct number of command line parameters have been defined.
                This is a simple example so we omit that code for the sake of
                brevity.
            </para>
        </callout>
        <callout arearefs='subex_subobj'>
            <para>
                We create a
                <classname>CVarMgrSubscriptions</classname> object to
                interact with the publish/subscribe service.  The
                specific <classname>CVarMgrSubscriptions</classname>
                constructor we used knows how to translate service names
                into ports.
            </para>
        </callout>
        <callout arearefs='subex_subscribe'>
            <para>
                This line of code adds a path prefix subscription to our
                subscription list.  You can add any number of subscriptions your
                application needs.  You may not add duplicat subscriptions,
                a <classname>std::runtime_error</classname> exception will be
                thrown if you attempt to.
                If you add an overlapping subscriptions
                (e.g <filename>/test</filename> and <filename>/test/dir/</filename>),
                you will only get a single message for changes that match all
                overlaps.
            </para>
        </callout>
        <callout arearefs='subex_read'>
            <para>
                The <methodname>read</methodname> method blocks until the next notification
                message arrives breaks it up into a
                <classname>>CVarMgrSubscriptions::Message</classname> struct and
                returns that struct.                
            </para>
            <para>
                The remainder of the loop simply outputs the notification message
                to <literal>cout</literal>.
            </para>
        </callout>
    </calloutlist>
    <para>
        For reference information on <classname>CVarMgrSubscriptions</classname> see
        <link linkend='daq3_cvarmgrsubscriptions' endterm='daq3_cvarmgrsubscriptions_title' />
        In addition to a C++ class, there are
        Tcl  (<link linkend='tcl3_varmgrsubscribe' endterm='tcl3_varmgrsubscribe_title' />)
        and Python
        (<link linkend='python3_varmgrnotify' endterm='python3_varmgrnotify_title' />)
        bindings to this class.
    </para>
</chapter>
<!-- /chapter -->

<!-- manpage 1daq -->
<refentry id="daq1_vardbserver">
  <refentryinfo>
    <author>
            <personname>
                    <firstname>Ron</firstname>
                    <surname>Fox</surname>
            </personname>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='daq1_vardbserver_title'>vardbServer</refentrytitle>
     <manvolnum>1daq</manvolnum>
     <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>vardbServer</refname>
     <refpurpose>Server for variable databases</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
    <command>
$DAQBIN/vardbServer
<option>--database</option> <replaceable>databaseFile</replaceable>
<optional>...</optional>
    </command>
    </cmdsynopsis>

  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
      The variable database server provides centralized access to variable
      databases.  It will also publish data about changes to subscriber
      processes.
     </para>
  </refsect1>
  <refsect1>
     <title>
        OPTIONS
     </title>
     <variablelist>
      <varlistentry>
          <term><option>--help</option></term>
          <listitem>
              <para>
                  Outputs a brief help text for the program and exits.
                  This option supercedes all other options.
              </para>
          </listitem>
      </varlistentry>
      <varlistentry>
          <term><option>--database</option> <replaceable>database-file</replaceable></term>
          <listitem>
              <para>
                  This option is the only required option.  It's value
                  is the path to the variable database file.
                  It is an error to specify a non-existent file
                  unless <option>--create-ok</option> is
                  <literal>yes</literal>.
              </para>
          </listitem>
      </varlistentry>
      <varlistentry>
          <term><option>--create-ok</option> <replaceable>yes | no</replaceable></term>
          <listitem>
              <para>
                  If the value of this option is <literal>yes</literal>,
                  and the database file specified by
                  <option>--database</option> does not exist
                  it will be created.  Otherwise it is an error
                  to specify a nonexistent database file.
              </para>
              <para>
                  If the database file does exist, and
                  <option>--create-ok</option> is
                  <literal>yes</literal>, the file is opened as is.
                  Note that the default value for
                  <option>--create-ok</option> is
                  <literal>no</literal>
              </para>
          </listitem>
      </varlistentry>
      <varlistentry>
          <term><option>--publish-service</option> <replaceable>service-name</replaceable></term>
          <listitem>
              <para>
                  Overrides the default service name for the publish port.
                  The default value is <literal>vardb-changes</literal>.
                  This is the name the publish port is advertised as
                  in the host system's port manager.
              </para>
          </listitem>
      </varlistentry>
      <varlistentry>
          <term><option>--request-service</option> <replaceable>service-name</replaceable></term>
          <listitem>
              <para>
              </para>
          </listitem>
      </varlistentry>
      
     </variablelist>
  </refsect1>

</refentry>

<!-- /manpage -->

<!-- manpage 3tcl -->
      <refentry id="tcl3_varmgr">
        <refentryinfo>
          <author>
                  <personname>
                          <firstname>Ron</firstname>
                          <surname>Fox</surname>
                  </personname>
          </author>
          <productname>NSCLDAQ</productname>
          <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='tcl3_varmgr_title'>varmgr</refentrytitle>
           <manvolnum>3tcl</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>varmgr</refname>
           <refpurpose>Tcl Bindings to Variable Database API</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
            <cmdsynopsis>
                <command>
lappend auto_path [$::env(DAQROOT) TclLibs]
package require varmgr
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
varmgr::create <replaceable>filename</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>handle</replaceable> [varmgr::open <replaceable>uri</replaceable>]
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
varmgr::close <replaceable>$handle</replaceable>
                </command>
            </cmdsynopsis>
            
            <cmdsynopsis>
                <command>
varmgr::mkdir <replaceable>$handle directory-path</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
varmgr::cd <replaceable>$handle directory-path</replaceable>                    
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
set wd [varmgr::getwd <replaceable>$handle</replaceable>]
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
varmgr::ls <replaceable>$handle ?directory-path?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
varmgr::rmdir <replaceable>$handle directory-path</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
varmgr::var <replaceable>subcommand $handle args...</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
varmgr::enum <replaceable>$handle type-name list-of-values</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
varmgr::statemachine <replaceable>$handle type-name transition-dict</replaceable>
                </command>
            </cmdsynopsis>
            
            
            
        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            The <literal>varmgr</literal> package provides Tcl bindings to the
            variable manager API.  The bindings appear as a set of commands in the
            <literal>::varmgr::</literal> namespace (See COMMANDS below).
           </para>
           <para>
            This package, once a handle is open is compatible with
            <link linkend='tcl3_vardb' endterm='tcl3_vardb_title' />
           </para>
           <para>
            The difference is that a database is opened by specifying a URI.
            The URI allows either direct connection with the database file
            (<literal>file</literal> URI's), or connection via a database
            server which will also publish database change notifications
            to subscribing clients (<literal>tcp</literal>) protocol URIs.
           </para>
           <para>
            The bindings follow an object-handle manipulation
            pattern.  <command>::varmgr::open</command> opens a database file and
            returns a database handle that must be used in other  varmgr commands.
            The <command>::varmgr::close</command> command closes handles returned
            by <command>::varmgr::open</command> rendering them useless, and releasing
            any associated resources.
           </para>
        </refsect1>
        <refsect1>
           <title>
              COMMANDS
           </title>
           <variablelist>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                            <command>
varmgr::create <replaceable>filename</replaceable>
                            </command>
                        </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates a new variable database in
                        <parameter>filename</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                            <command>
set <replaceable>handle</replaceable> [varmgr::open <replaceable>uri</replaceable>]
                            </command>
                        </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Opens an existing variable database and
                        returns a handle to it.  That handle must
                        be used in all variable database commands that are
                        intended to apply to that database.
                    </para>
                    <para>
                        The <parameter>uri</parameter> argument defines both how
                        the database is connected and which database is connected
                        to the handle.
                    </para>
                    <para>
                        The <replaceable>database-uri</replaceable> is a URI with either a
                        <literal>file</literal> protocol (to directly talk to the database file)
                        or a <literal>tcp</literal> protocol (to work through a database server).
                    </para>
                    <para>
                        If the <replaceable>database-uri</replaceable> uses the
                        <literal>file</literal> protocol, and the specified file
                        does not yet exist,
                        you will be prompted to confirm creating a new database. If the
                        <replaceable>database-file</replaceable> exists and is a valid
                        variable database that database will be used for the shell's session.
                        If the <replaceable>database-file</replaceable> exists but is not
                        a valid variable database, the shell exits with an error message.
                        Examples of a file protocol URI are:
                        <literal>file:///user/0400x/test.db</literal> which specifies
                        a direct connection to the file <filename>/user/0400x/test.db</filename>
                    </para>
                    <para>
                        If the <replaceable>database-uri</replaceable> is a <literal>tcp</literal>
                        protocol, it specifies the host and either TCP port or published service
                        on which the database server is running.  There are three possible
                        forms of this sort of uri:
                    </para>
                    <orderedlist>
                        <listitem><para>
                            <literal>tcp://hostname</literal>  in this case the connection
                            is made to a server running in <literal>hostname</literal> that
                            is listening on the default service for database change requests.
                        </para></listitem>
                        <listitem><para>
                            <literal>tcp://hostname:port-num</literal>  in this case
                            the connection is made to a server running in <literal>hostname</literal>
                            that is listening on the port <replaceable>port-num</replaceable>
                            for database change requests.  <replaceable>port-num</replaceable>
                            is a numeric TCP/IP port number.
                        </para></listitem>
                        <listitem><para>
                            <literal>tcp://hostname/service-name</literal> in this case
                            the connection is made to a server running in <literal>hostame</literal>
                            that has published itself as listening for database change requests
                            on the service <replaceable>service-name</replaceable>.
                        </para></listitem>
                    </orderedlist>
                    <note>
                        <title>NOTE</title>
                        <para>
                            Service names are qualitifed by the name of the user looking them
                            up.  Therefore two users can unambiguously publish the same
                            service name and not collide.
                        </para>
                    </note>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                            <command>
varmgr::close <replaceable>$handle</replaceable>
                            </command>
                        </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Closes the database represented by the
                        <parameter>handle</parameter> parameter.  The
                        <parameter>handle</parameter> parameter must be a value
                        returned from a previous successful
                        <command>::varmgr::open</command> command.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                            <command>
varmgr::mkdir <replaceable>$handle directory-path</replaceable>
                            </command>
                        </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates a directory in the variable database
                        represented by <parameter>handle</parameter>.
                        The <parameter>handle</parameter> parameter must have
                        been returned from a successful prior
                        <command>::varmgr::open</command> command. The
                        <parameter>directory-path</parameter> is an absolute
                        or relative path that specifies which directory to create.
                    </para>
                    <para>
                        The Tcl bindings create any missing path elements along
                        the way to the terminal path element.  For example,
                        in an emtpy database (only the root directory exists)
                        <command>::varmgr::mdkir $handle /this/directory/here</command>
                        creates three directories:
                        <filename>/this</filename>, <filename>/this/directory</filename>
                        and the terminal node: <filename>/this/directory/here</filename>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                            <command>
varmgr::cd <replaceable>$handle directory-path</replaceable>                    
                            </command>
                        </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Sets the current working directory to
                        <parameter>directory-path</parameter> in the database
                        represented by <parameter>handle</parameter>.
                    </para>
                    <para>
                        Each database handle has an associated current working
                        directory.  When first opened, the current working directory
                        is the root directory; <literal>/</literal>.  The current
                        working directory is the starting point for relative paths.
                    </para>
                    <para>
                        Suppose, for example, that the current working directory
                        is <filename>/here/now</filename>.  The path:
                        <filename>../there/again</filename> refers to the
                        absolute path <filename>/here/there/again</filename>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                            <command>
set wd [varmgr::getwd <replaceable>$handle</replaceable>]
                            </command>
                        </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        This command returns as its value the current working
                        directory for the database represented by the.
                        <parameter>handle</parameter>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                            <command>
varmgr::ls <replaceable>$handle ?directory-path?</replaceable>
                            </command>
                        </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a list of the directories immediately below
                        the <parameter>directory-path</parameter> parameter
                        if provided or the current working directory if not.
                        The directories are in the database represented by
                        the <parameter>handle</parameter> parameter.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                            <command>
varmgr::rmdir <replaceable>$handle directory-path</replaceable>
                            </command>
                        </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes the directory <parameter>directory-path</parameter>
                        in the variable database represented by <parameter>handle</parameter>
                        It is an error to remove a directory that is not empty.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        varmgr::var <replaceable>subcommand $handle args...</replaceable>
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Performs an operation on a variable.  In the discussion
                        below, relative paths are interpreted to be relative to
                        the current working directory established by the
                        most recent
                        <command>varmgr::cd</command> command.
                    </para>
                    <para>
                        The operation
                        performed depends on the subcommand and arguments
                        that follow the <varname>handle</varname>:
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term><command>create <replaceable>handle path type ?value?</replaceable></command></term>
                            <listitem>
                                <para>
                                    Creates a new variable.
                                    <parameter>path</parameter> determines
                                    the path to the new variable.
                                    <parameter>type</parameter>
                                    is the type of the variable
                                    (e.g. <literal>string</literal>).
                                    <parameter>value</parameter> is the
                                    optional initial value of the variable.
                                    note that all types have a default value
                                    the variable is initialized to if
                                    <parameter>value</parameter>
                                    is not supplied.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>destroy <replaceable>handle path</replaceable></command></term>
                            <listitem>
                                <para>
                                    Destroys the variable specified by <parameter>path</parameter>
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>set <replaceable>handle path value</replaceable></command></term>
                            <listitem>
                                <para>
                                    Sets the variable described by
                                    <parameter>path</parameter> to a new
                                    <parameter>value</parameter>.  
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>get <replaceable>handle path</replaceable></command></term>
                            <listitem>
                                <para>
                                    Returns the value of the variable
                                    specified by
                                    <parameter>path</parameter>
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>ls <replaceable>handle ?path?</replaceable></command></term>
                            <listitem>
                                <para>
                                    Returns a list describing the variables that
                                    live in a directory.  If the
                                    <parameter>path</parameter> parameter is
                                    not provided, the current working directory
                                    is listed.  If <parameter>path</parameter>
                                    is provided and is a relative path, the variable's
                                    path is computed with the current working directory
                                    as a base. 
                                </para>
                                <para>
                                    The command returns a (possibly empty) list.
                                    Each element of the list is a 5 element sublist
                                    containing in order the variable's id,
                                    the variables name (excluding the directory path
                                    part of it), the variable's type,
                                    the id of the variable type
                                    and the id of the
                                    directory that contains the variable and the
                                </para>
                            </listitem>
                        </varlistentry>
                        
                    </variablelist>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        varmgr::enum <replaceable>$handle type-name list-of-values</replaceable>
                        </command>
                    </cmdsynopsis>

                </term>
                <listitem>
                    <para>
                        Creates a new data type <parameter>type-name</parameter>
                        that is an enumerated data type.
                        <parameter>list-of-values</parameter> is a Tcl list that
                        defines the set of legal values for variables created of
                        this new type.
                    </para>
                    <para>
                        Once <parameter>type-name</parameter> has been created
                        you can create variables of that type just like you
                        would
                        any other variable.   The first value of the
                        <parameter>list-of-values</parameter> will be the default
                        value for variables of thsi type.
                    </para>
                    <para>
                        For example:
                    </para>
                    <informalexample>
                        <programlisting>
varmgr::enum $handle colors [list red white blue]
varmgr::var create $handle /mycolor;            # /mycolor is red (default).
varmgr::var create $handle /anothercolor blue;  # /anothercolor is blue.
varmgr::var set $handle /mycolor grey;          # fails, grey is not a valid color.
varmgr::var set $handle /mycolor white;         # /mycolor is now white.
                        </programlisting>
                    </informalexample>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
varmgr::statemachine <replaceable>$handle type-name transition-dict</replaceable>
                        </command>
                    </cmdsynopsis>
            
                </term>
                <listitem>
                    <para>
                        Creates a new type <parameter>type-name</parameter>
                        that is a state machine.  The statemachine has a
                        transition map that is determined by its
                        <parameter>transition-dcit</parameter>.  The
                        <parameter>transition-dict</parameter> is a Tcl
                        dict object whose keys are valid states inthe state
                        machine and whose values are reachable states from
                        the key state.
                    </para>
                    <para>
                        Note that the alphabetically first state will be the
                        initial state for variables of this type.
                    </para>
                    <para>
                        For example,  If you want to produce a state machine
                        with the following transition table:
                    </para>
                    <informaltable frame='all'>
                        <tgroup cols='2' align='left' colsep='1' rowsep='1'>
                        <thead>
                            <row>
                                <entry>From State</entry>
                                <entry>To State</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>Not-Ready</entry><entry>Inactive</entry>
                            </row>
                            <row>
                                <entry>Inactive</entry><entry>Active</entry>
                            </row>
                            <row>
                                <entry>Inactive</entry><entry>Not-Ready</entry>
                            </row>
                            <row>
                                <entry>Active</entry><entry>Inactive</entry>
                            </row>
                            <row>
                                <entry>Active</entry><entry>Not-Ready</entry>
                            </row>
                        </tbody>
                    </tgroup>
                    </informaltable>
                <para>
                    You might use the following code.  Note that we name
                    the <literal>Not-Ready</literal> state to be
                    <literal>0Not-Ready</literal> to ensure it is the
                    initial state:
                </para>
                <informalexample>
                    <programlisting>
set runStates [dict create   0Not-Ready Inactive   \
    Inactive [list 0Not-Ready Active]              \
    Active   [list 0Not-Ready Inactive]]
    
    
varmgr::statemachine runStateMachine $runStates

                    </programlisting>
                </informalexample>
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>

      </refentry>
      <refentry id="tcl3_varmgrsubscribe">
        <refentryinfo>
          <author>
                  <personname>
                          <firstname>Ron</firstname>
                          <surname>Fox</surname>
                  </personname>
          </author>
          <productname>NSCLDAQ</productname>
          <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='tcl3_varmgrsubscribe_title'>varmgr::subscribe</refentrytitle>
           <manvolnum>3tcl</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>varmgr::subscribe</refname>
           <refpurpose>Tcl bindings to the variable database publish/subscribe service.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
package require varmgr
          </command>
          </cmdsynopsis>
          <programlisting>
varmgr::subscribe <replaceable>uri command</replaceable>
<replaceable>command</replaceable> subscribe <replaceable>pathPrefix</replaceable>
<replaceable>command</replaceable> unsubscribe <replaceable>pathPrefix</replaceable>
<replaceable>command</replaceable> wait <replaceable>?timeout?</replaceable>
<replaceable>command</replaceable> read
<replaceable>command</replaceable> notify <replaceable>script</replaceable>
<replaceable>command</replaceable> destroy

          </programlisting>
        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Provides a Tcl-ish encapsulation of the variable database manager's
            subscription API.  This API allows your script to subscribe to and be
            informed of changes to the variable database.
           </para>
           <para>
            Subscriptions take the form of a path prefix that is textually matched
            to the first characters of the path field for each publication. If
            the path matches, the subscription is fulfilled and the message
            is made available to the application.
           </para>
           <para>
            The API is based on the creation of a new command ensemble for each
            bundle of subscriptions.  The command ensemble include a subcommand that
            can destroy itself.
           </para>
        </refsect1>
        <refsect1>
           <title>
              COMMANDS
           </title>
            <para>
                A subscription set consists of a command ensemble.  An ensemble
                represents a connection to the subscription  service of a variable
                database server.  It is possible to have several such ensembles in
                existence each talking with a different database server or even
                several ensembles talking with the same server.
            </para>
            <para>
                The
                <informalexample>
                    <programlisting>
varmgr::subscribe
                    </programlisting>
                </informalexample>
                command creates a new ensemble.  The first parameter is a URI
                that specifies the server the new command will be connected to.
                The second parameter is the name of a new command that will be
                created to manage the subscriptions on this service.
            </para>
            <para>
                The connection URI is of the form:
                <filename>tcp://hostname?:portnum:/service-name</filename>
                where <replaceable>hostname</replaceable> is the host
                name or dotted ip of the system that is running the server.
                <replaceable>portnum</replaceable> is the numeric port on which the
                service is waiting for connections and <replaceable>service-name</replaceable>
                is the name of the service the server advertises for its publish/subscribe
                service.
            </para>
            <para>
                The URI has several constraints and special cases:
            </para>
            <itemizedlist>
                <listitem><para>A URI must use the <literal>tcp</literal> protocol
                </para></listitem>
                <listitem><para>The URI cannot have both the port and the
                    service name.
                </para></listitem>
                <listitem><para>If the URI has neither the port number nor the
                    service name, the default service name is translated to
                    determine the port.</para></listitem>
            </itemizedlist>
            <para>
                The created command is an ensemble with the following subcommands:
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <replaceable>command</replaceable> subscribe <replaceable>pathPrefix</replaceable>
                    </term>
                    <listitem>
                        <para>
                            Adds a subscription to the part of the database
                            specified by <parameter>pathPrefix</parameter>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <replaceable>command</replaceable> unsubscribe <replaceable>pathPrefix</replaceable>
                    </term>
                    <listitem>
                        <para>
                            Removes a subscription to <parameter>pathPrefix</parameter>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <replaceable>command</replaceable> wait <replaceable>?timeout?</replaceable>
                    </term>
                    <listitem>
                        <para>
                            Waits for a message to arrive for at most
                            <parameter>timeout</parameter> milliseconds.
                            If <parameter>timeout</parameter> is <literal>0</literal>
                            the function never blocks.  If <parameter>timeout</parameter>
                            is omitted or negative, the command blocks until a
                            message is available.
                        </para>
                        <para>
                            The command returns 0 if no message is avaialble and 1 if
                            it is on return.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <replaceable>command</replaceable> read
                    </term>
                    <listitem>
                        <para>
                            Reads the next notification message, blocking if needed
                            until one is available.  The method returns a
                            dict with the following keys:
                        </para>
                        <itemizedlist>
                            <listitem><para>
                                <literal>path</literal> the path for which the
                                notification is being delivered.
                            </para></listitem>
                            <listitem><para>
                                <literal>op</literal> the operation that was
                                performed.
                            </para></listitem>
                            <listitem><para>
                                <literal>data</literal> additional data associated
                                with the notification.
                            </para></listitem>
                        </itemizedlist>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <replaceable>command</replaceable> notify <replaceable>script</replaceable>
                    </term>
                    <listitem>
                        <para>
                            This command is used with scripts that use
                            event loops (e.g. Tk scripts or scripts that
                            vwait).  When a notification message is available
                            and the script is in the event loop,
                            <parameter>script</parameter> is run.
                        </para>
                        <para>
                            To remove notification scripts, use notify with an empty
                            script.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <replaceable>command</replaceable> destroy
                    </term>
                    <listitem>
                        <para>
                            Destroys the command ensemble.  If any notification is
                            enabled, it too is destroyed.
                        </para>
                    </listitem>
              
                    
                </varlistentry>               
            </variablelist>
        </refsect1>

      </refentry>


<!-- /manpage -->

<!-- manpage 3daq -->
<refentry id="daq3_cvarmgrapi">
  <refentryinfo>
    <author>
        <personname>
            <firstname>Ron</firstname>
            <surname>Fox</surname>
        </personname>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='daq3_cvarmgrapi_title'>CVarMgrApi</refentrytitle>
     <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>CVarMgrApi</refname>
     <refpurpose>Defines the variable manager API.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <synopsis>
#include &lt;CVarMgrApi.h&gt;
class <ooclass><classname>CVarMgrApi</classname></ooclass>
{
public:
    typedef <type>std::vector&lt;std::string&gt; EnumValues;</type>
    typedef <type>std::map&lt;std::string, std::set&lt;std::string&gt; &gt; StateMap;</type>
public:
    <methodsynopsis>
        <modifier>virtual </modifier>
        <type>void </type>
        <methodname>cd</methodname>
        <methodparam>
            <modifier>const</modifier><type> char*</type>
                <parameter>path </parameter>
                <initializer>= "/"</initializer>
        </methodparam>
        <modifier>= 0</modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier>virtual </modifier>
        <type>std::string </type>
        <methodname>getwd</methodname>
        <void />
        <modifier> = 0</modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier>virtual </modifier>
        <type>void </type>
        <methodname>mkdir</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
            <parameter>path</parameter>
        </methodparam>
        <modifier> = 0</modifier>
    </methodsynopsis>      
    <methodsynopsis>
        <modifier>virtual </modifier>
        <type>void </type>
        <methodname>rmdir</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>path</parameter>
        </methodparam>
        <modifier>    = 0;</modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier>virtual </modifier>
        <type>void </type>
        <methodname>declare</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>path</parameter>
        </methodparam>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>type</parameter>
        </methodparam>
        <methodparam>
            <modifier>char* </modifier><type></type>
                <parameter>initial</parameter>
                <initializer>=0</initializer>
        </methodparam>
        <modifier>= 0</modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier>virtual </modifier>
        <type>void </type>
        <methodname>set</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>path</parameter>
        </methodparam>
        <methodparam>
            <modifier> const </modifier><type>char* </type>
                <parameter>value </parameter>
        </methodparam>
        <modifier>= 0</modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier>virtual </modifier>
        <type>std::string </type>
        <methodname>get</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>path</parameter>
        </methodparam>
        <modifier> = 0</modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier>virtual </modifier>
        <type>void </type>
        <methodname>defineEnum</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>typeName</parameter>
        </methodparam>
        <methodparam>
            <modifier></modifier><type> EnumValues </type>
                <parameter>values</parameter>
        </methodparam>
         <modifier> = 0</modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier>virtual </modifier>
        <type>void </type>
        <methodname>defineStateMachine</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>typeName</parameter>
        </methodparam>
        <methodparam>
            <modifier></modifier><type>StateMap </type>
                <parameter>transitions</parameter>
        </methodparam>
        <modifier>= 0</modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>addTransition</methodname>
        <methodparam>
            <modifier></modifier><type>StateMap&amp; </type>
                <parameter>map</parameter>
        </methodparam>
        <methodparam>
            <modifier></modifier><type>std::string </type>
                <parameter>fromState</parameter>
        </methodparam>
        <methodparam>
            <modifier></modifier><type>std::string  </type>
                <parameter>toState</parameter>
        </methodparam>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>bool </type>
        <methodname>validTransitionMap</methodname>
        <methodparam>
            <modifier></modifier><type>StateMap</type>
                <parameter>map</parameter>
        </methodparam>
    </methodsynopsis>      
    
};
   </synopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        This class is an abstract base class that defines
        an API for a variable database.  In conjunction with
        <link linkend='daq3_cvarmgrapifactory'
              endterm='daq3_cvarmgrapifactory_title' />,
        and concrete subclasses of <classname>CVarMgrApi</classname>,
        applications have an API to variable databases that is
        independent of the connection mechanism (direct or via
        server).
     </para>
     <para>
        In addition, this class provides a set of utility methods that
        applications and derived classes can use to build and validate the
        state transition tables used to define new state machine data types.
     </para>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <variablelist>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>virtual </modifier>
                    <type>void </type>
                    <methodname>cd</methodname>
                    <methodparam>
                        <modifier>const</modifier><type> char*</type>
                            <parameter>path </parameter>
                            <initializer>= "/"</initializer>
                    </methodparam>
                    <modifier>= 0</modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    The API has the concept of a current working directory.
                    When paths are provided to the API that are relative
                    (not starting with a <literal>/</literal>), the actual
                    path used s calculated relative to this working directory.
                </para>
                <para>
                    The <methodname>cd</methodname> method changes the
                    current working directory to <parameter>path</parameter>.
                    If the <parameter>path </parameter> does not exist a
                    <classname>CVarMgrApi::CException</classname> is thrown.
                    See PUBLIC VARIABLES, TYPES and CONSTANTS
                    for more about this exception.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>virtual </modifier>
                    <type>std::string </type>
                    <methodname>getwd</methodname>
                    <void />
                    <modifier> = 0</modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns the current working directory.  See
                    the description of <methodname>cd</methodname>
                    above for more information.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>virtual </modifier>
                    <type>void </type>
                    <methodname>mkdir</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                        <parameter>path</parameter>
                    </methodparam>
                    <modifier> = 0</modifier>
                </methodsynopsis>      
            </term>
            <listitem>
                <para>
                    Creates a new directory specified by
                    <parameter>path</parameter>.  If the
                    <parameter>path</parameter> is relative
                    the actual path is computed relative to the
                    current working directory.   If needed,
                    missing intermediate path elements are also
                    created.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>virtual </modifier>
                    <type>void </type>
                    <methodname>rmdir</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>path</parameter>
                    </methodparam>
                    <modifier>    = 0;</modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Deletes a diretory specified by
                    <parameter>path</parameter>.  Relative paths are
                    computed relative to thye object's current working
                    directory.
                </para>
                <para>
                    If the directory does not exist or is not empty,
                    <classname>CVarMgrApi::CException</classname> is
                    thrown.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>virtual </modifier>
                    <type>void </type>
                    <methodname>declare</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>path</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>type</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier>char* </modifier><type></type>
                            <parameter>initial</parameter>
                            <initializer>=0</initializer>
                    </methodparam>
                    <modifier>= 0</modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Creates a new variable.  The path to the variable is
                    determined by <parameter>path</parameter> in conjunction
                    (if the <parameter>path</parameter> is relative) with the
                    current working directory.  
                </para>
                <para>
                    The type of the variable is specified by the <parameter>type</parameter>
                    parameter.  If the <parameter>initial</parameter> parameter
                    is defined, it must be a legal value for the specified
                    <parameter>type</parameter> and is assigned to be the
                    initial value of the variable.  If the parameters is not
                    suppied, the defautl vale for the type is used instead.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>virtual </modifier>
                    <type>void </type>
                    <methodname>set</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>path</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier> const </modifier><type>char* </type>
                            <parameter>value </parameter>
                    </methodparam>
                    <modifier>= 0</modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Sets the variable <parameter>path</parameter> to a
                    new <parameter>value</parameter>.  The
                    <parameter>value</parameter> must be legal for
                    the variable's type.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>virtual </modifier>
                    <type>std::string </type>
                    <methodname>get</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>path</parameter>
                    </methodparam>
                    <modifier> = 0</modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns the value of the variable specified by
                    the <parameter>path</parameter> parameter. If the
                    <parameter>path</parameter> is relative, the
                    current working directory is used as the base of the
                    path computation.
                </para>
                <para>
                    If the variable does not exist the
                    <classname>CVarDbMgr::CException</classname> exception
                    is thrown.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>virtual </modifier>
                    <type>void </type>
                    <methodname>defineEnum</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>typeName</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier></modifier><type> EnumValues </type>
                            <parameter>values</parameter>
                    </methodparam>
                     <modifier> = 0</modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Defines a new enumerated type.  <parameter>typeName</parameter>
                    is the name of the type.  <parameter>value</parameter>
                    is a vector of allowed values.  An exception derived
                    from <classname>std::runtime_error</classname> is thrown
                    if there are duplicate values in <parameter>values</parameter>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>virtual </modifier>
                    <type>void </type>
                    <methodname>defineStateMachine</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>typeName</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier></modifier><type>StateMap </type>
                            <parameter>transitions</parameter>
                    </methodparam>
                    <modifier>= 0</modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Defines a state machine data type.  The name of the new
                    data type will be <parameter>typeName</parameter>.
                    The state transition map is <parameter>transitions</parameter>.
                </para>
                <para>
                    See <methodname>addTransition</methodname> below
                    for information about how to build up state transition
                    maps.  In addtion the <methodname>validTransitionMap</methodname>
                    will validate the transition map for unreachable states and
                    transitions to states that were not defined.  If you use
                    <methodname>addTransition</methodname> to build your
                    state map there can be no dead end states (states with no
                    outbound transitions) as that method defines a state
                    when a transition from that state is first defined.
                </para>
            </listitem>
        </varlistentry>        
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>addTransition</methodname>
                    <methodparam>
                        <modifier></modifier><type>StateMap&amp; </type>
                            <parameter>map</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier></modifier><type>std::string </type>
                            <parameter>fromState</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier></modifier><type>std::string  </type>
                            <parameter>toState</parameter>
                    </methodparam>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    This utility is implemente in the
                    <classname>CVarMgrApi</classname> base class.
                    It defines a new state transition in the
                    state transition <parameter>map</parameter>.
                    <parameter>fromState</parameter> is the originating
                    state. If necessary it is created.  The
                    <parameter>toState</parameter> is the final state
                    of the transition.  It is not created.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>bool </type>
                    <methodname>validTransitionMap</methodname>
                    <methodparam>
                        <modifier></modifier><type>StateMap</type>
                            <parameter>map</parameter>
                    </methodparam>
                </methodsynopsis>      
            </term>
            <listitem>
                <para>
                    Returns <literal>true</literal> if the
                    state transition <parameter>map</parameter>
                    is a valid state transition map.  The map is
                    checked to ensure that the target states of
                    all transitions are defined and that there
                    are no states defined that do not have at least
                    one transition as their target (island states).
                </para>
            </listitem>
        </varlistentry>
     </variablelist>
  </refsect1>
   <refsect1>
      <title>PUBLIC VARIABLES, TYPES and CONSTANTS</title>
      <para>
        The <classname>CVarMgrApi</classname> class defines the following
        internal types.  By internal type we mean a type that is defined
        within the class namespace (e.g. <classname>CVarMgrApi::CException</classname>
        not just <classname>CException</classname>).
      </para>
      <variablelist>
        <varlistentry>
            <term><type>std::vector&lt;std::string&gt; EnumValues;</type></term>
            <listitem>
                <para>
                    Used to describe the set of values an enumerated type
                    may take.  
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><type>std::map&lt;std::string, std::set&lt;std::string&gt; &gt; StateMap;</type></term>
            <listitem>
                <para>
                    Used to describe state transitions.  The keys in the map are
                    defined states. The sets for each key are the target states
                    reachable from the key state.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>CException</term>
            <listitem>
                <para>
                    Exception type that is derive from
                    <classname>std::runtime_exception</classname> used to report
                    API errors.
                </para>
            </listitem>
        </varlistentry>

      </variablelist>
   </refsect1>
</refentry>

<refentry id="daq3_cvarmgrapifactory">
  <refentryinfo>
    <author>
        <personname>
            <firstname>Ron</firstname>
            <surname>Fox</surname>
        </personname>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='daq3_cvarmgrapifactory_title'>CVarMgrFactory</refentrytitle>
     <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>CVarMgrFactory</refname>
     <refpurpose>Producer of <classname>CVarMgrApi</classname> objects.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <synopsis>
#include &lt;CVarMgrApiFactory.h&gt;
class <ooclass><classname>CVarMgrApiFactory</classname></ooclass>
{
        <methodsynopsis>
            <modifier>static </modifier>
            <type>CVarMgrApi* </type>
            <methodname>create</methodname>
            <methodparam>
                <modifier></modifier><type>std::string </type>
                    <parameter>uri</parameter>
            </methodparam>
        </methodsynopsis>  
        <methodsynopsis>
            <modifier>static </modifier>
            <type>CVarMgrApi*</type>
            <methodname> createFileApi</methodname>
            <methodparam>
                <modifier></modifier><type>std::string </type>
                    <parameter>path</parameter>
            </methodparam>
          </methodsynopsis>  
        <methodsynopsis>
            <modifier>static </modifier>
            <type>CVarMgrApi* </type>
            <methodname>createServerApi</methodname>
            <methodparam>
                <modifier></modifier><type>std::string </type>
                    <parameter>host</parameter>
            </methodparam>
            <methodparam>
                <modifier></modifier><type>int</type>
                    <parameter> port</parameter>
            </methodparam>
            
        </methodsynopsis>  
        <methodsynopsis>
            <modifier>static </modifier>
            <type>CVarMgrApi* </type>
            <methodname>createServerApi</methodname>
            <methodparam>
                <modifier></modifier><type>std::string </type>
                    <parameter>host</parameter>
            </methodparam>
            <methodparam>
                <modifier></modifier><type>std::string </type>
                    <parameter>service</parameter>
                    <initializer>std::string("vardb-request")</initializer>
            </methodparam>
            
        </methodsynopsis>  
    
};
   </synopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        The <classname>CVarMgrApiFactory</classname> class creates
        <classname>CVarMgrApi</classname> objects for your application
        program. All methods are static so it is not necessary to
        instantiate an object.  Simply qualify the calls with the name
        of the class (e.g. <methodname>CMVarMgrApi::create(uri);</methodname>).
     </para>
     <para>
        All methods either return a pointer to a dynamically created
        <classname>CVarMgrApi</classname> object or throw a
        <classname>CVarMgrApi::CException</classname> object.
        If your application is finished using an API object created by
        this factory, you should <literal>delete</literal> it to recover
        resources used by that object.
     </para>
     <para>
        In most cases your application will only need to use the
        <methodname>create</methodname> method.  The other methods
        of the factory are used by that method to create specific
        types of APIs, and are available in the event you are writing
        an application that needs a specific API type.
     </para>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <variablelist>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>static </modifier>
                    <type>CVarMgrApi* </type>
                    <methodname>create</methodname>
                    <methodparam>
                        <modifier></modifier><type>std::string </type>
                            <parameter>uri</parameter>
                    </methodparam>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Creates a new <classname>CVarMgrApi</classname> object.
                    The <parameter>uri</parameter> parameter is a URI
                    string that determines both the actual type of the
                    object and what database connection is performed.
                </para>
                <para>
                    If the protocol of the URI is  <literal>file</literal>,
                    the host part of <parameter>uri</parameter> is
                    ignored and the path part of <parameter>uri</parameter>
                    specifies the path to a variable database file that
                    will be directly connected to a
                    <classname>CVarMgrFileApi</classname> object.  See
                    <methodname>createFileApi</methodname> below for more
                    information about the characeristics of these objects.
                </para>
                <para>
                    If the protocol part of <parameter>uri</parameter>
                    is a <literal>tcp</literal>, a
                    <classname>CVarMgrServerApi</classname> object is
                    created to connect to the variable database via a server
                    process.  In this case, the host part of
                    <parameter>uri</parameter> is mandatory and
                    specifies a computer in which a variable database server
                    is running.  The port used to connect with the server
                    is determined as follows:
                </para>
                <itemizedlist>
                    <listitem><para>
                        If a port number is supplied in <parameter>uri</parameter>
                        that port is used for the connection attempt.
                    </para></listitem>
                    <listitem><para>
                        If a path is present in <parameter>uri</parameter> it
                        is a service name that is translated using the
                        DAQ port manager in the host part of the
                        <parameter>uri</parameter> to determine which port
                        is used for the connection attempt.
                    </para></listitem>
                    <listitem><para>
                        If neither a port number nor a path is present in
                        <parameter>uri</parameter>, a default service name
                        is translated in the specified host to determine
                        which port is used for the connection attempt.
                    </para></listitem>
                </itemizedlist>
                <para>
                    Supplying both a port and a path to the <parameter>uri</parameter>
                    is not legal for the <literal>tcp</literal> protocol and
                    results in a a
                    <classname>CVarMgrApi::CException</classname> being thrown.
                    For more information about the <classname>CVarMgrApi</classname>
                    see the <methodname>createServerApi</methodname> methods below.
                </para>
                <para>
                    Regardless of the type of <classname>CVarMgrApi</classname>
                    created, your application should <literal>delete</literal>
                    it when it is no longer needed.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>static </modifier>
                    <type>CVarMgrApi*</type>
                    <methodname> createFileApi</methodname>
                    <methodparam>
                        <modifier></modifier><type>std::string </type>
                            <parameter>path</parameter>
                    </methodparam>
              </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Creates a <classname>CVarMgrFileApi</classname> object.
                    <parameter>path</parameter> is the filesystem path
                    to the data base file.  This is normally used by
                    <methodname>create</methodname> when presented with a
                    URI that specifies a 
                    <literal>file</literal> protocol.
                </para>
                <para>
                    <classname>CVarMgrFileApi</classname> objects implement the
                    interface described by
                    <link linkend='daq3_cvarmgrapi' endterm='daq3_cvarmgrapi_title' />
                    operating directly on a variable database file.
                </para>
                <para>
                    This is suitable for use when the experiment is not running.
                    For example, setting up the initial contents of the database
                    prior to starting the experiment or examining it after the
                    experiment is done.
                </para>
                <para>
                    This is because it is the database server that publishes
                    changes to clients.  Direct access, without going through
                    the database server will circumvent change publications.
                </para>
                <para>
                    Furtheremore, the sorts of locking that SQLite needs to do
                    to allow multiple writers to operate on a database file
                    in a consistent and safe manner don't work properly on
                    many NFS implementations, and in most cases your variable
                    databases will be located on NFS servers.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>static </modifier>
                    <type>CVarMgrApi* </type>
                    <methodname>createServerApi</methodname>
                    <methodparam>
                        <modifier></modifier><type>std::string </type>
                            <parameter>host</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier></modifier><type>int</type>
                            <parameter> port</parameter>
                    </methodparam>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Constructs a <classname>CVarMgrServerApi</classname>
                    object.  This object connects to a variable database
                    via a server process. In addition to responding to requests
                    to modify/query the database, the server implements a
                    publish/subscribe system that notifies subscribers of
                    changes in the database that clients requested.
                </para>
                <para>
                    This method is invoked by <methodname>creaet</methodname>
                    when the URI has a <literal>tcp</literal> protocol.
                    <parameter>host</parameter> specifies the system in
                    which the server is running while <parameter>port</parameter>
                    specifies the numbered port that the server is using
                    for its REQ/REP communications service.
                </para>
                <para>
                    <classname>CVarMgrServerApi</classname> objects
                    completely implement the interface
                    described by
                    <link linkend='daq3_cvarmgrapi'
                          endterm='daq3_cvarmgrapi_title' />
                </para>
                <para>
                    <classname>CVarMgrServerApi</classname> objects are what
                    should be used when the experiment is running.  Using
                    it serializes multiple requestors and runs the PUB/SUB
                    system that allows clients to be informed when
                    parts of the database they are interested in change.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>static </modifier>
                    <type>CVarMgrApi* </type>
                    <methodname>createServerApi</methodname>
                    <methodparam>
                        <modifier></modifier><type>std::string </type>
                            <parameter>host</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier></modifier><type>std::string </type>
                            <parameter>service</parameter>
                            <initializer>std::string("vardb-request")</initializer>
                    </methodparam>
                </methodsynopsis>      
            </term>
            <listitem>
                <para>
                    Creates a <classname>CVarMgrServerApi</classname> object.
                    See the previous method for more information about the
                    object created.  The only difference between this
                    method and the previous one is that the
                    port connected to is determined by translating the
                    <parameter>service</parameter> name via the
                    DAQ port manager running in the <parameter>host</parameter>
                    system.
                </para>
                <para>
                    The default value for the <parameter>service</parameter>
                    parameter is the the same as the default service advertised
                    by the server for its REQ/REP service.
                </para>
                <para>
                    Note as well that DAQ Port manager service names are
                    qualified by the name of the user running the application.
                    When doing the service name lookup, this method only
                    looks for service names run by the user running the
                    application.
                </para> 
            </listitem>
        </varlistentry>
     </variablelist>
  </refsect1>
  <refsect1>
    <title>BUGS and RESTRICTIONS</title>
    <para>
        It is not possible to directly use the factory to generate an API object
        for a server run by a different user.  Your application can, however
        accomplish this by using the DAQ Port manager API to locate the
        correct service port and call the version of
        <methodname>createServerApi</methodname> that accepts a
        numeric <parameter>port</parameter>
        parameter.
    </para>
  </refsect1>
   <refsect1>
      <title>SEE ALSO</title>
      <para>
        <link linkend='daq3_cvarmgrapi' endterm='daq3_cvarmgrapi_title' />
      </para>
   </refsect1>
</refentry>     

<!-- /manpage -->

<!-- manpage 5daq -->
<refentry id="daq5_vardbserver_reqprotocol">
<refentryinfo>
  <author>
          <personname>
                  <firstname>Ron</firstname>
                  <surname>Fox</surname>
          </personname>
  </author>
  <productname>NSCLDAQ</productname>
  <productnumber></productnumber>
</refentryinfo>
<refmeta>
   <refentrytitle id = 'daq5_vardbserver_reqprotocol_title'>vardbServer REQ message formats</refentrytitle>
   <manvolnum>5daq</manvolnum>
   <refmiscinfo class='empty'></refmiscinfo>
</refmeta>
<refnamediv>
   <refname>vardbServer</refname>
   <refpurpose>vardbServer</refpurpose>
</refnamediv>

<refsynopsisdiv>
  <note>
    <title>NOTE</title>
    <para>
        The current reference information for the message data
        structure and detailed messages are maintained on
        the wiki for the project in the NSCLDAQ internal
        redmine server.  If you require a copy of that document,
        contact the NSCL team maintaining NSCLDAQ.
    </para>
    <para>
        Note that the messages described here do not include
        whatever message envelopes used by 0mq in transmitting
        data between <literal>REQ/REP</literal> sockets.
        You must use 0mq to talk with the server or else
        undefined results may occur.
    </para>
  </note>

</refsynopsisdiv>
<refsect1>
   <title>DESCRIPTION</title>
   <para>
    With the possible exception of the 0mq message envelopes, the
    messages exchanged beetween the client and server are purely
    textual. 
   </para>
   <para>
    Each request consists of three colon separated fields that are
    called the <literal>operation</literal>, <literal>operand1</literal>
    and <literal>operand2</literal>.  For most messages,
    <literal>operand1</literal> is a path specification within the
    variable directory tree.
   </para>
   <para>
    Each reply consists of two colon separated fields that are called
    the <literal>status</literal> and <literal>data</literal> fields.
    The <literal>status</literal> field will contain either
    <literal>OK</literal> or <literal>FAIL</literal> indicating whether
    the request succeeded.  For <literal>FAIL</literal>
    returns, the <literal>data</literal> field contains a human
    readable error message.
    For <literal>OK</literal> returns, the <literal>data</literal>
    field contents depend on the operation requested.
   </para>
</refsect1>
<refsect1>
   <title>
      REQUESTS
   </title>
   <segmentedlist>
    <segtitle>Operation</segtitle><segtitle>Operand1</segtitle><segtitle>Operand2</segtitle>
    <segtitle>Description</segtitle>
    <seglistitem>
        <seg>MKDIR</seg><seg>path</seg><seg></seg>
        <seg>
            Attempts to create a new directory specified by
            <literal>path</literal>.
            On success, the reply's <literal>data</literal> field is empty.
        </seg>
    </seglistitem>
    <seglistitem>
        <seg>RMDIR</seg><seg>path</seg><seg></seg>
        <seg>
            Attempts to remove the directory indicated by the path.
            On success, the <literal>data</literal> field of
            the reply will be empty.
        </seg>
    </seglistitem>
    <seglistitem>
        <seg>DECL</seg><seg>path</seg><seg>type|?value?</seg>
        <seg>
            Attempts to create a new variable specified by
            the absolute <literal>path</literal> provided.
            <literal>type</literal> is the data type for the
            variable and if <literal>value</literal> is present
            and legal, specifies the initial value.
            If <literal>value</literal> is not present,
            the type's default value is used.  On success, the
            <literal>data</literal> field of the reply
            is empty.
        </seg>
    </seglistitem>
    <seglistitem>
        <seg>SET</seg><seg>path</seg><seg>value</seg>
        <seg>
            Attempt to set the variable specified by
            <literal>path</literal> to <literal>value</literal>.
            Type/value checking is done on the server and results
            in a <literal>FAIL</literal> status if the
            <literal>value</literal> is not valid for the
            variable's type.  On success, the <literal>data</literal>
            field of the reply is empty.
        </seg>
    </seglistitem>
    <seglistitem>
        <seg>GET</seg><seg>path</seg><seg></seg>
        <seg>
            Retrieves the value of the variable specified
            by <literal>path</literal>.  If the status
            of the request is <literal>OK</literal>, the
            value of the variable is returned in the
            <literal>data</literal> field of the reply.
        </seg>
    </seglistitem>
    <seglistitem>
        <seg>ENUM</seg><seg>type-name</seg><seg>value1|value2...</seg>
        <seg>
            Defines a new enumerated data type <literal>type-name</literal>.
            The possible values this type can hold are pipe separated
            fields of operand2.  The first item given is the default
            value for variables of this type.
            On success the data field of the reply
            is empty.
        </seg>
    </seglistitem>
    <seglistitem>
        <seg>SMACHINE</seg><seg>type-name</seg><seg>state1,target1,...|state2,...</seg>
        <seg>
            Defines a new state machine type <literal>type-name</literal>.
            The states and transitions are given in the operand 2 field.
            This field is a set of <literal>|</literal> separated fields.
            Each of those fields is a <literal>,</literal> separated set
            of fields that give the state name, and the valid target states
            in that order.  The state machine's initial state is the
            alphabetically 'smallest' state name.  Therefore it is normal
            for this state to be a name like <literal>0actual-state-name</literal>.
        </seg>
    </seglistitem>
    <seglistitem>
        <seg>DIRLIST</seg><seg>directory-path</seg><seg></seg>
        <seg>
            Requests a list of the sub directories in the specified
            <literal>directory-path</literal>.   The data part of the
            return message is the set of subdirectories in that path
            separated by the pipe (<literal>|</literal>) character.
        </seg>
        <seg>VARLIST</seg><seg>directory-path</seg><seg></seg>
        <seg>
            Requests a list of the variables in the directory specified by the
            <literal>directory-path</literal>.
            The data part of a success reply contains a list of pipe
            (<literal>|</literal>) separated fields.  Three consecutive fields
            are required/used to describe a single variable.  In order, these
            contain the variable's name, data type and value as of when the
            message was marshalled for transmission.
        </seg>
    </seglistitem>
   </segmentedlist>
</refsect1>
<refsect1>
    <title>BUGS</title>
    <para>
        There is no way to escape field separators.  This is not a problem for
        most cases however it does mean that enumerated types cannot have the
        <literal>|</literal> character in their values.  
    </para>
    <para>
        Note that where there are a fixed number of fields, splitting fields stops
        when the required number of fields have been split apart. Thus in:
        <literal>DECL:a:string|This string|has pipes and :s</literal>,
        since it is known that messages have 3 fields and that the last field
        has two subfields, the <literal>|</literal> and <literal>:</literal>
        characters are allowed in the string's value.
    </para>
</refsect1>
</refentry>

<refentry id="daq5_varserver_pubprotocol">
  <refentryinfo>
    <author>
            <personname>
                    <firstname>Ron</firstname>
                    <surname>Fox</surname>
            </personname>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='daq5_varserver_pubprotocol_title'>Variable database server published messages</refentrytitle>
     <manvolnum>5daq</manvolnum>
     <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>vardbServer</refname>
     <refpurpose>vardbServer</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
  <note>
    <title>NOTE</title>
    <para>
        The current reference information for the message data
        structure and detailed messages are maintained on
        the wiki for the project in the NSCLDAQ internal
        redmine server.  If you require a copy of that document,
        contact the NSCL team maintaining NSCLDAQ.
    </para>
    <para>
        Note that the messages described here do not include
        whatever message envelopes used by 0mq in transmitting
        data between <literal>PUB/SUB</literal> sockets.
        You must use 0mq to talk with the server or else
        undefined results may occur.
    </para>
  </note>
    

  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        With the exception of the 0mq message envelopes, the message
        data are fully textual.  Since this service is a
        <literal>PUB/SUB</literal> set of sockets where
        the variable database is the publishers, messages flow
        from the server without any back traffic along that
        port set.
     </para>
     <para>
        Messages consist of notifications to subscribers that
        about changes to the contents of the database.
        Each message consists of three colon separated fields in order;
        <literal>Path</literal>, the path to the entity affectedm,
        <literal>Operation</literal> the operation that was performed.
        <literal>Data</literal> any additional data.
     </para>
     <para>
        Since the <literal>Path</literal> field is first, and since
        0mq subscriptions are based on the leading part of messages
        published, it is trivial to declare interest in subtrees of
        the variable database.  Note that a 0mq subscriber is allowed
        to have more than one concurrent subscription.
     </para>
  </refsect1>
  <refsect1>
     <title>
        MESSAGES
     </title>
    <segmentedlist>
        <segtitle>Path</segtitle><segtitle>Operation</segtitle><segtitle>Data</segtitle>
        <seglistitem>
            <seg>containing directory</seg><seg>MKDIR</seg><seg>created directory</seg>
            <seg>
                Publishes the creation of a new directory.  The path field contains
                a path to the parent directory while the data field contains
                the name of the directory that was created with in that path.
                Thus <literal>/this/that/the:MKDIR:other</literal>
                notifies you of the creation of the directory
                <literal>/this/that/the/other</literal>
            </seg>
        </seglistitem>
        <seglistitem>
            <seg>containing directory</seg><seg>RMDIR</seg><seg>deleted directory</seg>
            <seg>
                Publishes the deletion of a directory.  The <literal>path</literal>
                and <literal>data</literal> fields are used in a
                mannger identical to <literal>MKDIR</literal> above
                however the directory is being deleted rather than being
                created.
            </seg>
        </seglistitem>
        <seglistitem>
            <seg>type-name</seg><seg>TYPE</seg><seg>data-type</seg>
            <seg>
                Publishes the creation of a new data type. In this case the
                <literal>path</literal> field is used to publish the new
                type-name while the data field is the type family to
                which the new type belongs (currently either <literal>enum</literal>
                or <literal>statemachine</literal>).
            </seg>
        </seglistitem>
        <seglistitem>
            <seg>path-to-variable</seg><seg>NEWVAR</seg><seg>type|value</seg>
            <seg>
                Publishes the creation of a new variable.  The path
                field is the full absolute path to the variable while
                the data field consists of a pair of <literal>|</literal>
                separated subfields holding in order the name of the variable's
                data type and its intial value.  Note that the actual initial
                value is supplied even if the value was defaulted at creation
                time.  For example: <literal>/mydir/myvar:NEWVAR:colors|red</literal>
                indicates the variable <literal>/mydir/myvar</literal> was created
                and has the type <literal>colors</literal> with the initial value
                <literal>red</literal>.
            </seg>
        </seglistitem>
        <seglistitem>
            <seg>path-to-variable</seg><seg>ASSIGN</seg><seg>new-value</seg>
            <seg>
                In most cases, these are the messages a real application
                wants to see.  These messages indicate a new value
                has been assigned to the variable specified by
                the path field.  The new value is in the data field.
            </seg>
        </seglistitem>
    </segmentedlist>
  </refsect1>
  <refsect1>
    <title>BUGS</title>
    <para>
        Due to the irregular use of the path field for the <literal>TYPE</literal>
        message, in general you can only get those notifications by subscribing
        to everything.  In fact, there are few use cases where that's
        meaningful so that is probably not an issue for real applications.
    </para>
  </refsect1>
</refentry>

<!-- /manpage  -->
<!-- manpage 3python -->
<refentry id="python3_varmgr">
  <refentryinfo>
    <author>
        <personname>
            <firstname>Ron</firstname>
            <surname>Fox</surname>
        </personname>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='python3_varmgr_title'>nscldaq.vardb.varmgr</refentrytitle>
     <manvolnum>3</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>nscldaq.vardb.varmgr.Api</refname>
     <refpurpose>Python bindings to variable manager API.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   
    <programlisting>
import nscldaq.vardb.varmgr

nscldaq.vardb.varmgr.create(filepath)

api = nscldaq.vardb.varmgr.Api(uri)
api.mkdir(path)
api.cd(path)
api.getwd()
api.rmdir(path)
api.declare(path, typename[, initialValue])
api.set(path, newValue)
value = api.get(path)
api.defineEnum(typeName, values)
api.defineStateMachine(typeName, transitions)
dirs = api.ls([path])
vars = api.lsvar([path])
api.rmvar(path)


    </programlisting>
   
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        <literal>nscldaq.vardb.varmgr</literal> provides  binding to the
        VarMgr api and api factories.  This allows python scripts to be
        written that can operate either directly on database files of via
        the variable database server.
     </para>
     <para>
        A module level method;
        <methodname>nscldaq.vardb.varmgr.create</methodname>
        allows your script to create a new varialbe database.
     </para>
     <para>
        All errors are reported by raising the
        <literal>nscldaq.vardb.varmgr.error</literal> exception.  This
        exception's string representation is a human readable error message.
     </para>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <variablelist>
        <varlistentry>
         <term>
            <methodname>nscldaq.vardb.varmgr.create(<replaceable>filepath</replaceable>)</methodname>
         </term>
         <listitem>
             <para>
                Creates a new database in the file specified by
                <parameter>filepath</parameter>.  If the file already
                exists and is a valid database, this is a no-op.
                If the file exists and is an SQLite database but does not
                have the variable datbase schema, the schema is created.
                This allows a variable database to co-exist with other
                tables in another database.
             </para>
             <para>
                If <parameter>filpath</parameter> does not specify
                a createable file, or if it specifies an existing file that
                is not an SQLite database, the
                <literal>nscldaq.vardb.varmgr.error</literal>
                exception is raised.
             </para>
         </listitem>
        </varlistentry>
         <varlistentry>
             <term>
                <methodname>nscldaq.vardb.varmgr.Api(<replaceable>uri</replaceable>)</methodname>
             </term>
             <listitem>
                 <para>
                    Creates an instance of a new VarMgr API object. The
                    <parameter>uri</parameter> parameter determines how
                    the API connects to the database.  Two URI protocols
                    are supported; <literal>file</literal> and <literal>tcp</literal>
                 </para>
                 <para>
                    A <literal>file</literal> protocol indicates a direct
                    connection to a file.  These URI's are of the form
                    <literal>tcp://</literal><replaceable>/path/to/file</replaceable>.
                    Where <replaceable>/path/to/file</replaceable> is the
                    File system path to the data base file.  The database file must
                    already exist and be a valid variable database.
                    Note that <replaceable>/path/to/file</replaceable> is an
                    absolute file system path and knows nothing of your
                    current working directory.
                 </para>
                 <para>
                    A <literal>tcp</literal> protocol indicates a connection
                    to a variable database server.  Using the variable database
                    server provides notification of changes to the variable
                    database to applications that subscsribe to notifications.
                    There are three forms the <literal>tcp</literal> protocol
                    URI's can take.
                 </para>
                 <para>
                    The first form a <literal>tcp</literal> protocol URI can take
                    is <literal>tcp://</literal><replaceable>hostname</replaceable>
                    In this form, the server is considered to be running in
                    the system <replaceable>hostname</replaceable>.  The server's
                    request port is determined by looking up a default service name
                    for that request port via the DAQPortManager running in
                    <replaceable>hostname</replaceable>.  Since the server
                    publishes its service names via the DAQPortManager, if you
                    started up the server using the default service names, this
                    sort of URI works just fine.
                 </para>
                 <para>
                    The second form a <literal>tcp</literal> protocol is most
                    often used when you used a request service name other than
                    the default.  It takes the form:
                    <literal>tcp://</literal><replaceable>hostname/servicename</replaceable>
                    Once more,  The <replaceable>hostname</replaceable>  is the
                    name of the system in which the server is running.  The
                    request port is determined by looking up the
                    service <replaceable>servicename</replaceable> in the
                    DAQPort manager running in <replaceable>hostname</replaceable>.
                 </para>
                 <para>
                    The final form of a <literal>tcp</literal> protocol URI
                    is almost never needed.  It takes the form:
                    <literal>tcp://</literal><replaceable>hostname:portnum</replaceable>
                    Where <replaceable>hostname</replaceable> is the host in which the
                    server is running and <replaceable>portnum</replaceable>
                    is the numeric port on which the server processes requests.
                    Since the server publishes a service name/port mapping with
                    the port manager, this form of URI is only supplied for
                    completeness and because URI's are allowed to have a port number
                    specified in a host specification.
                 </para>
             </listitem>
         </varlistentry>
         <varlistentry>
             <term>
                <methodname>api.mkdir(<replaceable>path</replaceable>)</methodname>
             </term>
             <listitem>
                 <para>
                    Given an API object, this method creates a new directory
                    in the variable database.  The variable database is organized
                    as a set of hierarchical directories.  Each directory can
                    contain subdirectories and  variables.  The
                    <parameter>path</parameter> parameter is the path to the
                    directory to be created.
                 </para>
                 <para>
                    As we will later see, the api object has a concept of a
                    current working directory (or cwd).  The <parameter>path</parameter>
                    can be specified as either an absolute path or a path relative
                    to the Api object's cwd.
                 </para>
                 <para>
                    If needed, missing intermediate directories will be created.
                    It is an error to create a duplicate directory.  That
                    error will raise a <classname>nscldaq.vardb.varmgr.error</classname>
                 </para>
             </listitem>
             
         </varlistentry>
         <varlistentry>
             <term>
                <methodname>api.cd(<replaceable>path</replaceable>)</methodname>
             </term>
             <listitem>
                 <para>
                    Api objects have a concept of a current working directory
                    (much like the Unix does with its file system).  This
                    method sets the api object's current working directory
                    to <parameter>path</parameter>.  If <parameter>path</parameter>
                    is relative the new cwd is computed relative to the
                    old cwd.
                 </para>
                 <para>
                    It is an error to attempt to make a nonexistent directory
                    current.  It is an error to specify a cwd that is above the
                    root directory.  All error will be flagged by raising
                    a <classname>nscldaq.vardb.varmgr.error</classname> exception.
                 </para>
                 <para>
                    The code fragment below illustrates illustrates
                    the manner in which relative directories are computed.
                 </para>
                 <informalexample>
                    <programlisting>
                    ...
                    api.cd('/some/directory')
                    api.cd('deeper')      # cwd is now /some/directory/deeper
                    api.cd('..')          # cwd is now /some/directory
                    </programlisting>
                 </informalexample>
             </listitem>
         </varlistentry>
         <varlistentry>
             <term>
                <methodname>api.getwd()</methodname>
             </term>
             <listitem>
                 <para>
                    This method returns a string that is the canonicalized
                    current working directory.   The example
                    below shows what is meant by canonicalized
                 </para>
                 <informalexample>
                    <programlisting>
                        api.cd('/some/directory')
                        api.cd('../other/directory')
                        print(api.getwd())   # prints /some/other/directory
                    </programlisting>
                 </informalexample>
                 <para>
                    Note how the output from the print will be
                    <literal>/some/other/directory</literal> rather than
                    <literal>some/directory/../other/directory</literal>.
                    That is what is mean by canonicalized.
                 </para>
             </listitem>
         </varlistentry>
         <varlistentry>
             <term>
                <methodname>api.rmdir(<replaceable>path</replaceable>)</methodname>
             </term>
             <listitem>
                 <para>
                    Removes the directory specified by <parameter>path</parameter>.
                    If <parameter>path</parameter> is relative the actual
                    directory is computed using the current working directory
                    as the base.
                 </para>
                 <para>
                    It is illegal to remove a directory that does not exist.
                    It is also illegal to remove a directory that is not empty.
                    All errors are reported by raising a
                    <classname>nscldaq.vardb.varmgr.error</classname> exception.
                 </para>
             </listitem>
         </varlistentry>
         <varlistentry>
             <term>
                <methodname>api.declare(<replaceable>path, typename[, initialValue]</replaceable>)</methodname>
             </term>
             <listitem>
                 <para>
                    Creates a new variable. <parameter>path</parameter> specifies
                    the variable's name and directory.  If <parameter>path</parameter>
                    is relative the actual variable path is computed using the api
                    object's current working directory as the base path.
                 </para>
                 <para>
                    <parameter>typename</parameter> is the type of the variable.
                    If provided <parameter>initialValue</parameter> specifies an
                    initial value for the variable.  If this optional parameter
                    is omitted, the variable is initialize with the type's
                    default initial value.
                 </para>
                 <para>
                    It is an error to create a duplicate variable.
                    It is an error to create a variable in a directory that does not
                    yet exist.
                    It is an error to specify an undefined <parameter>typeName</parameter>.
                    It is an error to specify an <parameter>initialValue</parameter>
                    that is not a legal initial value for the variable.
                    These and all other errors are reported to your script by
                    raising a <classname>nscldaq.vardb.varmgr.error</classname>
                    exception.
                 </para>
             </listitem>
         </varlistentry>
         <varlistentry>
             <term>
                <methodname>api.set(<replaceable>path, newValue</replaceable>)</methodname>
             </term>
             <listitem>
                 <para>
                    Modifies the value of the variable specified by
                    <parameter>path</parameter> to be
                    <parameter>newValue</parameter>.  If
                    <parameter>path</parameter> is relative the
                    actual absolute path is computed using
                    the api object's current working directory as
                    a base.
                 </para>
                 <para>
                    It is an error to specify a variable that does not exist.
                    It is an error to specify a <parameter>newValue</parameter>
                    that is not legal for the variable's underlying type.
                    These and all other errors are reported to your script by
                    raising a <classname>nscldaq.vardb.varmgr.error</classname>
                    exception.
                 </para>
             </listitem>
         </varlistentry>
         <varlistentry>
             <term>
                <methodname>api.get(<replaceable>path</replaceable>)</methodname>
             </term>
             <listitem>
                 <para>
                    Returns the value of the variable specified by
                    <parameter>path</parameter>.
                    If
                    <parameter>path</parameter> is relative the
                    actual absolute path is computed using
                    the api object's current working directory as
                    a base.
                 </para>
                 <para>
                    Note that while variables have underlying types,
                    in order to accomodate the wide variety of possible values,
                    variable values are stored in the database, and returned
                    from this method as strings.
                 </para>
                 <para>
                    If <parameter>path</parameter> specifies a
                    nonexistent variable,
                    a <classname>nscldaq.vardb.varmgr.error</classname>
                    exception is raised.
                 </para>
             </listitem>
         </varlistentry>
         <varlistentry>
             <term>
                <methodname>api.defineEnum(<replaceable>typeName, values</replaceable>)</methodname>
             </term>
             <listitem>
                 <para>
                    Defines a new enumerated type.  <parameter>typeName</parameter>
                    is the name of the new type.  <parameter>values</parameter>
                    is any iterable.   Each element of the iterable is a legal
                    value that variables of that type can be assigned.
                 </para>
                 <para>
                    Remember that strings are iterables.  The following two types
                    are different:

                 </para>
                 <informalexample>
                    <programlisting>
                        api.defineEnum('letters', ('hi'))
                        api.defineEnum('word', ('hi', ))
                    </programlisting>
                 </informalexample>
                 <para>
                    In the first statement, the legal values for
                    <literal>letters</literal> variables are
                    <literal>h</literal> and <literal>i</literal>, while
                    the legal value of <literal>word</literal> variables
                    is only <literal>hi</literal>.
                 </para>
                 <para>
                    Defining a duplicate data type is an error.
                    Having duplicate values is an error.
                    Having elements that are not strings is an error as well.
                    These and all other errors are reported to your script by
                    raising a <classname>nscldaq.vardb.varmgr.error</classname>
                    exception.
                 </para>
             </listitem>
         </varlistentry>
         <varlistentry>
             <term>
                <methodname>api.defineStateMachine(<replaceable>typeName, transitions</replaceable>)</methodname>
             </term>
             <listitem>
                 <para>
                    Defines a new statemachine data type named
                    <parameter>typeName</parameter>.  <parameter>transitions</parameter>
                    define both the states and legal transitions.
                    <parameter>transitions</parameter> is a dict whose keys are
                    legal states and whose values are iterables whose elements are
                    reachable states.  The  lexically first state is the default initial
                    state of the machine.  Note that if you create a state machine
                    variable the only legal initial values you can supply are
                    states that are reachable from the default initial state.
                 </para>
                 <para>
                    It is illegal to define a duplicate data type name.
                    It is illegal to define a state that is not reachable.
                    It is illegal to define a transition to an undefined state.
                    These and all other errors are reported to your script by
                    raising a <classname>nscldaq.vardb.varmgr.error</classname>
                    exception.
                 </para>
             </listitem>
         </varlistentry>
         <varlistentry>
             <term>
                <methodname>dirs = api.ls(<replaceable>[path]</replaceable>)</methodname>
             </term>
             <listitem>
                 <para>
                    Returns a tuple whose values are subdirectories.  If
                    <parameter>path</parameter> is provided it is an absolute
                    or relative path that defines which directory is listed.
                    If not supplied the cwd is listed.
                 </para>
                 <informalexample>
                    <programlisting>
                        api.cd('/this/that/theother')
                        result1 = api.ls()      # /this/that/theother is listed
                        result2 = api.ls('/this') # /this is listed.
                        result3 = api.ls('..')    # /this/that is listed.
                    </programlisting>
                 </informalexample>
                 <para>
                    If the <parameter>path</parameter> resolves to a nonexistent
                    directory, a <classname>nscldaq.vardb.varmgr.error</classname>
                    exception is raised.
                 </para>
             </listitem>
         </varlistentry>
         <varlistentry>
             <term>
                <methodname>api.lsvar(<replaceable>[path]</replaceable>)</methodname>
             </term>
             <listitem>
                 <para>
                    Returns information about the variables in a directory.
                    If the optional parameter <parameter>path</parameter>
                    is not given the cwd is listed.   If provided it can
                    be an absolute path or a relative path referenced
                    to the cwd.
                 </para>
                 <para>
                    The method returns a (possibly empty) tuple of maps.
                    Each map has the following key values:
                 </para>
                 <variablelist>
                    <varlistentry>
                        <term><literal>name</literal></term>
                        <listitem>
                            <para>
                                The name of the variable.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>type</literal></term>
                        <listitem>
                            <para>
                                The variable type.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>value</literal></term>
                        <listitem>
                            <para>
                                The current value of the variable.
                            </para>
                        </listitem>
                    </varlistentry>
                    
                 </variablelist>
                 <para>
                    If the <parameter>path</parameter> resolves to a nonexistent
                    directory, a <classname>nscldaq.vardb.varmgr.error</classname>
                    exception is raised.
                 </para>
             </listitem>
         </varlistentry>
         <varlistentry>
             <term>
                <methodname>api.rmvar(<replaceable>path</replaceable>)</methodname>
             </term>
             <listitem>
                 <para>
                    Removes (destroys) the variable described by the
                    <parameter>path</parameter> parameter.
                    <parameter>path</parameter> can either be an
                    absolute path or it can be a path relative to the
                    cwd.
                 </para>
                 <para>
                    If the <parameter>path</parameter> resolves to a nonexistent
                    directory, a <classname>nscldaq.vardb.varmgr.error</classname>
                    exception is raised.
                 </para>
             </listitem>
         </varlistentry>
     </variablelist>
  </refsect1>
   
</refentry>

      <refentry id="python3_varmgrnotify">
        <refentryinfo>
          <author>
                  <personname>
                          <firstname>Ron</firstname>
                          <surname>Fox</surname>
                  </personname>
          </author>
          <productname>NSCLDAQ</productname>
          <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id="python3_varmgrnotify_title">nscldaq.vardb.notifier</refentrytitle>
           <manvolnum>3python</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>nscldaq.vardb.notifier</refname>
           <refpurpose>Python bindings for variable database publish/subscribe API</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <programlisting>
import nscldaq.vardb.notifier


sub = nscldaq.vardb.notifier.Notifier(uri)
sub.subscribe(pathPrefix)
sub.unsubscribe(pathPrefix)
if sub.waitmsg(timeout):
    # Message is available.
    ...
if sub.readable():
    # Message is avaiable.

msg = sub.read()

          </programlisting>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            The variable database server provides a publish/subscribe service
            that allows applications to be selectively notified of changes
            to the database.  This module provides access to the
            underlying API for that service.
           </para>
        </refsect1>
        <refsect1>
           <title>
              METHODS
           </title>
           <variablelist>
            <varlistentry>
                <term>nscldaq.vardb.notifier.Notifier(uri)</term>
                <listitem>
                    <para>
                        Creates a new notifier object.  A notifier object
                        encapsulates a connection to the publish/subscribe
                        service of one variable datbase server.  The
                        <parameter>uri</parameter> identifies which server
                        is being used.
                    </para>
                    <para>
                        The <parameter>uri</parameter> has the form:
                        <informalexample>
                            <programlisting>
tcp://<replaceable>hostname</replaceable><optional>:portnum</optional><optional>/service-name</optional>.        
                            </programlisting>
                        </informalexample>
                        Where <replaceable>hostname</replaceable> is the name of the
                        host in which the sever is running.  The
                        <replaceable>portnum</replaceable> if supplied is the
                        numerical port number on which the server is offering the
                        publish subscribe service.  The <replaceable>service-name</replaceable>
                        is the service name the server has advertised for the publish
                        subscribe service.
                    </para>
                    <para>
                        It is illegal to provide both the port and service name.
                        If neither the port nor the servide name are provided, the
                        port is determined by translating the default service name for
                        the variable database server (<literal>vardb-changes</literal>).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>subscribe(pathPrefix)</methodname></term>
                <listitem>
                    <para>
                        Adds a subscription for <parameter>pathPrefix</parameter>.
                        Path prefixes are textually matched against the first
                        characters in the path field of publications.
                        If there is a match, a message is generated and delivered
                        to the application.
                    </para>
                    <para>
                        It is an error for the same path prefix to be subscribed
                        to more than once.  There is not, however detection of
                        overlapping path prefixes (e.g.
                        <filename>/test/</filename> and <filename>/test/dir/</filename>).
                        Note that if there are overlapping subscriptions, only one
                        message is generated, rather than one for each matching
                        subscription.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>unsubscribe(pathPrefix)</methodname></term>
                <listitem>
                    <para>
                        Removes the <parameter>pathPrefix</parameter> from the
                        current subscription set.  It is an error to
                        unsubscribe a path prefix that you have not yet
                        subscribed to in this object.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>waitmsg(timeout)</methodname></term>
                <listitem>
                    <para>
                        Waits for a subscription message to be ready to read
                        for at most <parameter>timeout</parameter> milliseconds.
                        If <parameter>timeout</parameter> is <literal>0</literal>,
                        the program will not block.  If the <parameter>timeout</parameter>
                        is negative, the wait operation will not timeout.
                    </para>
                    <para>
                        Receipt of a signal halts the <methodname>waitmsg</methodname>.
                        The return value of <methodname>waitmsg</methodname> is
                        a boolean <literal>True</literal> if when the method
                        returns a message can be read without blocking.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>readable()</methodname></term>
                <listitem>
                    <para>
                        This is equivalent to <methodname>waitmsg(0)</methodname>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><methodname>read</methodname></term>
                <listitem>
                    <para>
                        Reads the next notification message from the socket
                        blocking if needed until there is a message.
                        The message is return as a dict with the following keys:
                    </para>
                    <itemizedlist>
                        <listitem><para>
                            <literal>path</literal> contains the path part of
                            the message.
                        </para></listitem>
                        <listitem><para>
                            <literal>op</literal> Contains the operation field of
                            the message.
                        </para></listitem>
                        <listitem><para>
                            <literal>data</literal> contains the addtional data field
                            of the message.
                        </para></listitem>
                    </itemizedlist>
                </listitem>
            </varlistentry>
           </variablelist>
        </refsect1>

      </refentry>



<!-- /manpage -->
<!-- manpage 3daq -->

<refentry id="daq3_cvarmgrsubscriptions">
  <refentryinfo>
    <author>
        <personname>
            <firstname>Ron</firstname>
            <surname>Fox</surname>
        </personname>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='daq3_cvarmgrsubscriptions_title'>CVarMgrSubscriptions</refentrytitle>
     <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>CVarMgrSubscriptions</refname>
     <refpurpose>Subscribe to variable database manager changes.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <synopsis>
#include &lt;CVarMgrSubscriptions.h&gt;
       <ooclass><classname>CVarMgrSubscriptions</classname></ooclass>
{
public:
    typedef struct _Message {
        std::string      s_path;
        std::string      s_operation;
        std::string      s_data;
    } Message, *pMessage;

    <constructorsynopsis>
       <methodname>CVarMgrSubscriptions</methodname>
       <methodparam>
        <modifier>const</modifier><type> char* </type>
            <parameter>host</parameter>
       </methodparam>
       <methodparam>
        <modifier></modifier><type>int </type>
            <parameter>port</parameter>
       </methodparam>
    </constructorsynopsis>
    <constructorsynopsis>
       <methodname>CVarMgrSubscriptions</methodname>
       <methodparam>
        <modifier>const </modifier><type>char* </type>
            <parameter>host</parameter>
       </methodparam>
       <methodparam>
        <modifier>const </modifier><type>char* </type>
            <parameter>service</parameter>
       </methodparam>
       
    </constructorsynopsis>
    <methodsynopsis>
        <modifier>virtual </modifier>
        <type></type>
        <methodname>~CVarMgrSubscriptions</methodname>
        <void />
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>zmq::socket_t* </type>
        <methodname>socket</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>int  </type>
        <methodname>fd</methodname>
        <void />
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>subscribe</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>pathPrefix</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>unsubscribe</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>pathPrefix</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>bool </type>
        <methodname>waitmsg</methodname>
        <methodparam>
            <modifier></modifier><type>int </type>
                <parameter>milliseconds </parameter>
                <initializer>-1</initializer>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void operator()</type>
        <methodname></methodname>
        <methodparam>
            <modifier></modifier><type>int </type>
                <parameter>milliseconds</parameter>
                <initializer>-1</initializer>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>bool </type>
        <methodname>readable</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>Message </type>
        <methodname>read</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>virtual </modifier>
        <type>void</type>
        <methodname>notify</methodname>
        <methodparam>
            <modifier>const </modifier><type>pMessage </type>
                <parameter>message</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>  

    <ooclass><classname>class CException : public std::runtime_error</classname></ooclass>
    {
        <constructorsynopsis>
           <methodname>CException</methodname>
           <methodparam>
            <modifier></modifier><type>std::string</type>
                <parameter> what</parameter>
           </methodparam>
           
           <exceptionname>noexcept </exceptionname>
        </constructorsynopsis>
        <constructorsynopsis>
           <methodname>CException</methodname>
           <methodparam>
            <modifier>const</modifier><type>char*</type>
                <parameter> what</parameter>
           </methodparam>
           
           <exceptionname>noexcept </exceptionname>
        </constructorsynopsis>
    };

};
   </synopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        This class encapsulates a connection to the publish/subscribe
        service offered by the variable database server. By using it a
        client program can gain access to this service, manipulate a set of
        subscriptions and obtain notifications for changes relevant to
        the subscriptions that have been established.
     </para>
     <para>
        Sufficient introspection exists to allow code to interface with event loops
        for most application frameworks allowing a seamless integration
        with those frameworks.
     </para>
     <para>
        All errors are reported via by throwing
        <classname>CVarMgrSubscriptions::CException</classname> objects.
        For more information about this nested class see
        <literal>PUBLIC VARIABLES, TYPES and CONSTANTS</literal> below.
     </para>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <variablelist>
        <varlistentry>
            <term>
                <constructorsynopsis>
                   <methodname>CVarMgrSubscriptions</methodname>
                   <methodparam>
                    <modifier>const</modifier><type> char* </type>
                        <parameter>host</parameter>
                   </methodparam>
                   <methodparam>
                    <modifier></modifier><type>int </type>
                        <parameter>port</parameter>
                   </methodparam>
                </constructorsynopsis>
            </term>
            <listitem>
                <para>
                    Constructor for a
                    <classname>CVarMgrSubscriptions</classname> object.
                    <parameter>host</parameter> is the host in which
                    the variable database server is running. This can
                    be either a resolvable host name or a string that is
                    a dotted IP address (e.g. <literal>35.8.34.123</literal>).
                    <parameter>port</parameter> is the numeric port on
                    which the server maintains its publish/subscribe
                    service.
                </para>
                <para>
                    Errors are reported by throwing a
                    <classname>CVarMgrSubscriptions::CException</classname>
                    which is derived from a <classname>std::runtime_error</classname>
                    exception.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <constructorsynopsis>
                   <methodname>CVarMgrSubscriptions</methodname>
                   <methodparam>
                    <modifier>const </modifier><type>char* </type>
                        <parameter>host</parameter>
                   </methodparam>
                   <methodparam>
                    <modifier>const </modifier><type>char* </type>
                        <parameter>service</parameter>
                   </methodparam>
                   
                </constructorsynopsis>
            </term>
            <listitem>
                <para>
                    Constructor for <classname>CVarMgrSubscriptions</classname>
                    objects.  As before, the <parameter>host</parameter> specifies
                    the system in which the server is running.
                    <parameter>service</parameter> is the service name the
                    server published its publish/subscribe service as.  By default
                    this is <literal>vardb-changes</literal>.  Note that the
                    constructor does not accept a default value for this.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>zmq::socket_t* </type>
                    <methodname>socket</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns a pointer to the underlying ZMQ socket object
                    that is connected to the publish/subscribe service.
                    This is intended to allow the
                    zmq <methodname>poll</methodname> function to be
                    called with sockets from this and other ZMQ connections.
                </para>
                <para>
                    For simplicity, actually reading or checking for readability
                    should be done using the methods provided in this class, as
                    that will insulate you from application level message format
                    changes that might occur with time.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>int  </type>
                    <methodname>fd</methodname>
                    <void />
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns the file descriptor used by the underlying ZMQ socket.
                    This is intended for use in integrating this class's notifications
                    with an event loop provided by an application framework.
                </para>
                <para>
                    Note that according to the ZMQ documentation if the file
                    descriptor indicates readability it may not yet actually have
                    a message.  It is best to first invoke <methodname>readable</methodname>
                    to test if a message is fully received.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>subscribe</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>pathPrefix</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Adds a subscription (<parameter>pathPrefix</parameter>)
                    to the set of monitored path
                    prefixes.  Subscriptions are on prefixes of paths in the
                    variable database.  A prefix is a string that is the leading
                    part of a path specification.  Note that maching is not done
                    in the semantics of the database but as a string. 
                </para>
                <para>
                    This implies that the path prefix
                    <filename>/test</filename> will not only match changes in
                    <filename>/test/thing</filename> but also
                    <filename>/testing/stuff</filename>.
                    To force path matching semantics,
                    path prefixes should include a trailing <literal>/</literal>
                    (e.g. <filename>/test/</filename>) above.
                </para>
                <para>
                    No checking is performed to determine if there actually are
                    entities with the specified path prefix.
                    It is illegal to specify a <parameter>pathPrefix</parameter>
                    that has already been established.  It is legal to
                    specify overlapping path prefixes (e.g. <filename>/test/</filename>
                    and <filename>/test/subdir/</filename>).  If you do so, however
                    only one message will be received for changes in the overlap.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>unsubscribe</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>pathPrefix</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Removes the specified <parameter>pathPrefix</parameter>
                    from the set that are subscribed.  It is an error if
                    <parameter>pathPrefix</parameter> is not a current
                    subscription.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>bool </type>
                    <methodname>waitmsg</methodname>
                    <methodparam>
                        <modifier></modifier><type>int </type>
                            <parameter>milliseconds </parameter>
                            <initializer>-1</initializer>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Blocks until a notification message is available or
                    until the <parameter>milliseconds</parameter> (at most)
                    milliseconds have elapsed.  <parameter>milliseconds</parameter>
                    is a maximum timeout as if a signal is handled by the program
                    the wait will end at that time.
                </para>
                <para>
                    The return value is <literal>true</literal> if a message
                    is available and <literal>false</literal> if not.  If
                    <parameter>milliseconds</parameter> is <literal>0</literal>, the
                    method never blocks. If it is negative, there is no timeout
                    and the method will block until either a signal or a message
                    is available.  It is therefore important to check the return
                    value even if you supply a negative timeout.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void operator()</type>
                    <methodname></methodname>
                    <methodparam>
                        <modifier></modifier><type>int </type>
                            <parameter>milliseconds</parameter>
                            <initializer>-1</initializer>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Provides a hook for the class to implement an event callback
                    scheme.   This method is very much like:
                </para>
                <informalexample>
                    <programlisting>
if (waitmsg(milliseconds)) {
    Message msg = read();
    notify(&amp;msg);
}
                    </programlisting>
                </informalexample>
                <para>
                    To use this method you must create a subclass and override the
                    <methodname>notify</methodname> virtual method to implement
                    the desired behavior when a message is received.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>bool </type>
                    <methodname>readable</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    This method is a short hand for
                    a call to <methodname>waitmsg(0)</methodname>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>Message </type>
                    <methodname>read</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    If necessary blocks until a message can be read.  The message
                    is read from the underlying <classname>zmq::socket_t</classname>
                    object and processed into a <classname>CVarMgrSubscriptions::Message</classname>
                    type which is returned.
                </para>
                <para>
                    For more on the <classname>CVarMgrSubscriptions::Message</classname>
                    see <literal>PUBLIC VARIABLES, TYPES and CONSTANTS</literal>
                    below.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>virtual </modifier>
                    <type>void</type>
                    <methodname>notify</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>pMessage </type>
                            <parameter>message</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Virtual method that is called by
                    <methodname>operator()</methodname> when a message is
                    received.  The <parameter>message</parameter> parameter
                    is a pointer to the decoded message.  The base class
                    implementation of this function is emtpy.  To use
                    <methodname>operator()</methodname>, you must
                    therefore create a subclass of
                    <classname>CVarMgrSubscriptions</classname> that
                    overrides <methodname>notify</methodname> to
                    implement the desired behavior.
                </para>
            </listitem>
        </varlistentry>
        
     </variablelist>
  </refsect1>
   <refsect1>
      <title>PUBLIC VARIABLES, TYPES and CONSTANTS</title>
      <para>
        The <classname>CVarMgrSubscriptions</classname> class includes
        a nested class and a structure that are publicly visible.
      </para>
      <para>
        The
        <classname>CVarMgrSubscriptions::CException</classname> is thrown
        as an exception when errors are detected.  It is derived from the
        <classname>std::runtime_error</classname> exception class.
      </para>
      <para>
        The <classname>CVarMgrSubscriptions::Message</classname> type is
        a struct used to represent a message that was received by the
        from the publication/subscription interface.  It has the following fields:
      </para>
      <variablelist>
        <varlistentry>
            <term><structfield>std::string s_path</structfield></term>
            <listitem>
                <para>
                    Has the notification path.  Depending on what is being
                    notified, this is either the path of the object being
                    modified or the path of the directory that contains
                    the object being notified.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><structfield>std::string s_operation</structfield></term>
            <listitem>
                <para>
                    Contains a string that is the operation field fo the
                    message received.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <structfield>std::string s_data</structfield>
            </term>
            <listitem>
                <para>
                    Contains the data's message field.
                </para>
            </listitem>
        </varlistentry>
        
      </variablelist>
      <para>
        For more information about what these message fields can contain see
        <link linkend='daq5_varserver_pubprotocol'
              endterm='daq5_varserver_pubprotocol_title' />
      </para>
   </refsect1>
</refentry>     
<!-- /manpage -->