<!-- manpage 3daq -->

<refentry id="daq3_cvariabledb">
  <refentryinfo>
    <author>
        <personname>
            <firstname>Ron</firstname>
            <surname>Fox</surname>
        </personname>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='daq3_cvariabledb_title'>CVariableDb</refentrytitle>
     <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>CVariableDb</refname>
     <refpurpose>Encapsulate connections to variable database files.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <synopsis>
    
#include &lt;CVariableDb.h&gt;

       <ooclass><classname>CVariableDb : public CSqlite</classname></ooclass> {
       <ooclass><classname>CException : public std::exception;</classname></ooclass>
       <methodsynopsis>
           <modifier> static </modifier>
           <type>void </type>
           <methodname>create</methodname>
           <methodparam>
            <modifier>const </modifier><type>char*</type> <parameter>pFilePath</parameter>
           </methodparam>
           <exceptionname>CVariableDb::CException</exceptionname>
       </methodsynopsis>  
       <constructorsynopsis>
          <methodname>CVariableDb</methodname>
          <methodparam>
            <modifier>const</modifier> <type>char*</type> <parameter>pFilePath</parameter>
          </methodparam>
          <exceptionname></exceptionname>
       </constructorsynopsis>

};      
   </synopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        <classname>CVariableDb</classname> represents a connection to a variable
        database.  As variable databases are built on SQLite database files,
        <classname>CVariableDb</classname> is derived from
        <classname>CSqlite</classname> as a base class.
     </para>
     <para>
        Errors detected from class methods are reported as exceptions that are
        derived from <classname>std::exception</classname>.  Those that come
        specifically from the <classname>CVariableDb</classname> are thrown
        as <classname>CVariableDb::CException</classname> objects.
     </para>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <variablelist>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier> static </modifier>
                    <type>void </type>
                    <methodname>create</methodname>
                    <methodparam>
                     <modifier>const </modifier><type>char*</type> <parameter>pFilePath</parameter>
                    </methodparam>
                    <exceptionname>CVariableDb::CException</exceptionname>
                </methodsynopsis> 
            </term>
            <listitem>
                <para>
                    This static method creates a new variable database  in the
                    file whose name is pointed to by <parameter>pFilePaht</parameter>.
                    A new SQLite database is created and the schema (tables)
                    required to
                    make it a variable database are defined.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <constructorsynopsis>
                   <methodname>CVariableDb</methodname>
                   <methodparam>
                     <modifier>const</modifier> <type>char*</type> <parameter>pFilePath</parameter>
                   </methodparam>
                   <exceptionname></exceptionname>
                </constructorsynopsis>
            </term>
            <listitem>
                <para>
                    Constructs a new database using the file in
                    <parameter>pFilePath</parameter>.  If this is not
                    an SQLite database or if the file does not have the
                    variable data base schema in it, an exception is thrown.
                    <classname>CSqliteException</classname> is thrown if the
                    error was detected by the Sqlite api and
                    <classname>CVariableDb::CException</classname> is thrown
                    if the schema is incorrect.
                </para>
            </listitem>
        </varlistentry>
     </variablelist>
  </refsect1>
</refentry>     
<refentry id="daq3_cvardirtree">
  <refentryinfo>
    <author>
        <personname>
            <firstname>Ron</firstname>
            <surname>Fox</surname>
        </personname>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='daq3_cvardirtree_title'>CVarDirTree</refentrytitle>
     <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>CVarDirTree</refname>
     <refpurpose>Variable Database Directory Tree</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <synopsis>
#include &lt;CVarDirTree.h&gt;    
       <ooclass><classname>CVarDirTree</classname></ooclass> {
        <methodsynopsis>
            <modifier>static </modifier>
            <type>std::vector&lt;std::string&gt; </type>
            <methodname>parsePath</methodname>
            <methodparam>
                <modifier>const </modifier><type>char* </type>
                <parameter>path</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <modifier>static </modifier>
            <type>bool </type>
            <methodname>isRelative</methodname>
            <methodparam>
                <modifier>const </modifier><type>char* </type>
                <parameter>path</parameter>
            </methodparam>
        </methodsynopsis>
        <constructorsynopsis>
           <methodname>CVarDirTree</methodname>
           <methodparam>
            <type>CVariableDb&amp; </type><parameter>db</parameter>
           </methodparam>
           <exceptionname>CVarDirTree::CException</exceptionname>
        </constructorsynopsis>
        <constructorsynopsis>
            <methodname>CVarDirTree</methodname>
            <methodparam>
                <type>CVariableDb&amp;</type> <parameter>db</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>id</parameter>
            </methodparam>
            <exceptionname>CVarDirTree::CException</exceptionname>
        </constructorsynopsis>
        <methodsynopsis>
            
            <type>CVarDirTree::DirInfo </type>
            <methodname>getwd </methodname>
            <void />            
            <modifier>const</modifier>
        </methodsynopsis>
        <methodsynopsis>
            
            <type>int     </type>
            <methodname>getRootid</methodname>
            <void />
            
            <modifier>const </modifier>
        </methodsynopsis>
        <methodsynopsis>
            
            <type>void </type>
            <methodname>mkdir</methodname>
            <methodparam>
                <modifier>const </modifier><type>char* </type>
                <parameter>path</parameter>
            </methodparam>
            <methodparam>
                <type>bool </type><parameter>createIntermediate</parameter>
                <initializer>true</initializer>
            </methodparam>
            
        </methodsynopsis>  
        <methodsynopsis>
            
            <type>void </type>
            <methodname>rmdir</methodname>
            <methodparam>
                <modifier>const </modifier><type>char* </type>
                <parameter>path</parameter>
            </methodparam>
            
            
        </methodsynopsis>  
        <methodsynopsis>
            
            <type>void </type>
            <methodname>cd</methodname>
            <methodparam>
                <modifier>const </modifier><type>char* </type>
                <parameter>path</parameter>
            </methodparam>
            <exceptionname></exceptionname>
            
        </methodsynopsis>  
        <methodsynopsis>
            
            <type>std::vector&lt;CVarDirTree::DirInfo&gt;</type>
            <methodname>ls</methodname>
            <void />
            
        </methodsynopsis>  
        <methodsynopsis>
            
            <type>std::string</type>
            <methodname>wdPath</methodname>
            <void />
            
        </methodsynopsis>  
      
        typedef struct _DirInfo {
            std::string s_name;
            int         s_id;
            int         s_parentId;
        } DirInfo, *pDirInfo;

        class <classname>CException</classname> : public <classname>std::runtime_error</classname>
        static const char m_pathSeparator = '/';
};
   </synopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        Objects of the class <classname>CVarDirTree</classname> represent the
        the directory hierarchy (tree) of a variable database.  These objects have
        the concept of a default directory which serves as the origin for
        relative paths.  
     </para>
     <para>
        Methods are also provided to navigate, query and modify the directories
        in the tree.  Static methods are provided as well to break up paths
        into their elements and to determine if a path is relative or
        absolute.
     </para>
     <para>
        A path string defines how to get to some initial directory node to
        some other directory node. Path strings are composed of path
        elements that are separated by
        <classname>CVarDirTree</classname>::<varname>m_pathSeparator</varname>.
        If a path begins with the
        <classname>CVarDirTree</classname>::<varname>m_pathSeparator</varname>
        it is said to be absolute and the starting point for the traversal is
        the top level or <firstterm>root</firstterm> directory.  The
        <classname>CVarDirTree</classname>::<varname>m_pathSeparator</varname>
        by itself as a path string represents this root directory.
     </para>
     <para>
        Relative paths are those that do not start with
        <classname>CVarDirTree</classname>::<varname>m_pathSeparator</varname>.
        These paths have as their starting point the
        object's <firstterm>current working directory</firstterm>.  The special
        path element <literal>..</literal> selects the parent directory of
        the current position in the path. For example, the path:
        <filename>../george</filename> is a relative path that selects
        the directory <filename>george</filename> in the parent directory
        of the current working directory.
     </para>
     <para>
        Errors are reported by throwing exceptions that are derived
        from <classname>std::exception</classname>.  These encapsulate
        a human readable error message that can be retrieved using that
        class's <methodname>what</methodname> method.
        If you are catching <classname>std::exception</classname>s in a
        try/catch block, be sure to catch by reference rather than value
        to preserve the polymorphic behavior of <methodname>what</methodname>.
     </para>
     <para>
        Incorrect:
     </para>
     <informalexample>
        <programlisting>
try {
...
}
catch (std::exception e) {
    // e.what() is the fixed string returned by std::exception::what()
}
        </programlisting>
     </informalexample>
     <para>
        Correct:
     </para>
     <informalexample>
        <programlisting>
try {
...
}
catch (std::exception&amp; e) {
   // e.what() returns the string determined by e's actual class.
}
        </programlisting>
     </informalexample>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <variablelist>
        <varlistentry>
            <term>
                <methodsynopsis>
                        <modifier>static </modifier>
                        <type>std::vector&lt;std::string&gt; </type>
                        <methodname>parsePath</methodname>
                        <methodparam>
                            <modifier>const </modifier><type>char* </type>
                            <parameter>path</parameter>
                        </methodparam>
                    </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Given a
                    <parameter>path</parameter>,
                    either absolute or relative, returns
                    a vector of the elements of that path.  Note that the
                    resulting vector of strings will have had all path
                    separators removed and therefore it is no longer possible
                    to tell just from the vector if the original path was
                    absolute or relative.
                </para>
                <para>
                    For example, if <parameter>path</parameter> is
                    <literal>/a/b</literal> a two element vector is
                    returned.  Element 0 contains the string
                    <literal>a</literal> and element 1 contains the
                    string <literal>b</literal>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                        <modifier>static </modifier>
                        <type>bool </type>
                        <methodname>isRelative</methodname>
                        <methodparam>
                            <modifier>const </modifier><type>char* </type>
                            <parameter>path</parameter>
                        </methodparam>
                    </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns <literal>true</literal> if the
                    <parameter>path</parameter> parameter is a relative path,
                    <literal>false</literal> otherwise.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <constructorsynopsis>
                       <methodname>CVarDirTree</methodname>
                       <methodparam>
                        <type>CVariableDb&amp; </type><parameter>db</parameter>
                       </methodparam>
                       <exceptionname>CVarDirTree::CException</exceptionname>
                    </constructorsynopsis>
            </term>
            <listitem>
                <para>
                    Constructs a new <classname>CVarDirTree</classname>
                    object using <parameter>db</parameter> as
                    the connection to the database.
                    The method throws an exception if it is not able
                    to locate the root directory element in the
                    directories table.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <constructorsynopsis>
                    <methodname>CVarDirTree</methodname>
                    <methodparam>
                        <type>CVariableDb&amp;</type> <parameter>db</parameter>
                    </methodparam>
                    <methodparam>
                        <type>int</type> <parameter>id</parameter>
                    </methodparam>
                    <exceptionname>CVarDirTree::CException</exceptionname>
                </constructorsynopsis>
            </term>
            <listitem>
                <para>
                    Constructs a directory tree object whose current working
                    directory is initially defined by the directory whose
                    primary key is <parameter>id</parameter>.  If there
                    is no directory with that primary key, the constructor
                    throws a <classname>CVarDirTree::CException</classname>
                    object.
                </para>
                <para>
                    One use case for this is to, give a
                    <classname>CVariable</classname> object, construct
                    a <classname>CVarDirTree</classname> object whose
                    working directory is that of the variable.  A second
                    use case is where you want to create a copy of an existing
                    directory tree object.
                </para>
            </listitem>
        </varlistentry>
        
        <varlistentry>
            <term>
                <methodsynopsis>
                        
                        <type>CVarDirTree::DirInfo </type>
                        <methodname>getwd </methodname>
                        <void />            
                        <modifier>const</modifier>
                    </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns a directory information structure
                    that describe the current working directory.
                    See <literal>PUBLIC VARIABLES TYPES AND CONSTANTS</literal>
                    below for information about the contents of the
                    <classname>CVarDirTree::DirInfo</classname> struct.
                </para>
                <para>
                    See also <methodname>wdPath</methodname> for a method
                    that gives the full absolute path to the current working
                    directory.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                        
                        <type>int     </type>
                        <methodname>getRootid</methodname>
                        <void />
                        
                        <modifier>const </modifier>
                    </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns the primary key of the
                    root directory entry.  This is normally only used
                    internally by the variable database system.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                        
                        <type>void </type>
                        <methodname>mkdir</methodname>
                        <methodparam>
                            <modifier>const </modifier><type>char* </type>
                            <parameter>path</parameter>
                        </methodparam>
                        <methodparam>
                            <type>bool </type><parameter>createIntermediate</parameter>
                            <initializer>true</initializer>
                        </methodparam>
                        
                    </methodsynopsis> 
            </term>
            <listitem>
                <para>
                    Creates a new directory entry.  <parameter>path</parameter>
                    is an absolute or relative path that specifies the new
                    directory to create.  If the path is relative it is relative
                    to the current working directory of the object.
                </para>
                <para>
                    If <parameter>createIntermediate</parameter> is
                    <literal>true</literal> any missing intermediate
                    directories along the path are created (like the
                    <option>-p</option> option in the linux <command>mkdir</command>
                    command).  If not than it is an error if any of the directories
                    along the path to the last path element don't already exist.
                </para>
                <para>
                    Errors are thrown as <classname>CVarDirTree::CException</classname>
                    objects.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                        
                        <type>void </type>
                        <methodname>rmdir</methodname>
                        <methodparam>
                            <modifier>const </modifier><type>char* </type>
                            <parameter>path</parameter>
                        </methodparam>
                        
                        
                    </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Removes the directory specified by
                    <parameter>path</parameter>.  Note that only the
                    last path entry is removed, not the entire path to it.
                    The path can be absolute or relative to the current working
                    directory.  It is an error to attempt to remove a directory
                    that is not empty. It is also an error to attempt to remove
                    a nonexistent directory.  It is also an error to attempt to remove
                    the root directory.
                </para>
                <para>
                    Errors are reported by throwing a
                    <classname>CVarDirTree::CException</classname> object.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                        
                        <type>void </type>
                        <methodname>cd</methodname>
                        <methodparam>
                            <modifier>const </modifier><type>char* </type>
                            <parameter>path</parameter>
                        </methodparam>
                        <exceptionname></exceptionname>
                        
                    </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Sets the current working directory of the object to the
                    absolute or relative <parameter>path</parameter>.
                    It is an error to try to set the working directory to
                    a nonexistent directory.  It is also an error to specify
                    a path that is above the root director.
                </para>
                <para>
                    Errors are reported by throwing a
                    <classname>CVarDirTree::CException</classname> object.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                        
                        <type>std::vector&lt;CVarDirTree::DirInfo&gt;</type>
                        <methodname>ls</methodname>
                        <void />
                        
                    </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns a vector of <classname>CVarDirTree::DirInfo</classname>
                    structs that describe the subdirectories that are
                    immediately below the current working directory.
                    This method does not recurse into the subdirectories
                    themselves.
                </para>
                <para>
                    See <literal>PUBLIC VARIABLES, TYPES and CONSTANTS</literal>
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                        
                        <type>std::string</type>
                        <methodname>wdPath</methodname>
                        <void />
                        
                    </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns the absolute path string of the current working
                    directory.
                </para>
            </listitem>
        </varlistentry>
     </variablelist>
  </refsect1>
   <refsect1>
      <title>PUBLIC VARIABLES, TYPES and CONSTANTS</title>
      <variablelist>
        <varlistentry>
            <term>
                <literal>
                    typedef struct _DirInfo {
                        std::string s_name;
                        int         s_id;
                        int         s_parentId;
                    } DirInfo, *pDirInfo;
                </literal>
            </term>
            <listitem>
                <para>
                    This structure defines the characteristics
                    of a directory entry.  It contains:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><structfield>s_name</structfield></term>
                        <listitem>
                            <para>
                                The name of the directory.  Note that this is
                                not the full path name but the terminal element
                                name.  For example for
                                <literal>/this/that/the/other</literal>,
                                <structfield>s_name</structfield> will be
                                <literal>other</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><structfield>s_id</structfield></term>
                        <listitem>
                            <para>
                                The primary key of the directory in the
                                directories table of the database. Each
                                directory is an entry in a database table,
                                the primary key uniquely identifies each entry
                                (you can almost but not quite think of it as the
                                row number).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><structfield>s_parentId</structfield></term>
                        <listitem>
                            <para>
                                The primary key of the parent directory of
                                this element.  The root directory parent id is
                                <literal>null</literal>.  It is this field that
                                creates the hierarchy of the directory, by requiring
                                that, with the exception of the root directory,
                                every directory has a parent.
                            </para>
                        </listitem>
                    </varlistentry>
                    
                </variablelist>
            </listitem>
        </varlistentry>
            <varlistentry>
              <term><classname>CException</classname></term>
              <listitem>
                  <para>
                      Objects of this nested class are thrown whenever an
                      error is detected by by methods of the
                      <classname>CVarDirTree</classname> class.  This class
                      is derived from the <classname>std::exception</classname>
                      class.  That implies that it has a method
                      <methodname>what</methodname> that returns a meaningful
                      error string.
                  </para>
              </listitem>
          </varlistentry>
          <varlistentry>
              <term><type>static const char</type><varname>m_pathSeparator</varname></term>
              <listitem>
                  <para>
                      This character constant contains the character used to
                      separate a path into its components.  In this implementation
                      it is <literal>/</literal>
                  </para>
              </listitem>
          </varlistentry>            

      </variablelist>
   </refsect1>
</refentry>

<refentry id="daq3_cvariable">
  <refentryinfo>
    <author>
        <personname>
            <firstname>Ron</firstname>
            <surname>Fox</surname>
        </personname>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='daq3_cvariable_title'>CVariable</refentrytitle>
     <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>CVariable</refname>
     <refpurpose>Operations on variables in variable databases</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <synopsis>
#include &lt;CVariable&gt;
        <ooclass><classname>CVariable</classname></ooclass> {
        <methodsynopsis>
            <modifier>static</modifier>
            <type>CVariable*</type>
            <methodname>create</methodname>
            <methodparam>
                <type>CVariableDb&amp;</type> <parameter>db</parameter>
            </methodparam>
            <methodparam>
                <modifier>const</modifier><type>char*</type>
                <parameter>path</parameter>
            </methodparam>
            <methodparam>
                <modifier>const</modifier><type>char*</type>
                    <parameter>type</parameter>
            </methodparam>
            <methodparam>
                <modifier>const</modifier><type>char*</type>
                    <parameter>initial</parameter>
                    <initializer>0</initializer>
            </methodparam>
            <exceptionname>CVariable::CException</exceptionname>
            
        </methodsynopsis>
        <methodsynopsis>
            <modifier>static </modifier>
            <type>CVariable* </type>
            <methodname>create</methodname>
            <methodparam>
                <type>CVariableDb&amp;</type><parameter> db</parameter>
            </methodparam>
            <methodparam>
                <type> CVarDirTree&amp;</type>
                    <parameter>dir</parameter>
            </methodparam>
            <methodparam>
                <modifier>const </modifier><type>char*</type>
                    <parameter> path</parameter>
            </methodparam>
            <methodparam>
                <modifier>const </modifier><type>char* </type>
                    <parameter>type</parameter>
            </methodparam>
            <methodparam>
                <modifier>const </modifier><type>char* </type>
                    <parameter>initial</parameter>
                    <initializer>0</initializer>
            </methodparam>
            
            <exceptionname>CVariable::CException</exceptionname>
            
        </methodsynopsis>
        <methodsynopsis>
            <modifier>static </modifier>
            <type>void </type>
            <methodname>destroy</methodname>
            <methodparam>
                <type>CVariableDb&amp;</type><parameter>db</parameter>
            </methodparam>
            <methodparam>
                <type>int </type>
                    <parameter>id</parameter>
            </methodparam>
            <exceptionname>CVariable::CException</exceptionname>
            
        </methodsynopsis>
        <methodsynopsis>
            <modifier>static </modifier>
            <type>void </type>
            <methodname>destroy</methodname>
            <methodparam>
                <type>CVariable* </type><parameter>pVariable</parameter>
            </methodparam>
            <methodparam>
                <type>bool </type>
                    <parameter>doDelete</parameter>
                    <initializer>true</initializer>
            </methodparam>
            
            <exceptionname>CVariable::CException</exceptionname>
            
        </methodsynopsis>
        <methodsynopsis>
            <modifier>static</modifier>
            <type> void </type>
            <methodname>destroy</methodname>
            <methodparam>
                <type>CVariableDb&amp;</type><parameter> db</parameter>
            </methodparam>
            <methodparam>
                <type>CVarDirTree&amp;</type>
                    <parameter>dir</parameter>
            </methodparam>
            <methodparam>
                <modifier>const </modifier><type>char*</type>
                    <parameter> path</parameter>
            </methodparam>
            
            <exceptionname>CVariable::CException</exceptionname>
            
        </methodsynopsis>
        <methodsynopsis>
            <modifier>static </modifier>
            <type>void </type>
            <methodname>destroy</methodname>
            <methodparam>
                <type>CVariableDb&amp;</type><parameter> db</parameter>
            </methodparam>
            <methodparam>
                <modifier>const </modifier><type>char* </type>
                    <parameter>path</parameter>
            </methodparam>
            
            <exceptionname>CVariable::CException</exceptionname>
            
        </methodsynopsis>
        <methodsynopsis>
            <modifier>static </modifier>
            <type>std::vector&lt;VarInfo&gt; </type>
            <methodname>list</methodname>
            <methodparam>
                <type>CVariableDb*</type> <parameter>db</parameter>
            </methodparam>
            <methodparam>
                <type>CVarDirTree&amp;</type>
                    <parameter> dir</parameter>
            </methodparam>
            <methodparam>
                <modifier>const </modifier><type>char* </type>
                    <parameter>path</parameter>
                    <initializer>0</initializer>
            </methodparam>
            
            <exceptionname></exceptionname>
            
        </methodsynopsis>  
        <constructorsynopsis>
           <methodname>CVariable</methodname>
           <methodparam>
            <type>CVariableDb&amp;</type>
                <parameter>db</parameter>
           </methodparam>
           <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>path</parameter>
           </methodparam>
           <exceptionname>CVariable::CException</exceptionname>
        </constructorsynopsis>
        <constructorsynopsis>
           <methodname>CVariable</methodname>
           <methodparam>
            <type>CVariableDb&amp;</type>
                <parameter>db</parameter>
           </methodparam>
           <methodparam>
            <type>CVarDirTree&amp;</type>
                <parameter>dir</parameter>
           </methodparam>
           <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>path</parameter>
           </methodparam>
           
           <exceptionname>CVariable::CException</exceptionname>
        </constructorsynopsis>
        <constructorsynopsis>
           <methodname>CVariable</methodname>
           <methodparam>
            <type>CVariableDb&amp;</type>
                <parameter>db</parameter>
           </methodparam>
           <methodparam>
            <type>int </type>
                <parameter>id</parameter>
           </methodparam>
           
           <exceptionname>CVariable::CException</exceptionname>
        </constructorsynopsis>
        <methodsynopsis>
            
            <type>void </type>
            <methodname>set</methodname>
            <methodparam>
                <modifier>const </modifier><type>char* </type>
                    <parameter>newValue</parameter>
            </methodparam>
            
            <exceptionname>CVariable::CException</exceptionname>
            
        </methodsynopsis>
        <methodsynopsis>
            
            <type>std::string</type>
            <methodname>get</methodname>
            <void />
            
        </methodsynopsis>
        <methodsynopsis>
            
            <type>int</type>
            <methodname>getId</methodname>
            <void />
            
            <modifier>const</modifier>
        </methodsynopsis>
        <methodsynopsis>
            
            <type>std::string</type>
            <methodname>getName</methodname>
            <void />
            
            <modifier>const</modifier>
        </methodsynopsis>
        <methodsynopsis>
            
            <type>std::string</type>
            <methodname>getDirectory</methodname>
            <void />
            
            <modifier>const</modifier>
        </methodsynopsis>  
};
   </synopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        The purpose of the variable database is to contain variables.
        Variables are named entities that live in a directory and
        have  a strongly typed value.  The legal value of a variable
        may be further constrained.
     </para>
     <para>
        <classname>CVariable</classname> provides methods for
        creating and deleting variables. <classname>CVariable</classname>
        objects can modify the value of a variable, get the value of
        a variables as well as obtain properties of variables.
     </para>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <para>
        The methods of the <classname>CVariable</classname>are broken into several categories.
        Each category is described separately below.
     </para>
     <refsect2>
        <title>Variable creation methods</title>
        <para>
            These methods are static methods that are responsible for creating
            variables in an existing directory.  It is an error to attempt to
            create a variable in a nonexistent directory or to create a duplicate
            variable. Note: <filename>/this/is/bad</filename> twice is bad but does
            not conflict with <filename>/this/is/not/bad</filename> since in the
            second case the the variable <varname>bad</varname> is in a different
            directory.
        </para>
        <para>
            In general to create a directory you must provide a database
            (<classname>CVarDb</classname>), a path, a data type and an optional
            initial value.  The optional initial value must be consistent with
            the type, if supplied.  The overloads for the method simply vary with
            respect to how the path is supplied.
        </para>
        <para>
            All creational methods return a dynamically created
            <classname>CVariable</classname> object.  It is the caller's
            responsibility to <command>delete</command> that object
            when it is no longer needed.
        </para>
        <synopsis>
            <methodsynopsis>
                <modifier>static</modifier>
                <type>CVariable*</type>
                <methodname>create</methodname>
                <methodparam>
                    <type>CVariableDb&amp;</type> <parameter>db</parameter>
                </methodparam>
                <methodparam>
                    <modifier>const</modifier><type>char*</type>
                    <parameter>path</parameter>
                </methodparam>
                <methodparam>
                    <modifier>const</modifier><type>char*</type>
                        <parameter>type</parameter>
                </methodparam>
                <methodparam>
                    <modifier>const</modifier><type>char*</type>
                        <parameter>initial</parameter>
                        <initializer>0</initializer>
                </methodparam>
                <exceptionname>CVariable::CException</exceptionname>
                
            </methodsynopsis>
        <methodsynopsis>
            <modifier>static </modifier>
            <type>CVariable* </type>
            <methodname>create</methodname>
            <methodparam>
                <type>CVariableDb&amp;</type><parameter> db</parameter>
            </methodparam>
            <methodparam>
                <type> CVarDirTree&amp;</type>
                    <parameter>dir</parameter>
            </methodparam>
            <methodparam>
                <modifier>const </modifier><type>char*</type>
                    <parameter> path</parameter>
            </methodparam>
            <methodparam>
                <modifier>const </modifier><type>char* </type>
                    <parameter>type</parameter>
            </methodparam>
            <methodparam>
                <modifier>const </modifier><type>char* </type>
                    <parameter>initial</parameter>
                    <initializer>0</initializer>
            </methodparam>
            
            <exceptionname>CVariable::CException</exceptionname>
            
        </methodsynopsis>
        </synopsis>
        <para>
            In the methods described above, the parameters are as follows:
        </para>
        <variablelist>
            <varlistentry>
                <term><parameter>db</parameter></term>
                <listitem>
                    <para>
                        Reference to a
                        <classname>CVariableDb</classname> object.
                        <parameter>db</parameter> determines which database
                        the variable is created in.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><parameter>dir</parameter></term>
                <listitem>
                    <para>
                        Reference to a <classname>CVarDirTree</classname>
                        object.  If the <parameter>path</parameter> is
                        specified as a relative path,
                        <methodname>create</methodname> overloads that have a
                        <parameter>dir</parameter> parameter use that directory's
                        current working directory to determine the base of the
                        relative path. 
                    </para>
                    <para>
                        If a <methodname>create</methodname> method does not
                        take a <parameter>dir</parameter> parameter,
                        relative paths are computed from the root directory.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><parameter>initial</parameter></term>
                <listitem>
                    <para>
                        If <parameter>initial</parameter> is not a null pointer,
                        it points to an initial value string for the variable.
                        If this string
                        is not compatible with the specified
                        <parameter>type</parameter>, the variable will not be
                        created and a <classname>CVariable::CException</classname>
                        will be thrown.
                    </para>
                    <para>
                        If the <parameter>initial</parameter> pointer is null, the
                        initial value of the variable is taken from a default value
                        for the data type.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><parameter>path</parameter></term>
                <listitem>
                    <para>
                        Specifies the <parameter>path</parameter> to the variable.
                        The final path element is the variable name itself. For
                        example, the path
                        <filename>/this/is/a/dir/myvar</filename> specifies a
                        variable named <varname>myvar</varname> in the directory
                        <filename>/this/is/a/dir</filename>.
                    </para>
                    <para>
                        If the path is relative (does not begin with a a
                        <literal>/</literal>), the point the path is relative to
                        depends on the specific <methodname>create</methodname>
                        overload.  Overloads that have a <parameter>db</parameter>
                        parameter compute the path relative to that parameter's
                        current working directory.  Those without a
                        <parameter>db</parameter> parameter compute it relative
                        to the root directory.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><parameter>type</parameter></term>
                <listitem>
                    <para>
                        Provides the <parameter>type</parameter> of data that
                        can be assigned to a variable
                        (e.g. <literal>integer</literal>).
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
     </refsect2>
     <refsect2>
        <title>Variable destruction</title>
        <para>
            The static methods in this section are responsible for destroying
            existing variables.  It is an error to destroy a variable that does
            not exist.
        </para>
        <synopsis>
            <methodsynopsis>
                <modifier>static </modifier>
                <type>void </type>
                <methodname>destroy</methodname>
                <methodparam>
                    <type>CVariableDb&amp;</type><parameter>db</parameter>
                </methodparam>
                <methodparam>
                    <type>int </type>
                        <parameter>id</parameter>
                </methodparam>
                <exceptionname>CVariable::CException</exceptionname>
                
            </methodsynopsis>
            <methodsynopsis>
                <modifier>static </modifier>
                <type>void </type>
                <methodname>destroy</methodname>
                <methodparam>
                    <type>CVariable* </type><parameter>pVariable</parameter>
                </methodparam>
                <methodparam>
                    <type>bool </type>
                        <parameter>doDelete</parameter>
                        <initializer>true</initializer>
                </methodparam>
                
                <exceptionname>CVariable::CException</exceptionname>
                
            </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier>
                <type> void </type>
                <methodname>destroy</methodname>
                <methodparam>
                    <type>CVariableDb&amp;</type><parameter> db</parameter>
                </methodparam>
                <methodparam>
                    <type>CVarDirTree&amp;</type>
                        <parameter>dir</parameter>
                </methodparam>
                <methodparam>
                    <modifier>const </modifier><type>char*</type>
                        <parameter> path</parameter>
                </methodparam>
                
                <exceptionname>CVariable::CException</exceptionname>
                
            </methodsynopsis>
            <methodsynopsis>
                <modifier>static </modifier>
                <type>void </type>
                <methodname>destroy</methodname>
                <methodparam>
                    <type>CVariableDb&amp;</type><parameter> db</parameter>
                </methodparam>
                <methodparam>
                    <modifier>const </modifier><type>char* </type>
                        <parameter>path</parameter>
                </methodparam>
                
                <exceptionname>CVariable::CException</exceptionname>
                
            </methodsynopsis>
                
        </synopsis>
        <para>
            The parameters for these methods are as follows:
        </para>
        <variablelist>
            <varlistentry>
                <term><parameter>db</parameter></term>
                <listitem>
                    <para>
                        A reference to a
                        <classname>CVariableDb</classname> object that
                        determines which database is operated on.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><parameter>dir</parameter></term>
                <listitem>
                    <para>
                        A reference to a <classname>CVarDirTree</classname>.
                        This parameter is present in a method that takes
                        a <parameter>path</parameter> parameter. If
                        present, the <parameter>dir</parameter> parameter's
                        working directory determines the base directory from
                        which a relative <parameter>path</parameter>
                        is computed.
                    </para>
                    <para>
                        In overloads that have a <parameter>path</parameter>
                        parameter but no <parameter>dir</parameter> parameter,
                        relative paths are computed from the root directory.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><parameter>doDelete</parameter></term>
                <listitem>
                    <para>
                        For the over load that deletes a the variable defined
                        by a <classname>CVariable</classname> object, if this
                        is true, that object is deleted.
                    </para>
                </listitem>
            </varlistentry>
            
            <varlistentry>
                <term><parameter>id</parameter></term>
                <listitem>
                    <para>
                        The primary key of the variable to delete in the
                        variables table.  All variables have a unique
                        <parameter>id</parameter>.  If you have an instance
                        of a <classname>CVariable</classname> object, the
                        <methodname>getId</methodname>  method returns this
                        id.
                    </para>
                </listitem>
            </varlistentry>
            
            <varlistentry>
                <term><parameter>path</parameter></term>
                <listitem>
                    <para>
                        The <parameter>path</parameter> (absolute or relative)
                        to the variable to delete.  As with
                        <methodname>create</methodname>, the final path element
                        is the variable name.  
                    </para>
                    <para>
                        See the <parameter>dir</parameter> parameter for informaton
                        about how relative paths are computed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><parameter>pVariable</parameter></term>
                <listitem>
                    <para>
                        The overload that takes this parameter deletes the
                        variable it represents.
                    </para>
                </listitem>
            </varlistentry>
            
        </variablelist>
            
     </refsect2>
     <refsect2>
        <title>Informationals</title>
        <synopsis>
            <methodsynopsis>
                <modifier>static </modifier>
                <type>std::vector&lt;VarInfo&gt; </type>
                <methodname>list</methodname>
                <methodparam>
                    <type>CVariableDb*</type> <parameter>db</parameter>
                </methodparam>
                <methodparam>
                    <type>CVarDirTree&amp;</type>
                        <parameter> dir</parameter>
                </methodparam>
                <methodparam>
                    <modifier>const </modifier><type>char* </type>
                        <parameter>path</parameter>
                        <initializer>0</initializer>
                </methodparam>
                
                <exceptionname></exceptionname>
                
            </methodsynopsis>  
            
        </synopsis>
        <para>
            <methodname>list</methodname> provides information about the
            variables that live in a directory.  The return value is a possibly
            empty vector of <classname>CVariable::VarInfo</classname> structs.
            See <literal>PUBLIC VARIABLES, TYPES and CONSTANTS</literal> below
            for a description of that type.
        </para>
        <para>
            The parameters of the method establish which directory is listed:
        </para>
        <variablelist>
            <varlistentry>
                <term><parameter>db</parameter></term>
                <listitem>
                    <para>
                        A pointer to a <classname>CVariableDb</classname>
                        object that determines which 
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><parameter>dir</parameter></term>
                <listitem>
                    <para>
                        Directory that either is listed, provides a base
                        from which relative <parameter>path</parameter>s are
                        computed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><parameter>path</parameter></term>
                <listitem>
                    <para>
                        If this is null, the current working directory of
                        <parameter>dir</parameter> is listed.
                    </para>
                    <para>
                        If not null and a relative path, the path computed
                        relative to <parameter>dir</parameter>'s current
                        working directory is listed.
                    </para>
                    <para>
                        If not null and an absolute path, the absolute path
                        determines which directory is listed.
                    </para>
                </listitem>
            </varlistentry>
            
        </variablelist>
     </refsect2>
     <refsect2>
        <title><classname>CVariable</classname> objects</title>
        <para>
            <classname>CVariable</classname> objects wrap a variable in the database.
            The constructors described in this section as well as the
            <methodname>create</methodname> methods described above
            create <classname>CVariable</classname> objects.
        </para>
        <para>
            Once a <classname>CVariable</classname> object is instantiated,
            it provides methods that allow you to set and get the value of the
            underlying variable, as well as to get information about the
            variable.
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                       <methodname>CVariable</methodname>
                       <methodparam>
                        <type>CVariableDb&amp;</type>
                            <parameter>db</parameter>
                       </methodparam>
                       <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>path</parameter>
                       </methodparam>
                       <exceptionname>CVariable::CException</exceptionname>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a <classname>CVariable</classname>. 
                        <parameter>db</parameter> is the
                        <classname>CVariableDb</classname> in which the
                        variable lives.  <parameter>path</parameter> is
                        an absolute path to the variable.  
                    </para>
                    <para>
                        The last
                        path element is the variable name while the remaining
                        path elements specify the directory in which that
                        variable lives  for example:
                        <filename>/this/is/a/variable</filename> is a variable
                        named <varname>variable</varname> in the directory
                        <filename>/this/is/a</filename>.
                    </para>
                    <para>
                        If the variable does not exist a
                        <classname>CVariable::CException</classname> object
                        is thrown.  See
                        <literal>PUBLIC VARIABLES, TYPES and CONSTANTS</literal>
                        for information about this class.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                       <methodname>CVariable</methodname>
                       <methodparam>
                        <type>CVariableDb&amp;</type>
                            <parameter>db</parameter>
                       </methodparam>
                       <methodparam>
                        <type>CVarDirTree&amp;</type>
                            <parameter>dir</parameter>
                       </methodparam>
                       <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>path</parameter>
                       </methodparam>
                       
                       <exceptionname>CVariable::CException</exceptionname>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Same as the constructor above, however if
                        <parameter>path</parameter> is a relative path,
                        the current working directory of <parameter>dir</parameter>
                        determines the actual path.  For example:
                    </para>
                    <informalexample>
                        <programlisting>
                            ...
CVariableDb&amp; db("somedb");
CVarDirTree      dir(db);
dir.cd("/this/is");
CVariable        var(db, dir, "a/variable");
                            ...
                        </programlisting>
                    </informalexample>
                    <para>
                        <varname>var</varname> is an object that represents
                        the variable <filename>/this/is/a/variable</filename>.
                    </para>
                    <para>
                        If the path is absolute, the <parameter>dir</parameter>
                        parameter is ignored.
                    </para>
                    <para>
                        If the variable specified does not exist, an
                        <classname>CVariable::CException</classname> is
                        thrown.  See
                        <literal>PUBLIC VARIABLES, TYPES and CONSTANTS</literal>
                        for information about this class.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                       <methodname>CVariable</methodname>
                       <methodparam>
                        <type>CVariableDb&amp;</type>
                            <parameter>db</parameter>
                       </methodparam>
                       <methodparam>
                        <type>int </type>
                            <parameter>id</parameter>
                       </methodparam>
                       
                       <exceptionname>CVariable::CException</exceptionname>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Construts a variable given the primary key,
                        <parameter>id</parameter> of the variable in the
                        variables database table.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        
                        <type>void </type>
                        <methodname>set</methodname>
                        <methodparam>
                            <modifier>const </modifier><type>char* </type>
                                <parameter>newValue</parameter>
                        </methodparam>
                        
                        <exceptionname>CVariable::CException</exceptionname>
                        
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Sets the variable to a <parameter>newValuer</parameter>.
                        If <parameter>newValue</parameter> is not consistent
                        with the variable type or any other value constraints
                        that may be applied to the variable, a
                        <classname>CVariable::CException</classname> will be
                        thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        
                        <type>std::string</type>
                        <methodname>get</methodname>
                        <void />
                        
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the current value of the variable.  Variables
                        in the variable database always have a well defined value.
                        Even if an initial value is not supplied when a variable is
                        created, the variable type defines a default initial
                        value that will be assigned to the variable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        
                        <type>int</type>
                        <methodname>getId</methodname>
                        <void />
                        
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the id of the variable.  The variable id is
                        a unique integer value that unambiguously identifies the
                        variable.  It is, in fact, the primary key of the
                        variable in the database variables table.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        
                        <type>std::string</type>
                        <methodname>getName</methodname>
                        <void />
                        
                        <modifier>const</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the variable name.  This name does not include
                        the directory path.  Thus for the variable
                        <filename>/this/is/a/variable</filename>,
                        <literal>variable</literal> will be returned.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        
                        <type>std::string</type>
                        <methodname>getDirectory</methodname>
                        <void />
                        
                        <modifier>const</modifier>
                    </methodsynopsis>  
                </term>
                <listitem>
                    <para>
                        Returns the path of the directory that contains the
                        variable.  For example for the variable
                        <filename>/this/is/a/variable</filename>,
                        <literal>/this/is/a</literal> would be returned.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
     </refsect2>
  </refsect1>
   <refsect1>
      <title>PUBLIC VARIABLES, TYPES and CONSTANTS</title>
      <para>
        The <classname>CVariable</classname> class defines two nested
        types.  <classname>CVariable::VarInfo</classname>, which is used
        to provid information about a variable (see <methodname>list</methodname>),
        and <classname>CVariable::CException</classname> which is thrown to
        indicate error conditions detected by the API.
      </para>
      <refsect2>
        <title>CVariable::VarInfo</title>
        <para>
            This is a struct that provides the following bits of information
            about a variable:
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <structfield>s_id</structfield>
                </term>
                <listitem>
                    <para>
                        An integer which is the id of the variable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <structfield>s_name</structfield>
                </term>
                <listitem>
                    <para>
                        A <classname>std::string</classname> that is the
                        name of the variable (without the directory).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <structfield>s_type</structfield>
                </term>
                <listitem>
                    <para>
                        A <classname>std::string</classname> that is the
                        name of the variable type
                        (e.g. <literal>integer</literal>).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><structfield>s_typeId</structfield></term>
                <listitem>
                    <para>
                        The id of the type.  This is the primary key
                        of the variable type in the variable_types table.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><structfield>s_dirid</structfield></term>
                <listitem>
                    <para>
                        The id of the directory the variable is defined in.  This
                        is the primary key of that directory in the directory
                        table.
                    </para>
                </listitem>
            </varlistentry>
            
        </variablelist>
      </refsect2>
      <refsect2>
        <title>CVariable::CException</title>
        <para>
            This class is derived from <classname>std::runtime_error</classname>
            which has as its ultimate base class
            <classname>std::exception</classname>.
            The key method this class offers a consumer of these exceptions is:
        </para>
        <synopsis>
        <methodsynopsis>
            <modifier>virtual</modifier>
            <type>const char*</type>
            <methodname>what</methodname>
            <void />
        </methodsynopsis>
        </synopsis>
        <para>
            This method returns a pointer to an errro message that is human
            readable.
        </para>
      </refsect2>
   </refsect1>
</refentry>
<refentry id="daq3_CEnumeration">
  <refentryinfo>
    <author>
        <personname>
            <firstname>Ron</firstname>
            <surname>Fox</surname>
        </personname>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='daq3_cenumeration_title'>CEnumeration</refentrytitle>
     <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>CEnumeration</refname>
     <refpurpose>Support variable database enumeration  types.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <synopsis>
#include &lt;CEnumeration.h&gt;
       <ooclass><classname>CEnumeration</classname></ooclass>
{
        <methodsynopsis>
            <modifier>static </modifier>
            <type>int </type>
            <methodname>create</methodname>
            <methodparam>
                <modifier>CVariableDb&amp; </modifier><type></type>
                    <parameter>db</parameter>
            </methodparam>
            <methodparam>
                <modifier>const </modifier><type>char* </type>
                    <parameter>pTypeName</parameter>
            </methodparam>
            <methodparam>
                <type>std::vector&lt;std::string&gt; </type>
                    <parameter>values</parameter>
            </methodparam>
            
            <exceptionname>CEnumeration::CException</exceptionname>
            
        </methodsynopsis>
        
        <methodsynopsis>
            <modifier>static </modifier>
            <type>void </type>
            <methodname>addValue</methodname>
            <methodparam>
                <type> CVariableDb&amp;</type>
                    <parameter> db </parameter>
            </methodparam>
            <methodparam>
                <modifier>const </modifier><type>char* </type>
                    <parameter>pTypeName</parameter>
            </methodparam>
            <methodparam>
                <modifier>const </modifier><type>char* </type>
                    <parameter>value</parameter>
            </methodparam>
            <exceptionname>CEnumeration::CException</exceptionname>
        </methodsynopsis>
        <methodsynopsis>
            <modifier>static </modifier>
            <type>std::vector&lt;std::string&gt; </type>
            <methodname>listValues</methodname>
            <methodparam>
                <type>(CVariableDb&amp; </type>
                    <parameter>db</parameter>
            </methodparam>
            <methodparam>
                <modifier>const </modifier><type>char* </type>
                    <parameter>pTypeName</parameter>
            </methodparam>
            <exceptionname>CEnumeration::CException</exceptionname>
        </methodsynopsis>
        <methodsynopsis>
            <modifier>static </modifier>
            <type>std::vector&lt;std::string&gt; </type>
            <methodname>listEnums</methodname>
            <methodparam>
                <type>CVariableDb&amp;</type>
                    <parameter>db</parameter>
            </methodparam>
            
            
        </methodsynopsis>  
    
};
   </synopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        This class allows you to manipulate enumeration types in the
        variable database.  Enumerated types are a family of types.
        Each enumerated type has a specific, finite set of allowed
        values variables of that type can have.
     </para>
     <para>
        An enumerated type is defined by a type name, and a set of
        values variables of that type can be assigned.  Once an enumerated
        type is created, it acts exactly like primitive data types do:
        Variables can be created, and deleted, assigned and queried for
        their values.  One of the set of values is the default value for
        variables that are created without a specific value.  Modification
        of the varaible value is not allowed if a value is provided that
        is not in the set of legal values for that type.
     </para>
     <para>
        The class provides static methods that allow you programs to create
        new enumerated data types, add additional values to the set
        of values an enumerated type can take, and get information
        about the enumerated types already defined.
     </para>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <variablelist>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>static </modifier>
                    <type>int </type>
                    <methodname>create</methodname>
                    <methodparam>
                        <modifier>CVariableDb&amp; </modifier><type></type>
                            <parameter>db</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>pTypeName</parameter>
                    </methodparam>
                    <methodparam>
                        <type>std::vector&lt;std::string&gt; </type>
                            <parameter>values</parameter>
                    </methodparam>
                    
                    <exceptionname>CEnumeration::CException</exceptionname>
                    
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Creates a new data type that is an enumeration.
                    <parameter>db</parameter> is a reference to the database
                    object connected to the database in which the type will be
                    created.  <parameter>pTypeName</parameter> is the name
                     of the new type.  <parameter>values</parameter> is a
                     vector whose elements define the values variables of
                     this new type can have.    The first element
                     of <parameter>values</parameter> will be the default value
                     for the type.
                </para>
                <para>
                    The return value of this method, when successful is the
                    <firstterm>id</firstterm> of the new type.  The type's id
                    is the primary key in the <literal>variable_types</literal>
                    database table for this data type.  It is mostly useful
                    for functions and methods internal to the database API as
                    queries that require matches on primary keys are very
                    efficient.
                </para>
                <para>
                    Errors detected by this method are signalled by throwing
                    a <classname>CEnumeration::CException</classname> exception.
                    See <literal>PUBLIC VARIABLES, TYPES and CONSTANTS</literal>
                    for more information about this data type.  It is an error
                    to define a type that already exists.  It is an error to
                    have a duplicate entry in the <parameter>values</parameter>
                    vector.  It is an error to provide an empty
                    <parameter>values</parameter> vector.
                </para>
                <para>
                    Once the new type has been successfully created the
                    <link linkend='daq3_cvariable' endterm='daq3_cvariable_title' />
                    class can be used to create variables and manipulate them
                    in the same way that class can work with variables of
                    primitive/built-in types.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>static </modifier>
                    <type>int </type>
                    <methodname>id</methodname>
                    <methodparam>
                        <type>CVariableDb&amp;</type>
                            <parameter>db</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>pEnumName</parameter>
                    </methodparam>
                    
                    <exceptionname>CEnumeration::Exception</exceptionname>
                    
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                     Given the <parameter>pEnumName</parameter> which is the
                     name of an enumerated type, this method returns the
                     id of that type.  See the discussion of
                     <methodname>create</methodname> above for information
                     about what this is.  
                </para>
                <para>
                    If <parameter>pEnumName</parameter> is not an enumerated
                    type, <classname>CEnumeration::CException</classname> is
                    thrown to indicate this error. 
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>static </modifier>
                    <type>void </type>
                    <methodname>addValue</methodname>
                    <methodparam>
                        <type> CVariableDb&amp;</type>
                            <parameter> db </parameter>
                    </methodparam>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>pTypeName</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>value</parameter>
                    </methodparam>
                    
                </methodsynopsis>    
            </term>
            <listitem>
                <para>
                    Allows yout to add a new legal value to an enumerated
                     data type.  <parameter>db</parameter> is the database
                     in which the data type is defined.
                     <parameter>pTypeName</parameter> is the name of the type
                     to modify.  <parameter>value</parameter> is the new
                     legal value.
                </para>
                <para>
                    All errors are signalled by throwing a
                    <classname>CEnumeration::CException</classname> object.
                    It is an error for <parameter>pTypeName</parameter> to
                    not specify an existing enumeration type.  It is an
                    error for <parameter>value</parameter> to specify an
                    existing data type.  If <parameter>value</parameter>
                    does not point at a null terminated string, the operation
                    of this method is not only not defined, but will invariably
                    end badly.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>static </modifier>
                    <type>std::vector&lt;std::string&gt; </type>
                    <methodname>listValues</methodname>
                    <methodparam>
                        <type>(CVariableDb&amp; </type>
                            <parameter>db</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>pTypeName</parameter>
                    </methodparam>
                    <exceptionname>CEnumeration::CException</exceptionname>
                </methodsynopsis>
                
            </term>
            <listitem>
                <para>
                    Returns a vector of strings whose elements are the legal
                    values of a specific enumerated type.
                    <parameter>db</parameter> specifies the database in which
                    this type is defined. <parameter>pTypeName</parameter>
                    specifies the datatype name.
                </para>
                <para>
                    Errors are signalled by throwing a
                    <classname>CEnumeration::CException</classname>.  It is an
                    error to specify a <parameter>pTypeName</parameter> that is
                    not an existing enumerated type in <parameter>db</parameter>
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>static </modifier>
                    <type>std::vector&lt;std::string&gt; </type>
                    <methodname>listEnums</methodname>
                    <methodparam>
                        <type>CVariableDb&amp;</type>
                            <parameter>db</parameter>
                    </methodparam>
                    
                    
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns a vector of strings whose elements are the names
                    of defined enumerated types.  <parameter>db</parameter>
                    is the database queried for this information.  Note that
                    the vector returned may be empty.  This method does not
                    throw any errors.
                </para>
            </listitem>
        </varlistentry>
        
                
     </variablelist>
  </refsect1>
   <refsect1>
      <title>PUBLIC VARIABLES, TYPES and CONSTANTS</title>
      <para>
        The nested class <classname>CEnumeration::CException</classname> thrown
        to signal errors detected by the methods of this class.  This exception
        type is derived from <classname>std::exception</classname>.  What this
        specifically means is that the class's <methodname>what</methodname>
        method returns a human readable error message string.
      </para>
      <para>
        <classname>std::exception</classname>, in turn is a base class for
        a hiearchy of exceptions defined by the standard C++ library.
        For more information see e.g.
        <ulink url='http://en.cppreference.com/w/cpp/error/exception'>http://en.cppreference.com/w/cpp/error/exception</ulink>.
        The specific inheritance chain is
        <classname>std::exception</classname> -&lt; <classname>std::runtime_error</classname>
        -&lt; <classname>CEnumeration::CException</classname>
      </para>
   </refsect1>
</refentry>
<refentry id="daq3_cstatemachine">
  <refentryinfo>
    <author>
        <personname>
            <firstname>Ron</firstname>
            <surname>Fox</surname>
        </personname>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id ='daq3_cstatemachine_title'>CStateMachine</refentrytitle>
     <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>CStateMachine</refname>
     <refpurpose>Manipulate state machine data types.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <synopsis>
#include &lt;CStateMachine&gt;
       <ooclass><classname>CStateMachine</classname></ooclass>
{
public:
<type>typedef std::map&lt;std::string, std::set&lt;std::string&gt; &gt; TransitionMap;</type>
public:
        <methodsynopsis>
            <modifier>static </modifier>
            <type>void </type>
            <methodname>addTransition</methodname>
            
            <methodparam>
                <type>TransitionMap&amp;</type>
                    <parameter>map</parameter>
            </methodparam>
            <methodparam>
                <type>std::string </type>
                    <parameter>from</parameter>
            </methodparam>
            <methodparam>
                <type>std::string to</type>
                    <parameter>std::string to</parameter>
            </methodparam>
            
        </methodsynopsis>
        <methodsynopsis>
            <modifier>static </modifier>
            <type>int </type>
            <methodname>create </methodname>
            
            <methodparam>
                <type>CVariableDb&amp; </type>
                    <parameter>db</parameter>
            </methodparam>
            <methodparam>
                <type>std::string </type>
                    <parameter>typeName </parameter>
            </methodparam>
            <methodparam>
                <type>TransitionMap </type>
                    <parameter>transitions</parameter>
            </methodparam>
            
        </methodsynopsis>
        <methodsynopsis>
            <modifier>static </modifier>
            <type>bool </type>
            <methodname>isStateMachine</methodname>
            
            <methodparam>
                <type>CVariableDb&amp;</type>
                    <parameter> db</parameter>
            </methodparam>
            <methodparam>
                <type>int</type>
                    <parameter>typeId</parameter>
            </methodparam>
            
        </methodsynopsis>
        <methodsynopsis>
            <modifier>static </modifier>
            <type>std::vector&lt;std::string&gt;</type>
            <methodname>validNextStates</methodname>
        
            <methodparam>
                <type>CVariableDb&amp;</type>
                    <parameter> db</parameter>
            </methodparam>
            <methodparam>
                <type>int </type>
                    <parameter>typeId</parameter>
            </methodparam>
            <methodparam>
                <type>std::string </type>
                    <parameter>from</parameter>
            </methodparam>
            
        </methodsynopsis>
        <methodsynopsis>
            <modifier>static </modifier>
            <type>std::vector&lt;std::string&gt; </type>
            <methodname>validNextStates</methodname>
        
            <methodparam>
                <type>CVariableDb&amp; </type>
                    <parameter>db</parameter>
            </methodparam>
            <methodparam>
                <type>int </type>
                    <parameter>varId</parameter>
            </methodparam>
            
        </methodsynopsis>
        <methodsynopsis>
            <modifier>static </modifier>
            <type>TransitionMap </type>
            <methodname>getTransitionMap</methodname>
            
            <methodparam>
                <type>CVariableDb&amp; </type>
                    <parameter>db</parameter>
            </methodparam>
            <methodparam>
                <type>int </type>
                    <parameter>typeId</parameter>
            </methodparam>
            
        </methodsynopsis>
        <ooclass><classname>CException : public std::runtime_error</classname></ooclass> {
            <constructorsynopsis>
               <methodname>explicit CException</methodname>
               <methodparam>
                <modifier>const</modifier><type>std::string&amp;</type>
                    <parameter>mst</parameter>
               </methodparam>
               
            </constructorsynopsis>
        };
};
   </synopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        A state machine type is a type that has a discrete number of values
        (states) and well defined trasitions from value to value within those
        states.  A state machine can also be thought of as an enumerated type
        with constraints on which values a variable can be assigned that depend
        on the current value (state) of the variable.
     </para>
     <para>
        <classname>CStateMachine</classname> allows you to manipulate state
        state machine data types.  You must still use
        <link linkend='daq3_cvariable' endterm='daq3_cvariable_title' /> to
        create actual instances of state machines.
     </para>
     <para>
        In order to describe a state machine (states and transitions) a
        data structure,
        <type>CStateMachine::TransitionMap</type> is used.  A convenience
        method, <methodname>addTransition</methodname>, is provided to
        help build up this data structure.
        For more information about this data structure see:
        <link linkend='daq3_cstatemachine_pvtc'
              endterm='daq3_cstatemachine_pvtc_title' /> below.
     </para>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <variablelist>
        
        <varlistentry>
            <term>
                <methodsynopsis>
                        <modifier>static </modifier>
                        <type>void </type>
                        <methodname>addTransition</methodname>
                        
                        <methodparam>
                            <type>TransitionMap&amp;</type>
                                <parameter>map</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::string </type>
                                <parameter>from</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::string to</type>
                                <parameter>std::string to</parameter>
                        </methodparam>
                    </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Convenience method to build up a description of the
                    states and allowed transtions needed to
                    create a state machine type.  <parameter>map</parameter>
                    is the state machine transition map that is being built up.
                    <parameter>from</parameter> is the initial state prior to the
                    transition being described and <parameter>to</parameter>
                    is a state directly reachable when the state is
                    <parameter>from</parameter>.
                </para>
                <para>
                    If <parameter>from</parameter> has not yet been seen,
                    it is added as a valid state.
                    <type>CStateMachine::TransitionMap</type> is such that
                    dead end states (states with no outbound transitions) are
                    not allowed.  This is intentional and is because in general
                    state machines used by the data acquisition system
                    don't have terminal states but run for the life of the system.
                </para>
                <para>
                    For more information about the
                    <type>CStateMachine::TransitinoMap</type> data type,
                    see
                    <link linkend='daq3_cstatemachine_pvtc'
                        endterm='daq3_cstatemachine_pvtc_title' /> below.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                        <modifier>static </modifier>
                        <type>int </type>
                        <methodname>create </methodname>
                        
                        <methodparam>
                            <type>CVariableDb&amp; </type>
                                <parameter>db</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::string </type>
                                <parameter>typeName </parameter>
                        </methodparam>
                        <methodparam>
                            <type>TransitionMap </type>
                                <parameter>transitions</parameter>
                        </methodparam>
                    </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Creates a new state machine data type.
                    <parameter>db</parameter> is a reference to the database
                    in which the data type is being created.
                    <parameter>typeName</parameter> is the name of the data type
                    being created.  <parameter>transitions</parameter> is the
                    <type>CStateMachine::TransitionMap</type>
                    that defines the state machine.
                </para>
                <para>
                    For more information about
                    <type>CStateMachine::TransitionMap</type> see
                    <link linkend='daq3_cstatemachine_pvtc'
                        endterm='daq3_cstatemachine_pvtc_title' /> below.
                    Note as well that the simplest way to build up a state
                    transition map is to use the
                    <methodname>addTransition</methodname> repeatedly to
                    describe all legal transitions.
                </para>
                <para>
                    The return value is the type id of the new data type.
                    <classname>CStateMachine::CException</classname> will be
                    thrown if:
                    <orderedlist>
                        <listitem><para>
                            A state transition list for a state is empty.
                            This cannot happen if you use
                            <methodname>addTransition</methodname> to build up
                            the transition map.
                        </para></listitem>
                        <listitem><para>
                            A transition in the transition map identifies
                            a state that is not defined.
                        </para></listitem>
                        <listitem><para>
                            The data type <parameter>typeName</parameter>
                            is already defined.
                        </para></listitem>
                    </orderedlist>
                </para>
                <para>
                    The initial state of a state machine is defined as the
                    alphabetically first state in the map.  Thus you may want
                    your initial state to be named something like
                    <literal>0</literal><replaceable>state-name</replaceable>.
                    When you create a state machine variable, it can oly be
                    given an intial value that matches the initial state
                    of the variable.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                        <modifier>static </modifier>
                        <type>bool </type>
                        <methodname>isStateMachine</methodname>
                        
                        <methodparam>
                            <type>CVariableDb&amp;</type>
                                <parameter> db</parameter>
                        </methodparam>
                        <methodparam>
                            <type>int</type>
                                <parameter>typeId</parameter>
                        </methodparam>
                    </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns <literal>true</literal> if
                    <parameter>typeId</parameter> is the type id of a state
                    machine in the data base identified by
                    <parameter>db</parameter>.
                </para>
                <para>
                    An exception is thrown if <parameter>typeId</parameter>
                    does not identify a data type.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                        <modifier>static </modifier>
                        <type>std::vector&lt;std::string&gt;</type>
                        <methodname>validNextStates</methodname>
                        
                        <methodparam>
                            <type>CVariableDb&amp;</type>
                                <parameter> db</parameter>
                        </methodparam>
                        <methodparam>
                            <type>int </type>
                                <parameter>typeId</parameter>
                        </methodparam>
                        <methodparam>
                            <type>std::string </type>
                                <parameter>from</parameter>
                        </methodparam>
                        
                    </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns a vector of the allowed next states
                    of the state machine whose type id identified by
                    <parameter>typeId</parameter> in the
                    database connected on <parameter>db</parameter> given
                    it is in the state <parameter>from</parameter>.
                    The return value is a vector of strings.  Each element of
                    the vetor is a valid next state for the state
                    <parameter>from</parameter>.
                </para>
                <para>
                    This method will throw a
                    <classname>CStateMachine::CException</classname> if:
                    <orderedlist>
                        <listitem><para>
                            The <parameter>typeId</parameter> parameter does not
                            identify a variable type.
                        </para></listitem>
                        <listitem><para>
                            <parameter>typeId</parameter> does not identify
                            a state machine.
                        </para></listitem>
                    </orderedlist>
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                        <modifier>static </modifier>
                        <type>std::vector&lt;std::string&gt; </type>
                        <methodname>validNextStates</methodname>
                        
                        <methodparam>
                            <type>CVariableDb&amp; </type>
                                <parameter>db</parameter>
                        </methodparam>
                        <methodparam>
                            <type>int </type>
                                <parameter>varId</parameter>
                        </methodparam>
                        
                    </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns the valid next states for the
                    variable identifies by <parameter>varId</parameter>
                    in the database <parameter>db</parameter>.
                    This method determins the data type of the variable
                    and invokes the previous overload of this method.
                    Thus it has the same return value and exception
                    specifications.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                        <modifier>static </modifier>
                        <type>TransitionMap </type>
                        <methodname>getTransitionMap</methodname>
                        
                        <methodparam>
                            <type>CVariableDb&amp; </type>
                                <parameter>db</parameter>
                        </methodparam>
                        <methodparam>
                            <type>int </type>
                                <parameter>typeId</parameter>
                        </methodparam>
                        
                    </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns the transition map that defines the
                    state machine type <parameter>typeId</parameter> in
                    the database <parameter>db</parameter>.
                    See
                    <link linkend='daq3_cstatemachine_pvtc'
                        endterm='daq3_cstatemachine_pvtc_title' /> below for
                        more information about the data structure returned.
                    An exception (
                    <classname>CStateMachine::CException</classname>)
                    is thrown if:
                    <orderedlist>
                        <listitem><para>
                            The <parameter>typeId</parameter> parameter does not
                            identify a data type.
                        </para></listitem>
                        <listitem><para>
                            The <parameter>typeId</parameter> parameter identifies
                            a data type that is not a state machine.
                        </para></listitem>
                    </orderedlist>
                </para>
            </listitem>
        </varlistentry>
                     
     </variablelist>
  </refsect1>
   <refsect1 id='daq3_cstatemachine_pvtc'>
      <title id='daq3_cstatemachine_pvtc_title'>PUBLIC VARIABLES, TYPES and CONSTANTS</title>
      <para>
        <classname>CStateMachine</classname> exports two types.
        <type>CStateMachine::TransitionMap</type> describes the states and
        allowed transitions between those states that define a state machine.
        <classname>CStateMachine::CException</classname> is the type of exception
        that is thrown directly from methods in the
        <classname>CStateMachine</classname> class.  Note that other exception
        types may be thrown from methods called by those methods.
      </para>
      <para>
        <classname>CStateMachine::CException</classname> is derived from
        the C++ standard library exception:
        <classname>std::runtime_error</classname>.  All exceptions thrown directly
        by the variable database API are derived from that exception as well.
        Unless you need a more granular detection of the specific orign of
        an exception, your code can just catch
        <classname>std::runtime_exception&amp;</classname> exceptions and use the
        <methodname>what</methodname> method to retrieve and report the error message.
        <ulink url='http://en.cppreference.com/w/cpp/error/runtime_error'>
            http://en.cppreference.com/w/cpp/error/runtime_error
        </ulink> provides more information about the
        <classname>std::runtime_error</classname> class.
      </para>
      <para>
        <type>CStateMachine::TransitionMap</type> is defined as an
        <classname>std::map</classname> whose elements are
        <classname>std::set&lt;std::string&gt;</classname> and whose
        indices are <classname>std::string</classname> objects.
        Each index of the map represents a legal state for the state machine.
        The set that index references is the set of allowed next states
        the machine can be in if it is in the index state.
      </para>
      <para>
        The <methodname>addTransition</methodname> method adds a transition
        specification to the map. If you use <methodname>addTransiton</methodname>
        to cdreate your state machine's transition map, you can not define
        terminal states (a terminal state is one that has no valid outbound
        transitions).  The initial state of the machine is the alphabetically first
        state.  This is a consequence of the fact that
        <classname>std::map</classname> keys have a defined ordering.  It is
        therefore recommended that you have an initial state named something
        like <literal>0</literal><replaceable>state-name</replaceable> to esnure
        full control over what the initial state is.
      </para>
      <para>
        In most cases not having a terminal state is not a problem as DAQ
        state machines tend to run for the length of the experiment.  If, however
        you need a terminal state in your state machine you can create one using
        code like that below:
      </para>
      <informalexample>
        <programlisting>
#include &lt;CStateMachine.h&gt;
...
{
...
    CStateMachine::TransitionMap myStateMachine;
    ...
    std::set&lt;std::string&gt; dummy = myStateMachine["terminal"];
    ...
}
        </programlisting>
      </informalexample>
      <para>
        Since, presumably the state <literal>terminal</literal> has not
        been a <parameter>from</parameter> for a call to
        <methodname>addTransition</methodname>, this creates a new key in the
        map for <literal>terminal</literal> whose value is the empty
        set (result of a default constructino of
        <classname>std::set&lt;std::string&gt;</classname>).
        <literal>terminal</literal>  will be a valid state with no outbound
        transitions as long as it does not appear as no states are inserted
        into its target state set.  If you stock the remaining part of
        <varname>myStateMachine</varname> using
        <methodname>addTransition</methodname> this means not having
        <literal>terminal</literal> as a <parameter>from</parameter>
        parameter.
      </para>
   </refsect1>
</refentry>     
<refentry id="daq3_ctypefactory">
  <refentryinfo>
    <author>
        <personname>
            <firstname>Ron</firstname>
            <surname>Fox</surname>
        </personname>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='daq3_ctypefactory_title'>CTypeFactory</refentrytitle>
     <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>CTypeFactory</refname>
     <refpurpose>Generate variable database type objects</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <synopsis>
#include &lt;CTypeFactory.h&gt;

       <ooclass><classname>CTypeFactory : public CExtensibleFactory&lt;CDataType&gt;</classname></ooclass>
{
        <methodsynopsis>
            <modifier>static</modifier>
            <type>void</type>
            <methodname>createSchema</methodname>
            <methodparam>
                <type>CSqlite&amp;</type>
                    <parameter>db</parameter>
            </methodparam>
        </methodsynopsis>  
        <constructorsynopsis>
           <methodname>CTypeFactory</methodname>
           <methodparam>
            <type>CSqlite&amp;</type> <parameter>db</parameter>
           </methodparam>
        </constructorsynopsis>
        <methodsynopsis>
            
            <type>CDataTpe*</type>
            <methodname>create</methodname>
            <methodparam>
                <type>std::string</type>
                    <parameter>typeName</parameter>
            </methodparam>
            
        </methodsynopsis>
        <methodsynopsis>
            
            <type>void</type>
            <methodname>addCreator</methodname>
            <methodparam>
                <type>std::string</type>
                    <parameter>typeName</parameter>
            </methodparam>
            <methodparam>
                <type>CDataTypeCreator*</type>
                    <parameter>pCreator</parameter>
            </methodparam>
            
        </methodsynopsis>
        <methodsynopsis>
            
            <type>void</type>
            <methodname>addUnknonwnTypeHandler</methodname>
            <methodparam>
                <type>CUnknownTypeHandler*</type>
                    <parameter>pHandler</parameter>
            </methodparam>
            
            
        </methodsynopsis>  
};
   </synopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        The variable data base type system defines data types in the database.
        Code, however is currently required to define, given a data type, if
        a proposed value is legal, and what the default value for a type is.
     </para>
     <para>
        A class hierarchy rooted in
        <link linkend='daq3_cdatatype' endterm='daq3_cdatatype_title' />
        provides those methods.  The variable database, however needs to know
        how to create the appropriate <classname>CDataType</classname> object
        from the textual name of a datatype (e.g. from the
        <literal>variable_types</literal> table).  This pattern, instantiating
        an object given some text string is tailor made for the
        <link linkend='daq3_cextensiblefactory'  endterm='daq3_cextensiblefactory_title' />
        templated class.
     </para>
     <para>
        A further problem presents, beyond the typical scope of an extensible
        factory.  That is how and when to register creators for defined types
        (like enums).  These types not only can be created at run time, but may
        already be defined in the database when the factory is instantiated.
     </para>
     <para>
        To handle this, the variable database API introduces the concept of
        <firstterm>type families</firstterm>.  A type family is a collection
        of data types that have the same properties but are parameterized in some
        way.  For example, all enumerated types allow their variables to take
        one of a discrete set of values, but the set of values varies from
        type to type.  Thus enumerations can be considered a type family.
     </para>
     <para>
        To deal with the complexities of knowing how to instantiate
        type creators and data type objects for type families, the
        <classname>CTypeFactory</classname> class layers on top of the
        <classname>CExtensibleFactory</classname> the ability to provide
        an ordered list of handlers that are called when the factory
        is asked to <methodname>create</methodname> a type with a type
        string that does not yet have a creator.
     </para>
     <para>
        Unknown type handlers are called in registration order and can return
        either a NULL, indicating they don't know how to deal with this type,
        or a pointer to a <classname>CDataType</classname> if they do.
        Once an unknown handler provides a data type object, the iteration
        through unknown handlers terminates.  If no handler is able to return
        non-null, then the type is truly unknown and
        <methodname>create</methodname> returns a null pointer.
     </para>
     <para>
        Typically, an unkown type handler, in addition to providing a
        <classname>CDataType</classname> to its caller will register
        a <classname>CDataTypeCreator</classname> for the specific
        instance of the data type family it represents with the factory.
        This improves the performance of future <methodname>create</methodname>
        calls for that instance of the family.
     </para>
     <para>
        Finally:  Since type families often require tables that describe
        specific instances of their type, it is normal for
        <classname>CUnknownTypeHandlers</classname> to create additional tables,
        if those tables don't yet exist, when they are instantiated.
        The <classname>CTypeFactory</classname> knows about built in
        type families and registers they unknown type handlers when constructed.
     </para>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <variablelist>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>static</modifier>
                    <type>void</type>
                    <methodname>createSchema</methodname>
                    <methodparam>
                        <type>CSqlite&amp;</type>
                            <parameter>db</parameter>
                    </methodparam>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    This static method creates the tables needed by the
                    <classname>CTypeFactory</classname>  in the database open on
                    <parameter>db</parameter> if those tables don't exist
                    yet.  In practice this means creating the
                    <literal>variable_types</literal> table.
                </para>
                <para>
                    If tables required already exist, they are not created.
                    Note that this method can be fooled.  If a database
                    has a table of the correct name but wrong schema,
                    <classname>CTypeFactory</classname> will not detect this
                    and will probably fail later.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <constructorsynopsis>
                   <methodname>CTypeFactory</methodname>
                   <methodparam>
                    <type>CSqlite&amp;</type> <parameter>db</parameter>
                   </methodparam>
                </constructorsynopsis>
            </term>
            <listitem>
                <para>
                    The constructor for the type factory installs built in
                    primitive type creators as well as the built in
                    data type family unknown type handlers. 
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    
                    <type>CDataTpe*</type>
                    <methodname>create</methodname>
                    <methodparam>
                        <type>std::string</type>
                            <parameter>typeName</parameter>
                    </methodparam>
                    
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Creates and returns a pointer to the
                    <classname>CDataType</classname> object specified
                    by <parameter>typeName</parameter>.  If no data type object
                    can be created for <parameter>typeName</parameter> a null
                    pointer is returned.  See
                    <literal>DESCRIPTION</literal> above for a much more
                    detailed look at how this function operates.
                </para>
                <para>
                    Note that this function overrides the base class
                    <methodname>create</methodname> method, only calling
                    it as the first step in its implementation.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    
                    <type>void</type>
                    <methodname>addCreator</methodname>
                    <methodparam>
                        <type>std::string</type>
                            <parameter>typeName</parameter>
                    </methodparam>
                    <methodparam>
                        <type>CDataTypeCreator*</type>
                            <parameter>pCreator</parameter>
                    </methodparam>
                    
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    This method is actually defined and implemented in the base
                    class.  It is used to add a new data type (either a
                    primitive type or an instance of a type family) to the API.
                    <parameter>pCreator</parameter> must be an object that knows
                    how to create <classname>CDataType</classname> objects
                    associated with the <parameter>typeName</parameter>.
                </para>
                <para>
                    For more on <classname>CDataTypeCreator</classname>s see
                    <link linkend='daq3_cdatatypecreator' endterm='daq3_cdatatypecreator_title' />.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    
                    <type>void</type>
                    <methodname>addUnknonwnTypeHandler</methodname>
                    <methodparam>
                        <type>CUnknownTypeHandler*</type>
                            <parameter>pHandler</parameter>
                    </methodparam>
                    
                    
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Adds an unknown type handler for a type family to the factory.
                    <parameter>pHandler</parameter> is a
                    <classname>CUnknownTypeHandler</classname> that will be called on
                    if an unknown type name is handed to
                    <methodname>create</methodname>.
                </para>
                <para>
                    See
                    <literal>DESCRIPTION</literal> above for more on how type families
                    are used.
                    See
                    <link linkend='daq3_cunknowntypehandler' endterm='daq3_cunknowntypehandler_title' />
                    for more about the <classname>CUnknownTypeHandler</classname> base class.
                </para>
            </listitem>
        </varlistentry>
     </variablelist>
  </refsect1>
   <refsect1>
      <title>SEE ALSO</title>
      <para>
        <link linkend='daq3_cdatatype' endterm='daq3_cdatatype_title' />,
        <link linkend='daq3_cdatatypecreator' endterm='daq3_cdatatypecreator_title' />,
        <link linkend='daq3_cunknowntypehandler' endterm='daq3_cunknowntypehandler_title' />,
        <link linkend='daq3_cextensiblefactory'  endterm='daq3_cextensiblefactory_title' />
      </para>
   </refsect1>
</refentry>
<refentry id="daq3_cdatatype">
  <refentryinfo>
    <author>
        <personname>
            <firstname>Ron</firstname>
            <surname>Fox</surname>
        </personname>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='daq3_cdatatype_title'>CDataType</refentrytitle>
     <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>CDataType</refname>
     <refpurpose>Base class for variable database type objects</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <synopsis>
#include &lt;CDataType.h&gt;    
       <ooclass><classname>CDataType</classname></ooclass>
{
        <constructorsynopsis>
           <methodname>CDataType</methodname>
           <methodparam>
            <type>int</type>
                <parameter>id</parameter>
           </methodparam>
           <methodparam>
            <type>std::string</type>
                <parameter>typeName</parameter>
           </methodparam>
           
        </constructorsynopsis>
        
        <methodsynopsis>
            
            <type>int</type>
            <methodname>id</methodname>
            <void />
            <modifier>const </modifier>
        </methodsynopsis>
        <methodsynopsis>
            
            <type>std::string</type>
            <methodname>type</methodname>
            <void />
            <modifier>const</modifier>
        </methodsynopsis>
        <methodsynopsis>
            <modifier> virtual</modifier>
            <type>bool</type>
            <methodname>legal</methodname>
            <methodparam>
                <modifier>const </modifier><type>char* </type>
                    <parameter>attempt</parameter>
            </methodparam>
            <modifier> const = 0</modifier>
        </methodsynopsis>
        <methodsynopsis>
            <modifier>virtual</modifier>
            <type>std::string </type>
            <methodname>defaultValue</methodname>
            <void />
            <modifier>const = 0</modifier>
        </methodsynopsis>  
};
   </synopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        This abstract base class is the root type of the hierarchy of classes
        that allow the variable database to work with data types at run time.
        See
        <link linkend='daq3_ctypefactory' endterm='daq3_ctypefactory_title' />
        for more information about data types and how they are handled.
     </para>
     <para>
        In order to add a data type, or data type family to the variable database
        API, you will at least need to write a concrete subclass of
        <classname>CDataType</classname>, a creator for it (sublcass of
        <classname>CDataTypeCreator</classname>).  If data types are instances
        of a family of data types you will need to also write a
        <classname>CUnknownTypeHandler</classname> subclass.
     </para>
     <para>
        If your type is a simple type, you'll need to register your
        data type creator with the factory on each factory instantiation.
        If your type is a member of a type family you'll need to register
        your unknow type handler with each factory instantiation.
     </para>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <variablelist>
        <varlistentry>
            <term>
                <constructorsynopsis>
                   <methodname>CDataType</methodname>
                   <methodparam>
                    <type>int</type>
                        <parameter>id</parameter>
                   </methodparam>
                   <methodparam>
                    <type>std::string</type>
                        <parameter>typeName</parameter>
                   </methodparam>
                   
                </constructorsynopsis>

            </term>
            <listitem>
                <para>
                    Since the base class provides services
                    that return the id and name of the type
                    represented, derived class constructors
                    must construct using this base class
                    constructor to provide that information
                    to the base class.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    
                    <type>int</type>
                    <methodname>id</methodname>
                    <void />
                    <modifier>const </modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns the type's id.  This is the
                    primary key for the type in the
                    <literal>variable_types</literal>
                    database.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    
                    <type>std::string</type>
                    <methodname>type</methodname>
                    <void />
                    <modifier>const</modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns the name of the type.
                    Typically this will be the
                    <varname>type_name</varname>
                    field for the type in the
                    <literal>variable_types</literal> table
                    of the database.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier> virtual</modifier>
                    <type>bool</type>
                    <methodname>legal</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>attempt</parameter>
                    </methodparam>
                    <modifier> const = 0</modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    This pure virtual method must be implementyed by concrete
                    classes.  Given a proposed new value,
                    <parameter>attempt</parameter>, for a variable
                    of the type represented by the object, returns
                    <literal>true</literal> if that value is
                    legal for the type.  If <parameter>attempt</parameter>
                    is not legal <literal>false</literal> should be
                    returned.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>virtual</modifier>
                    <type>std::string </type>
                    <methodname>defaultValue</methodname>
                    <void />
                    <modifier>const = 0</modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    This pure virtual method must return the default value for
                    variables of this type.  This is used to supply the initial
                    value when a
                    variable of this type is created but not given an initial value
                </para>
            </listitem>
        </varlistentry>
                
     </variablelist>
  </refsect1>
</refentry>
<refentry id="daq3_cdatatypecreator">
  <refentryinfo>
    <author>
        <personname>
            <firstname>Ron</firstname>
            <surname>Fox</surname>
        </personname>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='daq3_cdatatypecreator_title'>CDataTypeCreator</refentrytitle>
     <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>CDataTypeCreator</refname>
     <refpurpose>Create specific CDataType objects (ABC) (variable database).</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <synopsis>
 #include &lt;CDataTypeCreator.h&gt;
       <ooclass><classname>CDataTypeCreator : public CDataTypeCreator</classname></ooclass>
{
        <constructorsynopsis>
           <methodname>CDataTypeCreatorBase</methodname>
           <methodparam>
            <type>CSqlite&amp;</type>
                <parameter> db</parameter>
           </methodparam>
        </constructorsynopsis>
        <methodsynopsis>
            
            <type>int </type>
            <methodname>lookupId</methodname>
            <methodparam>
                <modifier>const</modifier><type>char*</type>
                    <parameter>typeName</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <modifier>virtual </modifier>
            <type>CDataType* </type>
            <methodname>operator()</methodname>
            <void />
            
        </methodsynopsis>  
        <methodsynopsis>
            <modifier>virtual </modifier>
            <type>std::string </type>
            <methodname>describe</methodname>
            <void />
            <modifier>const</modifier>
        </methodsynopsis>  
};
   </synopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        This "abstract" base class is  the base class of the
        helper objects used by the
        <classname>CTypeFactory</classname> to create data type objects
        appropriate to a type name.   Each concrete data type will have a
        data type creator registered with the data type factory and associated
        with that type's name.
     </para>
     <para>
        When the data type factory is asked to create a data type object for
        a type name, its first step in doing so is to attempt to find a
        data type creator associated with that type name.  If one is found,
        it is used to create the actual data type.
     </para>
     <para>
        Note that while this class is not strictly an abstract class for purposes
        of testability, it should be treated as if the
        <methodname>operator()</methodname> and <methodname>describe</methodname>
        methods were abstract.
     </para>
     <para>
        Note that if you don't need the <methodname>lookupId</methodname> method,
        you can instead derive directly from <classname>CDataTypeCreator</classname>
     </para>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <variablelist>
        <varlistentry>
            <term>
                <constructorsynopsis>
                   <methodname>CDataTypeCreatorBase</methodname>
                   <methodparam>
                    <type>CSqlite&amp;</type>
                        <parameter> db</parameter>
                   </methodparam>
                </constructorsynopsis>
            </term>
            <listitem>
                <para>
                    Since this base class provides the service
                    <methodname>lookupId</methodname>, which requires
                    database queries, Concrete subclasses must
                    construct in a way that provides the base class
                    with a reference to the database on which they
                    are operating.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    
                    <type>int </type>
                    <methodname>lookupId</methodname>
                    <methodparam>
                        <modifier>const</modifier><type>char*</type>
                            <parameter>typeName</parameter>
                    </methodparam>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Given the name of a type, <parameter>typeName</parameter>,
                    return the id of that type.  Note that the caller better know
                    what it is doing, as if the type is not yet defined in the
                    <literal>variable_types</literal> table it is entered and
                    the resulting id returned.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>virtual </modifier>
                    <type>CDataType* </type>
                    <methodname>operator()</methodname>
                    <void />
                    
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    This method should be treated as if it is abstract.  It
                    must be implemented in concrete derived classes so that
                    it return s a pointer to a data type object appropriate to the
                    data type represented by this creator.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>virtual </modifier>
                    <type>std::string </type>
                    <methodname>describe</methodname>
                    <void />
                    <modifier>const</modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    This method should be treated as an abstract base method.
                    It must be implemented by concreate subclasses to return
                    a string that describes the type created by this class..
                    For example, the <classname>CIntegerTypeCreator</classname>
                    returns <literal>integer</literal>.
                </para>
            </listitem>
        </varlistentry>
     </variablelist>
  </refsect1>
</refentry>     
<refentry id="daq3_cunknowntypehandler">
  <refentryinfo>
    <author>
        <personname>
            <firstname>Ron</firstname>
            <surname>Fox</surname>
        </personname>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='daq3_cunknowntypehandler_title'>CUnknownTypeHandler</refentrytitle>
     <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>CUnknownTypeHandler</refname>
     <refpurpose>Abstract base class for unknown type handlers (variable database)</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <synopsis>
#include &lt;CUnknownTypeHandler.h&gt;
       <ooclass><classname>CUnknownTypeHandler</classname></ooclass>
{
        <methodsynopsis>
            <modifier>virtual </modifier>
            <type>CDataType*</type>
            <methodname>create(</methodname>
            <methodparam>
                <modifier>const </modifier><type>char* </type>
                    <parameter>typeName</parameter>
            </methodparam>
            <methodparam>
                <type>CSqlite&amp; </type>
                    <parameter>db</parameter>
            </methodparam>
            <methodparam>
                <type>CTypeFactory&amp;</type>
                    <parameter>factory</parameter>
            </methodparam>
            <modifier> = 0</modifier>
        </methodsynopsis>  
};
   </synopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        This is the abstract base class for unknown type handlers that can be
        registered with the type factory.  Unknown type factories are registered
        as an ordered list of objects that are given a chance to create an object
        for types that don't (yet) have creators.
     </para>
     <para>
        Each handler's <methodname>create</methodname> method is invoked.
        If the object knows how to create the specified type it must return
        a pointer to that type's <classname>CDataType</classname> object.
        If not it must return <literal>NULL</literal>.
     </para>
     <para>
        Optionally, the handler can register a new creator for that data type.
        This is normally done when the data type is a specific member of a
        type family.  In that case, registering a creator for that type
        can substantially reduce the overhead of subsequent type object creation.
     </para>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <variablelist>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier>virtual </modifier>
                    <type>CDataType*</type>
                    <methodname>create(</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>typeName</parameter>
                    </methodparam>
                    <methodparam>
                        <type>CSqlite&amp; </type>
                            <parameter>db</parameter>
                    </methodparam>
                    <methodparam>
                        <type>CTypeFactory&amp;</type>
                            <parameter>factory</parameter>
                    </methodparam>
                    <modifier> =0 </modifier>
        
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    This pure virtual method must be implemented by concrete
                    unknown type handlers. <parameter>typeName</parameter> is
                    the type the factory has been asked to create.
                    <parameter>db</parameter> is a reference to the database the
                    type factory is operatig in.  <parameter>factory</parameter>
                    is a reference to the factory itself.
                </para>
                <para>
                    If the type can be created, its object must be returned.
                    Often determining this requires database actions.
                </para>
            </listitem>
        </varlistentry>
     </variablelist>
  </refsect1>
   <refsect1>
      <title>EXAMPLE</title>
      <para>
        Enumerated types are a type family and therefore are created using
        an enumerated type family handler. The <classname>CEnumTypeCreator</classname>
        constructor is coded to accept a database and typename.  It will
        either find itself in the database of throw an exception if there
        is not an enumerated type of the givenname.
      </para>
      <para>
        Here therefore is the implementation of the <methodname>create</methodname>
        method for the enumerated data type family:
      </para>
      <example>
        <title>Enumerated type handler</title>
        <programlisting>
CDataType*
CEnumTypeFamilyHandler::create(const char* typeName, CSqlite&amp; db, CTypeFactory&amp; factory)
{
    
    try {
        CEnumTypeCreator* pCreator = new CEnumTypeCreator(db, std::string(typeName));
        factory.addCreator(typeName, pCreator);
        return (*pCreator)();
    } catch (...) {
        return 0;
    }
}

        </programlisting>
      </example>
   </refsect1>
</refentry>     


<!-- /manpage -->

<!-- manpage 3tcl -->

      <refentry id="tcl3_vardb">
        <refentryinfo>
          <author>
                  <personname>
                          <firstname>Ron</firstname>
                          <surname>Fox</surname>
                  </personname>
          </author>
          <productname>NSCLDAQ</productname>
          <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='tcl3_vardb_title'>vardb</refentrytitle>
           <manvolnum>3tcl</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>vardb</refname>
           <refpurpose>Tcl Bindings to Variable Database API</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
            <cmdsynopsis>
                <command>
lappend auto_path [$::env(DAQROOT) TclLibs]
package require vardb
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
vardb::create <replaceable>filename</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
set <replaceable>handle</replaceable> [vardb::open <replaceable>filename</replaceable>]
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
vardb::close <replaceable>$handle</replaceable>
                </command>
            </cmdsynopsis>
            
            <cmdsynopsis>
                <command>
vardb::mkdir <replaceable>$handle directory-path</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
vardb::cd <replaceable>$handle directory-path</replaceable>                    
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
set wd [vardb::getwd <replaceable>$handle</replaceable>]
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
vardb::ls <replaceable>$handle ?directory-path?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
vardb::rmdir <replaceable>$handle directory-path</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
vardb::var <replaceable>subcommand $handle args...</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
vardb::enum <replaceable>$handle type-name list-of-values</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
vardb::statemachine <replaceable>$handle type-name transition-dict</replaceable>
                </command>
            </cmdsynopsis>
            
            
            
        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            The <literal>vardb</literal> package provides Tcl bindings to the
            variable database API.  The bindings appear as a set of commands in the
            <literal>::vardb::</literal> namespace (See COMMANDS below).
           </para>
           <para>
            The bindings follow an object-handle manipulation
            pattern.  <command>::vardb::open</command> opens a database file and
            returns a database handle that must be used in other  vardb commands.
            The <command>::vardb::close</command> command closes handles returned
            by <command>::vardb::open</command> rendering them useless, and releasing
            any associated resources.
           </para>
        </refsect1>
        <refsect1>
           <title>
              COMMANDS
           </title>
           <variablelist>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                            <command>
vardb::create <replaceable>filename</replaceable>
                            </command>
                        </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates a new variable database in
                        <parameter>filename</parameter>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                            <command>
set <replaceable>handle</replaceable> [vardb::open <replaceable>filename</replaceable>]
                            </command>
                        </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Opens an existing variable database and
                        returns a handle to it.  That handle must
                        be used in all variable database commands that are
                        intended to apply to that database.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                            <command>
vardb::close <replaceable>$handle</replaceable>
                            </command>
                        </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Closes the database represented by the
                        <parameter>handle</parameter> parameter.  The
                        <parameter>handle</parameter> parameter must be a value
                        returned from a previous successful
                        <command>::vardb::open</command> command.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                            <command>
vardb::mkdir <replaceable>$handle directory-path</replaceable>
                            </command>
                        </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates a directory in the variable database
                        represented by <parameter>handle</parameter>.
                        The <parameter>handle</parameter> parameter must have
                        been returned from a successful prior
                        <command>::vardb::open</command> command. The
                        <parameter>directory-path</parameter> is an absolute
                        or relative path that specifies which directory to create.
                    </para>
                    <para>
                        The Tcl bindings create any missing path elements along
                        the way to the terminal path element.  For example,
                        in an emtpy database (only the root directory exists)
                        <command>::vardb::mdkir $handle /this/directory/here</command>
                        creates three directories:
                        <filename>/this</filename>, <filename>/this/directory</filename>
                        and the terminal node: <filename>/this/directory/here</filename>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                            <command>
vardb::cd <replaceable>$handle directory-path</replaceable>                    
                            </command>
                        </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Sets the current working directory to
                        <parameter>directory-path</parameter> in the database
                        represented by <parameter>handle</parameter>.
                    </para>
                    <para>
                        Each database handle has an associated current working
                        directory.  When first opened, the current working directory
                        is the root directory; <literal>/</literal>.  The current
                        working directory is the starting point for relative paths.
                    </para>
                    <para>
                        Suppose, for example, that the current working directory
                        is <filename>/here/now</filename>.  The path:
                        <filename>../there/again</filename> refers to the
                        absolute path <filename>/here/there/again</filename>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                            <command>
set wd [vardb::getwd <replaceable>$handle</replaceable>]
                            </command>
                        </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        This command returns as its value the current working
                        directory for the database represented by the.
                        <parameter>handle</parameter>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                            <command>
vardb::ls <replaceable>$handle ?directory-path?</replaceable>
                            </command>
                        </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a list of the directories immediately below
                        the <parameter>directory-path</parameter> parameter
                        if provided or the current working directory if not.
                        The directories are in the database represented by
                        the <parameter>handle</parameter> parameter.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                            <command>
vardb::rmdir <replaceable>$handle directory-path</replaceable>
                            </command>
                        </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Removes the directory <parameter>directory-path</parameter>
                        in the variable database represented by <parameter>handle</parameter>
                        It is an error to remove a directory that is not empty.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        vardb::var <replaceable>subcommand $handle args...</replaceable>
                        </command>
                    </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Performs an operation on a variable.  In the discussion
                        below, relative paths are interpreted to be relative to
                        the current working directory established by the
                        most recent
                        <command>vardb::cd</command> command.
                    </para>
                    <para>
                        The operation
                        performed depends on the subcommand and arguments
                        that follow the <varname>handle</varname>:
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term><command>create <replaceable>handle path type ?value?</replaceable></command></term>
                            <listitem>
                                <para>
                                    Creates a new variable.
                                    <parameter>path</parameter> determines
                                    the path to the new variable.
                                    <parameter>type</parameter>
                                    is the type of the variable
                                    (e.g. <literal>string</literal>).
                                    <parameter>value</parameter> is the
                                    optional initial value of the variable.
                                    note that all types have a default value
                                    the variable is initialized to if
                                    <parameter>value</parameter>
                                    is not supplied.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>destroy <replaceable>handle path</replaceable></command></term>
                            <listitem>
                                <para>
                                    Destroys the variable specified by <parameter>path</parameter>
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>set <replaceable>handle path value</replaceable></command></term>
                            <listitem>
                                <para>
                                    Sets the variable described by
                                    <parameter>path</parameter> to a new
                                    <parameter>value</parameter>.  
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>get <replaceable>handle path</replaceable></command></term>
                            <listitem>
                                <para>
                                    Returns the value of the variable
                                    specified by
                                    <parameter>path</parameter>
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><command>ls <replaceable>handle ?path?</replaceable></command></term>
                            <listitem>
                                <para>
                                    Returns a list describing the variables that
                                    live in a directory.  If the
                                    <parameter>path</parameter> parameter is
                                    not provided, the current working directory
                                    is listed.  If <parameter>path</parameter>
                                    is provided and is a relative path, the variable's
                                    path is computed with the current working directory
                                    as a base. 
                                </para>
                                <para>
                                    The command returns a (possibly empty) list.
                                    Each element of the list is a 5 element sublist
                                    containing in order the variable's id,
                                    the variables name (excluding the directory path
                                    part of it), the variable's type,
                                    the id of the variable type
                                    and the id of the
                                    directory that contains the variable and the
                                </para>
                            </listitem>
                        </varlistentry>
                        
                    </variablelist>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
        vardb::enum <replaceable>$handle type-name list-of-values</replaceable>
                        </command>
                    </cmdsynopsis>

                </term>
                <listitem>
                    <para>
                        Creates a new data type <parameter>type-name</parameter>
                        that is an enumerated data type.
                        <parameter>list-of-values</parameter> is a Tcl list that
                        defines the set of legal values for variables created of
                        this new type.
                    </para>
                    <para>
                        Once <parameter>type-name</parameter> has been created
                        you can create variables of that type just like you
                        would
                        any other variable.   The first value of the
                        <parameter>list-of-values</parameter> will be the default
                        value for variables of thsi type.
                    </para>
                    <para>
                        For example:
                    </para>
                    <informalexample>
                        <programlisting>
vardb::enum $handle colors [list red white blue]
vardb::var create $handle /mycolor;            # /mycolor is red (default).
vardb::var create $handle /anothercolor blue;  # /anothercolor is blue.
vardb::var set $handle /mycolor grey;          # fails, grey is not a valid color.
vardb::var set $handle /mycolor white;         # /mycolor is now white.
                        </programlisting>
                    </informalexample>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <cmdsynopsis>
                        <command>
vardb::statemachine <replaceable>$handle type-name transition-dict</replaceable>
                        </command>
                    </cmdsynopsis>
            
                </term>
                <listitem>
                    <para>
                        Creates a new type <parameter>type-name</parameter>
                        that is a state machine.  The statemachine has a
                        transition map that is determined by its
                        <parameter>transition-dcit</parameter>.  The
                        <parameter>transition-dict</parameter> is a Tcl
                        dict object whose keys are valid states inthe state
                        machine and whose values are reachable states from
                        the key state.
                    </para>
                    <para>
                        Note that the alphabetically first state will be the
                        initial state for variables of this type.
                    </para>
                    <para>
                        For example,  If you want to produce a state machine
                        with the following transition table:
                    </para>
                    <informaltable frame='all'>
                        <tgroup cols='2' align='left' colsep='1' rowsep='1'>
                        <thead>
                            <row>
                                <entry>From State</entry>
                                <entry>To State</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>Not-Ready</entry><entry>Inactive</entry>
                            </row>
                            <row>
                                <entry>Inactive</entry><entry>Active</entry>
                            </row>
                            <row>
                                <entry>Inactive</entry><entry>Not-Ready</entry>
                            </row>
                            <row>
                                <entry>Active</entry><entry>Inactive</entry>
                            </row>
                            <row>
                                <entry>Active</entry><entry>Not-Ready</entry>
                            </row>
                        </tbody>
                    </tgroup>
                    </informaltable>
                <para>
                    You might use the following code.  Note that we name
                    the <literal>Not-Ready</literal> state to be
                    <literal>0Not-Ready</literal> to ensure it is the
                    initial state:
                </para>
                <informalexample>
                    <programlisting>
set runStates [dict create   0Not-Ready Inactive   \
    Inactive [list 0Not-Ready Active]              \
    Active   [list 0Not-Ready Inactive]]
    
    
vardb::statemachine runStateMachine $runStates

                    </programlisting>
                </informalexample>
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>

      </refentry>


<!-- /manpage -->

<!-- manpage 3python -->

<refentry id="python3_vardb">
  <refentryinfo>
    <author>
        <personname>
            <firstname>Ron</firstname>
            <surname>Fox</surname>
        </personname>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='python3_vardb_title'>vardb</refentrytitle>
     <manvolnum>3python</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>VarDb</refname>
     <refpurpose>
        Encapsulates the
        <link linkend='daq3_cvariabledb' endterm='daq3_cvariabledb_title' /> C++ class
     </refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <programlisting>

import nscldaq.vardb.vardb

<methodname>create</methodname>(<parameter>fileName</parameter>)

db = VarDb(<parameter>filename</parameter>)

   </programlisting>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        This module provides the ability to create and connect to variable
        databases for scripts written in Python.  Objects of the type
        <classname>VarDb</classname>, represent connections to variable databases.
        These objects are normally used to construct other variable database
        objects such as
        <link linkend='python3_dirtree' endterm='python3_dirtree_title' />.
     </para>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <variablelist>
        <varlistentry>
            <term>
                <methodname>create</methodname>(<parameter>fileName</parameter>)
            </term>
            <listitem>
                <para>
                    This is a module level method that creates a new empty
                    variable database in the file <parameter>fileName</parameter>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                db = VarDb(<parameter>fileName</parameter>) 
            </term>
            <listitem>
                <para>
                    Constructs a new database connection to the variable
                    database in <parameter>fileName</parameter>.  If
                    <parameter>fileName</parameter>  does not exist,
                    or is not a valid variable database, a
                    <classname>nscldaq.vardb.vardb.error</classname>
                    exception is raised with an error message that
                    explains why the creation failed.
                </para>
                <para>
                    The object resulting from this construction is used to construct
                    other variable database objects such as
                    <link linkend='python3_dirtree' endterm='python3_dirtree_title' />
                    but does not provide any actual useful public methods of its own.
                </para>
            </listitem>
        </varlistentry>
     </variablelist>
  </refsect1>
</refentry>     
<refentry id="python3_dirtree">
  <refentryinfo>
    <author>
        <personname>
            <firstname>Ron</firstname>
            <surname>Fox</surname>
        </personname>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='python3_dirtree_title'>dirtree</refentrytitle>
     <manvolnum>3python</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>DirTree</refname>
     <refpurpose>
        Python encpapsulation of
        <link linkend='daq3_cvardirtree' endterm='daq3_cvardirtree_title' />
     </refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <programlisting>
import nscldaq.vardb.dirtree
pathList = <methodname>parsePath</methodname>(<parameter>pathString</parameter>)
flag     = <methodname>isRelative</methodname>(<parameter>pathString</parameter>)
    </programlisting>

    <constructorsynopsis>
       <methodname>DirTree</methodname>
       <methodparam>
        <type>VarDb</type> <parameter>db</parameter>
       </methodparam>
    </constructorsynopsis>
    
    <methodsynopsis>
        
        <type>integer</type>
        <methodname>gerRootId</methodname>
        <void />
    </methodsynopsis>
    
    <methodsynopsis>
        
        <type></type>
        <methodname>mkdir</methodname>
        <methodparam>
            <type>string</type> <parameter>pathString</parameter>
        </methodparam>
    </methodsynopsis>
    
    <methodsynopsis>
        
        <type></type>
        <methodname>cd</methodname>
        <methodparam>
            <type>string</type> <parameter>pathString</parameter>
        </methodparam>
    </methodsynopsis>
    
    <methodsynopsis>
        
        <type>string</type>
        <methodname>wdPath</methodname>
        <void />
    </methodsynopsis>  
    
    <methodsynopsis>
        
        <type>dict</type>
        <methodname>getwd</methodname>
        <void />
    </methodsynopsis>
    
    <methodsynopsis>
        
        <type>tuple</type>
        <methodname>ls</methodname>
        <void />
    </methodsynopsis>  
    
    <methodsynopsis>
        
        <type></type>
        <methodname>rmdir</methodname>
        <methodparam>
            <type>string</type> <parameter>directoryPath</parameter>
        </methodparam>
    </methodsynopsis>  
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        This module performs directory and path manipulations on variable
        databasese.  Module level convenience methods provide the ability
        to break up a path into a tuple of path elements as well as to determine
        if the original path string is absolute or relative.
     </para>
     <para>
        The <classname>DirTree</classname> class can have object constructed on
        <classname>VarDb objects
        (see: </classname><link linkend='python3_vardb' endterm='python3_vardb' />).
        <classname>DirTree</classname> objects can then manipulate and traverse
        the variable database directory tree.
     </para>
     <para>
        Path strings are similar to unix directory specifications.  There is a root
        directory. All other directories are children (direct or indirect) of that
        root directory.  The path string describing a  directory is a set of
        path elements separated by the <literal>/</literal> character.
     </para>
     <para>
        <classname>DirTree</classname> objects have a
        <firstterm>current working directory</firstterm> that can be set using the
        <methodname>cd</methodname> method and queried using either
        <methodname>wdPath</methodname> or <methodname>getwd</methodname> depending
        on what information is required.
        Path strings that begin with a <literal>/</literal> character are said to be
        absolute.  They specify a path relative to the root directory.
        Path strings that do not begin with a <literal>/</literal> are said to be
        relative.  They specify a path relative to the object's current working
        directory.
     </para>
     <para>
        For example if the current working directory is <filename>/this/that</filename>
        the relative path <filename>the/other</filename> specifies the absolute path
        <filename>/this/that/the/other</filename>.  

     </para>
     <para>
        Path elements can also be
        <literal>..</literal> which specifies the parent of the path specified so far.
        For example, the absolute path <filename>/this/something/../that/the/other</filename>
        reduces to the path <filename>/this/that/the/other</filename>.  Similarly if the
        current working directory is
        <filename>/this/that/something</filename>, the relative path
        <filename>../the/other</filename> also specifies
        <filename>/this/that/the/other</filename>
     </para>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <para>
        All methods will report errors by raising a
        <classname>nscldaq.vardb.dirtree.error</classname> exception
        encapsulating a
        meaningful error message.
     </para>
     <variablelist>
        <varlistentry>
            <term>
                <methodname>parsePath</methodname>(<parameter>pathString</parameter>)
            </term>
            <listitem>
                <para>
                    This module level method breaks up a
                    <parameter>pathString</parameter> into a tuple of path elements.
                    The resulting tuple loses information about whether or not the
                    path is relative or absolute.  To determin that you must
                    invoke <methodname>isRelative</methodname> on the original
                    path string.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodname>isRelative</methodname>(<parameter>pathString</parameter>)
            </term>
            <listitem>
                <para>
                    This module level method returns a boolean that is
                    <literal>True</literal> if the <parameter>pathString</parameter>
                    specifies a relative path, <literal>False</literal> is
                    returned if this is not the case.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <constructorsynopsis>
                   <methodname>DirTree</methodname>
                   <methodparam>
                    <type>VarDb</type> <parameter>db</parameter>
                   </methodparam>
                </constructorsynopsis>
            </term>
            <listitem>
                <para>
                    Contructs a <classname>DirTree</classname>
                    object.  The <parameter>db</parameter>
                    parameter is a
                    <classname>VarDb</classname> object that represents
                    a connection to the variable database whose directory tree will
                    be manipulated by the <classname>DirTree</classname>
                    object.
                    See <link linkend='python3_vardb' endterm='python3_vardb_title' />
                    for more on <classname>VarDb</classname> objects.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    
                    <type>integer</type>
                    <methodname>gerRootId</methodname>
                    <void />
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns the primary key of the root directory. The directory
                    hierarchy is held in a database table in an SQLite database.
                    The primary key of a table element is a unique identifier of
                    a row in the table. For more about the database schema see
                    <link linkend='daq5_vardb' endterm='daq5_vardb' />
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    
                    <type></type>
                    <methodname>mkdir</methodname>
                    <methodparam>
                        <type>string</type> <parameter>pathString</parameter>
                    </methodparam>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Creates a new directory in the path specified by
                    <parameter>PathString</parameter>.  This method
                    returns <literal>None</literal>.  The
                    <parameter>pathString</parameter> can be either an
                    absolute or relative path.
                </para>
                <para>
                    If not all elements in the
                    path exist the missing ones will be created.  For example,
                    suppose the root directory is empty and the
                    <parameter>pathString</parameter> is
                    <filename>/this/that/the/other</filename>,
                    <methodname>mkdir</methodname> will create
                    <filename>/this</filename>,
                    <filename>/this/that</filename>,
                    <filename>/this/that/the</filename> and
                    <filename>/this/that/the/other</filename>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    
                    <type></type>
                    <methodname>cd</methodname>
                    <methodparam>
                        <type>string</type> <parameter>pathString</parameter>
                    </methodparam>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Sets the current working directory to the absolute
                    or relative path specified by
                    <parameter>pathString</parameter>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    
                    <type>string</type>
                    <methodname>wdPath</methodname>
                    <void />
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns <type>string</type> that is the
                    absolute path specification of the
                    current working directory.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    
                    <type>dict</type>
                    <methodname>getwd</methodname>
                    <void />
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns a <type>dict</type> that describes
                    the current working directory.  The dict
                    has the following keys:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>name</literal> (<type>string</type></term>
                        <listitem>
                            <para>
                                Contains the bottom path element of the
                                directory.  For example for the directory
                                <filename>/this/that/the/other</filename>
                                this will be <literal>other</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>id</literal> (<type>integer</type></term>
                        <listitem>
                            <para>
                                Contains the primary key of the directory in its
                                SQLite table.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>parent</literal> (<type>integer</type></term>
                        <listitem>
                            <para>
                                Contains the primary key of the parent directory.
                                This field is how the directory hierarchy is
                                maintained.  For the root directory, this field
                                will be <literal>-1</literal> indicating there is
                                no parent.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    
                    <type>tuple</type>
                    <methodname>ls</methodname>
                    <void />
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns a tuple containing the last path element of all
                    subdirectories to the current working directory.
                    The tuple is sorted alphabetically.
                </para>
                <para>
                    For example suppose the directories
                    <filename>/three/stooges/larry</filename>,
                    <filename>/three/stopges/curly</filename> and 
                    <filename>/three/stooges/moe</filename> exist
                    (yes trivia fans I know there was once a stooge named <literal>shemp</literal>).
                    have been created.
                    If the current working directory is
                    <filename>/three/stooges</filename>,
                    <methodname>ls</methodname> will return
                    <literal>('curly', 'larry', 'moe')</literal>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    
                    <type></type>
                    <methodname>rmdir</methodname>
                    <methodparam>
                        <type>string</type> <parameter>directoryPath</parameter>
                    </methodparam>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Removes the directory specified by the absolute or relative
                    <parameter>directoryPath</parameter>.
                    <methodname>rmdir</methodname> raises an error if you attempt
                    to remove a non-empty directory.
                </para>
            </listitem>
        </varlistentry>
     </variablelist>
  </refsect1>
</refentry>

<refentry id="python3_variable">
  <refentryinfo>
    <author>
        <personname>
            <firstname>Ron</firstname>
            <surname>Fox</surname>
        </personname>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='python3_variable_title'>variable</refentrytitle>
     <manvolnum>3python</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>variable</refname>
     <refpurpose>Encapsulate variable database variables.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <synopsis>
import nscldaq.vardb.vardb
import nscldaq.vardb.dirtree
import nscldaq.vardb.variable

nscldaq.vardb.variable.create(vardb, dir_or_none, path, type[, initial])
info = nscldaq.vardb.variable.ls(db, dir[, path])
nscldaq.vardb.variable.destroy(db, id)
nscldaq.vardb.variable.destroy(db, dir_or_none, path)

   
      <constructorsynopsis>
        <methodname>nscldaq.vardb.variable.Variable</methodname>
        <methodparam>
            <type></type>
                <parameter>db</parameter>
        </methodparam>
        <methodparam>
            <type></type>
                <parameter>keywords...</parameter>
        </methodparam>
        
        <exceptionname>nscldaq.vardb.variable.error</exceptionname>
      </constructorsynopsis>
      <methodsynopsis>
          
          <type>integer</type>
          <methodname>getId</methodname>
          
            <void />
          
          
      </methodsynopsis>
      <methodsynopsis>
          
          <type></type>
          <methodname>set</methodname>
          <methodparam>
            <type>string</type> <parameter>value</parameter>
          </methodparam>
          <exceptionname>nscldaq.vardb.variable.error</exceptionname>
          
      </methodsynopsis>
      <methodsynopsis>
          
          <type>string</type>
          <methodname>get</methodname>
          <void />
          
      </methodsynopsis>
      <methodsynopsis>
          
          <type>string</type>
          <methodname>getName</methodname>
          <void />
          
          
      </methodsynopsis>
      <methodsynopsis>
          
          <type>string</type>
          <methodname>getDirectory</methodname>
          <void />
          
      </methodsynopsis>
      
      
   </synopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        Encapsulates operations on variables themselves.  The purpose of the
        variable database is to store variables, their properties and their
        values.  A variable lives in a directory, has a strong type and a value.
     </para>
     <para>
        The methods in this module allow you to create, delete and get information
        about variables.  You can also wrap a variable in an object.  Once
        wrapped you can set and get the value of that variable.
     </para>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <variablelist>
        <varlistentry>
            <term>
                nscldaq.vardb.variable.create(vardb, dir_or_none, path, type[, initial])
            </term>
            <listitem>
                <para>
                    Creates a new variable. <parameter>vardb</parameter>
                    must be a <classname>nscldaq.vardb.VarDb</classname>
                    object and specifies which database the object is created in.
                    
                </para>
                <para>
                    <parameter>dir_or_none</parameter>, together with
                    <parameter>path</parameter> determine both the directory
                    and name of the variable that will be created in that
                    directory.
                    If <parameter>path</parameter> is relative,
                    and <parameter>dir_or_none</parameter> is a valid
                    <classname>nscldaq.vardb.directory.VarDirTree</classname>
                    object, it's working directory sets tha base relative
                    to which the path is computed.
                    If <parameter>dir_or_none</parameter> is
                    <literal>None</literal>, or <parameter>path</parameter>
                    is absolute, the path is computed relative to the
                    root directory.
                </para>
                <para>
                    <parameter>type</parameter> specifies the variable
                    type e.g. <literal>'integer'</literal>.
                </para>
                <para>
                    If the parameter <parameter>initial</parameter>
                    is provided it is used to set the variables initial value.
                    If it is not provided, the type's default value is used to
                    initialize the variable.  Note that variables always have
                    a well defined value.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                info = nscldaq.vardb.variable.ls(db, dir[, path])
            </term>
            <listitem>
                <para>
                    Returns a list of dicts that describe the variables
                    in a directory.  <parameter>db</parameter> is
                    a <classname>nscldaq.vardb.vardb.VarDb</classname>
                    object that determines which database is interrogated.
                </para>
                <para>
                    The directory path interrogated is determineed by
                    a combination of the <parameter>dir</parameter>
                    and, if provided the <parameter>path</parameter>
                    arguments.  <parameter>dir</parameter> is a
                    <classname>nscldaq.vardb.directory.VarDirTree</classname>
                    object.  If <parameter>path</parameter> is not provided,
                    its current working directory is listed.
                    if <parameter>path</parameter> is provided and is
                    relative, the path to interrogate is computed relative
                    to <parameter>dir</parameter>'s current working directory.
                    If <parameter>path</parameter> is absolute, the
                    <parameter>dir</parameter> parameter is ignored.
                </para>
                <para>
                    The return value is a list of dicts.  Each dict
                    containst the following keys:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>id</literal></term>
                        <listitem>
                            <para>
                                The id of the variable.
                            </para>
                        </listitem>
                    </varlistentry>
                   <varlistentry>
                       <term><literal>name</literal></term>
                       <listitem>
                           <para>
                                The name of the variable exclusive of its
                                path.
                           </para>
                       </listitem>
                   </varlistentry>
                    <varlistentry>
                        <term><literal>type</literal></term>
                        <listitem>
                            <para>
                                The type string of the variable.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>typeId</literal></term>
                        <listitem>
                            <para>
                                The id of the type of the variable.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>dirId</literal></term>
                        <listitem>
                            <para>
                                The id of the directory the variable
                                lives in.
                            </para>
                        </listitem>
                    </varlistentry>
                    
                </variablelist>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                nscldaq.vardb.variable.destroy(db, id)
            </term>
            <listitem>
                <para>
                    Destroys the variable in the database
                    determined by <parameter>db</parameter>
                    with the specified <parameter>id</parameter>
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>nscldaq.vardb.variable.destroy(db, dir_or_none, path)</term>
            <listitem>
                <para>
                    Destroys the variable in the database
                    <parameter>db</parameter> whos path is determined
                    by the combination of <parameter>dir_or_none</parameter>
                    and <parameter>path</parameter>
                </para>
                <para>
                    The <methodname>create</methodname> module method
                    describes how <parameter>dir_or_none</parameter>
                    and <parameter>path</parameter> combine to
                    produce a variable name path.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <constructorsynopsis>
                   <methodname>nscldaq.vardb.variable.Variable</methodname>
                   <methodparam>
                       <type></type>
                           <parameter>db</parameter>
                   </methodparam>
                   <methodparam>
                       <type></type>
                           <parameter>keywords...</parameter>
                   </methodparam>
                   
                   <exceptionname>nscldaq.vardb.variable.error</exceptionname>
                 </constructorsynopsis>
            
            </term>
            <listitem>
                <para>
                    Returns an instance of a <classname>Variable</classname>
                    object that wraps a variable in the variable database.
                </para>
                <para>
                    <parameter>db</parameter> selects the variable database.
                    The remaining parameters are keyword/value parameters.
                    The following keywords are defined:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>dir</literal></term>
                        <listitem>
                            <para>
                                Value is a <classname>VarDirTree</classname>
                                object that, together with a
                                <literal>path</literal> determines which variable
                                to wrap.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>path</literal></term>
                        <listitem>
                            <para>
                                Along with an optional dir determines the
                                variable to wrap.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>id</literal></term>
                        <listitem>
                            <para>
                                Value is the id of the variable to wrap.
                            </para>
                        </listitem>
                    </varlistentry>
                    
                </variablelist>
                <para>
                    There are constraints on which keywords can be provided:
                </para>
                <itemizedlist>
                    <listitem><para>
                        There must be either an <literal>id</literal> or a
                        <literal>path</literal> parmaeter but not both.
                    </para></listitem>
                    <listitem><para>
                        There cannot be both a <literal>dir</literal> and an
                        <literal>id</literal>
                    </para></listitem>
                </itemizedlist>
                <para>
                    Given these constraints.  If <literal>id</literal> is provided
                    that is the id of the variable to wrap.  if, a
                    <literal>path</literal> is provided, and is absolute, that
                    determines the variable to wrap.  If <literal>path</literal>
                    is relative and <literal>dir</literal> is provided the
                    absolute path of the variable to wrap is determined relative
                    to <literal>dir</literal>'s current working directory.
                    If <literal>path</literal> is relative and
                    <literal>dir</literal> is not supplied the final path
                    to wrap is computed relative to the root directory.
                </para>
                <para>
                    If <literal>path</literal> is supplied, the last path element
                    is the variable name and all prior path elements specify
                    the directory, for example:
                    <literal>/this/is/a/variable</literal> is a variable
                    named <literal>variable</literal> that is in the
                    directory <literal>/this/is/a</literal>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    
                    <type>integer</type>
                    <methodname>getId</methodname>
                   
                      <void />
                   
                    
                </methodsynopsis>

            </term>
            <listitem>
                <para>
                    Returns the id of the variable wrapped by the object.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    
                    <type></type>
                    <methodname>set</methodname>
                    <methodparam>
                      <type>string</type> <parameter>value</parameter>
                    </methodparam>
                    <exceptionname>nscldaq.vardb.variable.error</exceptionname>
                    
                </methodsynopsis>

            </term>
            <listitem>
                <para>
                    Sets a new <parameter>value</parameter> for the variable.
                    <classname>nscldaq.vardb.variable.error</classname> is
                    raised if <parameter>value</parameter> is not legal
                    for the variable's type or constraints.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                      
                      <type>string</type>
                      <methodname>get</methodname>
                      <void />
                      
                  </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns the variables current value.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    
                    <type>string</type>
                    <methodname>getName</methodname>
                    <void />
                    
                    
                </methodsynopsis>
                
            </term>
            <listitem>
                <para>
                    Returns the name of the variable
                    (exclusive of the directory path).
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    
                    <type>string</type>
                    <methodname>getDirectory</methodname>
                    <void />
                    
                </methodsynopsis>                
            </term>
            <listitem>
                <para>
                    Returns the directory path in which the
                    variable lives.
                </para>
            </listitem>
        </varlistentry>
        
     </variablelist>
  </refsect1>
</refentry>


<refentry id="python3_enum">
  <refentryinfo>
    <author>
        <personname>
            <firstname>Ron</firstname>
            <surname>Fox</surname>
        </personname>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='python3_enum_title'>enum</refentrytitle>
     <manvolnum>3python</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>enum</refname>
     <refpurpose>Python bindings to enum types (variable database)</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <synopsis>
import nscldaq.vardb.vardb
import nscldaq.vardb.enum

nscldaq.vardb.enum.create(db, typeName, values)
id = nscldaq.vardb.enum.id(db, typeName)
valueSet = nscldaq.vardb.enum.listValues(db, typeName)
typeSet  = nscldaq.vardb.enum.listEnums(db)

try:
    # nscldaq.vardb.enum operations here
except nscldaq.vardb.enum.error as error:
    # Process errors from enum.

   </synopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        This module contains module level methods for enumerated data types.
        An enumerated data type is a data type that can only have one of a
        discrete set of values.  Enumerated data types constitute a family of
        datatypes.  This module allows you to create and query the attributes
        of instances of that family.
     </para>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <variablelist>
        <varlistentry>
            <term>
                nscldaq.vardb.enum.create(db, typeName, values)
            </term>
            <listitem>
                <para>
                    Creates a new variable data type.  <parameter>db</parameter>
                    is a variable database instance that was opened on the database
                    in which the type will be created. <parameter>typeName</parameter>
                    is the name of the type being created.  <parameter>values</parameter>
                    is an iterable object that contains the legal values for the type.
                </para>
                <para>
                    Once the type has been successfully created, you can create
                    variables of that type just like any other data type.
                    Errors are signalled by raising an
                    <classname>nscldaq.vardb.enum.error</classname> exception.
                </para>
                <para>
                    It is an error for <parameter>typeName</parameter> to name
                    a data type that already exists. It is an error
                    for <parameter>values</parameter> to be an empty object
                    or to contain duplicate elements.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                id = nscldaq.vardb.enum.id(db, typeName)
            </term>
            <listitem>
                <para>
                    Returns the id of the enumerated type
                    <parameter>typeName</parameter>.  <parameter>db</parameter>
                    is the database object that determines which database file
                    we are querying.
                </para>
                <para>
                    The id returned is the primary key of the data type
                    <parameter>typeName</parameter> in the
                    <literal>variable_types</literal> table.
                </para>
                <para>
                    Errors are signalled by raising a
                    <classname>nscldaq.vardb.enum.error</classname> exception.
                    It is an error for the <parameter>typeName</parameter>
                    to either not exist or to exist but not be an enum type.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>valueSet = nscldaq.vardb.enum.listValues(db, typeName)</term>
            <listitem>
                <para>
                    Returns a set that contains the values an enumerated type can
                    take.  <parameter>db</parameter> is the database being queried.
                    <parameter>typeName</parameter> is the name of the type.
                </para>
                <para>
                    Errors are signalled by raising a
                    <classname>nscldaq.vardb.enum.error</classname> exception.
                    It is an error for <parameter>typeName</parameter> to either
                    not exist or to not be an enumerated type.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>typeSet  = nscldaq.vardb.enum.listEnums(db)       </term>
            <listitem>
                <para>
                    Returns a set that contains the names of all enumerated data
                    types.  The <parameter>db</parameter> parameter is the
                    database queried.
                </para>
            </listitem>
        </varlistentry>
     </variablelist>
  </refsect1>
</refentry>
<refentry id="python3_statemachine">
  <refentryinfo>
    <author>
        <personname>
            <firstname>Ron</firstname>
            <surname>Fox</surname>
        </personname>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='python3_statemachine_title'>nscldaq.vardb.statemachine</refentrytitle>
     <manvolnum>3python</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>nscldaq.vardb.statemachine</refname>
     <refpurpose>Python wrappers for manipulating state machines</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <synopsis>
import nscldaq.vardb.vardb
import nscldaq.vardb.statemachine

typeId         = nscldaq.vardb.statemachine.create(db, typeName, transitionDict)
isSm           = nscldaq.vardb.statemachine.isStateMachine(db, typeId)
nextStates     = nscldaq.vardb.statemachine.validNextStates(db, typeId, currentState)
nextStates     = nscldaq.vardb.statemachine.validNextStates(db, varId)
transitionDict = nscldaq.vardb.statemachine.getTransitionMap(db, typeId)


   </synopsis>
  </refsynopsisdiv>
  <refsect1 id='python3_statemachine_description'>
     <title id='python3_statemachine_description_title'>DESCRIPTION</title>
     <para>
        This module is a wrapper for the class
        <link linkend='daq3_cstatemachine' endterm='daq3_cstatemachine_title' />.
        It provides module level methods for creating and interrogating state
        machies.
     </para>
     <para>
        A state machine can be thought of as an enumerated type with
        constraints that determine which enum values are valid given
        the current value of the machine.  The constraints are
        expressed as a set of <firstterm>reachable states</firstterm>
        from each allowed state.  A state with no reachable states is
        called a <firstterm>terminal state</firstterm>.
        Each state machine also has an
        <firstterm>initial state</firstterm>, which is the only allowed value
        a state machine variable can have when it is created.  The initial state
        is the alphabetically smallest state name.  Thus it is common to
        prefix the initial state with e.g. <literal>0</literal>.
     </para>
     <para>
        In the python bindings to <classname>CStateMachine</classname>,
        the state machine states and transitions are represented by a python
        dict.  Keys in the dict represent valid states while values, which are
        iterables, represent reachable states from the key state.
        It is perhaps simplest to give a small example that shows how to
        define a state machine that represents a simplified run state diagram:
     </para>
     <para>
        First lets look at a tabular representation of the state diagram:
     </para>
     <informaltable frame='all'>
        <tgroup cols='2' align='left' colsep='1' rowsep='1'>
            <thead>
                <row>
                    <entry>From State</entry>
                    <entry>To State</entry>
                </row>
            </thead>
            <tbody>
                <row>
                    <entry>Not-Ready</entry><entry>Inactive</entry>
                </row>
                <row>
                    <entry>Inactive</entry><entry>Active</entry>
                </row>
                <row>
                    <entry>Inactive</entry><entry>Not-Ready</entry>
                </row>
                <row>
                    <entry>Active</entry><entry>Inactive</entry>
                </row>
                <row>
                    <entry>Active</entry><entry>Not-Ready</entry>
                </row>
            </tbody>
        </tgroup>
     </informaltable>
     <para>
        We want the initial state to be <literal>Not-Ready</literal>
        from the <literal>Not-Ready</literal> state as programs
        needed to take data are started, we transition to the
        <literal>Inactive</literal> state.  From there
        we can transition back and for to <literal>Active</literal>
        as runs are started and stopped.  Failures will transition
        back to the <literal>Not-Ready</literal> state.
     </para>
     <informalexample>
        <programlisting>
            ...
transitions = {'0Not-Ready' : ('Inactive',)
   'Inactive' : ('Active', '0Not-Ready'),
   'Active'   : ('Inactive', '0Not-Ready')}
   
smId = nscldaq.vardb.statemachine.create(db, runStateMachine, transitions)
...
        </programlisting>
     </informalexample>
     <para>
        First note that we ensure that the <literal>Not-Ready</literal> state
        is initial by naming it <literal>0Not-Ready</literal>.
        Second note that if we only have one reachable state we need to
        add a trailing comma in the list to ensure that Python interprets
        that as a list and not just a string in a parenthesized expression.
        Using <literal>...'0Not-Ready': ('Inactive'),...</literal> would
        be interpreted as a the state <literal>'0Not-Ready</literal> with
        reachable states <literal>I,n,a,c,t,i,v</literal> and <literal>e</literal>
        because strings are iterable in Python.
     </para>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <variablelist>
        <varlistentry>
            <term>
                <cmdsynopsis>
                    <command>
typeId         = nscldaq.vardb.statemachine.create(db, typeName, transitionDict)
                    </command>
                </cmdsynopsis>
                
            </term>
            <listitem>
                <para>
                    Creates a new state machine type named
                    <parameter>typeName</parameter> in the database whose handle
                    is <parameter>db</parameter>.  The
                    <parameter>transitionDict</parameter> is a python dict
                    that defines the legal states and transitions.  See
                    <link linkend='python3_statemachine_description'
                          endterm='python3_statemachine_description_title' />
                    for information on how to describe state machines.
                </para>
                <para>
                    The value returned is the id of the type in the
                    variable types table.  It can be used to refer to this
                    data type in other methods in this module.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <cmdsynopsis>
                    <command>
isSm           = nscldaq.vardb.statemachine.isStateMachine(db, typeId)
                    </command>
                </cmdsynopsis>
                
            </term>
            <listitem>
                <para>
                    Returns <literal>True</literal> if
                    <parameter>typeId</parameter> is the type id for a state
                    machine data type in the database <parameter>db</parameter>.
                    If <parameter>typeId</parameter> is a type but not
                    a statemachine, the method returns <literal>False</literal>.
                    If <parameter>typeId</parameter> is not a valid data type a
                    <classname>nscldaq.vardb.statemachine.error</classname>
                    is raised.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <cmdsynopsis>
                    <command>
nextStates     = nscldaq.vardb.statemachine.validNextStates(db, typeId, currentState)
                    </command>
                </cmdsynopsis>
                
            </term>
            <listitem>
                <para>
                    Given a database connectino; <parameter>db</parameter>,
                    a state machine <parameter>typeId</parameter>, and
                    a <parameter>currentState</parameter>, this method
                    returns a tuple that contains the states reachable from
                    <parameter>currentState</parameter>
                </para>
                <para>
                    If <parameter>typeId</parameter> is not a statemachine
                    or not a valid type id,
                    <classname>nscldaq.vardb.statemachine.error</classname>
                    is raised.  If <parameter>currentState</parameter>
                    is not a valid state for the state machine;
                    <classname>nscldaq.vardb.statemachine.error</classname>
                    is raised.  if <parameter>currentState</parameter> has
                    no reachable states, is also thrown.
                    <classname>nscldaq.vardb.statemachine.error</classname>.
                    This is also the case for a <parameter>currentState</parameter>
                    that is not a valid state.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <cmdsynopsis>
                    <command>
nextStates     = nscldaq.vardb.statemachine.validNextStates(db, varId)                                        
                    </command>
                </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Returns a tuple containing the valid next values
                    the variable with the id <parameter>varId</parameter>
                    can take in the database <parameter>db</parameter>.
                    Raises a <classname>nscldaq.vardb.statemachine.error</classname>
                    if the variable is not a state machine.
                    Raises a <classname>nscldaq.vardb.variable.error</classname>
                    if <parameter>varId</parameter> is not the id of a variable.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <cmdsynopsis>
                    <command>
transitionDict = nscldaq.vardb.statemachine.getTransitionMap(db, typeId)        
                    </command>
                </cmdsynopsis>
                
            </term>
            <listitem>
                <para>
                    Returns a dict that describes the states and transitions
                    that are legal for the statemachine whose type id
                    is <parameter>typeId</parameter> in the database
                    connected to <parameter>db</parameter>.
                    The resulting dict has the same structure as the
                    dict used in
                    <methodname>nscldaq.vardb.statemachine.create</methodname>.
                    If <parameter>typeId</parameter> is not a statemachine or
                    not a valid type id,
                    <classname>nscldaq.vardb.statemachine.error</classname> is
                    raised.
                </para>
            </listitem>
        </varlistentry>
        
     </variablelist>
  </refsect1>
</refentry>     
<!-- /manpage -->
<!-- manpage 5daq -->

<refentry id="daq5_vardb">
  <refentryinfo>
    <author>
            <personname>
                    <firstname>Ron</firstname>
                    <surname>Fox</surname>
            </personname>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='daq5_vardb_title'>Variable Database Schema</refentrytitle>
     <manvolnum>5daq</manvolnum>
     <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>Variable Database Schema</refname>
     <refpurpose>Variable Database Schema</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <programlisting>

-- Directory tree:

CREATE TABLE directory (
   id     INTEGER PRIMARY KEY NOT NULL,
   name   VARCHAR(256) NOT NULL,
   parent INTEGER DEFAULT NULL
);
INSERT INTO directory (name) VALUES("");        -- Create the root directory

-- Primitive data types:

CREATE TABLE variable_types (
   id    INTEGER PRIMARY KEY NOT NULL,
   type_name VARCHAR(256) NOT NULL
);
-- Define the standard primitive data types:

INSERT INTO variable_types (typename) VALUES ('integer');
INSERT INTO variable_types (typename) VALUES ('real');
INSERT INTO variable_types (typename) VALUES ('string');

-- Holds the variables.

CREATE TABLE variables (
    id                  INTEGER PRIMARY KEY NOT NULL,
    name                VARCHAR(256) NOT NULL,
    directory_id        INTEGER NOT NULL,           -- fk into directory
    type_id             INTEGER NOT NULL,           -- fk into variable_types
    value               VARCHAR(256)  NOT NULL      -- String representation of the data.
);

-- Values of enumerated types:

CREATE TABLE enumerated_values (                       
    id                INTEGER PRIMARY KEY NOT NULL,     
    type_id           INTEGER NOT NULL,            -- fk into variable_types      
    value             VARCHAR(256) NOT NULL        -- legal enum type.
);

-- State machines are enumerated typs with constraints on allowed transitions:

CREATE TABLE state_transitions (
    id          INTEGER PRIMARY KEY NOT NULL, 
    current_id  INTEGER NOT NULL,                 -- FK into enumerated_values: current state
    next_id     INTEGER NOT NULL                  -- FK into enumerated_values: an allowed next state.
);
    </programlisting>

  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        The variable database is an SQLite database.  This manpage
        describes each table and its relationship to other tables.
     </para>
     <refsect2>
        <title>The <literal>directory</literal> table</title>
        <para>
            The <literal>directory</literal> table contains the
            director hierarchy.  A directory can be thought of as
            a container.  Directories can contain other directories
            (sub directories) and <firstterm>variables</firstterm>.
        </para>
        <para>
            The fields in the directory table are:
        </para>
        <variablelist>
            <varlistentry>
                <term><literal>id     INTEGER PRIMARY KEY NOT NULL</literal></term>
                <listitem>
                    <para>
                        The primary key is a unique integer that is used
                        to refer to a directory.  With one exception
                        that we will describe below, <structfield>id</structfield>
                        values are assigned automatically by the
                        SQLite database when a new row is created.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>name   VARCHAR(256) NOT NULL,</literal></term>
                <listitem>
                    <para>
                        The name of the directory.  Given a directory path,
                        this will be the last element in that path.  For
                        example for <filename>/this/that/the/other</filename>
                        <structfield>name</structfield> will contain
                        <literal>other</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>parent INTEGER DEFAULT NULL</literal></term>
                <listitem>
                    <para>
                        This is the primary key (<structfield>id</structfield>)
                        of the directory that is the parent to this directory.
                        All directories except the root directory have parents.
                    </para>
                </listitem>
            </varlistentry>
            
        </variablelist>
        <para>
            When the <literal>directory</literal> table is created a special
            entry called the <firstterm>root directory</firstterm> is created:
            <literal>INSERT INTO directory (name) VALUES("")</literal>.
            The root directory is special because not only is its name the empty
            string but it's <structfield>parent</structfield> field is
            <literal>null</literal>.
        </para>
        <para>
            The database API and, hence its language bindings prevent the
            destruction of the root directory.  The path specification of the
            root directory is just <literal>/</literal>
        </para>
     </refsect2>
     <refsect2>
        <title>Primitive Data types</title>
        <para>
            Primitive data types are those that have a simple checker that can
            determine if a value is valid (compared for example with an
            <type>enum</type> which requires a list of values for each enum).
        </para>
        <para>
            The known data types are defined in the table
            <literal>variable_types</literal>, which is pre-stocked with the
            primitive data types.  This table has the fields:
        </para>
        <variablelist>
            <varlistentry>
                <term><literal>id    INTEGER PRIMARY KEY NOT NULL</literal></term>
                <listitem>
                    <para>
                        The primary key for the table entries.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>type_name VARCHAR(256) NOT NULL</literal></term>
                <listitem>
                    <para>
                        The name of the type.
                    </para>
                </listitem>
            </varlistentry>
            
        </variablelist>
        <para>
            The currently defined primitive data types are:
            <literal>integer</literal>, <literal>real</literal>,
            and <literal>string</literal>, whose meaning should
            be pretty obvious.
        </para>
     </refsect2>
     <refsect2>
        <title>Variables</title>
        <para>
            Variables are data containers.  All data that can be stored is
            assumed to have a string representation.   The value of each variable
            is therefore stored as a string.
        </para>
        <para>
            Variables are stored in the <literal>variables</literal> table which
            has the following fields:
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <literal>id                  INTEGER PRIMARY KEY NOT NULL</literal>
                </term>
                <listitem>
                    <para>
                        The primary key, used to unambiguously identify a variable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <literal>name                VARCHAR(256) NOT NULL</literal>
                </term>
                <listitem>
                    <para>
                        The name of the variable (this is the last path element
                        of the path used to create the variable).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <literal>directory_id        INTEGER NOT NULL</literal>
                </term>
                <listitem>
                    <para>
                        Foreign key into the <literal>directory</literal> table.
                        This value is the primary key in <literal>directory</literal>
                        of the directory in which the variable is defined.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <literal>type_id             INTEGER NOT NULL</literal>
                </term>
                <listitem>
                    <para>
                        Foreign key into the <literal>variable_types</literal>
                        table.  This value is a primary key in the
                        <literal>variable_types</literal> table that determines
                        the data type of the variable.
                    </para>
                </listitem>
            </varlistentry>
            
        </variablelist>
     </refsect2>
     <refsect2>
        <title>enumerated_values</title>
        <para>
            This table is used to supported the enumeration data type family.
            Enumerated data types are defined types that can take only one of
            a discrete set of values.  The default value of an instance of
            an enumerated type is the one with the smallest primary key in the
            <literal>enumerated_values</literal> table.
        </para>
        <para>
            The <literal>enumerated_values</literal> table has the folowing
            fields:
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <literal>id                INTEGER PRIMARY KEY NOT NULL</literal>
                </term>
                <listitem>
                    <para>
                        The primary key of the record.  This is unique and normally
                        assigned by SQLite.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <literal>type_id           INTEGER NOT NULL</literal>
                </term>
                <listitem>
                    <para>
                        This is a foreign key into the <literal>variable_types</literal>
                        table.  The entry in <literal>variable_types</literal>
                        that has this as its primary key is the data type for
                        which this record is a legal value.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <literal>value             VARCHAR(256) NOT NULL</literal>
                </term>
                <listitem>
                    <para>
                        An allowed value for the enumerated type.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
        <para>
            Here are some illustrative queries:
        </para>
        <informalexample>
            <programlisting>
-- A type is an enum if the result is nonzero:

SELECT COUNT(*) FROM variable_types t
   INNER JOIN enumerated_values e ON e.type_id = t.id;
   
-- Get the list of legal values for a type known to be an enumeration:

SELECT e.value FROM enumerated_values e
   INNER JOIN variable_types t ON t.id = e.type_id
   WHERE t.type_name='colors';
   
-- 1 if a specified value is legal for an enum:

SELECT COUNT(*) FROM enumerated_values e
  INNER JOIN variable_types t on t.id = e.type_id
  WHERE t.type_name = 'colors'
  AND   e.value = 'red';
  
-- Find the default value for a type known to be an enumeration:

SELECT e.value FROM enumerated_values e
   INNER JOIN variable_types t on t.id = e.type_id
   WHERE t.type_name = 'colors'
   ORDER BY e.id
   LIMIT 1;
   
 -- List the names of all enumerated types:
 
 SELECT DISTINCT t.type_name FROM variable_types t
    INNER JOIN enumerated_values e ON e.type_id = t.id;
    
            </programlisting>
        </informalexample>
     </refsect2>
     <refsect2>
        <title>state_transtions</title>
        <para>
            This table supports state machine data types by defining
            the valid transitions a state machine variable can take.
            State machines can be thought of as a subclass of enumerated
            types and therefore, state machines use the
            <literal>enumerated_values</literal> table to store the
            state names.  The values in those tables point back into
            <literal>variable_types</literal> to indicate the
            data type they are used in.
        </para>
        <para>
            The fields of the <literal>enumerated_values</literal>
            table are:
        </para>
        <variablelist>
            <varlistentry>
                <term>
                    <literal>id          INTEGER PRIMARY KEY NOT NULL</literal>
                </term>
                <listitem>
                    <para>
                        The primary key of the record in this table.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <literal>current_id  INTEGER NOT NULL</literal>
                </term>
                <listitem>
                    <para>
                        The id of a record in the
                        <literal>enumerated_values</literal> table that
                        represents an originating (current state).
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <literal>next_id     INTEGER NOT NULL</literal>
                </term>
                <listitem>
                    <para>
                        The id of a record in the
                        <literal>enumerated_values</literal> table that
                        represents a state reachable from the state
                        indicated by <literal>current_id</literal>.
                    </para>
                </listitem>
            </varlistentry>
            
        </variablelist>
        <para>
            You can think of <literal>state_transitions</literal> as a join table
            but it's a bit peculiar in that it joins
            <literal>enumerated_values</literal> to itself forming a join
            between a state and a state that can be legally reached from that
            state.
        </para>
        <example>
            <title>Determining if a new state is legal for a variable</title>
            <programlisting>
 SELECT COUNT(*) FROM state_transitions t   
            INNER JOIN enumerated_values vf ON vf.id = t.current_id     
            INNER JOIN enumerated_values vt ON vt.id = t.next_id        
            INNER JOIN variable_types    types ON types.id = vt.type_id 
            INNER JOIN variables         v     ON v.type_id = types.id  
            WHERE v.id = :varid                                              
            AND   vt.value = :nextvalue                                         
            AND   vf.value = v.value               
            </programlisting>
        </example>
        <para>
            In the example above, <literal>:varid</literal> is a place holder
            for the variable's id (primary key in the
            <literal>variables</literal> table)m, and
            <literal>:nextvalue</literal> is a placeholder for the
            string that is the value we are testing for legality.
        </para>
        <para>
            The query will have one result item with a single field that
            will be <literal>1</literal> if the next value is legal
            and <literal>0</literal> if not.
        </para>
     </refsect2>
  </refsect1>

</refentry>


<!-- /manpage -->