#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec @prefix@/bin/inittcl "$0" ${1+"$@"}

#    This software is Copyright by the Board of Trustees of Michigan
#    State University (c) Copyright 2014.
#
#    You may use this software under the terms of the GNU public license
#    (GPL).  The terms of this license are described at:
#
#     http://www.gnu.org/licenses/gpl.txt
#
#    Authors:
#             Ron Fox
#             Jeromy Tompkins 
#	     NSCL
#	     Michigan State University
#	     East Lansing, MI 48824-1321



##
# @file vardbsh.tcl
# @brief variable data base shell.
# @author Ron Fox <fox@nscl.msu.edu>
#

##
# usage:
#   vardbsh  db-uri
#   *   if db-uri is a file: uri and the file does not exist, user is prompted
#       to create a new one or exit.
#   *   if db-uri is a file: uri andis not a variable database, program
#       exits with message.
#
#   Prompts are handled as follows:
#   * Initial command prompt is ([file tail])[pwd]
#   * Continuation prompt is '_'
#
lappend auto_path [file join  [file dirname [info script]] .. TclLibs]

package require varmgr

namespace eval vardbsh {
    set varDbFile ""
    set varDbHandle ""
    set prompt1     ""
}

##
# prompt1
#   This proc returns the command prompt for the start of a command.
#
proc prompt1 {} { 
    set suffix [::varmgr::getwd $::vardbsh::varDbHandle]
    
    return "($::varmgr::prompt1): $suffix "

}

##
# prompt2
#   This proc returns the command prompt for command continuations.
#
proc prompt2 {} {
    return "_ "
}


#----------------------------------------------------------------------------
#  Initial entry and validation:

if {[llength $argv] != 1} {
    puts stderr "Usage:"
    puts stderr "   vardbsh database-uri"
    puts stderr " NOTE: If the path provided does not exist you'll be allowed to"
    puts stderr "       to create it as a variable database file"
    exit -1
}

# If a file URI, figure out the file and, if it does not exist offer to create
# it:



set uri [lindex $argv 0]
set protocol [lindex [split $uri :] 0]
set vardbsh::varDbFile [string range $uri [string length $protocol]+1 end]

if {$protocol eq "file"} {
    set vardbsh::varDbFile [file normalize $vardbsh::varDbFile]
    if {![file exists $vardbsh::varDbFile]} {
        puts -nonewline "$vardbsh::varDbFile does not exist. Create it? "
        flush stdout
        set reply [gets stdin]
        if {[string range $reply 0 0] in [list Y y]} {
            varmgr::create $vardbsh::varDbFile
        } else {
            exit 0
        }
    }
    set ::varmgr::prompt1 [file tail $::vardbsh::varDbFile]
} else {
    set ::varmgr::prompt1 $::vardbsh::varDbFile
}
# By now the database file should exist:

if {[catch {varmgr::open $uri} ::vardbsh::varDbHandle]} {
    puts stderr "Could not open $vardbsh::varDbFile as a variable database"
    puts stderr $vardbsh::varDbHandle
    exit -1
}


#  Set the prompts.

set tcl_prompt1 {puts -nonewline [prompt1]}
set tcl_prompt2 prompt2

##
#  Define the top level commands.  Note that pwd cd get re-defined to
#  Cd and Pwd so tht they are still available to shell users.
#

##
# mkdir
#   Wraps the mkdir command:
#
#  @param path - path of directory to create:
#
proc mkdir path {
    ::varmgr::mkdir $::vardbsh::varDbHandle  $path
}
##
# ls
#   List the contents of the cwd:
# @param path (optional) path to list contents of.
proc ls {{path {}}} {
    
    #  First the subdirectories:
    
    if {$path eq ""} {
        set subdirs [::varmgr::ls $::vardbsh::varDbHandle]
    } else {
        set subdirs [::varmgr::ls $::vardbsh::varDbHandle $path]
    }
    foreach subdir $subdirs {
        puts $subdir/
    }
    #  Now the variables:
     
     if {$path ne ""} {
        set vars [::varmgr::var ls $::vardbsh::varDbHandle $path]
     } else {
        set vars [::varmgr::var ls $::vardbsh::varDbHandle]
        set path [pwd]
     }
    
    foreach var $vars {
        set name [lindex $var 1]
        set type [lindex $var 2]
        set value [get [file join $path $name]]
        
        puts [format {%10s %10s %s} $name $type $value]
    }


}
##
# cd
#  Change directory
# @param path - new default working directory.
#
rename cd Cd
proc cd path {
    ::varmgr::cd $::vardbsh::varDbHandle $path
    set a ""
}
##
# pwd
#   Print the working directory
#
rename pwd Pwd
proc pwd {} {
    ::varmgr::getwd $::vardbsh::varDbHandle
}

##
# rmdir
#   Remove a directory
# @param path - path to remvoe.
#
proc rmdir {path} {
    ::varmgr::rmdir $::vardbsh::varDbHandle $path
}

##
# declare
#   Declare a new variable
#
# @param path  - path to the variable.
# @param type  - Type of variable.
# @param initial- Optional initial value.
#
proc declare {path type args} {
    if {[llength $args] == 0} {
        varmgr::var create $::vardbsh::varDbHandle $path $type
    } elseif {[llength $args] == 1} {
        varmgr::var create $::vardbsh::varDbHandle $path $type $args
    } else {
        error "usage: declare path type ?initial-value?"
    }
}

##
# let
#   Assign a variable a value
#
# @param path - variable path.
# @param value - new variable value.
#
proc let {path value} {
    varmgr::var set $::vardbsh::varDbHandle $path $value
}
##
# get
#    Get variable value
# @param path path name
# @return current value.
proc get {path} {
    return [varmgr::var get $::vardbsh::varDbHandle $path]
}
##
#  del
#    Delete a variable.
#
# @param path - path to dwelete.
#
proc del {path} {
    varmgr::var destroy $::vardbsh::varDbHandle $path
}

##
# enum
#   Create an enumerated data type.  Once created, you can create variables of
#   this type.
#
# @param typename - Name of the new type
# @param value-list - List of values the type can have.
#
proc enum {typename values} {
    varmgr::enum $::vardbsh::varDbHandle $typename $values
}

##
# statemachine
#    Create a statemachine data type.  Once created you can create variables
#    of this type.
#
# @param typename    - name of the new type.
# @param transitions - Tcl dict that defines the state diagram of the type.
#                      dict keys are allowed states and dict values are lists
#                      of legal states to which the key state can transition.
#                      This is probably made clearer with an example:
#                      dict create first second second third third [list first second]
#                      defines a state machine with the following transition table:
# \verbatim
#                     |    From      |        To     |
#                     +--------------+---------------+
#                     |  first       | second        |
#                     |  second      | third         |
#                     |  third       | first         |
#                     |  third       | second        |
#                     +--------------+---------------+
# \endverbatim
#
#
proc statemachine {typename transitions} {
    varmgr::statemachine $vardbsh::varDbHandle $typename $transitions
}

set tcl_interactive 1

