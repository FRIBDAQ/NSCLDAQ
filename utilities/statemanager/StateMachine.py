#!/usr/bin/env python


##
# @file   statemachine.py
# @brief  implement an abstract state machine.
# @author David Mertz
# @note   The normal NSCL Copyright notice is omitted because this code is
#         shamelessly stolen (and possbily modified from)the IBM developer
#         works web article:  Charming Python: Using state machines
#         available as of this date (June 18, 2014) at:
#         http://www.ibm.com/developerworks/linux/library/l-python-state/index.html
#
from string import upper
class StateMachine:
  def __init__(self):
      self.handlers = {}
      self.startState = None
      self.endStates = []

  ##
  # add_state - add a new state to the system.
  # @param name - Name of  the state (case insensitive).
  # @param handler - A function called when the state is entered.  The function
  #                  takes a parameter generated by the prior state (or passed)
  #                  in to the initial state by tyhe run method and is expected
  #                  to return a list containing the new state and the parameter
  #                  to pass to its state handler.
  # @param end_state - If non zero, this state is an end state, reaching it causes
  #                    the state machine loop to exit.
  # @note  Several states can be end states.
  #
  def add_state(self, name, handler, end_state=0):
      name = upper(name)
      self.handlers[name] = handler
      if end_state:
           self.endStates.append(name)
  ##
  # set_start  - Define the start state.
  # @param name - The name of the state at which the state machine starts.
  #               (case insensitive).
  # @note if called multiple time, the temporally last call wins.
  #
  def set_start(self, name):
      self.startState = upper(name)
  ##
  # run - run the state machine until an end state is reached.
  # @param cargo - The value of the parameter passed to the initial state
  #                 state handler.
  def run(self, cargo):
      try:
         handler = self.handlers[self.startState]
      except:
         raise "InitializationError", "must call .set_start() before .run()"
      
      if not self.endStates:
         raise  "InitializationError", "at least one state must be an end_state"
      
      while 1:
         (newState, cargo) = handler(cargo)
         if upper(newState) in self.endStates:
            break
         else:
            handler = self.handlers[upper(newState)]