<!-- chapter libraries -->
<chapter>
    <title>
        State Manager API.
    </title>
    <para>
        State manager programs are those that force global state transitions.
        This chapter provides:
    </para>
    <itemizedlist>
        <listitem><para>
            Background information about state manager programs and what they
            can do.
        </para></listitem>
        <listitem><para>
            A small sample state manager program.
        </para></listitem>
        <listitem><para>
            The State manager ReadoutGUI is described.
        </para></listitem>
    </itemizedlist>
    <para>
        Reference information is available:
    </para>
    <variablelist>
        <varlistentry>
            <term>
                <link linkend='daq3_cstatemanager'
                      endterm='daq3_cstatemanager_title' />
            </term>
            <listitem>
                <para>
                    The C++ <classname>CStateManager</classname> class
                    which makes up the API.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <link linkend='tcl3_statemanager'
                      endterm='tcl3_statemanager_title' />
            </term>
            <listitem>
                <para>
                    Documents the Tcl bindings to the
                    <classname>CStateManager</classname> class.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <link linkend='python3_statemanager'
                      endterm='python3_statemanager_title' />
            </term>
            <listitem>
                <para>
                    Documents the pyhon bindings to the
                    <classname>CStateManager</classname>
                    class.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <link linkend='daq1_readoutgui'
                      endterm='daq1_readoutgui_title' />
            </term>
            <listitem>
                <para>
                    Describes how to use the state manager Run control GUI.
                </para>
            </listitem>
        </varlistentry>
    </variablelist>
    <para>
        The C++ header that defines the state manager API is
        <filename>&lt;CStateManager.h&gt;</filename>.
        The library you must link to is
        <filename>$DAQLIB/libstateclient</filename>.
    </para>
    <section>
        <title>State managers and what they can do</title>
        <para>
            State managers can perform the following functions:
        </para>
        <itemizedlist>
            <listitem><para>
                The can create/delete and edit the definition of programs
                known to the state management system.
            </para></listitem>
            <listitem><para>
                They can enable, disable programs.
            </para></listitem>
            <listitem><para>
                They can set or clear program standalong flags.
            </para></listitem>
            <listitem><para>
                They can set run global parameters.
            </para></listitem>
            <listitem><para>
                Most importantly, they can initiate global or program
                state transitions and, in the case of global transitions,
                know when and if they have succeeded.
            </para></listitem>
        </itemizedlist>
        <para>
            State manager programs play a central role in defining and running
            the experiment.            
        </para>
        <para>
            During program definition and setup,
            the program/dataflow editor defines state
            sensitive programs and links them together by means of ring
            buffers. 
        </para>
        <para>
            During setup the program manager can select the set of programs
            that actually participate in global state transitions.  The
            program manager can also select programs that run in stand-alone
            mode for debuggin/testing and development.
        </para>
        <para>
            The Run control panel, together with the boot manager
            initiate global and local state transitions.  The boot manager
            ensures that the right set of programs are running while
            the run control panel performs state changes, displays the
            local and global states and ensures that global state
            transitions have correctly completed.
        </para>
    </section>
    <section>
        <title>A Sample state manager program</title>
        <para>
            This simple sample program starts a run, first incrementing
            the run number and setting the title to <literal>This is a test title</literal>.
        </para>
        <para>
            The remainder of this section shows sample code fragments that:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Create a new <classname>CStateManager</classname>
                    object.
                </para>
            </listitem>
            <listitem><para>
                Begin the run.
            </para></listitem>
            <listitem><para>
                Ensure the run  starts correctly while outputting messages
                that track the participant state transitions.
            </para></listitem>
        </itemizedlist>
        <section>
            <title>Creating the CStateManager object.</title>
            <para>
                In writing this code we are going to assume the state manager
                program is run with environment variables:
            </para>
            <variablelist>
                <varlistentry>
                    <term>VARMGR_REQ</term>
                    <listitem>
                        <para>
                            The URI of the variable database
                            server's REQ port.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>VARMGR_SUB</term>
                    <listitem>
                        <para>
                            The URI of the variable database server's SUB port.
                        </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>
            <example>
                <title>Createing a CStateManager Object</title>
                <programlisting>
#include &lt;stdlib.h&gt;
#include &lt;CStateManager.h&gt;                      <co id='make_statemgr_hdr' />

CStateManager*
makeStateManager()
{
   const char* reqUri = getenv("VARMGR_REQ");        <co id='make_statmgr_getenv' />
   const char* subUri = getenv("VARMGR_SUB");
   
   return new CStateManager(reqUri, subUri);         <co id='make_statemgr_new' />
}
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='make_statemgr_hdr'>
                    <para>
                        To use the <classname>CStateManager</classname> within
                        a program unit, the <filename>CStateManager.h</filename>
                        header must be included.  This file defines the
                        class sufficiently for the compiler.
                    </para>
                </callout>
                <callout arearefs='make_statmgr_getenv'>
                    <para>
                        Translate the environment variables.  This is not
                        production quality code.  The code should protect
                        itself against return values of
                        <literal>NULL</literal>, which indicate the
                        environament variable was not defined.
                        Error handling was removed for clarity.
                    </para>
                </callout>
                <callout arearefs='make_statemgr_new'>
                    <para>
                        Create and return a new state manager object.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section>
            <title>Starting the run.</title>
            <para>
                The sample code in this section:
            </para>
            <itemizedlist>
                <listitem><para>
                    Sets a new run title.
                </para></listitem>
                <listitem><para>
                    Increments the run number.
                </para></listitem>
                <listitem><para>
                    Initiates a state change to start taking data.
                </para></listitem>
            </itemizedlist>
            <para>
                Note that no effort is made to ensure that the
                system is in a state where data taking can be started.
                If the global state is not compatible with a transition
                to the <literal>Beginning</literal> state the
                function below will propagate an exception.
            </para>
            <example>
                <title>
                    Starting a run.
                </title>
                <programlisting>
#include &lt;CStateManager.h&gt;

void
startRun(CStateManager* pStateManager, const char* title) <co id='sm_begrun_sig' />
{
    pStateManager->title(title);                          <co id='sm_begrun_title' />
    pStateManager->runNumber(runNumber() + 1);            <co id='sm_begrun_incrun' />
    
    pStateManager->setGlobalState("Beginning");           <co id='sm_begrun_beg' />
}
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='sm_begrun_sig'>
                    <para>
                        The first functino parameter is a pointer to the
                        <classname>CStateManager</classname> object
                        we created in the previous section. The second parameter
                        is a new title string.
                    </para>
                </callout>
                <callout arearefs='sm_begrun_title'>
                    <para>
                        Sets the new title string.
                    </para>
                </callout>
                <callout arearefs='sm_begrun_incrun' >
                    <para>
                        Increments the run number.
                    </para>
                </callout>
                <callout arearefs='sm_begrun_beg'>
                    <para>
                        The <literal>Begining</literal> state indicates
                        to all participants that they must start a
                        data taking run.  The full description of
                        what participants must do and the tracking
                        of the start of the run is shown in the next
                        section.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section>
            <title>Tracking the state transition</title>
            <para>
                In the previous section, we had made a global state
                transtion to <literal>Beginning</literal>.  In response
                to this transition, participants are expected to:
            </para>
            <orderedlist>
                <listitem><para>
                    Make a local transition to <literal>Beginning</literal>.
                </para></listitem>
                <listitem><para>
                    Perform all initialization required to begin data
                    taking.
                </para></listitem>
                <listitem><para>
                    Make a local state transition to <literal>Active</literal>.
                </para></listitem>
                <listitem><para>
                    When the global state transitions to <literal>Active</literal>,
                    programs are supposed to start taking data.
                </para></listitem>
            </orderedlist>
            <para>
                If at any point in this process, a participant program
                encounters an error it cannot recover from, it must
                set its state to <literal>NotReady</literal> and exit.
                This will result in a global state transition to
                <literal>NotReady</literal> which, in turn, will eventually
                cause all participants to go <literal>NotReady</literal>
                and exit.
            </para>
            <example>
                <title>Tracking the state changes to start a run</title>
                <programlisting>
#include &lt;CStateManager.h&gt;
#include &lt;iostream&gt;
#include &lt;string&gt;

void reportTransition(                      <co id='sm_mon_cbsig' />
    CStateManager&amp; mgr, std::string program, std::string state,
    void* cd
)
{
    std::cout &lt;&lt; program &lt;&lt; " transitioned to  " 
        &lt;&lt; state &lt;&lt; std::endl; 
}

void monitorTransition(CStateManager* pMgr)
{
    try {
        pMgr->waitTransition(reportTransition, NULL);   <co id='sm_mon_mon' />
    }
    catch (std::exception&amp; e) {                    <co id='sm_mon_fail' />
        std::cerr &lt;&lt; " Transition failed: " &lt;&lt; e.what() &lt;&lt; std::endl;
    }
}

                </programlisting>
            </example>
            <calloutlist>
                <callout  arearefs='sm_mon_mon'>
                    <para>
                        <methodname>waitTransition</methodname> waits for
                        a transition to complete, time out or fail.  Transitions
                        timeout when the state manager is table for longer than
                        the number of seconds in
                        <filename>/RunState/Timeout</filename>.
                        Transitions fail if one or more participants declare
                        themselves as <literal>NotReady</literal>
                    </para>
                    <para>
                        <methodname>waitTransition</methodname> can call a callback
                        function every time a participant reports a state change.
                        In this case we've specified <function>reportTransition</function>
                        as our callback.
                    </para>
                </callout>
                <callout arearefs='sm_mon_cbsig'>
                    <para>
                        Our state transition callback will just output
                        the program and its new state so that our
                        users can see the progress of that transition.
                    </para>
                </callout>
                <callout arearefs='sm_mon_fail'>
                    <para>
                        A failed or timed out transition throws an exception
                        which is caught and reported here.
                    </para>
                </callout>
            </calloutlist>
            
        </section>
    </section>
    <section>
        <title>The ReadoutGui</title>
        <para>
            The ReadoutGUI is used with the service manager to provide a
            graphical user interface that controls the startup and shutdown
            of a DAQ system as well as guiding the system through state changes
            (beginning, ending, pausing and resuming runs).  Using the
            ReadoutGUI essentially allows you control over almost all of the content
            in the <filename>/RunState</filename> directory.
        </para>
        <para>
            To use the ReadoutGUI you must first:
        </para>
        <itemizedlist>
            <listitem><para>
                Configure the variable database server as a service
            </para></listitem>
            <listitem><para>
                Configure the boot manager as a service.
            </para></listitem>
            <listitem><para>
                Run the service manager and start all services.
            </para></listitem>
        </itemizedlist>
        <para>
            Once the above steps ahve been accomplished you can run
            the ReadoutGui:
        </para>
        <informalexample>
            <cmdsynopsis><command>
$DAQBIN/ReadoutGui <replaceable>requestUri subscriptionUri</replaceable>
            </command></cmdsynopsis>
        </informalexample>
        <para>
            Where <parameter>requestUri</parameter> and
            <parameter>subscriptionUri</parameter> are the URIs of the
            request and subscription services advertised by the variable
            database server you started via the service manager.
            
        </para>
        <para>
            The GUI of the ReadoutGUi is a tabbed widget with a pair of tabs.
            The <literal>RunControl</literal> tab supplies the user interface
            for controlling the runs.  On the other hand, the
            <literal>Program states</literal> tab provides information about the
            states of the state sensitive programs being controlled.
        </para>
        <para>
            The ReadoutGUI works via the variable database.  You can run as many
            instances as you like.  The ReadoutGui uses variable change
            subscription/notification to update its appearance.  This means that
            changes performed in one ReadoutGUI instance will be reflected in all
            instances that are connected to the same variable database.
        </para>
        <para>
            Some features of note about the GUI:
        </para>
        <itemizedlist>
            <listitem><para>
                The Top section of the <literal>Run Control</literal> tab
                allow you to set information about the next run.   In addition
                to the title and the run number there is a checkbox to enable
                or disable recording.  This check button assumes there is a state
                aware event logger that will log data to disk when this box is
                checked.
            </para>
            <para>
                When the run is active, these controls are replaced by labels so
                that they cannot be modified.
            </para></listitem>
            <listitem>
                <para>
                    The global state is always displayed below the run information
                    section.   The global state will determine which controls will
                    be displayed below it.
                </para>
            </listitem>
            <listitem>
                <para>
                    There is always either a <guibutton>Boot</guibutton> or
                    <guibutton>Shutdown</guibutton> button at the bottom of the
                    UI.  When the system is in <literal>NotReady</literal> state
                    the <guibutton>Boot</guibutton> button changes the global
                    state to <literal>Readying</literal> which instructs the
                    boot manager to start the state sensitive programs and
                    complete the transition to Ready.
                </para>
                <para>
                    When the state sensitive programs are running, the
                    <guibutton>Boot</guibutton> button is removed and
                    replaced with a <guibutton>Shutdown</guibutton> button.
                    The <guibutton>Shutdown</guibutton> button
                    sets the global state to <literal>NotReady</literal>
                    which instructs
                    the boot manager to kill off the state sensitive programs.
                </para>
            </listitem>
            <listitem>
                <para>
                    Above the <guibutton>Boot</guibutton> and
                    <guibutton>Shutdown</guibutton> area is an area where run
                    control buttons approprate to the run state will be displayed.
                    The buttons that can be displayed are:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><guibutton>Begin</guibutton></term>
                        <listitem>
                            <para>
                                This button appears only in the <literal>Ready</literal>
                                state.  Clicking on it sets the global state to
                                <literal>Beginning</literal>.  State sensitive
                                programs then do what they need to do to start a
                                new run completing the transition to
                                <literal>Active</literal>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            <guibutton>End</guibutton>
                        </term>
                        <listitem>
                            <para>
                                Appears only in the <literal>Active</literal>
                                and <literal>Paused</literal> states.  Clicking the
                                button sets the global state to <literal>Ending</literal>.
                                State sensitive programs then shut down data taking, if
                                active,
                                end their runs and complete the state transition to
                                <literal>Ready</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><guibutton>Pause</guibutton></term>
                        <listitem>
                            <para>
                                Appears only in the <literal>Active</literal>
                                state.  When clicked sets the global state to
                                <literal>Pausing</literal>.  State sensitive
                                programs temporarily pause data taking and complete
                                the transition to the <literal>Paused</literal>
                                state.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><guibutton>Resume</guibutton></term>
                        <listitem>
                            <para>
                                Only present in the <literal>Paused</literal> state.
                                This button transitions to the <literal>Resuming</literal>
                                state.  State sensitive programs continue taking data
                                after a pause in the run and complete a state
                                transition to <literal>Active</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </listitem>
            <listitem><para>
                The <literal>Program States</literal> tab consists of a table
                that is periodically updated.  The table has a line for each
                state sensitive program that is registered in the variable
                database.  The line for a program displays the program's name,
                individual state and the state of the <literal>Enabled</literal>
                and <literal>Standalone</literal> flags.
            </para></listitem>
        </itemizedlist>
    </section>
</chapter>
<!-- /chapter -->

<!-- manpage 1daq -->
      <refentry id="daq1_readoutgui">
        <refentryinfo>
          <author>
                  <personname>
                          <firstname>Ron</firstname>
                          <surname>Fox</surname>
                  </personname>
          </author>
          <productname>NSCLDAQ</productname>
          <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='daq1_readoutgui_title'>ReadoutGui</refentrytitle>
           <manvolnum>1daq</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>ReadoutGui</refname>
           <refpurpose>Run control via variable database</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
          <command>
$DAQBIN/ReadoutGui <replaceable>requestURI subscriptionURI</replaceable>
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Runs the ReadoutGui program.  This program interacts with a variable
            database server to visually maintain the state of the system as
            well as to request changes to the state of the system.
           </para>
           <para>
            <parameter>requestURI</parameter> and <parameter>subscriptionURI</parameter>
            are URIs that respectively
            specify the request and subscription ports of the
            a variable database server.  By using the subscription mechanims,
            all instances of the ReadoutGui that specify the same
            <parameter>requestURI</parameter> and <parameter>subscriptionURI</parameter>
            values will be synchronized with each other.
           </para>
        </refsect1>
        
      </refentry>

<!-- /manpage -->

<!-- manpage 3daq -->

<refentry id="daq3_CStateProgram">
  <refentryinfo>
    <author>
        <personname>
            <firstname>Ron</firstname>
            <surname>Fox</surname>
        </personname>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='daq3_CStateProgram_title'>CStateProgram</refentrytitle>
     <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>CStateProgram</refname>
     <refpurpose>API for manipulating state sensitive program definitions</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <synopsis>
#include &lt;CStateProgram.h&gt;
class <ooclass><classname>CStateProgram</classname></ooclass>
{
public:
    typedef struct _ProgramDefinition {
        bool        s_enabled;
        bool        s_standalone;
        std::string s_path;
        std::string s_host;
        std::string s_outRing;
        std::string s_inRing;
    } ProgramDefinition, *pProgramDefinition;

public:
    <constructorsynopsis>
       <methodname>CStateProgram</methodname>
       <methodparam>
        <modifier>const </modifier><type>char* </type>
            <parameter>uri</parameter>
       </methodparam>
    </constructorsynopsis>
    <constructorsynopsis>
       <methodname>CStateProgram</methodname>
       <methodparam>
        <modifier></modifier><type>CVarMgrApi*</type>
            <parameter> pApi</parameter>
       </methodparam>
    </constructorsynopsis>

    <methodsynopsis>
        <modifier></modifier>
        <type>std::string</type>
        <methodname>getProgramParentDir</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>setProgramParentDir</methodname>
        <methodparam>
            <modifier>const </modifier><type>char*</type>
                <parameter> path</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>addProgram</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <modifier>const </modifier><type>pProgramDefinition</type>
                <parameter> def</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>ProgramDefinition </type>
        <methodname>getProgramDefinition</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>modifyProgram</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <modifier>const </modifier><type>pProgramDefinition </type>
                <parameter>def</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>void</type>
        <methodname>setEditorPosition</methodname>
        <methodparam>
            <modifier>const</modifier><type>char*</type>
                <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <modifier></modifier><type>int</type>
                <parameter>x</parameter>
        </methodparam>
        <methodparam>
            <modifier></modifier><type>int</type>
                <parameter>y</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>int</type>
        <methodname>getEditorXPosition</methodname>
        <methodparam>
            <modifier>const</modifier><type> char*</type>
                <parameter>name</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>int</type>
        <methodname>getEditorYPosition</methodname>
        <methodparam>
            <modifier>const</modifier><type> char*</type>
                <parameter>name</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>enableProgram</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname> disableProgram</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>bool</type>
        <methodname>isProgramEnabled</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>setProgramStandalone</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>void</type>
        <methodname>setProgramNoStandalone</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>bool</type>
        <methodname>isProgramStandalone</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>std::vector&lt;std::string&gt; </type>
        <methodname>listPrograms</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>std::vector&lt;std::string&gt; </type>
        <methodname>listEnabledPrograms</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>std::vector&lt;std::string&gt; </type>
        <methodname>listStandalonePrograms</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>std::vector&lt;std::string&gt; </type>
        <methodname>listInactivePrograms</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>std::vector&lt;std::string&gt; </type>
        <methodname>listActivePrograms</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void  </type>
        <methodname>deleteProgram</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>  
};
   </synopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        <classname>CStateProgram</classname> provides an API that allows you to
        define and modify the definitions of state sensitive programs.  By state
        sensitive, we mean programs that participate in global state transitions
        (see <link linkend='daq3_cstatemanager' endterm='daq3_cstatemanager_title' />).
     </para>
     <para>
        The <classname>CStateManager</classname> class provides this functinoality
        as well, however its instantitation requires providing a PUB/SUB
        URI in addition to a request URI.  This class only requires a request
        URI and can, therefore, operate directly on a database file.
     </para>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <variablelist>
        <varlistentry>
            <term>
                <constructorsynopsis>
                   <methodname>CStateProgram</methodname>
                   <methodparam>
                    <modifier>const </modifier><type>char* </type>
                        <parameter>uri</parameter>
                   </methodparam>
                </constructorsynopsis>
            </term>
            <listitem>
                <para>
                    Normal constructor of for <classname>CStateProgram</classname>
                    objects.  The <parameter>uri</parameter> parameter provides
                    a URI that indicates how to connect with the database.
                    A <literal>file:</literal> protocol URI will directly open
                    the database file.  A <literal>tcp:</literal> protocol
                    URI will connect to a database server.
                </para>
                <para>
                    If there are programs running
                    that subscribe to changes in the program
                    configuration, the server must be used to provide these
                    notifications.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <constructorsynopsis>
                   <methodname>CStateProgram</methodname>
                   <methodparam>
                    <modifier></modifier><type>CVarMgrApi*</type>
                        <parameter> pApi</parameter>
                   </methodparam>
                </constructorsynopsis>
            </term>
            <listitem>
                <para>
                    This is the constructor used by the
                    <link linkend='daq3_cstatemanager'
                          endterm='daq3_cstatemanager_title' /> class.  It uses
                    this constructor to be able to implement its state
                    program API as mostly a thin wrapper around the
                    <classname>CStateProgram</classname> api.
                </para>
                <para>
                    <parameter>pApi</parameter> points to an instance of
                    a variable manager API.  Obviously this can also be
                    used to share api instances between a program that uses
                    several APIs.
                </para>
            </listitem>
        </varlistentry>        
        <varlistentry>
             <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::string</type>
                    <methodname>getProgramParentDir</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>
             </term>
             <listitem>
                 <para>
                    All program definitions are directories that live beneath
                    a parent directory.  This method returns the path to the
                    program parent directory.
                 </para>
             </listitem>
         </varlistentry>   
         <varlistentry>
             <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>setProgramParentDir</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char*</type>
                            <parameter> path</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>
             </term>
             <listitem>
                 <para>
                    Changes the parent directory in which program definitions are
                    made.  Note that no existing definitions are copied over.
                    This allows you to configure several state sensitive
                    configurations which you can then easily switch between.
                    <parameter>path</parameter> will be the path to the new
                    parent directory. This should be an absolute path.
                 </para>
             </listitem>
         </varlistentry>       
         <varlistentry>
             <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>addProgram</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier>const </modifier><type>pProgramDefinition</type>
                            <parameter> def</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>
             </term>
             <listitem>
                 <para>
                     Adds a new state sensitive program.  <parameter>name</parameter>
                     provides a name for the program which can be used to refer
                     to it in subsequent API calls.  <parameter>def</parameter>
                     describes the configuration of the program.
                     See <literal>PUBLIC VARIABLES, TYPES and CONSTANTS</literal>
                     for information about the <type>pProgramDefinition</type>
                     type which is a pointer to a <type>ProgramDefinition</type>
                     struct.
                 </para>
             </listitem>
         </varlistentry>       
         <varlistentry>
             <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>ProgramDefinition </type>
                    <methodname>getProgramDefinition</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>  
             </term>
             <listitem>
                 <para>
                    Returns the <type>ProgramDefinition</type> struct for
                    an already defined program; <parameter>name</parameter>.
                 </para>
             </listitem>
         </varlistentry>       
         <varlistentry>
             <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>modifyProgram</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier>const </modifier><type>pProgramDefinition </type>
                            <parameter>def</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>  
             </term>
             <listitem>
                 <para>
                    Modifies the definition of an existing program; <parameter>name</parameter>
                    to bring it in line with the description in
                    <parameter>def</parameter>.
                    To only partially modify a program definition, first use
                    <methodname>getPogtramDefinition</methodname> to get its
                    definition, then simply change the fields you want modified
                    and pass a pointer to the resulting <type>ProgramDefinition</type>
                    struct to <methodname>modifyProgram</methodname>.
                 </para>
             </listitem>
         </varlistentry>
         <varlistentry>
             <term>
                <methodsynopsis>
                   <modifier></modifier>
                   <type>void</type>
                   <methodname>setEditorPosition</methodname>
                   <methodparam>
                       <modifier>const</modifier><type>char*</type>
                           <parameter>name</parameter>
                   </methodparam>
                   <methodparam>
                       <modifier></modifier><type>int</type>
                           <parameter>x</parameter>
                   </methodparam>
                   <methodparam>
                       <modifier></modifier><type>int</type>
                           <parameter>y</parameter>
                   </methodparam>
                   <modifier></modifier>
               </methodsynopsis>
               
             </term>
             <listitem>
                 <para>
                    Saves the position of an existing state sensitive program
                    on the experiment editor canvas.  This position is used to
                    layout the experiment components if when an experiment is
                    restored for further editing or viewing.
                 </para>
                 <para>
                    <parameter>name</parameter> is the name of the program being
                    modified, while <parameter>x</parameter> and <parameter>y</parameter>
                    are the new coordinates to save.
                 </para>
             </listitem>
         </varlistentry>
         <varlistentry>
             <term>
                <methodsynopsis>                   
                       <modifier></modifier>
                       <type>int</type>
                       <methodname>getEditorXPosition</methodname>
                       <methodparam>
                           <modifier>const</modifier><type> char*</type>
                               <parameter>name</parameter>
                       </methodparam>
                       <modifier></modifier>
                   </methodsynopsis>
             </term>
             <listitem>
                 <para>
                    Returns the X coordinate of the editor canvas position
                    saved with the state sensitive program <parameter>name</parameter>.
                 </para>
             </listitem>
         </varlistentry>
         <varlistentry>
             <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>int</type>
                    <methodname>getEditorYPosition</methodname>
                    <methodparam>
                        <modifier>const</modifier><type> char*</type>
                            <parameter>name</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>                
             </term>
             <listitem>
                 <para>
                    Returns the Y coordinate of the editor canvas position
                    saved with the state sensitive program <parameter>name</parameter>.
                 </para>
             </listitem>
         </varlistentry>       

         <varlistentry>
             <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>enableProgram</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>  
             </term>
             <listitem>
                 <para>
                    Sets the <literal>enable</literal> flag 
                    for the program <parameter>name</parameter> to
                    <literal>true</literal>.  If this flag is <literal>false</literal>,
                    the program is not expected to participate in global state
                    transitions.  If <literal>true</literal> it is expected
                    to participate.  See also <methodname>disableProgram</methodname>.
                 </para>
             </listitem>
         </varlistentry>       
         <varlistentry>
             <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname> disableProgram</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>  
             </term>
             <listitem>
                 <para>
                    Sets the <literal>enable</literal> flag for the
                    program <parameter>name</parameter> to
                    <literal>false</literal>.If this flag is <literal>false</literal>,
                    the program is not expected to participate in global state
                    transitions.  If <literal>true</literal> it is expected
                    to participate.  See also <methodname>enableProgramm</methodname>
                 </para>
             </listitem>
         </varlistentry>           
         <varlistentry>
             <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>bool</type>
                    <methodname>isProgramEnabled</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>
             </term>
             <listitem>
                 <para>
                    Examines the <literal>enable</literal> flag for the program
                    <parameter>name</parameter>.  Returns
                    <literal>true</literal> if the program is enabled and
                    <literal>false</literal> if not.  See
                    <methodname>enableProgram</methodname> and
                    <methodname>disableProgram</methodname> which modify
                    the state of this flag.  It is, of course, also possible
                    to modify the state of the flag using
                    <methodname>modifyProgram</methodname> as well.
                 </para>
             </listitem>
         </varlistentry>
         <varlistentry>
             <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>setProgramStandalone</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>
             </term>
             <listitem>
                 <para>
                    Sets the program <parameter>name</parameter>'s
                    <literal>standalone</literal>
                    flag to <literal>true</literal>.  Programs whose
                    <literal>standalone</literal> flag is <literal>true</literal>
                    are
                 </para>
                 <itemizedlist>
                    <listitem><para>
                        Not expected to partipate in global state transitions.
                    </para></listitem>
                    <listitem><para>
                        Are expected to take their state transition requests
                        from their local state variable rather than the
                        global state variable.   This allows them to be
                        controlled independently of the global state control
                        system.
                    </para></listitem>
                 </itemizedlist>
                 <para>
                    If the <literal>standalone</literal> flag for a program
                    is <literal>false</literal>, its enable state follows the
                    state of its <literal>enable</literal> flag and is
                    expected to take state transition requests from the global
                    state variable.
                 </para>
                 <para>
                    See also <methodname>setProgramNoStandalone</methodname>
                    below
                 </para>
             </listitem>
         </varlistentry>
         <varlistentry>
             <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void</type>
                    <methodname>setProgramNoStandalone</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>
             </term>
             <listitem>
                 <para>
                    Sets the <literal>standalone</literal> flag for the program
                    <parameter>name</parameter> to <literal>false</literal>.
                    See <methodname>setProgramStandalone</methodname> for a
                    discussion of this flag and what its possible values imply.
                 </para>
             </listitem>
         </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>bool</type>
                    <methodname>isProgramStandalone</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns the state of the <literal>standalone</literal> flag
                    for the program <parameter>name</parameter>
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::vector&lt;std::string&gt; </type>
                    <methodname>listPrograms</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns a vector containing the name of all programs defined
                    in the current program directory. 
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::vector&lt;std::string&gt; </type>
                    <methodname>listEnabledPrograms</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns a vector containing the name of all programs for
                    which the <literal>enabled</literal> flag is
                    <literal>true</literal>.
                </para>
            </listitem>
        </varlistentry>        
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::vector&lt;std::string&gt; </type>
                    <methodname>listStandalonePrograms</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns a vector containing the names of all programs
                    that have <literal>standalone</literal> flag set to
                    <literal>true</literal>.
                </para>
            </listitem>
        </varlistentry>        
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::vector&lt;std::string&gt; </type>
                    <methodname>listInactivePrograms</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns a vector of the names of programs that won't
                    participate in global state transitions.  These
                    are programs for which either the <literal>enable</literal>
                    flag is <literal>false</literal> or the
                    <literal>standalone</literal> flag is <literal>true</literal>.
                </para>
            </listitem>
        </varlistentry>        
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::vector&lt;std::string&gt; </type>
                    <methodname>listActivePrograms</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns a vector of the names of programs that will participate
                    in state transitions.  These are programs that have their
                    <literal>enable</literal> flag <literal>true</literal> and
                    their <literal>standalone</literal> flag <literal>false</literal>.
                </para>
            </listitem>
        </varlistentry>        
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void  </type>
                    <methodname>deleteProgram</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Removes the program definition for the program
                    <parameter>name</parameter>.
                </para>
            </listitem>
        </varlistentry>               
     </variablelist>
  </refsect1>
   <refsect1>
      <title>PUBLIC VARIABLES, TYPES and CONSTANTS</title>
      <para>
        The <classname>CStateProgram</classname> class defines a nested struct
        type  <type>CStateProgram::ProgramDefinition</type> and a typedef for a
        pointer to that struct <type>CStateProgram::pProgramDefinition</type>.
        The <type>CStateProgram::ProgramDefinition</type> strut has the following
        fields:
      </para>
      <variablelist>
        <varlistentry>
            <term>
                <type>bool</type> <structfield>s_enabled</structfield>
            </term>
            <listitem>
                <para>
                    The program's <literal>enabled</literal> flag.  See
                    the description of e.g. <methodname>enableProgram</methodname>
                    for a description of what this flag does.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <type>bool</type> <structfield>s_standalone</structfield>
            </term>
            <listitem>
                <para>
                    The program's <literal>standalone</literal> flag.
                    See the description of
                    <methodname>setProgramStandalone</methodname> for a description
                    of this flag.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <type>std::string</type> <structfield>s_path</structfield>        
            </term>
            <listitem>
                <para>
                    Contains the filesystem path to the program image.  When
                    the boot manager starts boots the data acqusition system,
                    this field describes what it actually runs for this
                    program.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <type>std::string</type> <structfield>s_host</structfield>        
            </term>
            <listitem>
                <para>
                    Contains the name or IP address of the host in which the
                    program will be started by the boot manager.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <type>std::string</type> <structfield>s_outRing</structfield>
            </term>
            <listitem>
                <para>
                    If non empty, the program will be the producer for the
                    ring name contained by this variable.  Note this must be
                    the name of a ring in the same host as the program.
                    The experiment editor will enforce this constraint.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <type>std::string</type> <structfield>s_inRing</structfield>        
            </term>
            <listitem>
                <para>
                    If non empty, the program will consume data from the'
                    ring whose URI is in this field.  Note that while it's
                    legal for a program to consume data from more than one
                    ring, at present this cannot be described in this schema.
                </para>
                <para>
                    Note that programs can be ring to ring filters in the
                    sense that a program can have both an input an an output
                    ring.
                </para>
            </listitem>
        </varlistentry>
        
    

      </variablelist>
   </refsect1>
</refentry>     

<refentry id="daq3_cstatemanager">
  <refentryinfo>
    <author>
        <personname>
            <firstname>Ron</firstname>
            <surname>Fox</surname>
        </personname>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='daq3_cstatemanager_title'>CStateManager</refentrytitle>
     <manvolnum>3daq</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>CStateManager</refname>
     <refpurpose>API for state manager programs.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <synopsis>
#include &lt;CStateManager&gt;
       class <ooclass><classname>CStateManager</classname></ooclass>
{
    typedef struct _ProgramDefinition {
        bool        s_enabled;
        bool        s_standalone;
        std::string s_path;
        std::string s_host;
        std::string s_outRing;
        std::string s_inRing;
    } ProgramDefinition, *pProgramDefinition;

   typedef void (*TransitionCallback)(
        CStateManager&amp; mgr, std::string program, std::string state, void* cd
    );
    typedef void (*BacklogCallback)(
        CStateManager&amp; mgr, CStateTransitionMonitor::Notification Notification,
        void* cd
    );
    <constructorsynopsis>
       <methodname>CStateManager</methodname>
       <methodparam>
        <modifier>const </modifier><type>char* </type>
            <parameter>requestUri</parameter>
       </methodparam>
       <methodparam>
        <modifier>const </modifier><type>char* </type>
            <parameter>subscriptionUri</parameter>
       </methodparam>
       
    </constructorsynopsis>    
    <methodsynopsis>
        <modifier></modifier>
        <type>std::string       </type>
        <methodname>getProgramParentDir</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>setProgramParentDir</methodname>
        <methodparam>
            <modifier>const</modifier><type>char* </type>
                <parameter>path</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void  </type>
        <methodname>addProgram</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <modifier>const </modifier><type>pProgramDefinition </type>
                <parameter>def</parameter>
        </methodparam>
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>ProgramDefinition </type>
        <methodname>getProgramDefinition</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>modifyProgram(</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <modifier>const </modifier><type>pProgramDefinition </type>
                <parameter>def</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void  </type>
        <methodname>enableProgram</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void  </type>
        <methodname>disableProgram</methodname>
        <methodparam>
            <modifier>const </modifier><type>char*</type>
                <parameter>char* name</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>bool  </type>
        <methodname>isProgramEnabled</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>void  </type>
        <methodname>setProgramStandalone</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void  </type>
        <methodname>setProgramNoStandalone</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>bool   </type>
        <methodname>isProgramStandalone</methodname>
        <methodparam>
            <modifier>const </modifier><type>char*</type>
                <parameter> name</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>std::vector&lt;std::string&gt; </type>
        <methodname>listPrograms</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>std::vector&lt;std::string&gt; </type>
        <methodname>listEnabledPrograms</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>std::vector&lt;std::string&gt; </type>
        <methodname>listStandalonePrograms</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>std::vector&lt;std::string&gt; </type>
        <methodname>listInactivePrograms</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>std::vector&lt;std::string&gt; </type>
        <methodname>listActivePrograms</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void  </type>
        <methodname>deleteProgram</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>setGlobalState</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>newState</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>std::string </type>
        <methodname>getGlobalState</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt; </type>
        <methodname>getParticipantStates</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>std::string </type>
        <methodname>title</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>title</methodname>
        <methodparam>
            <modifier>const </modifier><type>char*</type>
                <parameter>newTitle</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>unsigned </type>
        <methodname>timeout</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>timeout</methodname>
        <methodparam>
            <modifier></modifier><type>unsigned</type>
                <parameter> newValue</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>bool </type>
        <methodname>recording</methodname>
        <void />
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>bool </type>
        <methodname>recording</methodname>
        <methodparam>
            <modifier></modifier><type>bool</type>
                <parameter>state</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>runNumber</methodname>
        <methodparam>
            <modifier></modifier><type>unsigned </type>
                <parameter>newValue</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>runNumber</methodname>
        <void />
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>waitTransition</methodname>
        <methodparam>
            <modifier></modifier><type>TransitionCallback </type>
                <parameter>cb </parameter><initializer>0</initializer>
        </methodparam>
        <methodparam>
            <modifier></modifier><type>void* </type>
                <parameter>clientData</parameter><initializer>0</initializer>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>processMessages</methodname>
        <methodparam>
            <modifier></modifier><type>BacklogCallback</type>
                <parameter> cb</parameter><initializer>0</initializer>
        </methodparam>
        <methodparam>
            <modifier></modifier><type>void* </type>
                <parameter>clientData </parameter><initializer>0</initializer>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>bool </type>
        <methodname>isActive</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void </type>
        <methodname>setProgramState</methodname>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <modifier>const </modifier><type>char* </type>
                <parameter>state</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>std::string </type>
        <methodname>getProgramState</methodname>
        <methodparam>
            <modifier>const </modifier><type>char*</type>
                <parameter>name</parameter>
        </methodparam>
        
        <modifier></modifier>
    </methodsynopsis>  
    
};
   </synopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        <classname>CSateManager</classname> provides an API to the state
        management part of the variable database.  Since it requires
        notifications of changes to that part of the database, this class
        is meant to be used with a variable database server.
     </para>
     <para>
        The class addresses the following needs:
     </para>
     <itemizedlist>
        <listitem><para>
            Need to define, re-define, list and delete programs.
        </para></listitem>
        <listitem><para>
            Need to modify the enable and standalone flags for programs.
        </para></listitem>
        <listitem><para>
            Need to initiate and monitor global state transitions as well
            as initiating local state transitions for standalone programs.
        </para></listitem>
        <listitem><para>
            Need to process notification messages that can occur when state
            transitions are not in progress (e.g. program failures to
            <literal>NotReady</literal>).
        </para></listitem>
     </itemizedlist>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <variablelist>
        <varlistentry>
            <term>
                <constructorsynopsis>
                   <methodname>CStateManager</methodname>
                   <methodparam>
                    <modifier>const </modifier><type>char* </type>
                        <parameter>requestUri</parameter>
                   </methodparam>
                   <methodparam>
                    <modifier>const </modifier><type>char* </type>
                        <parameter>subscriptionUri</parameter>
                   </methodparam>
                   
                </constructorsynopsis>    
            </term>
            <listitem>
                <para>
                    The constructor requires
                    <parameter>requestUri</parameter>, the URI for the
                    request (REQ) port of a database server that is serving the
                    variable database whose state management system
                    we're going to manipulate.  It also requires
                    <parameter>subscriptinoUri</parameter> the URI
                    for the same server's subscription (SUB) port.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::string       </type>
                    <methodname>getProgramParentDir</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Programs that are state aware are registered
                    with the state management system via variables in
                    directories that are children of a specific parent.
                    This method returns the path to that parent
                    directory.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>setProgramParentDir</methodname>
                    <methodparam>
                        <modifier>const</modifier><type>char* </type>
                            <parameter>path</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    See <methodname>getProgramParentDir</methodname>,
                    this sets the parent directory for the state aware
                    program registry.  Note that use of ths allows several
                    data acquisition system configuration to co-exist in
                    the same database.   
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void  </type>
                    <methodname>addProgram</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier>const </modifier><type>pProgramDefinition </type>
                            <parameter>def</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Adds a new program to the state aware program registry.
                    The registry used is the one pointed to by the
                    curretn program parent directory.  <parameter>name</parameter>
                    is the name of the program and must be unique within that
                    registry.  <parameter>def</parameter> points to the
                    program definitions.  See
                    <literal>PUBLIC VARIABLES, TYPES and CONSTANTS</literal>
                    below for a description of the
                    <type>ProgramDefinition</type>
                    struct which <type>pProgramDefinition</type> points to
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>ProgramDefinition </type>
                    <methodname>getProgramDefinition</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns the definition of a specified program
                    given its <parameter>name</parameter>.
                    See
                    <literal>PUBLIC VARIABLES, TYPES and CONSTANTS</literal>
                    for a description of the <type>ProgramDefinition</type>
                    struct.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>modifyProgram(</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier>const </modifier><type>pProgramDefinition </type>
                            <parameter>def</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Modifies the definition of a specific program.
                    Normally this is used by first
                    invoking <methodname>getProgramDefinition</methodname>
                    both to ensure the program exists and to get it current
                    definition. The desired fields are then  modified
                    and passed to <parameter>modifyProgram</parameter>.
                </para>
                <para>
                    <parameter>name</parameter> is the name of the program
                    to modify.  This must exist in the current program registry.
                    <parameter>def</parameter> is a
                    <type>ProgramDefinition</type> pointer that points to the
                    new description of that program.
                    See <literal>PUBLIC VARIABLES, TYPES and CONSTANTS</literal>
                    for a description of the <type>ProgramDefinition</type>
                    struct.
                </para> 
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void  </type>
                    <methodname>enableProgram</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Enables the program <parameter>name</parameter>.
                    Enabled non-standalone programs participate in
                    global state transitions.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void  </type>
                    <methodname>disableProgram</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char*</type>
                            <parameter>char* name</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Disables the program specified by <parameter>name</parameter>.
                    Disabled programs do not take part in state transitions.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>bool  </type>
                    <methodname>isProgramEnabled</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns <literal>true</literal> if the program
                    <parameter>name</parameter> is enabled or
                    <literal>false</literal> otherwise.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void  </type>
                    <methodname>setProgramStandalone</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Sets a program selected by
                    <parameter>name</parameter> into standalone mode.
                    Standalone programs perform state transitions when
                    directed by their local state rather than the global
                    state.  This allows them to operate independently of the
                    system as a whole during development, testing and setup.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void  </type>
                    <methodname>setProgramNoStandalone</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Turn off the program <parameter>name</parameter>'s
                    standalone flag. with the standalone flag turned off,
                    the program, if enabled, will participate in global
                    state transitons.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>bool   </type>
                    <methodname>isProgramStandalone</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char*</type>
                            <parameter> name</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns <literal>true</literal> if the program
                    <parameter>name</parameter>'s standalone flag
                    is set.  If not, returns <literal>false</literal>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::vector&lt;std::string&gt; </type>
                    <methodname>listPrograms</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns a vector that contains the name of all
                    programs that are defined in the current state
                    aware programs registry.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::vector&lt;std::string&gt; </type>
                    <methodname>listEnabledPrograms</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns a vector that contains the nanmes of all
                    programs that have their enable flag set to
                    <literal>true</literal>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::vector&lt;std::string&gt; </type>
                    <methodname>listStandalonePrograms</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns a vector that contains the names of all
                    programs that have their standalone flags
                    set to <literal>true</literal>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::vector&lt;std::string&gt; </type>
                    <methodname>listInactivePrograms</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    An inactive program is one that is either
                    not enabled or has its standalone flag true.
                    This method returns a vector containing the
                    names of all inactive programs.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::vector&lt;std::string&gt; </type>
                    <methodname>listActivePrograms</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns a vector containing the names of all
                    programs that are not inactive (see
                    <methodname>listInactivePrograms</methodname>), that is
                    all programs that are active.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void  </type>
                    <methodname>deleteProgram</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Deletes the program <parameter>name</parameter>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>setGlobalState</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>newState</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Sets the global state to <parameter>newState</parameter>.
                    In general this initiates a state transition.  All
                    participating (active) programs will perform a set of
                    operations that, if successful will bring them and the
                    global state into the next steady state.
                </para>
                <para>
                    See <methodname>waitStateTransition</methodname> for information
                    on how to monitor the global state transition and know if
                    it succeeded, timed out or failed.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::string </type>
                    <methodname>getGlobalState</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns the current global state name.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt; </type>
                    <methodname>getParticipantStates</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    For each active program returns a pair containing in order the
                    program's name and its local state.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::string </type>
                    <methodname>title</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns the current title string.  This string is global
                    data that active programs can associate with data taking
                    runs.  The use of this string is entirely up to the program.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>title</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char*</type>
                            <parameter>newTitle</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Changes the global title string.  This should normally
                    only be done when the system is not in the middle
                    of a data taking run.  This includes the states:
                    <literal>0Initial</literal>, <literal>NotReady</literal>
                    <literal>Readying</literal>, and <literal>Ready</literal>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>unsigned </type>
                    <methodname>timeout</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Global state transitions must settle to the
                    proper final state within a timeout.  This
                    method returns the number of seconds in that timeout.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>timeout</methodname>
                    <methodparam>
                        <modifier></modifier><type>unsigned</type>
                            <parameter> newValue</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Sets the new state transition timeout to
                    <parameter>newValue</parameter> seconds.  This
                    must be a number that is at least <literal>1</literal>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>bool </type>
                    <methodname>recording</methodname>
                    <void />
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns the state of the global recording flag.  Participant
                    programs that are data loggers can use this to determine
                    whether or not to record data from a run.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>bool </type>
                    <methodname>recording</methodname>
                    <methodparam>
                        <modifier></modifier><type>bool</type>
                            <parameter>state</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Sets the new state of the global recording flag.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>runNumber</methodname>
                    <methodparam>
                        <modifier></modifier><type>unsigned </type>
                            <parameter>newValue</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Modifies the value of the global run number. The run number
                    is an integer that participant programs can associate with
                    a data taking run.  The new run number, which must be
                    a positive integer is <parameter>newValue</parameter>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>runNumber</methodname>
                    <void />
                    
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns the current value of the global run number.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>waitTransition</methodname>
                    <methodparam>
                        <modifier></modifier><type>TransitionCallback </type>
                            <parameter>cb </parameter><initializer>0</initializer>
                    </methodparam>
                    <methodparam>
                        <modifier></modifier><type>void* </type>
                            <parameter>clientData</parameter><initializer>0</initializer>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Waits for a state transition to either complete, time
                    out or fail.  If <parameter>cb</parameter> is supplied
                    and non null, it must be a function pointer. The
                    function is invoked for each program state transition.
                    The <parameter>clientData</parameter> parameter is
                    passed to that callback without interpretation.
                </para>
                <para>
                    See <literal>PUBLIC VARIABLES, TYPES and CONSTANTS</literal>
                    for a description of the <type>TransitionCallback</type>
                    function type and how it is called.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>processMessages</methodname>
                    <methodparam>
                        <modifier></modifier><type>BacklogCallback</type>
                            <parameter> cb</parameter><initializer>0</initializer>
                    </methodparam>
                    <methodparam>
                        <modifier></modifier><type>void* </type>
                            <parameter>clientData </parameter><initializer>0</initializer>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Each state manager has a thread that is responsible
                    for processing subscription messages into a queue.
                    These messages, among other things, inform the program
                    of state transitions.
                </para>
                <para>
                    When called, this method processes all messages in the
                    message queue backlog.  If a <parameter>cb</parameter>
                    is supplied it is called for each message.
                    See <literal>PUBLIC VARIABLES, TYPES and CONSTANTS</literal>
                    for a description of the <type>BacklogCallback</type> function
                    pointer data type and how those functions are called.
                    The <parameter>clientData</parameter> parameter is
                    passed to the callback without any interpretation.
                </para>
                <para>
                    It is important to call this from time to time to ensure
                    that the message queue does not expand without bound.
                    If your application is interested in knowing about
                    programs joining, leaving or failing supplying the
                    <parameter>cb</parameter> parameter makes that possible.   
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>bool </type>
                    <methodname>isActive</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    If the program <parameter>name</parameter> is active
                    this method returns <literal>true</literal> otherwise
                    it returns <literal>false</literal>,
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                
                <methodsynopsis>
                    <modifier></modifier>
                    <type>void </type>
                    <methodname>setProgramState</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <modifier>const </modifier><type>char* </type>
                            <parameter>state</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Used to set the state of a specific program. This is
                    normally used when either the program is standalone,
                    to drive it, or if it was detected that the program
                    exited without setting its state to <literal>NotReady</literal>.
                </para>
                <para>
                    <parameter>name</parameter> is the name of the program and
                    <parameter>state</parameter> is the desired new state.
                    Naturally the legal values for <parameter>state</parameter>
                    are constrained by the legal state transitions from the
                    program's current state.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                    <modifier></modifier>
                    <type>std::string </type>
                    <methodname>getProgramState</methodname>
                    <methodparam>
                        <modifier>const </modifier><type>char*</type>
                            <parameter>name</parameter>
                    </methodparam>
                    
                    <modifier></modifier>
                </methodsynopsis>  
            </term>
            <listitem>
                <para>
                    Returns the current local state of the program
                    <parameter>name</parameter>
                </para>
            </listitem>
        </varlistentry>
     </variablelist>
  </refsect1>
   <refsect1>
      <title>PUBLIC VARIABLES, TYPES and CONSTANTS</title>
        <para>
            The <classname>CStateManager</classname> defines
            three types.  Two of these are callback function
            prototypes, the last is a structure definition that
            describes a program.
        </para>
        <refsect2>
            <title>TransitionCallback</title>
            <para>
                This function prototype specifies the call signature
                of functions called back from the
                <methodname>waitTransition</methodname> method.
                The callback function must be of type <type>void</type>
                and takes parameters in the following order:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>CStateManager&amp;</type> <parameter>mgr</parameter></term>
                    <listitem>
                        <para>
                            Reference to the state manager that is doing
                            the callback.  This allows the callaback to
                            access the featurs and services of that
                            state manager.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>std::string</type> <parameter>program</parameter></term>
                    <listitem>
                        <para>
                            The name of the program that has just taken
                            a local state transition.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>std::string</type> <parameter>state</parameter></term>
                    <listitem>
                        <para>
                            That program's new state.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>void*</type> <parameter>cd</parameter></term>
                    <listitem>
                        <para>
                            The callback data parameter passed to
                            <methodname>waitTransition</methodname>.
                        </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>
        </refsect2>
        <refsect2>
            <title>BacklogCallback</title>
            <para>
                This function prototype represents functions that can be
                called back from <methodname>processMessages</methodname>.
                This function is of type <type>void</type> and has, in order,
                the following parameters:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>CStateManager&amp;</type> <parameter>mgr</parameter></term>
                    <listitem>
                        <para>
                            The <classname>CStateManager</classname> that is
                            performing this callback.  This allows the called
                            function to make use of the services of this class.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>CStateTransitionMonitor::Notification</type> <parameter>not</parameter></term>
                    <listitem>
                        <para>
                            The notification structure that describes the message
                            that is being processed. See
                            <link linkend='daq3_cstatetransitionmonitor'
                                  endterm='daq3_cstatetransitionmonitor_title'
                                  />
                            for more information about this struct.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>void*</type> <parameter>cd</parameter></term>
                    <listitem>
                        <para>
                            Callback data passed to
                            <methodname>processMessages</methodname>.
                        </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>
        </refsect2>
        <refsect2>
            <title>ProgramDefinition</title>
            <para>
                This data type is a struct that defines a program.
                It has the following fields:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>bool</type> <structfield>s_enabled</structfield></term>
                    <listitem>
                        <para>
                            This is true if the program is enabled.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>bool</type> <structfield>s_standalone</structfield></term>
                    <listitem>
                        <para>
                            This should be true if the program runs in standalone
                            mode.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>std::string</type> <structfield>s_path</structfield></term>
                    <listitem>
                        <para>
                            Path to the program to run.  This is used by he boot
                            manager to start the program.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>std::string</type> <structfield>s_host</structfield></term>
                    <listitem>
                        <para>
                            The host in wich the program runs.  This is used by the
                            boot manager to start the program.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>std::string</type> <structfield>s_outRing</structfield></term>
                    <listitem>
                        <para>
                            If the program is a ring buffer producer, this
                            should be set to the desired output ring name.
                            The program should honor this so that the
                            data flow can be set up by the experiment
                            defnition editor.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>std::string</type> <structfield>s_inRing</structfield></term>
                    <listitem>
                        <para>
                            If the program is a consumer of ring buffer data,
                            this should be set to the URI of the ring from
                            which data is taken.   The program should honor
                            this setting so that the data flow can be setup
                            by the experiment definition editor.
                        </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>
        </refsect2>
   </refsect1>
</refentry>     

<!-- /manpage -->

<!-- manpage 3tcl -->

      <refentry id="tcl3_statemanager">
        <refentryinfo>
          <author>
                  <personname>
                          <firstname>Ron</firstname>
                          <surname>Fox</surname>
                  </personname>
          </author>
          <productname>NSCLDAQ</productname>
          <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='tcl3_statemanager_title'>statemanager</refentrytitle>
           <manvolnum>3tcl</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>statemanager</refname>
           <refpurpose>Tcl Bindings to the CStateManager class.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <synopsis>
lappend auto_path [file join $::env(DAQROOT) TclLibs]
package require stateclient

::nscldaq::statemanager mgr requri ?suburi?
::nscldaq::statemanager -delete mgr

mgr programParentDir ?newpath?
mgr setProgramState  name newstate

mgr addProgram       name programDict
set programDict [mgr getProgram name]
mgr modifyProgram    name programDict

mgr setEditorPosition name x y
set x [mgr getEditorXPosition name]
set y [mgr getEditorYPosition name]

mgr enableProgram    name
mgr disableProgram   name
if {[mgr isProgramEnabled name]} {...}

mgr setStandalone    name
mgr setNoStandalone  name
if {[mgr isStandalone name]} {...}

foreach program [mgr listPrograms] {...}
foreach program [mgr listEnabledPrograms] {...}
foreach program [mgr listStandalonePrograms] {...}
foreach program [mgr listActivePrograms] {...}
foreach program [mgr listInactivePrograms] {...}

mgr deleteProgram name

mgr setGlobalState newState
set state [mgr getGlobalState]

set partDict [mgr getParticipantStates]

mgr title ?newTitle?
mgr timeout ?newTimeout?
mgr recording ?newRecordingState?
mgr runNumber ?newRunNumber?

mgr waitTransition ?callback?

mgr processMessages ?callback?

if {[mgr isActive name]} {...}
set state [mgr getProgramState name]

          </synopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This package provides a Tcl binding to
            <link linkend='daq3_cstatemanager'
                  endterm='daq3_cstatemanager_title' />
            The binding is implemented via a construction command
            which produces a command ensemble that wraps an instance
            of a <classname>CStateManager</classname>.
            Subcommands of he ensemble base command map directly to
            methods in the underlying <classname>CStateManager</classname>
            object.
           </para>
           <para>
            An ensemble is constructed via a command of the form:
           </para>
           <informalexample>
            <cmdsynopsis>
            <command>
::nscldaq::statemanager <replaceable>mgr requri ?suburi?</replaceable>
            </command>
            </cmdsynopsis>
           </informalexample>
           <para>
            <parameter>mgr</parameter> is the name of a new command
            that is created by this command.
            <parameter>requri </parameter> and <parameter>suburi</parameter>
            are the URI's that describe the REQ and SUB ports respectively
            of a variable database server that is managing the variable
            database that we want to connect to.
           </para>
           <para>
            If only the REQ URI is provided, the api ensemble can connect to
            a <literal>file:</literal> URI designating the database file.
            If only the REQ URI is provided
            only some of the subcommands described are legal.
            See <literal>ENSEMBLE SUBCOMMANDS</literal> for information
            about which commands are not legal when a single URI is used.
           </para>
           <para>
            An ensemble created in this way is destroyed by:
           </para>
           <informalexample>
            <cmdsynopsis>
                <command>
::nscldaq::statemanager -delete <replaceable>mgr</replaceable>
                </command>
            </cmdsynopsis>
           </informalexample>
           <para>
            Where <parameter>mgr</parameter> is the name of the command
            ensemble previously created by the
            <command>::nscldaq::statemanager</command> command.
           </para>
        </refsect1>
        <refsect1>
           <title>
              ENSEMBLE SUBCOMMANDS
           </title>
           <variablelist>
            <varlistentry>
                <term>
                    <command>mgr programParentDir ?newpath?</command>
                </term>
                <listitem>
                    <para>
                        Without the <parameter>newpath</parameter> optional
                        parameterk this returns the path to the current
                        program parent diretory.  With the parameter it
                        sets a new program parent path.
                        <parameter>newpath</parameter> must be a path
                        to an existing directory in the variable database.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr setProgramState  name newstate</command>
                </term>
                <listitem>
                    <para>
                        Changes the local state of a specific program.
                        The program is <parameter>name</parameter>
                        which is assigned the <parameter>newstate</parameter>.
                        Naturally <parameter>newstate</parameter> must
                        be compatible with the set of target states
                        allowed given the current state.
                    </para>
                    <para>
                        This is normally used to modfiy the state of
                        standalone programs or, if a program has crashed,
                        to set its state to <literal>NotReady</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>mgr addProgram       name programDict</command></term>
                <listitem>
                    <para>
                        Adds a new program; <parameter>name</parameter> to
                        the system. <parameter>name</parameter> must be
                        unique.  The <parameter>programDict</parameter>
                        is a dict that describes the new program.
                        It has the following key/value pairs:
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term><literal>path</literal> (required)</term>
                            <listitem>
                                <para>
                                    The path to the program to run.  This is
                                    used by the boot manager to start the
                                    program.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>host</literal> (required></term>
                            <listitem>
                                <para>
                                    The host in which the program should be run.
                                    This is used by the boot manager to starty
                                    the program.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>enabled</literal></term>
                            <listitem>
                                <para>
                                    Optional parameter that defaults to
                                    <literal>true</literal>.  Determines the
                                    initial enable state of the program.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>standalone</literal></term>
                            <listitem>
                                <para>
                                    Optional parameter that defaults to
                                    <literal>false</literal>.  Determines
                                    the initial state of the standalone flag
                                    of the program.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>outring</literal></term>
                            <listitem>
                                <para>
                                    Optional parameter that defaults to an
                                    empty string.  If the program is data
                                    producer for a ring buffer this should be the
                                    name of that ring (not URI).
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>inring</literal></term>
                            <listitem>
                                <para>
                                    Optional parameter that defaults to an
                                    empty string.  If the program is a data
                                    consumer froma  ring, this shold
                                    be the URI of that ring.
                                </para>
                            </listitem>
                        </varlistentry>
                        
                    </variablelist>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr getProgram name</command>
                </term>
                <listitem>
                    <para>
                        Returns a dict that describes the program
                        <parameter>name</parameter>.  The dict is described
                        in <command>addProgram</command> above.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr modifyProgram    name programDict</command>
                </term>
                <listitem>
                    <para>
                        Modifies the program <parameter>name</parameter>
                        in accordance with the <parameter>programDict</parameter>
                        parameter.  This dictionary is described in
                        <command>addProgram</command> above.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr setEditorPosition name x y</command>
                </term>
                <listitem>
                    <para>
                        Sets the canvas position associated with the program
                        <parameter>name</parameter> to <parameter>x</parameter>,
                        <parameter>y</parameter>.  This position is normally saved
                        by the experiment dataflow editor and used when restoring
                        a setup to layout the diagram elements as they were
                        before.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>set x [mgr getEditorXPosition name]</command>                    
                </term>
                <listitem>
                    <para>
                        Retrieves the x coordinate of the editor canvas
                        position for the program <parameter>name</parameter>.
                        See <command>setEditorPosition</command> for more
                        about this value.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    set y [mgr getEditorYPosition name]                    
                </term>
                <listitem>
                    <para>
                        Retrieves the y coordinate of the editor canvas position
                        for the program <parameter>name</parameter>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr enableProgram    name</command>
                </term>
                <listitem>
                    <para>
                        Enables the program <parameter>name</parameter>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr disableProgram   name</command>
                </term>
                <listitem>
                    <para>
                        Disables the program <parameter>name</parameter>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr isProgramEnabled name</command>
                </term>
                <listitem>
                    <para>
                        Returns true if <parameter>name</parameter>
                        is an enabled program.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr setStandalone    name</command>
                </term>
                <listitem>
                    <para>
                        Set the program <parameter>name</parameter>
                        to standalone mode.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr setNoStandalone  name</command>
                </term>
                <listitem>
                    <para>
                        Take the program <parameter>name</parameter>
                        out of standalone mode.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr isStandalone name</command>
                </term>
                <listitem>
                    <para>
                        Returns true if the program <parameter>name</parameter>
                        is in standalone mode.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr listPrograms</command>
                </term>
                <listitem>
                    <para>
                        Returns a list of the names of all programs
                        in the current program directory.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr listEnabledPrograms</command>
                </term>
                <listitem>
                    <para>
                        Returns a list of the names of all programs
                        that are enabled.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr listStandalonePrograms</command>
                </term>
                <listitem>
                    <para>
                        Returns a list of the names of programs that are
                        standalone.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr listActivePrograms</command>
                </term>
                <listitem>
                    <para>
                        Returns a list of the names of programs  that
                        are active.  A program is active if it is enabled
                        and not standalone; that is it will participate in
                        global state transitions.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr listInactivePrograms</command>
                </term>
                <listitem>
                    <para>
                        Return a list of the names of programs that are
                        not active.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr deleteProgram name</command>
                </term>
                <listitem>
                    <para>
                        Deletes the program <parameter>name</parameter>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr setGlobalState newState</command>
                </term>
                <listitem>
                    <para>
                        Only legal on a two URI construction
                    </para>
                    <para>
                        Set the global state to <parameter>newState</parameter>.
                        The <parameter>newState</parameter> must be a legal
                        next state for the current global state value.
                        In general, this command will initiate a global
                        state transition.  See <command>waitTransition</command>
                        for information about how to monitor that
                        state transition for success and progress.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr getGlobalState</command>
                </term>
                <listitem>
                    <para>
                        Only legal on a two URI construction
                    </para>
                    <para>
                        Returns the current value of the global state
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr getParticipantStates</command>
                </term>
                <listitem>
                    <para>
                        Only legal on a two URI construction
                    </para>
                    <para>
                        Returns a dict.  The dict keys are the
                        names of participant (active) programs.
                        Their values are the states of those programs.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr title ?newTitle?</command>
                </term>
                <listitem>
                    <para>
                        Only legal on a two URI construction
                    </para>
                    <para>
                        If <parameter>newTitle</parameter> is not supplied,
                        this returnst the current title string. If
                        <parameter>newTitle</parameter> is supplied, that
                        becomes the new title string..
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr timeout ?newTimeout?</command>
                </term>
                <listitem>
                    <para>
                        Only legal on a two URI construction
                    </para>
                    <para>
                        If <parameter>newTimeout</parameter> is not
                        supplied, the command returns the current state
                        transition timeout in seconds.  If
                        <parameter>newTimeout</parameter> is supplied,
                        it must be an integer greater than zero and
                        becomes the new state transition timeout.
                        
                    </para>
                    <para>
                        Note that state transition timeouts are enforced
                        by <command>waitTransition</command>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr recording ?newRecordingState?</command>
                </term>
                <listitem>
                    <para>
                        Only legal on a two URI construction
                    </para>
                    <para>
                        If <parameter>newRecordingState</parameter> is
                        supplied it becomes the new recording state flag (must
                        be a boolean).  If not, this command returns the
                        value of the current recording state..
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr runNumber ?newRunNumber?</command>
                </term>
                <listitem>
                    <para>
                        Only legal on a two URI construction
                    </para>
                    <para>
                        If <parameter>newRunNumber</parameter> is supplied
                        it becomes the new run number.  If not this command
                        returns the current run number value.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>mgr waitTransition ?callback?</command>
                </term>
                <listitem>
                    <para>
                        Only legal on a two URI construction
                    </para>
                    <para>
                        Waits for an in progress transition to complete.
                        The command returns a true value if the transition
                        completed successfully and a false value if not.
                    </para>
                    <para>
                        If <parameter>callback</parameter> is supplied it must
                        be a script that is invoked for every program
                        state transition that is observed.  The name of the
                        program and its new state are appended to the
                        callback.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <command>
                        mgr processMessage ?callback?    
                    </command>
                </term>
                <listitem>
                    <para>
                        Only legal on a two URI construction
                    </para>
                    <para>
                        Drains the message queue of subscribed messages.
                        If <parameter>callback</parameter> is supplied,
                        it is invoked for each messsage.
                    </para>
                    <para>
                        A dict is appended to the callback that contains
                        the some of following key value pairs:
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term><literal>type</literal></term>
                            <listitem>
                                <para>
                                    The type of message.  This is one of
                                    <literal>GlobalStateChange</literal>,
                                    <literal>ProgramStateChange</literal>
                                    <literal>ProgramJoins</literal> or
                                    <literal>ProgramLeaves</literal> with
                                    pretty obvious meanings.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>state</literal></term>
                            <listitem>
                                <para>
                                    This is present for either
                                    <literal>GlobalStateChange</literal> or
                                    <literal>ProgramStateChange</literal>.
                                    It contains the new state (global or program).
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>program</literal></term>
                            <listitem>
                                <para>
                                    Contains the name of the program involved.
                                    This is present for:
                                    <literal>ProgramStateChange</literal>
                                    <literal>ProgramJoins</literal> or
                                    <literal>ProgramLeaves</literal>.
                                </para>
                            </listitem>
                        </varlistentry>
                        
                    </variablelist>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>mgr isActive name</command></term>
                <listitem>
                    <para>
                        Retruns true if the program <parameter>name</parameter>
                        is active.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>getProgramState name</command></term>
                <listitem>
                    <para>
                        Only legal on a two URI construction
                    </para>
                    <para>
                        Returns the current program state for
                        <parameter>name</parameter>.
                    </para>
                </listitem>
            </varlistentry>
           </variablelist>
        </refsect1>

      </refentry>


<!-- /manpage -->


<!-- manpage 3python -->

<refentry id="python3_statemanager">
  <refentryinfo>
    <author>
        <personname>
            <firstname>Ron</firstname>
            <surname>Fox</surname>
        </personname>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='python3_statemanager_title'>statemanager</refentrytitle>
     <manvolnum>3python</manvolnum>
         <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>statemanager</refname>
     <refpurpose>Python bindings for CStateManager class.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
   <synopsis>
import nscldaq.vardb.statemanager
mgr = nscldaq.vardb.statemanager.Api(reqUri[, subUri])
mgr.getProgramParentDir()
mgr.setProgramParentDir(path)
mgr.addProgram(name, description)
mgr.getProgramDefinition(name)
mgr.modifyProgram(name, description)
mgr.setEditorPosition(name, x, y)
mgr.getEditorXPosition(name)
mgr.getEditorYPosition(name)
mgr.enableProgram(name)
mgr.disableProgram(name)
mgr.isProgramEnabled(name)
mgr.setProgramStandalone(name)
mgr.setProgramNoStandalone(name)
mgr.isProgramStandalone(name)
mgr.listPrograms()
mgr.listEnabledPrograms()
mgr.listStandalonePrograms()
mgr.listInactivePrograms()
mgr.listActivePrograms()
mgr.deleteProgram(name)
mgr.setGlobalState(newState)
mgr.getGlobalState()
mgr.getParticipantStates()
mgr.getTitle()
mgr.setTitle(title)
mgr.getTimeout()
mgr.setTimeout(timeout)
mgr.isRecording()
mgr.setRecording(flag)
mgr.getRunNumber()
mgr.setRunNumber(number)
mgr.waitTransition(callable, arg)
mgr.processMessages(callable, arg)
mgr.isActive(name)
mgr.setProgramState(name, state)
mgr.getProgramState(name)


   </synopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        This module provides a Python binding to the
        <link linkend='daq3_cstatemanager'
              endterm='daq3_cstatemanager_title' />.
     </para>
  </refsect1>
  <refsect1>
     <title>
    METHODS
     </title>
     <variablelist>
        <varlistentry>
            <term>
                nscldaq.vardb.statemanager.Api(reqUri[, subUri])
            </term>
            <listitem>
                <para>
                    Constructs a new state manager API object.
                    <parameter>reqUri</parameter> is the URI
                    of a variable manager's REQ port.
                    <parameter>subUri</parameter> is the
                    URI of the same variable manager's SUB port.
                </para>
                <para>
                    If the optional <parameter>subURI</parameter> is missing
                    several methods will be disabled (an exception raised if used).
                    In that case, the state manager object can specify a
                    <literal>file:</literal> protocol URI, and directly access
                    the database file, or a <literal>tcp:</literal> protocol
                    URI and access the database through a server.
                </para>
                <para>
                    Methods that are disabled with a single URI in the constructor
                    will be flagged in their descriptions below.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.getProgramParentDir()
            </term>
            <listitem>
                <para>
                    Return the path to the current program parent directory.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.setProgramParentDir(path)
            </term>
            <listitem>
                <para>
                    Sets the path to the new program parent directory to be
                    <parameter>path</parameter>.  This should be the path to an
                    already existing directory in the variable database.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.addProgram(name, description)
            </term>
            <listitem>
                <para>
                    Adds a program named <parameter>name</parameter>
                    to the system.  <parameter>description</parameter>
                    is a dictionary that describes the program.
                    <parameter>description</parameter> has the following key
                    value pairs.
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>enabled</literal></term>
                        <listitem>
                            <para>
                                Defaults to true.  If true the
                                program is created enabled.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>standalone</literal></term>
                        <listitem>
                            <para>
                                Defaults to false.  If true, the program
                                is created standalone.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>path</literal></term>
                        <listitem>
                            <para>
                                Required.  The path to the program to run.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>host</literal></term>
                        <listitem>
                            <para>
                                Required.  The host in which the program runs.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>outring</literal></term>
                        <listitem>
                            <para>
                                Optional.  If the program is to produce output
                                into a ringbuffer, this is the name of the
                                ringbuffer into which that data should be put.
                                Default value is the empty string.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>inring</literal></term>
                        <listitem>
                            <para>
                                Optional.  If the program is to consume data from
                                a ringbuffer, this is the URI of the ring.
                                Default value is the empty string.
                            </para>
                        </listitem>
                    </varlistentry>
                    
                </variablelist>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <command>mgr.setEditorPosition(name, x, y)</command>
            </term>
            <listitem>
                <para>
                    Saves the canvas position of the program selected by
                    <parameter>name</parameter>.  The saved coordinates
                    will be <parameter>x</parameter>,<parameter>y</parameter>.
                    This is normally used by the experiment editor to allow it
                    to restore a diagram to the original layout rather than
                    having to compute a layout.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <command>mgr.getEditorXPosition(name)</command>
            </term>
            <listitem>
                <para>
                    Returns the X coordinate of the editor position currently
                    held by <parameter>name</parameter>.   See
                    <command>setEditorPosition</command> for more information on
                    this value and what it means.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <command>mgr.getEditorYPosition(name)</command>
            </term>
            <listitem>
                <para>
                    Return the Y coordinate of the currently saved editor position
                    for <parameter>name</parameter>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.getProgramDefinition(name)
            </term>
            <listitem>
                <para>
                    Returns the program definition dictionary that
                    describes the program <parameter>name</parameter>.
                    The keys and values are described in
                    <methodname>addProgram</methodname> above.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.modifyProgram(name, description)
            </term>
            <listitem>
                <para>
                    Modifies the descriptionof a program.  <parameter>name</parameter>
                    names the program and <parameter>description</parameter>
                    is a dict that provides a new program definition.
                    The dict is described in
                    <methodname>addProgram</methodname>.
                </para>
                <para>
                    A very normal usage pattern is to first use
                    <methodname>getProgramDefinition</methodname> to obtain
                    the definition of the program.  Second change the specifid
                    items you want to change and finally, use
                    <methodname>modifyProgram</methodname> to update the
                    program definition.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.enableProgram(name)
            </term>
            <listitem>
                <para>
                    Enables the program <parameter>name</parameter>.  Enabled
                    programs participate in  state changes.  If they are
                    not standalone, they participate in global tate changes.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.disableProgram(name)
            </term>
            <listitem>
                <para>
                    Disables the program <parameter>name</parameter>.
                    Disabled programs don't participate in state changes.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.isProgramEnabled(name)
            </term>
            <listitem>
                <para>
                    Returnes <literal>True</literal> if
                    <parameter>name</parameter> is enabled else returns
                    <literal>False</literal>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.setProgramStandalone(name)
            </term>
            <listitem>
                <para>
                    Sets the program <parameter>name</parameter> into standalone mode
                    Enabled programs in standalone mode only take state transitions
                    from their local state variable.  This allows them to be
                    run in isolation, without participating in global state
                    transitions.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.setProgramNoStandalone(name)
            </term>
            <listitem>
                <para>
                    Sets the program <parameter>name</parameter> out of
                    standalone mode.  This means that if the program is enabled
                    it will participate in global state transitions.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.isProgramStandalone(name)
            </term>
            <listitem>
                <para>
                    Returns <literal>True</literal> if the program
                    <parameter>name</parameter> is in standalone mode
                    else returns <literal>False</literal>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                 mgr.listPrograms()
            </term>
            <listitem>
                <para>
                    Returns a list that contains the names of all the
                    programs that are known to the state transition system.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.listEnabledPrograms()
            </term>
            <listitem>
                <para>
                    Returns a list of the names of all enabled programs. 
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.listStandalonePrograms()
            </term>
            <listitem>
                <para>
                    Returns a list of the names of all standalone programs.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.listInactivePrograms()
            </term>
            <listitem>
                <para>
                    Return a list of the names of all inactive programs.
                    A programs is inactive if it does not participate in
                    global state transitions.  This can be either because
                    it is disabled or because it is standalone.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.listActivePrograms()
            </term>
            <listitem>
                <para>
                    Returns a list of the names of all programs that are
                    active.  Active programs are those that participate in
                    global state transitions because they are both
                    enabled an <emphasis>not</emphasis> standalone.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.deleteProgram(name)
            </term>
            <listitem>
                <para>
                    Deletes the definition for the program <parameter>name</parameter>.
                    This action is irreversible.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.setGlobalState(newState)
            </term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Sets the new global state value to <parameter>newState</parameter>.
                    This value must be a valid next state for the current state.
                    If successful, in general, this initiates a global state
                    transition in which all active programs participate.
                    You can determine the success of this transition as well
                    as monitor its progress via <methodname>waitTransition</methodname>
                    described below.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.getGlobalState()
            </term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Returns the current global state.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.getParticipantStates()
            </term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Returns a dict whose keys are program names and whose values
                    are the state that program is in.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.getTitle()
            </term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Returns the current title string.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.setTitle(title)
            </term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Sets the title string to the new value <parameter>title</parameter>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.getTimeout()
            </term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Returns the global state transition timeout value in seconds.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.setTimeout(timeout)
            </term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Sets the global state transition timeout to <parameter>timeout</parameter>
                    seconds.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.isRecording()
            </term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Returns <literal>True</literal> if the recording flag
                    is true.  <literal>False</literal> otherwise.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.setRecording(flag)
            </term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Sets the recording flag to the state of the
                    boolean <parameter>flag</parameter>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.getRunNumber()
            </term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Returns the current integer value of the run number.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.setRunNumber(number)
            </term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Set the run number to the unsigned positive value
                    <parameter>number</parameter>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.waitTransition(callable, arg)
            </term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Waits for global transitions to either succeed, fail or
                    timeout.  If the <parameter>callable</parameter> is
                    supplied, it is called for each participant state
                    transition.  The callable is passed:
                </para>
                <variablelist>
                    <varlistentry>
                        <term>Api</term>
                        <listitem>
                            <para>
                                The api object that is doing the
                                <methodname>waitTransition</methodname>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>program</term>
                        <listitem>
                            <para>
                                The name of the transitioning program.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>state</term>
                        <listitem>
                            <para>
                                That program's new state.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                            arg
                        </term>
                        <listitem>
                            <para>
                                The <parameter>arg</parameter> passed
                                to the <methodname>waitTransition</methodname>
                                method.
                            </para>
                        </listitem>
                    </varlistentry>
                    
                </variablelist>
                <para>
                    The method returns <literal>True</literal> if the
                    transition succeeded or <literal>False</literal> if not.
                    Transitions can fail due to a timeout or can fail if a
                    program changes state to <literal>NotReady</literal>
                    indicating it could not complete its part of the
                    global state transition.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.processMessages(callable, arg)
            </term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Process all messages in the subscription message backlog.
                    If <parameter>callable</parameter> is provided it is
                    called for each message processed and receives the
                    following parameters:
                    
                </para>
                <variablelist>
                    <varlistentry>
                        <term>api</term>
                        <listitem>
                            <para>
                                The api object that is executing the
                                <methodname>processMessages</methodname>
                                method.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>notDict</term>
                        <listitem>
                            <para>
                                A notification dictionary (see
                                <literal>PUBLIC VARIABLES, TYPES and CONSTANTS</literal>
                                for more information about this).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>arg</term>
                        <listitem>
                            <para>
                                The <parameter>arg</parameter> parameter
                                passed to <methodname>processMessages</methodname>.
                            </para>
                        </listitem>
                    </varlistentry>
                    
                </variablelist>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.isActive(name)
            </term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Returns <literal>True</literal> if the program
                    <parameter>name</parameter> is active.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                mgr.setProgramState(name, state)
            </term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Sets the program state for <parameter>name</parameter>
                    to <parameter>state</parameter>.  The <parameter>state</parameter>
                    parameter must be a valid next state for the
                    program's current state. 
                </para>
                <para>
                    This method is normally used to make a state transition
                    in a standalone program
                    and to make the state of a program that crashed badly
                    <literal>NotReady</literal> once that has been noticed.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>mgr.getProgramState(name)</term>
            <listitem>
                <para>
                    Not legal with single URI construction.
                </para>
                <para>
                    Returns the name of the program <parameter>name</parameter>'s
                    current state.
                </para>
            </listitem>
        </varlistentry>
     </variablelist>
  </refsect1>
   <refsect1>
      <title>PUBLIC VARIABLES, TYPES and CONSTANTS</title>
      <para>
        This class offers two dictionary types that are important, the
        notification dictionary and the program description dictionary.
      </para>
        <refsect2>
            <title>Notification dictionary</title>
            <para>
                Dictionaries of this type are passed in to the
                notification callback callable in calls to
                <methodname>processMessages</methodname>.  These dicts
                represent the information in a notification message.
            </para>
            <para>
                The <literal>type</literal> key is always present
                and contains a string that describes the notification
                type.  The notification type determines which other keys
                are present.  The possible other keys are
                <literal>state</literal> which is either the global state
                or a program state, and <literal>program</literal>
                which is a program name.
            </para>
            <para>
                Here are the notification types and the keys that are provided
                with them.
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal>GlobalStateChange</literal></term>
                    <listitem>
                        <para>
                            The message notifies you of a global state change.
                            <literal>state</literal> is the only other key
                            in the dictionary and it represents the new state.
                            This may mean some other program is forcing a
                            state transition. 
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <literal>ProgramStateChange</literal>
                    </term>
                    <listitem>
                        <para>
                            A program's state has changed.
                            <literal>program</literal> will contain the
                            name of the program and <literal>state</literal>
                            the new state name.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>ProgramJoins</literal></term>
                    <listitem>
                        <para>
                            Indicates a new program is being added to the
                            system.  <literal>program</literal> is the
                            name of the program.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>PorgramLeaves</literal></term>
                    <listitem>
                        <para>
                            A program has left the system (been deleted).
                            <literal>program</literal> is the name of the
                            program that left.
                        </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>
        </refsect2>
        <refsect2>
            <title>Program description dictionary</title>
            <para>
                This dictionary is used to describe programs.  It is used
                by <methodname>addProgram</methodname> and
                <methodname>modifyProgram</methodname>
                and also is returned by <methodname>getProgramDefinition</methodname>.
                The dictionary has the following keys:
            </para>
            <variablelist>
                <varlistentry>
                    <term><literal>enabled</literal></term>
                    <listitem>
                        <para>
                            Boolean value that is the state of the enable
                            flag for the program.  If the user does not
                            provide this it defaults to <literal>True</literal>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>standalone</literal></term>
                    <listitem>
                        <para>
                            Boolean value that is the state of the
                            standalone flag for the program.  If the user
                            does not provide this it defaults to
                            <literal>False</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>path</literal></term>
                    <listitem>
                        <para>
                            A string value that is the filesystem path
                            in which the program is installed.  This
                            is required and is used by the boot manager
                            to start the program.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>host</literal></term>
                    <listitem>
                        <para>
                            A string which is either the IP address or the
                            DNS hostname of the system on which the program
                            should run.  Again this is used by the boot manager
                            when starting the program.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>outring</literal></term>
                    <listitem>
                        <para>
                            This defaults to an empty string.  If the program
                            produces output in a ring buffer, it should
                            use this value to get the name of the ring buffer
                            it uses for output.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><literal>inring</literal></term>
                    <listitem>
                        <para>
                            This defaults to an empty string.  If the
                            program should be a consumer of data from a
                            ringbuffer it should use this value to get the
                            URI of the ring.
                        </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>
        </refsect2>
   </refsect1>
</refentry>     

<!-- /manpage -->
