#!/bin/sh
# -*- tcl -*-
# The next line is executed by /bin/sh, but not tcl \
exec tclsh "$0" ${1+"$@"}

#    This software is Copyright by the Board of Trustees of Michigan
#    State University (c) Copyright 2014.
#
#    You may use this software under the terms of the GNU public license
#    (GPL).  The terms of this license are described at:
#
#     http://www.gnu.org/licenses/gpl.txt
#
#    Authors:
#             Ron Fox
#             Jeromy Tompkins 
#	     NSCL
#	     Michigan State University
#	     East Lansing, MI 48824-1321



##
# @file tclapitest.test
# @brief Test tcl bindings to the ringbuffer database api.
# @author Ron Fox <fox@nscl.msu.edu>
#
package require tcltest
package require vardb

# Make an empty database file in the test tmp dir.
# return the full path to the file:

proc makeEmptyDb {} {
    set path [tcltest::makeFile "" testing.db]
    file delete $path
    
    vardb::create $path
    return $path
    
}

proc destroyDb file {
    tcltest::removeFile $file
}

# Returna  dict that describes a ring

proc ringToDict {file name host} {
    set h [vardb::open $file]
    set result [dict create name $name host $host]
    
    vardb::cd $h /RingBuffers/$name@$host
    dict set result datasize [vardb::var get $h datasize]
    dict set result maxconsumers [vardb::var get $h maxconsumers]
    
    vardb::close $h
    
    return $result
    
}

tcltest::test pkg-1 {We should be able to require the package} \
-body {
    catch {package require vardbringbuffer}
} -result 0

tcltest::test pkg-2 {Package should create the namespace ::nscldaq} \
-setup {
    package require vardbringbuffer
} \
-body {
    namespace exists ::nscldaq
} -result 1

tcltest::test pkg-3 {Package should create ::nscldaq::vardbringbuffer} \
-setup {
    package require vardbringbuffer
} \
-body {
    info commands ::nscldaq::vardbringbuffer
} -result ::nscldaq::vardbringbuffer


tcltest::test subcommand-needed {The command needs to have a subcommand} \
-setup {
    package require vardbringbuffer
} \
-body {
    catch {::nscldaq::vardbringbuffer}
} -result 1

tcltest::test create {Creating will make a new command} \
-setup {
    package require vardbringbuffer
    set file [makeEmptyDb]
} \
-cleanup {
    ::nscldaq::vardbringbuffer destroy api
    destroyDb $file
} \
-body {
    ::nscldaq::vardbringbuffer create api file://$file
    info commands api
} -result api

tcltest::test destroy {Destroy should make the command go away} \
-setup {
    package require vardbringbuffer
    set file [makeEmptyDb]
} \
-cleanup {
    destroyDb $file
} \
-body {
    ::nscldaq::vardbringbuffer create anapi file://$file
    ::nscldaq::vardbringbuffer destroy anapi
    info commands anapi
    
} -result [list]

tcltest::test create-dup {Duplicate command not allowed} \
-setup {
     package require vardbringbuffer
     set file [makeEmptyDb]
} \
-cleanup {
    ::nscldaq::vardbringbuffer destroy anapi
    destroyDb $file
} \
-body {
    ::nscldaq::vardbringbuffer create anapi file://$file
    catch {::nscldaq::vardbringbuffer create anapi file://$file}
} -result 1

tcltest::test api-needop {API command need an operation} \
-setup {
    package require vardbringbuffer
    set file [makeEmptyDb]
    ::nscldaq::vardbringbuffer create api file://$file
} \
-cleanup {
    ::nscldaq::vardbringbuffer destroy api
    destroyDb $file
} \
-body {
    catch {api}
} -result 1

tcltest::test api-noschema {Initial databases don't have the ring schema} \
-setup {
    package require vardbringbuffer
    set file [makeEmptyDb]
    ::nscldaq::vardbringbuffer create api file://$file
} \
-cleanup {
    ::nscldaq::vardbringbuffer destroy api
    destroyDb $file
} \
-body {
    api haveSchema
} -result 0

tcltest::test make-schema1 {Create the schema shows that it's created} \
-setup {
    package require vardbringbuffer
    set file [makeEmptyDb]
    ::nscldaq::vardbringbuffer create api file://$file
} \
-cleanup {
    ::nscldaq::vardbringbuffer destroy api
    destroyDb $file
} \
-body {
    api createSchema
    api haveSchema
} -result 1

tcltest::test create-1 {Create a ring with default parameters} \
-setup {
    package require vardbringbuffer
    set file [makeEmptyDb]
    ::nscldaq::vardbringbuffer create api file://$file
} \
-cleanup {
    ::nscldaq::vardbringbuffer destroy api
    destroyDb $file
} \
-body {
    api create fox charlie
    ringToDict $file fox charlie
} -result [dict create \
    name fox host charlie datasize [expr 8*1024*1024] maxconsumers 100]

tcltest::test create-2 {Create ring overiding default parameters} \
-setup {
    package require vardbringbuffer
    set file [makeEmptyDb]
    ::nscldaq::vardbringbuffer create api file://$file
} \
-cleanup {
    ::nscldaq::vardbringbuffer destroy api
    destroyDb $file
} \
-body {
    api create fox charlie [dict create datasize [expr 4*1024*1024] maxconsumers 10]
    ringToDict $file fox charlie
} -result [dict create name fox host charlie datasize [expr 4*1024*1024] maxconsumers 10]

tcltest::test destroy {Destroy a ring after creating it} \
-setup {
    package require vardbringbuffer
    set file [makeEmptyDb]
    ::nscldaq::vardbringbuffer create api file://$file
    
    api create fox charlie
} \
-cleanup {
    ::nscldaq::vardbringbuffer destroy api
    destroyDb $file
} \
-body {
    api destroy fox charlie
    set h [vardb::open $file]
    set status [catch {vardb::cd $h /RingBuffers/fox@charlie}]
    vardb::close $h
    
    set status
} -result 1

tcltest::test setmaxdata-1 {Set maximum data with a legal value} \
-setup {
    package require vardbringbuffer
    set file [makeEmptyDb]
    ::nscldaq::vardbringbuffer create api file://$file
    
    api create fox charlie
} \
-cleanup {
    ::nscldaq::vardbringbuffer destroy api
    destroyDb $file
} \
-body {
    api setMaxData fox charlie [expr 4*1024*1024]
    dict get [ringToDict $file fox charlie] datasize
} -result [expr 4*1024*1024]

tcltest::test setmaxdata-2 {Set maximum data with a illegal value} \
-setup {
    package require vardbringbuffer
    set file [makeEmptyDb]
    ::nscldaq::vardbringbuffer create api file://$file
    
    api create fox charlie
} \
-cleanup {
    ::nscldaq::vardbringbuffer destroy api
    destroyDb $file
} \
-body {
    catch {api setMaxData fox charlie [expr -4*1024*1024]}
} -result 1


tcltest::test setmaxclients-1 {set maximum clients to a legal value} \
-setup {
    package require vardbringbuffer
    set file [makeEmptyDb]
    ::nscldaq::vardbringbuffer create api file://$file
    
    api create fox charlie
} \
-cleanup {
    ::nscldaq::vardbringbuffer destroy api
    destroyDb $file
} \
-body {
    api setMaxConsumers fox charlie 10
    dict get [ringToDict $file fox charlie ] maxconsumers
} -result 10

tcltest::test setmaxclients-2 {Set maximum consumers to an illegal value} \
-setup {
    package require vardbringbuffer
    set file [makeEmptyDb]
    ::nscldaq::vardbringbuffer create api file://$file
    
    api create fox charlie
} \
-cleanup {
    ::nscldaq::vardbringbuffer destroy api
    destroyDb $file
} \
-body {
    catch {api setMaxConsumers fox charlie 0}
    
} -result 1

tcltest::test ringInfo {get info about a ring} \
-setup {
    package require vardbringbuffer
    set file [makeEmptyDb]
    ::nscldaq::vardbringbuffer create api file://$file
    
    api create fox charlie
} \
-cleanup {
    ::nscldaq::vardbringbuffer destroy api
    destroyDb $file
} \
-body {
    set apiValue [api ringInfo fox charlie]
    set rawValue [ringToDict $file fox charlie]
    
    expr {$apiValue == $rawValue}
} -result 1

tcltest::test list {get list of dicts about all rings} \
-setup {
    package require vardbringbuffer
    set file [makeEmptyDb]
    ::nscldaq::vardbringbuffer create api file://$file
    
    
} \
-cleanup {
    ::nscldaq::vardbringbuffer destroy api
    destroyDb $file
} \
-body {
    api create fox charlie
    api create built charlie [dict create datasize 1000000 maxconsumers 10]
    
    set listing [api list]
    
    lappend sb [ringToDict $file built charlie]
    lappend sb [ringToDict $file fox charlie]

    
    expr {$sb == $listing}
} -result 1

#-------------------------------------------------------------------------------
#
#   Global test teardown/reporting.


proc tcltest::cleanupTestsHook {} {
    variable numTests
    set ::exitCode $numTests(Failed)
}


tcltest::cleanupTests
