<!-- chapter frameworks -->

<chapter id="ch.usbframework">
    <title>Framework for xx-USB readout software</title>
    <para>
        This software provides a framework that can be specialized
        to produce readout software for the Wiener/JTEC USB controller modules.
        Specific implementations of readout programs for the
        <link linkend="ch.vmusbReadout">VM-USB (USB VME
        interface)</link>, and the CC-USB (USB CAMAC interface) have been written.
    </para>
    <para id="ch.vmusbReadout"></para>
    <para>
        This chapter consists of the following sections:
        <itemizedlist>
            <listitem>
                <para>
                    <link linkend="ch.usbframework.introduction">Introduction</link>,
                    an introduction to the framework, the devices it intended to
                    support and how it works.  Much of this can be skimmed by most
                    people as it contains information intended for developers.
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend="ch.usbframework.linking">Libraries and Linking</link>,
                    Describes the
                    set of libraries that make up the framework and how
                    to compile and link against them.
                </para>
            </listitem>
            <listitem>
                <para>
                    <link linkend="ch.usbframework.using">Using the Framework</link>,
                    Describes how to invoke specialized versions of the framework.
                </para>
            </listitem>
        </itemizedlist>
    </para>
    <section id="ch.usbframework.introduction">
        <title>Introduction</title>
        <para>
            Weiner/Jtec provide a pair of USB interfaces with similar capabilities.
            The VM-USB is a USB to VME interface, while the CC-USB is a USB
            to CAMAC interface.  Both interfaces provide support for
            autonomous mode data taking. 
        </para>
        <para>
            While the VM-USB and CC-USB are quite similar programmatically,
            they are different enough that separate readout programs are required
            for each interface.  The commmon code has been extracted into this
            framework.   The framework makes it possible to add capability to both
            programs in a central place, while providing better maintainability
            than a pair of completely separate programs would allow.
        </para>
        <para>
            The programs that result from building on this framework can
            be used with the Readout GUI, and provide data to the
            ring buffer based data distribution system of the NSCL DAQ.
            The remainder of this section describes the architecture of the framework.
            If you are not building support for an xx-USB like controller you can
            probably ignore much of the remainder of this section.
        </para>
        <para>
            For information about specific specializations of this software, see
            the chapters that describe that specialization.
        </para>
        <section>
            <title>Active Software Structure</title>
            <para>
                The running framework must solve the following set of problems:
                <itemizedlist>
                    <listitem>
                        <para>
                            When data taking is active, the VM-USB works
                            best if there is always a read pending on its event
                            data pipe.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            The user interface, must always be live to allow an
                            active data taking run to be stopped.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            The format of the data from the xx-USB devices requires
                            a bit of device dependent massaging before it can
                            be inserted into ring buffers.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Only one program can interact with the xx-USB device,
                            though external programs may wish to interact with
                            slow control devices that can only be contacted via
                            the USB interface...even while data taking is active.
                        </para>
                    </listitem>
                </itemizedlist>
            </para>
            <para>
                All of these concerns have led to a multithreaded programming framework.
                Each thread has a distinct set of functions it fulfills:
                <variablelist>
                    <varlistentry>
                        <term>Main</term>
                        <listitem>
                            <para>The main thread is an extended Tcl interpreter.
                                It is responsible for starting all of the other
                                threads that are persistent (see below), and
                                adding commands to the interpreter so that
                                runs can be started, paused, resumed and stopped.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>Readout</term>
                        <listitem>
                            <para>
                                This thread is started by the main thread when a
                                run begins.  It sets up the USB device for
                                data taking and processes buffers from that
                                device.
                            </para>
                            <para>
                                Per buffer processing is quite limited.  Buffers
                                are simply placed in an output queue for processing
                                by the Output thread (see below).
                            </para>
                            <para>
                                Between buffer arrivals and when buffer reads time out,
                                the readout program examines a request queue.
                                The request queue can have entries from the
                                main thread requesting it to pause or end data taking.
                                A Server thread (see below), and also request a
                                pause in data taking so that slow control devices
                                can be accessed.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>Output</term>
                        <listitem>
                            <para>
                                This thread takes buffer from the Readout thread's
                                output queue and turns events in them them into
                                the appropriate items in a ring buffer.
                                The ring buffer name is the same as the name of the user
                                running the program.  This allows several users to
                                take data on the same system simultaneously (but not one user to take
                                data from multiple sources on the same system).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>Server</term>
                        <listitem>
                            <para>
                                This thread listens on a TCP/IP port.  Connecting
                                clients are then allowed to send commands that
                                perform slow control.  The server interacts,
                                if needed with Readout to halt data taking
                                while it plays with devices.
                            </para>
                            <para>
                                The
                                Server is actually an extended Tcl interpreter,
                                with the extensions providing the commands for
                                slow control
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </para>
        </section>
        <section>
            <title>Logical Software Structure</title>
            <para>
                The logical software structure must solve the following set of
                problems:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        Each USB device must be controlled slightly differently
                        by the Readout thread, and the software should only
                        be allowed to connect with the correct type of
                        interface.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The format of data in the output buffers may be
                        different from device to device.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Each interface will have support for a different set
                        of acquisition and control modules, and how they
                        set up their lists is an interface specific
                        thing.
                    </para>
                </listitem>
                
            </itemizedlist>
            <para>
                We will next describe the base classes that can be extended to provide
                device specific functionality and, in general terms, the how to
                do these extensions.  The reference material will provide
                detailed descriptions of these classes.  The source code
                in the <filename>usb/vmusb</filename> and
                <filename>usb/ccusb</filename> directories serves as example
                code that you can look at by downloading the source code distribution
                of the NSCL DAQ software.
            </para>
            <section>
                <title>Configurable Objects and Data taking modules</title>
                <para>
                    Objects which take data usually must be configured.
                    This is done by interpreting a configuration script
                    in a slave, extended interpreter.  The USB Readout
                    framework provides support to make the creation
                    of configurable device support relatively simple.
                </para>
                <para>
                    The core of this is the <classname>CConfiguration</classname>
                    object. This is created by the framework.  Device specific code
                    provides commands for the configuration object, and devices
                    themselves, provide configuration options they understand.
                    Configuration options are name value pairs.  By convention names
                    start with a <literal>-</literal>. For example
                    <literal>-base</literal> is usually the name of the configuration
                    option that specifies a VME module's base address in the
                    VM-USB specialization of this software.
                </para>
                <para>
                    Let's take this a bit at a time starting with the actual device
                    support modules.
                </para>
                <para>
                    Each device is a class that is derived (usually indirectly)
                    from <classname>CConfigurableObject</classname>.
                    <classname>CConfigurableObject</classname> objects have
                    a protected member data; <varname>m_pConfiguration</varname>.
                    That member points to a <classname>CItemConfiguration</classname>
                    object that holds the configuration for the module as well as
                    definitions of the configurable parameters of the module.
                </para>
                <para>
                    Key member functions of the <classname>CItemConfiguration</classname>
                    are shown below.  See the reference material for more:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><function>addParameter</function></term>
                        <listitem>
                            <para>
                                Allows you to define a configuration parameter.
                                Configuration parameters can have
                                <firstterm>validator</firstterm> functions
                                attached to them.  Validators allow the
                                object to determine if an attempt to
                                provide a specific value for a configuration
                                parameter is legal.  For example, the
                                <literal>-base</literal> configuration
                                parameter should not be able to accept
                                <literal>george</literal>, but might be able to accept
                                <literal>0xdead0000</literal>.
                            </para>
                        </listitem>
                    </varlistentry>

                    <varlistentry>
                        <term><function>configure</function></term>
                        <listitem>
                            <para>
                                Allows a caller to attempt to provide a value for
                                a configuration item.  
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><function>cget</function></term>
                        <listitem>
                            <para>
                                Allows you to retrieve the string value of a
                                configuration parameter.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><function>getIntegerParameter</function>,
                              <function>getUnsignedParameter</function>,
                              <function>getBoolParameter</function>,
                              <function>getFloatparameter</function>
                              <function>getIntegerList</function>
                        </term>
                        <listitem>
                            <para>
                                Provide ways to fetch a configuration item
                                and interpret it as a type other than a string.
                                If you use these, you should supply a validator
                                with the configuration item that ensures
                                the item will have strings of the correct type.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>validators</term>
                        <listitem>
                            <para>
                                The class provides several static functions that
                                perform common validations.  For example,
                                <function>CItemConfiguration::isInteger</function>
                                ensures that a value is an integer, optionally
                                checking it against range constraints.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    <classname>CConfigurableObject</classname> objects therefore,
                    are what the name implies.  Objects that have a configuration.
                    <classname>CConfigurableObject</classname> objects use a
                    two stage construction.  The object is constructed, and then
                    a <classname>CItemConfiguration</classname> is attached to the
                    object via the <methodname>Attach</methodname> member.
                    This allows for objects to have configurations that are
                    subclasses of <classname>CItemConfiguration</classname>.
                </para>
                <para>
                    <classname>CConfigurableObject</classname> is an abstract
                    base class. It uses the <methodname>onAttache</methodname>
                    pure virtual member function, supplied by your derived
                    classes to define the configuration parameters an object
                    supports.
                </para>
                <para>
                    Other member functions of interest (see the reference material
                    for more information):
                </para>
                <variablelist>
                    <varlistentry>
                        <term><methodname>Attach</methodname></term>
                        <listitem>
                            <para>
                                Call this to attach a configuration to an object.
                                The function will establish this as the new
                                configuration and call <methodname>onAttache</methodname>
                                which is expected to define accepted configuration
                                parameters, their validity checkers and constraints.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>configure</methodname></term>
                        <listitem>
                            <para>
                                Delegates to the configuration's
                                <methodname>configure</methodname> method.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>cget</methodname></term>
                        <listitem>
                            <para>
                                Delegates to the configuration's
                                <methodname>cget</methodname> method.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    Typically each xx-USB specific program will want to
                    add a set of methods that know how to initialize
                    a module and how to contribute a module's readout instructions
                    to a list.
                </para>
                <para>
                    When the Readout thread starts, it runs a configuration Tcl
                    script.  That script is supposed to have commands that
                    create modules and organize them into lists that
                    can be associated with legal xx-USB triggers.
                </para>
                <para>
                    The object that runs that script is the <classname>CConfiguration</classname>
                    object.  A pointer to that object is stored in <varname>::Globals::pConfig</varname>
                </para>
                <para>
                    The <classname>CConfiguration</classname> maintains modules as a collection of
                    named <classname>CConfigurableObject</classname> pointers.  In addition, each
                    object can have a type associated with it (types are strings).
                </para>
                <para>
                    The <classname>CConfiguration</classname>
                    also maintains the interpreter used to process the
                    configuration script.  The interpreter can have
                    additional command registered on it.
                    These command are typically commands that
                    allow the script to create module support objects.
                </para>
                <para>
                    When constructing an object, these commands must
                    create an appropriate <classname>CConfigurableObject</classname>,
                    attach an item configuration to it and make it known to the configuration.
                </para>
                <para>
                    <classname>CConfiguration</classname> has the following key member functions:
                    For more information see the reference pages.
                </para>
                <variablelist>
                    <varlistentry>
                        <term><methodname>addObject</methodname></term>
                        <listitem>
                            <para>
                                Adds an object to the configuration.  The object
                                must have an item configuration attached to it
                                as it will probably be configured later on
                                during program execution.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>getObjectsOfType</methodname></term>
                        <listitem>
                            <para>
                                Returns a vector of the objects that match
                                a specific type.  This would typically be called
                                by the xx-USB specific setup code.  For example,
                                the VM-USB defines a <literal>stack</literal>
                                type to represent the readout lists.
                                It requests a list of all the <literal>stack</literal>
                                objects, asks each to initialize its modules,
                                create its list and then loads each list into
                                the interface.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>findObjectByName</methodname></term>
                        <listitem>
                            <para>
                                Locates an object given a name.  This is often used
                                by container objects and by command objects to
                                ensure the existence of objects or to
                                ensure that a new object will not clash in name
                                with an existing object.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>addCommand</methodname></term>
                        <listitem>
                            <para>
                                Adds a new command object to the interpreter that
                                processes configuration files.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>clearConfiguration</methodname></term>
                        <listitem>
                            <para>
                                Clears the set of modules from the configuration.
                            </para>
                        </listitem>
                    </varlistentry>
                    
                </variablelist>
            </section>
            <section>
                <title>The Device Driver and the Readout Thread</title>
                <para>
                    The Readout thread makes use of a pair of software
                    design patterns.  <classname>CAcquisitionThread</classname>
                    is a singleton object, having a <methodname>getInstance</methodname>
                    member function that returns a pointer to the object, creating it
                    if necessary.  The object itself uses a strategy pattern to
                    encapsulate the code that is interface dependent. The
                    <methodname>setDriver</methodname> provides a pointer to a
                    <classname>CUSBDeviceDriver</classname> derived object
                    that has methods that handle the device specific requests.
                </para>
                <para>
                    Each specific reealization of the code must implement
                    code that calls <methodname>setDriver</methodname> passing
                    the appropriate device driver object.  The driver must
                    implement the following interface:
                </para>
                <variablelist>
                    <varlistentry>
                        <term><methodname>usbToAutonomous</methodname></term>
                        <listitem>
                            <para>
                                Starts the device taking data autonomously.
                                Once started, typically these devices cannnot do
                                anything other than send you data until stopped.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>usbReadBuffer</methodname></term>
                        <listitem>
                            <para>
                                Read a block of data from the device.  This is intended
                                to read a block of data acquired in autonomous mode.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>usbSetup</methodname></term>
                        <listitem>
                            <para>
                                Prepares the device for data taking.
                                This includes figuring out the lists to load
                                loading and enabling them.  This will be called
                                prior to <methodname>usbToAutonomous</methodname>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>usbGetBufferSize</methodname></term>
                        <listitem>
                            <para>
                                Returns the size of a data taking buffer.  This
                                size will be used in buffer allocation and
                                future calls to <methodname>usbReadBuffer</methodname>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>usbStopAutonomous</methodname></term>
                        <listitem>
                            <para>
                                Halts autonomous data taking mode in the device.
                                Following a call to this, you can expect several
                                more calls to <methodname>usbReadBuffer</methodname>
                                to flush data in the USB FIFOs.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>isusbLastBuffer</methodname></term>
                        <listitem>
                            <para>
                                Returns <literal>true</literal> when given a
                                buffer if the buffer is the last one
                                from a data taking run.  This is used by the
                                data flush methods to determine when the flush
                                is complete.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>usbGroinKick</methodname></term>
                        <listitem>
                            <para>
                                This aptly named method is called by the
                                readout code when it thinks the controller has
                                hung.  It is supposed to take drastic action
                                to attempt to unhang the controller.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>usbFlushGarbage</methodname></term>
                        <listitem>
                            <para>
                                Intended to throw away any trash that might be
                                lingering in a usb controler FIFO.  This
                                function should read and discard data
                                until it believes the usb FIFO's are empty.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </section>
            <section>
                <title>Configuring supported slow control modules</title>
                <para>
                    The framework supports a Tcl server that performs slow
                    control operations on the behalf of client software.
                    Typically, client software is a GUI that connects to the
                    Tcl server in the Readout engine to perform slow control
                    operations.   This implies that the Readout software must
                    be running for these applications to work.
                </para>
                <para>
                    The framework is open with respect to control devices.
                    Control devices are described in a configuration file.
                    The configuration file is a Tcl script like all other
                    configuration files in the usb Readout framework.
                    It is processed by a slave interpreter at program start-time.
                    A control configuration file must exist, even if it is empty.
                </para>
                <para>
                    Prior to that time, the set of device driver modules for
                    control modules must be described to the Tcl Server framework
                    so that it knows how to interact with these devices as well
                    as how to interpret the control configuration script.
                </para>
                <para>
                    The prototype pattern is used to describe to the Tcl server
                    the types of modules that can be created.  The prototype
                    pattern creates objects by duplicating existing objects.
                    For each control module type that is supported, a driver
                    module must be registered with the Tcl server and given
                    a device module type name.
                </para>
                <para>
                    When a module of that type is created, the Tcl server
                    duplicates the prototype driver and associates it with
                    the module name so that it can be used to control the
                    module.
                </para>
                <para>
                    The <classname>TclServer</classname> class contains
                    a method named <methodname>addPrototype</methodname>
                    which is used to add a prototype driver to the
                    Tcl server.
                </para>
                <para>
                    Device drivers themselves are derived from the
                    <classname>CControlModule</classname> abstract base
                    class. device drivers for slow control objects are assumed
                    to have some set of named parameters that can be set
                    or retrieved.  Furthermore, device drivers are derived
                    from <classname>CConfigurableObject</classname> so they
                    include a <classname>CItemConfiguration</classname> and
                    can therefore support configuration options.
                    Drivers must implement
                    the following members (see the reference material for full
                    documentation):
                </para>
                <variablelist>
                    <varlistentry>
                    <term><methodname>Initialize</methodname></term>
                    <listitem>
                        <para>
                            Called when a device is specified in the
                            configuration file.  This method is intended
                            to connect the device to the driver, and optionally
                            set it to a known state.  This is an optional
                            method, as a no-op default is provided.
                        </para>
                    </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>onAttach</methodname></term>
                        <listitem>
                            <para>
                                Called when the object is connected to
                                its configuration object.  The driver
                                should define the set of configuration
                                options supported by the device.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>Update</methodname></term>
                        <listitem>
                            <para>
                                Some devices are write only.  This is called
                                to allow drivers to massively update their
                                internal copy of the device state back to the
                                device.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>Set</methodname></term>
                        <listitem>
                            <para>
                                Sets a named parameter in the module to a specific
                                value.  The name and value are not interpreted
                                or validated by the caller in any way. See the
                                reference pages for more information about that,
                                and how drivers should report errors.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>Get</methodname></term>
                        <listitem>
                            <para>
                                Return the current value of a named parameter.
                                The name is not validated by the caller.
                                See the reference pages for more information
                                about how to handle and report error
                                conditions.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>clone</methodname></term>
                        <listitem>
                            <para>
                                Produces a copy of the object.  This is called
                                by the Tcl server to turn the prototype instance
                                of a device driver into an instance of the device
                                driver that is bound to a device.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                <para>
                    Usually, a two-level derivation scheme is used to make
                    controller specific device drivers.  The first level creates
                    a device driver that is still asbstract, but implements the
                    methods above that interact with the hardware in such a way
                    that they delegate to identical methods that also get passed
                    a  controller object.  The second level implements specific
                    device support by using the controller arguments to interact
                    with the hardware.
                </para>
            </section>
            <section>
                <title>The Application object, and the entry point.</title>
                <para>
                    When the system is being started up, the pieces and parts
                    of the system must be created and knit together.  Furthermore,
                    threads objects must be created and started.
                </para>
                <para>
                    While this process is mostly device independent, there are
                    points in the process where device dependent configuration
                    must be performed.  A template method pattern is used to
                    implement this.
                </para>
                <para>
                    The <classname>CApplication</classname> class contains the
                    controller independent implementation sections of code.
                    These invoke pure virtual methods that are expected to implement
                    the device dependent pieces of the startup process.
                </para>
                <para>
                    The following are key methods for the <classname>CApplication</classname>
                    class and its subclasses.
                </para>
                <variablelist>
                    <varlistentry>
                        <term><methodname>main</methodname></term>
                        <listitem>
                            <para>
                                This is the entry point for the initialization.
                                Typically, the program main will create
                                the specialized application object and then
                                invoke its main entry.  See the example
                                below; which is code taken from the
                                <application>VMUSBReadout</application>
                                specialization of this framework.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>selectInterface</methodname></term>
                        <listitem>
                            <para>
                                Called to select and access a USB interface
                                of the appropriate type.  This method should
                                create a device driver object appropriate to the
                                interface, and bind that device driver object into
                                the acquisition thread.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>setupConfiguration</methodname></term>
                        <listitem>
                            <para>
                                Called to set up the daq configuration object so
                                that it is extended with the commands needed to
                                create the daq device driver objects.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>setupTclServer</methodname></term>
                        <listitem>
                            <para>
                                Called to set up the Tcl server, by stocking it
                                with the appropriate set of template device drivers.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>startOutputThread</methodname></term>
                        <listitem>
                            <para>
                                Recall that the outupt thread is derived from
                                a common base class and specialized for the
                                specific device via a template design pattern.
                                This member is called so that the correct
                                <classname>COutputThread</classname> subclass
                                object can be created and started.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><methodname>createBuffers</methodname></term>
                        <listitem>
                            <para>
                                Buffer sizes depend on the interface.  This
                                member function is called to create the
                                buffers in the buffer pool that will be filled
                                by USB reads with event data.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>

            <example>
                <title>Sample main code</title>
                <programlisting>
<![CDATA[
int
main(int argc, char** argv)
{
  App theApp;
  return theApp.main(argc, argv);
}


]]>
                </programlisting>
            </example>
            <para>
                The sample code aboveis the main program for the
                VMUSBReadout program.  The <classname>App</classname>
                class is the specialization of
                <classname>CApplication</classname> for the
                VM-USB.  An instance of that class is created and control
                transferred to its <methodname>main</methodname> method which
                initializes and runs the framework.
            </para>
            </section>
        </section>
    </section>
    <section id="ch.usbframework.linking">
        <title>Libraries and Linking</title>
        <para>
            The framework is made up of tons of libraries and headers.
            The headers are all located in the
            <filename>include</filename> subdirectory of your installation.
            The libraries are in the <filename>lib</filename> subdirectory.
        </para>
        <para>
            Therefore, when you are compiling a  module in a
            specialization of the framework,
            you will need to have something like the following (<literal>daqroot</literal>
            is assumed to point to the base of the DAQ intallation directory tree):
        </para>
        <example>
            <title>Compiling modules in the USB readout framework</title>
            <programlisting>
g++ -c -I$daqroot/include yourmodule.cpp
            </programlisting>
        </example>
        <para>
            When linking you will need to specify the location of thelibraries
            as well as a ton of libraries.  Suppose you have crammed all of your
            specializations into one file that has been compiled to
            <filename>tailoring.o</filename> (I don't recommend actually doing
            this).
        </para>
        <example>
            <title>Linking specialized frameworks</title>
            <programlisting>
gcc -o myapp tailoring.o -L$daqroot/lib \
    -lusbacqcommon -lusbtclcommon -lOutputStage \
    -lThreadComm -lusbapplication -lControlServer \
    -ldaqthreads -ltcl -lusb
            </programlisting>
        </example>
        <para>
            Note that on some/many Linux installations
            <literal>-ltcl</literal> may need to be replaced by a versioned
            library e.g. <literal>-ltcl8.4</literal>, or a link may need to be
            made to establish the 'default' version of Tcl.
        </para>
    </section>
    <section id="ch.usbframework.using">
        <title>Using the Framework</title>
        <para>
            An extension of the framework results in a program.  The
            program accepts a set of command line switches.
            These switches are parsed by the
            <methodname>main</methodname> member function of the
            <classname>CApplication</classname> object.0
        </para>
        <para>
            The following switches are supported:
        </para>
        <variablelist>
            <varlistentry>
                <term><option>--help</option></term>
                <listitem>
                    <para>
                        Prints brief help that descripts the options supported
                        by the program.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--version</option></term>
                <listitem>
                    <para>
                        Prints the program version and exits.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--daqconfig</option>=<replaceable>filename</replaceable></term>
                <listitem>
                    <para>
                        Overrides the default value of the readout configuration script.
                        By default, the readout configuration script it
                        <filename>~/config/daqconfig.tcl</filename>
                    </para>
                    <para>
                        Note that if the configuration file has errors, they will
                        not be detected until a run is started.  Note as well,
                        the configuration file is processed for each begin run,
                        so it can be changed between runs to reflect
                        changes in your hardware, without needing to restart
                        the program.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--ctlconfig</option>=<replaceable>filename</replaceable></term>
                <listitem>
                    <para>
                        Overrides the default control configuration file. By default,
                        the control configuration script is
                        <filename>~/config/ctlconfig.tcl</filename>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--port</option>=<replaceable>portspec</replaceable></term>
                <listitem>
                    <para>
                        Overrides the default port specification.  <replaceable>portspec</replaceable>
                        The port specification determines which port the application
                        listens on for slow control connections.  The
                        <replaceable>portspec</replaceable> can either be an integer port
                        number that must not be in use by any other server in the system,
                        or it can be the string <literal>managed</literal> in which the
                        port manager will be requested to allocated a port for a
                        service named <literal>SlowControls</literal>. See, however
                        <option>--application</option> below.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--application</option>=<replaceable>name</replaceable></term>
                <listitem>
                    <para>
                        If the port manager is used to allocate a port to the
                        slow controls TclServer, this overrides the default
                        application name of <literal>SlowControls</literal> with
                        the one specified by <replaceable>name</replaceable>
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </section>
        
</chapter>
                 
        

<!-- /chapter -->


<!-- manpage 3usbReadout -->

    <refentry id="manpage.CItemConfiguration">
      <refmeta>
         <refentrytitle>CItemConfiguration</refentrytitle>
         <manvolnum>3usbReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CItemConfiguration</refname>
	 <refpurpose>Capture the configuration of a <classname>CConfigurableObject</classname></refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CItemConfiguration.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CItemConfiguration</classname></ooclass>
            <constructorsynopsis>
                <methodname>CItemConfiguration</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CItemConfiguration</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CItemConfiguration&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~CItemConfiguration</methodname>
                                             <void />
            </destructorsynopsis>
         
         <methodsynopsis>
            <type>CItemConfiguration&amp;</type>
            <methodname>operator=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CItemConfiguration&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
         </methodsynopsis>
         <methodsynopsis>
            <type>int</type>
            <methodname>operator==</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CItemConfiguration&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
         </methodsynopsis>
         <methodsynopsis>
            <type>int</type>
            <methodname>operator!=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CItemConfiguration&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
         </methodsynopsis>
        <methodsynopsis>
            <type>std::string</type>
            <methodname>getName</methodname>
            <void /><modifier>const</modifier>
        </methodsynopsis>
        <methodsynopsis>
            <type>std::string</type>
            <methodname>cget</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>ConfigurationArray</type>
            <methodname>cget</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type>
            <methodname>getIntegerParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>unsigned int</type>
            <methodname>getUnsignedParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>bool</type>
            <methodname>getBoolParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>double</type>
            <methodname>getFloatParameter</methodname>
            <methodparam>
            <type>std::string</type> <parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>std::vector&lt;int&gt;</type>
            <methodname>getIntegerList</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type>
            <methodname>addParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>typeChecker</type> <parameter>checker</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>defaultValue</parameter><initializer>std::string("")</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type>
            <methodname>clearConfiguration</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type>
            <methodname>configure</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <modifier>static</modifier> <type>bool</type>
            <methodname>isInteger</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>value</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <modifier>static</modifier>
            <type>bool</type>
            <methodname>isBool</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>value</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <modifier>static</modifier>
            <type>bool</type>
            <methodname>isEnum</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>value</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <modifier>static</modifier>
            <type>bool</type>
            <methodname>isFloat</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>value</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <modifier>static</modifier>
            <type>bool</type>
            <methodname>isList</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>value</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <modifier>static</modifier>
            <type>bool</type>
            <methodname>isBoolList</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>value</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <modifier>static</modifier>
            <type>bool</type>
            <methodname>isIntList</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>value</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <modifier>static</modifier> <type>bool</type>
            <methodname>isStringList</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>value</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
            </methodparam>
        </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            <classname>CItemConfiguration</classname> objects capture a generic
            configuration database.  Configuration databases consist of a set
            of name value pairs.    Methods exist for defining keywords, providing
            them with default values, and mechanisms for validating proposed
            new values.
         </para>
         <para>
            <link linkend="manpage.cconfigurableobject"><classname>CConfigurableObject</classname></link>
            objects most often embed an item configuration.
         </para>
      </refsect1>
      <refsect1>
        <title>Validators</title>
        <para>
            While the raw configuration database is just a set of uninterpreted
            name value pairs, clearly in most cases configuration items
            have constraints on their legal values.
            <classname>CItemConfiguration</classname> uses
            <firstterm>validators</firstterm> to define and enforce these
            constraints.
        </para>
        <para>
            A validator is a function that is associated with a configuration
            parameter.  When a new value is proposed for a configuration
            item, the validator is called and must return <literal>true</literal>
            if the value is acceptable or <literal>false</literal> if not.
        </para>
        <para>
            If the validator returns <literal>false</literal>, a
            <type>std::string</type> exception is thrown with a value
            that begins with <literal>Validation failed for</literal>.
            If the validator fails, the value of the configuration item is
            not modified.
        </para>
        <para>
            The signature of a validator is:
            <programlisting>
typedef bool (*typeChecker)(std::string name, std::string value, void* arg);
            </programlisting>
            where <parameter>name</parameter> is the name of the paramter being
            modified, <parameter>value</parameter> is the proposed new value,
            and <parameter>arg</parameter> is data that is specified when the
            configuration item is specified and passed through to the validator
            without interpretation. 
        </para>
        <para>
            The <classname>CItemConfiguration</classname> class provides several
            static member functions that implement common constraints on
            parameter values. See Public member functions below.
        </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <methodsynopsis>
                <methodname>CItemConfiguration</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Normal constructor for an item configuration object.
                <parameter>name</parameter> specifies the name of the configuration
                object.  The object itself does not use the name, other than
                to be able to deliver it to a client for identification purposes.
            </para>
            <methodsynopsis>
                <methodname>CItemConfiguration</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CItemConfiguration&amp;</type> <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Copy constructor.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <methodname>~CItemConfiguration</methodname>
                                             <void />
            </methodsynopsis>
         <para>
            Destructor.
         </para>
         <methodsynopsis>
            <type>CItemConfiguration&amp;</type>
            <methodname>operator=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CItemConfiguration&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
         </methodsynopsis>
         <para>
            Assignment.
         </para>
         <methodsynopsis>
            <type>int</type>
            <methodname>operator==</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CItemConfiguration&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
         </methodsynopsis>
         <para>
            Equality comparison.
         </para>
         <methodsynopsis>
            <type>int</type>
            <methodname>operator!=</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CItemConfiguration&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
         </methodsynopsis>
         <para>
            Logical not of equality comparison.
         </para>
        <methodsynopsis>
            <type>std::string</type>
            <methodname>getName</methodname>
            <void /><modifier>const</modifier>
        </methodsynopsis>
        <para>
            Returns the name of the configuration item.
        </para>
        <methodsynopsis>
            <type>std::string</type>
            <methodname>cget</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Returns the string value of the configuration parameter
            specified by <parameter>name</parameter>. If <parameter>name</parameter>
            specifies a configuration parameter that has not been defined,
            a <type>std::string</type> exception is thrown.  The text of the
            exception describes this case and is of the form:
            <literal>CItemConfiguration::cget was asked for parameter: </literal>
            <parameter>name</parameter><literal> which is not defined</literal>
        </para>
        <methodsynopsis>
            <type>ConfigurationArray</type>
            <methodname>cget</methodname>
            <void />
        </methodsynopsis>
        <para>
            Returns the values of all of the configuration parameters. See
            <literal>Types and public data</literal> for the definition of
            <type>CItemConfiguration::ConfigurationArray</type>. 
        </para>
        <methodsynopsis>
            <type>int</type>
            <methodname>getIntegerParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            This is a convenience routine that returns the value of
            the configuration parameter <parameter>name</parameter> interpreted
            as an integer.  See <methodname>cget</methodname> for the exception
            thrown if <parameter>name</parameter> is not defined.
            If the value of the configuration parameter is not an integer,
            the string exception
            <literal>Expected an integer parameter value for config. parameter </literal>
            <parameter>name</parameter><literal> got: </literal><replaceable>value</replaceable>
            where <replaceable>value</replaceable> is what a call to <methodname>cget</methodname>
            would return for the parameter.
        </para>
        <para>
            The best way to use this is to define the parameter to use the
            <methodname>CItemConfiguration::isInteger</methodname> validator
            to ensure the parameter never gets set to a non-integer value.
        </para>
        <methodsynopsis>
            <type>unsigned int</type>
            <methodname>getUnsignedParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Returns the value of the configuration parameter <parameter>name</parameter>
            interpreted as an unsigned integer. See <methodname>getIntegerParameter</methodname>
            for the exception specifications as they are identical.
        </para>
        <para>
            Using the <methodname>CItemConfiguration::isInteger</methodname> validator
            with the lower limit set to zero and an unconstrained upper limit
            ensure the parameter value is never a non integer nor a negative
            value, but will cut the upper half of the range of unsigned integers
            off.  It is rare, however for unsigned parameters to have unconstrained upper
            bounds.
        </para>
        <methodsynopsis>
            <type>bool</type>
            <methodname>getBoolParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Returns the value of the configuration parameter
            <parameter>name</parameter> interpreted as a boolean.
            Valid booleans are
            <literal>true</literal>,
            <literal>yes</literal>,
            <literal>1</literal>,
            <literal>on</literal>,
            <literal>enabled</literal>,
            <literal>false</literal>,
            <literal>no</literal>,
            <literal>0</literal>
            <literal>off</literal>
            <literal>disabled</literal>
            with rather obvious meanings.
        </para>
        <para>
            <methodname>cget</methodname> is used to return the string value
            of the parameter so commens about its exceptional cases apply.
            You should use the
            <methodname>CItemConfiguration::isBool</methodname> validator
           with boolean parameters to ensure that they never get set
           to invalid values, as the function actually returns  true if
           the value is in the set of recognized <literal>true</literal>
            values and <literal>false</literal> otherwise.
        </para>
        <methodsynopsis>
            <type>double</type>
            <methodname>getFloatParameter</methodname>
            <methodparam>
            <type>std::string</type> <parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Returns a the configuration parameter <parameter>name</parameter>
            interpreted as a floating point value.  <methodname>cget</methodname>
            is used to initially fetch the string value of the parameter, so
            any exceptions it can throw can be thrown by
            <methodname>getFloatParameter</methodname>.
        </para>
        <para>
            Best practices are to use a
            <methodname>CItemConfiguration::isFloat</methodname> validator
            to ensure the parameter never has an invalid string.
            If, however the string cannot be interpreted as a floating point
            value, a string exception of the following form is thrown:
            <literal>Expected a floating point parameter value for config parameter </literal>
            <parameter>name</parameter><literal> got: </literal><replaceable>value</replaceable>.
        </para>
        <methodsynopsis>
            <type>std::vector&lt;int&gt;</type>
            <methodname>getIntegerList</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Returns the configurationitem <parameter>name</parameter>
            interpreted as a Tcl list of integer values.
            <methodname>cget</methodname> is used, as usual, to get the
            parameter string.
        </para>                            
        <para>
            <methodname>CItemConfiguration::isIntList</methodname> should be
            used as a validator for the parameter so that it never contains
            illegal values.  If the value is not a valid Tcl list, a string
            exception is thrown of the form:
            <literal>Expected a Tcl list for parameter </literal>
            <parameter>name</parameter>
            <literal> got: </literal><replaceable>value</replaceable>.
            Where <replaceable>value</replaceable> is the entire raw string
            value of the parameter.
        </para>
        <para>
            If any of the values in a properly formatted Tcl list do not
            translate to an integer, a string exception is thrown of the following
            form:
            <literal>Expected an integer list element but got </literal>
            <replaceable>listElementString</replaceable>.
        </para>
        <methodsynopsis>
            <type>void</type>
            <methodname>addParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>typeChecker</type> <parameter>checker</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>defaultValue</parameter><initializer>std::string("")</initializer>
            </methodparam>
        </methodsynopsis>
        <para>
            Adds a new configuration parameter.  <parameter>name</parameter> is
            the name of the new parameter.  By convention, this should begin
            with the <literal>-</literal> character.  The <parameter>checker</parameter>
            argument is a pointer to a validator function.  See "Validators" above
            for more information on validators.  This can be
            <literal>NULL</literal>
            if no validation is desired.
        </para>
        <para>
            The <parameter>arg</parameter> argument is passed without interpretation
            to the validator when a new value is proposed for the parameter.  See
            "Pre Defined Validators" below for some ideas about how this can be
            used.
        </para>
        <para>
            <parameter>defaultValue</parameter> provides an initial value for
            the parameter.   The <parameter>defaultValue</parameter> is not
            passed through the validator, as the programmer is assumed to know
            what s/he's doing.  For  example, is possible to use an invalid value
            to indicate that a configuration parameter that is required has not
            been specified.
        </para>
        <methodsynopsis>
            <type>void</type>
            <methodname>clearConfiguration</methodname>
            <void />
        </methodsynopsis>
        <para>
            Clears the configuration.  This is done just prior to executing
            the configuration script.
        </para>
        <methodsynopsis>
            <type>void</type>
            <methodname>configure</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Called to make configuration setting.
            <parameter>name</parameter> is the name of the configuration
            option to set while <parameter>value</parameter>
            is the proposed new value.
        </para>
        <para>
            If a validator is defined for the parameter, and it returns
            <literal>false</literal> a <classname>std::string</classname>
            exception will be thrown.  The exception string will be of
            the form:
            <literal>Validation failed for </literal><parameter> name </parameter>
            <literal> &lt;- </literal><parameter>value</parameter>.
        </para>
      </refsect1>
      <refsect1>
        <title>Pre Defined Validators</title>
        <para>
            The functions below are static member functions.
            They perform the most common validation
            operations, and can be passed as the
            validator argument for
            <methodname>addParameter</methodname>.
        </para>
        <methodsynopsis>
            <modifier>static</modifier> <type>bool</type>
            <methodname>isInteger</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>value</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Validator for integers.  The proposed parameter must fully decode
            as an integer.  When specifying this validator, the
            <parameter>arg</parameter>
            paramete of the
            <methodname>addParameter</methodname> member function should
            be <literal>NULL</literal> if any integer value is acceptable, or
            a pointer to a <classname>CItemConfiguration::Limits</classname>
            struct if range checking is required.
        </para>
        <para>
            See "Types and public data" below for a definition of the
            <classname>CItemConfiguration::Limits</classname> struct.
        </para>
        <methodsynopsis>
            <modifier>static</modifier>
            <type>bool</type>
            <methodname>isBool</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>value</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Validator for booleans.  No <parameter>arg</parameter> is used
            by this validator. Valid values are limited to:
            <literal>true, yes, 1, on, enabled, false, no, 0, off</literal>
            and <literal>disabled</literal>.
        </para>
        <methodsynopsis>
            <modifier>static</modifier>
            <type>bool</type>
            <methodname>isEnum</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>value</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Validator for enumerated paramters.  An enumerated parameter is one
            that can only take one of a distinct, countable set of vales.
            The <parameter>arg</parameter> parameter to the
            <methodname>addParameter</methodname> call must be a pointer to a
            <classname>CItemConfiguration::isEnumParameter</classname>
            object.  This object is described in
            "Types and public data" below, and is descdribes the set of
            legal values the parameter can take.
        </para>
        <methodsynopsis>
            <modifier>static</modifier>
            <type>bool</type>
            <methodname>isFloat</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>value</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Validates that a parameter is a floating point value.
            The proposed parameter must fuly decode to a floating
            point value.  The <parameter>args</parameter>
            parameter of the call to
            <methodname>addParameter</methodname>
            must be a pointer to a
            <classname>CItemConfiguration::FloatingLimits</classname> object, or
            <literal>NULL</literal> if no range checking is desired.
        </para>
        <para>
            The <classname>CItemConfiguration::FloatingLimis</classname>
            describes legal limits on the floatig value allowed.
        </para>
        <methodsynopsis>
            <modifier>static</modifier>
            <type>bool</type>
            <methodname>isList</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>value</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Validator for lists.  The proposed value must parse to a valid
            Tcl list.  The <parameter>arg</parameter> parameter
            of the call to
            <methodname>addParameter</methodname>
            must be a pointer to a
            <classname>CItemConfiguration::isListParameter</classname> struct.
            This struct defines limits on the size of the list as well as
            a validator for the items in the list.
        </para>
        <methodsynopsis>
            <modifier>static</modifier>
            <type>bool</type>
            <methodname>isBoolList</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>value</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Provides a validator for a list of Tcl boolean values.  The
            <parameter>args</parameter>
            parameter for the call to
            <methodname>addParameter</methodname>
            should be a pointer to a
            <classname>CItemConfiguration::ListSizeConstraint</classname>
            if you want to constrain the length of the list.
        </para>
        <para>
            The validator simply constructs a
            <classname>CItemConfiguration::isListParameter</classname>
            specifying <methodname>isBool</methodname> as the validator
            element and returns the value of
            <methodname>isList</methodname>.
        </para>
        <methodsynopsis>
            <modifier>static</modifier>
            <type>bool</type>
            <methodname>isIntList</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>value</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Provides a validator for Tcl lists of integers.  The
            <parameter>args</parameter> parameter for
            <methodname>addParameter</methodname> is a pointer to
            <classname>CItemConfiguration::ListSizeConstraint</classname>
            if you want to limit the size of the list.
        </para>
        <para>
            The validator simply constructs a
            <classname>CItemConfiguration::isListParameter</classname>
            specifying <methodname>isInteger</methodname> as the validator
            element and returns the value of
            <methodname>isList</methodname>.
        </para>
        <methodsynopsis>
            <modifier>static</modifier> <type>bool</type>
            <methodname>isStringList</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>value</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
            </methodparam>

        </methodsynopsis>
        <para>
            Provides a validator for arbitrary Tcl lists of strings.
            The
            <parameter>args</parameter> paramter of the call to
            <methodname>addParameter</methodname> is a pointer to a
            <classname>CItemConfiguration::ListSizeConstraint</classname>.
        </para>
        <para>
            The function simply creates a
            <classname>CItemConfiguration::isListParameter</classname>
            with <literal>NULL</literal> specified for the validator and
            returns the result of <methodname>isList</methodname>.
        </para>
      </refsect1>
      <refsect1>
         <title>Types and public data</title>
         <para>
            The public data types are mostly used for validation.
         </para>
         <refsect2>
            <title>Validator signatures</title>
            <para>
                Validators are functions that determine whether or not
                a proposed change to a configuration parameter provides a valid
                value for that parameter. For more information, see
                "Validators" above.  The signature of the validator is captured
                in the following typedef that is in the global namespace:
                <programlisting>
typedef bool (*typeChecker)(std::string name, std::string value, void* arg);
                </programlisting>
            </para>
            <para>
                Where:
            </para>
            <variablelist>
                <varlistentry>
                    <term><parameter>name</parameter></term>
                    <listitem>
                        <para>
                            Will be the name of the parameter being modified.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>value</parameter></term>
                    <listitem>
                        <para>
                            Will be the proposed new value for the parameter>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><parameter>arg</parameter></term>
                    <listitem>
                        <para>
                            Will be the value of the <parameter>arg</parameter>
                            parameter given to
                            <methodname>addParameter</methodname> when the
                            validator was specified.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                Validator functions are expected to return <literal>true</literal>
                if the proposed value is acceptable, and <literal>false</literal>
                otherwise.
            </para>
                      
        
        
         </refsect2>
         <refsect2>
            <title><classname>CItemConfiguration::limit</classname></title>
            <para>
                The <structname>CItemConfiguration::limit</structname>
                defines a structure that optionally checks a limit.
                It is normally used to compose other validator arguments.
            </para>
            <para>
                The following fields are defined:
            </para>
            <variablelist>
                <varlistentry>
                    <term><structfield>s_checkMe</structfield></term>
                    <listitem>
                        <para>If this <type>bool</type> is <literal>true</literal>,
                        the struct defines a constraint that should be checked.
                        If not, the value can be ignored.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><structfield>s_value</structfield></term>
                    <listitem>
                        <para>
                            The constraint value.  This only has meaning
                            if <structfield>s_checkMe</structfield>
                            is <literal>true</literal>
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
         </refsect2>
         <refsect2>
            <title><classname>Limits</classname></title>
            <para>
                This is an <classname>std::pair</classname> of
                <structname>limit</structname> structs:
            </para>
            <variablelist>
                <varlistentry>
                    <term><structfield>first</structfield></term>
                    <listitem>
                        <para>The lower limit of the pair.
                            remember that <structfield>first.s_checkMe</structfield>
                            must be <literal>true</literal> or else this
                            constraint will be ignored.
                                                
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><structfield>second</structfield></term>
                    <listitem>
                        <para>
                            The upper limit of the pair.
                            <structfield>second.s_checkMe</structfield> must
                            be true in this limit or there will be no upper
                            limit.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
         </refsect2>
         <refsect2>
            <title><type>CItemConfiguration::isEnumParameter</type></title>
            <para>
                This type is defined as a <classname>std::set&lt;std::string&gt;</classname>
                Each element of the set is a string that is a valid value for the
                enumerated parameter.
            </para>
         </refsect2>
         <refsect2>
            <title><structname>CItemConfiguration::ListSizeConstraint</structname></title>
            <para>
                This data type is a struct that defines the range of sizes a list
                parameter can take.   It has the following fields:
            </para>
            <variablelist>
                <varlistentry>
                    <term><type>CItemConfiguration::limit</type> <structfield>s_atLeast</structfield></term>
                    <listitem>
                        <para>
                            The least number of elements the list can have.
                            </para>
                        </listitem>
                    </varlistentry>
                <varlistentry>
                    <term><type>CItemConfiguration::limit</type> <structfield>s_atMost</structfield></term>
                    <listitem>
                        <para>
                            The most number of items the list can contain.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect2>
          <refsect2>
            <title><structname>CItemConfiguration::isListParameter</structname></title>
            <para>
                This data type defines the validity of a list.  It has the capability
                of constraining the size of a list as well as the contents of each
                element of the list. It is a struct that consists of the following fields:
                </para>
            <variablelist>
                <varlistentry>
                    <term><type>CItemConfiguration::ListSizeConstraint</type>
                    <structfield>s_allowedSize</structfield></term>
                    <listitem>
                        <para>
                            This field constrains the size of the list.
                            </para>
                        </listitem>
                    </varlistentry>
                <varlistentry>
                    <term><type>CItemConfiguration::TypeCheckInfo</type>
                    <structfield>s_checker</structfield></term>
                    <listitem>
                        <para>
                            Provides a type checker that can be run
                            on each list element. This field is of the form:
                            <type>std::pair&lt;typeChecker, void*&gt;</type>
                            where the <structfield>first</structfield>
                            item of the pair is a pointer to the type
                            checking function, and the
                            <structfield>second</structfield>
                            is passed uninterpreted to the type checker.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
            </refsect2>
          
            <refsect2>
                <title><type>CItemConfiguration::flimit</type></title>
                <para>
                    <structname>flimit</structname> defines an optional
                    limit on a floating point parameter.
                    </para>
                <variablelist>
                    <varlistentry>
                        <term><type>bool</type> <structfield>s_checkMe</structfield></term>
                        <listitem>
                            <para>
                                If this field is <literal>true</literal>,
                                the limit is checked.   If not, the limit is not
                                enforced.
                                </para>
                            </listitem>
                        </varlistentry>
                    <varlistentry>
                        <term><type>float</type> <structfield>s_value</structfield></term>
                        <listitem>
                            <para>
                                The limit value.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </refsect2>
            <refsect2>
                <title><type>FloatingLimits</type></title>
                <para>
                    Defines optional lower and upper limits on a floating point
                    value.  This is just a
                    <classname>std::pair&lt;flimit, flimit&gt;</classname> object
                    where <structfield>first</structfield> defines the low limit
                    and <structfield>second</structfield>    the upper limit
                    </para>
                </refsect2>
            <refsect2>
                <title><type>CItemConfiguration::ConfigurationArray</type></title>
                <para>
                    This type is used to return the configuration en masse.
                    It is defined as a
                    <classname>std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt;</classname>.
                    Each array element represents a configuration element.  The
                    <structfield>first</structfield> element of the array value is the configuration parameter's
                    name, while the <structfield>second</structfield> element is the value of that parameter.
                </para>
            </refsect2>
      </refsect1>
      <refsect1>
         <title>Exceptions</title>
         <para>
            String exceptions are thrown for most errors.   The string contents
            are suitable for display to users.
         </para>
      </refsect1>

   </refentry>

<refentry id="manpage.cconfigurableobject">
  <refmeta>
     <refentrytitle>CConfigurableObject</refentrytitle>
     <manvolnum>3usbReadout</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>CCOnfigurableObject</refname>
     <refpurpose>Base class for an object that encapsulates a <classname>CItemConfiguration</classname></refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <programlisting>
#include &lt;CConfigurableObject.h&gt;
        </programlisting>
        <classsynopsis>
            <ooclass><classname>CConfigurableObject</classname>    
            </ooclass>
            <constructorsynopsis>
                <methodname>CConfigurableObject</methodname>
                <void />
                </constructorsynopsis>
            <constructorsynopsis>
                <methodname>CConfigurableObject</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>CConfigurableObject&amp;</type> <parameter>rhs</parameter>
                    </methodparam>
                </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier>
                <methodname>~CConfigurableObject</methodname>
                <void />
                </destructorsynopsis>
            <methodsynopsis>
                <type>CConfigurableObject&amp;</type>
                <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>CConfigurableObject&amp;</type>
                    <parameter>rsh</parameter>
                    </methodparam>
                </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>CConfigurableObject&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                <modifier>const</modifier>
                </methodsynopsis>
            <methodsynopsis>
                <type>int</type>
                <methodname>operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier>
                    <type>CConfigurableObject&amp;</type>
                    <parameter>rhs</parameter>
                    </methodparam>
                <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type>
                <methodname>Attach</methodname>
                <methodparam>
                    <type>CItemConfiguration*</type>
                    <parameter>pConfiguration</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type> <parameter>dynamic</parameter>
                                      <initializer>true</initializer>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>configure</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type> <methodname>getName</methodname>
                                         <void /> <modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type>
                <methodname>cget</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>CItemConfiguration::ConfigurationArray</type>
                <methodname>cget</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>abstract virtual</modifier>
                <type>void</type> <methodname>onAttach</methodname>
                                  <void />
            </methodsynopsis>
        </classsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
        This class wraps a <classname>CItemConfiguration</classname> in an object
        that will make use of a configuration.  It does so in a way that the
        object can cleanly set up its own configuration via a two phase construction.
        Several methods of the wrapped <classname>CItemConfiguration</classname> object
        are exposed via delegation.
     </para>
  </refsect1>
  <refsect1>
     <title>
        Public Member Functions
     </title>
    <constructorsynopsis>
        <methodname>CConfigurableObject</methodname>
        <void />
        </constructorsynopsis>
    <para>
        Constructs a configurable object.  Because virtual functions don't
        polymorph at construction time, the configuration is attached later on,
        via the <methodname>Attach</methodname> member function.
    </para>
    <constructorsynopsis>
        <methodname>CConfigurableObject</methodname>
        <methodparam>
            <modifier>const</modifier>
            <type>CConfigurableObject&amp;</type> <parameter>rhs</parameter>
            </methodparam>
        </constructorsynopsis>
    <para>
        Copy construction
    </para>
    <destructorsynopsis>
        <modifier>virtual</modifier>
        <methodname>~CConfigurableObject</methodname>
        <void />
        </destructorsynopsis>
    <para>
        Destruction.
    </para>
    <methodsynopsis>
        <type>CConfigurableObject&amp;</type>
        <methodname>operator=</methodname>
        <methodparam>
            <modifier>const</modifier>
            <type>CConfigurableObject&amp;</type>
            <parameter>rsh</parameter>
            </methodparam>
        </methodsynopsis>
    <para>
        Assignment.
    </para>
    <methodsynopsis>
        <type>int</type> <methodname>operator==</methodname>
        <methodparam>
            <modifier>const</modifier>
            <type>CConfigurableObject&amp;</type>
            <parameter>rhs</parameter>
            </methodparam>
        <modifier>const</modifier>
        </methodsynopsis>
    <para>
        Comparison for equality.
    </para>
    <methodsynopsis>
        <type>int</type>
        <methodname>operator!=</methodname>
        <methodparam>
            <modifier>const</modifier>
            <type>CConfigurableObject&amp;</type>
            <parameter>rhs</parameter>
            </methodparam>
        <modifier>const</modifier>
    </methodsynopsis>
    <para>
        Comparison for not equal.
    </para>
    <methodsynopsis>
        <type>void</type>
        <methodname>Attach</methodname>
        <methodparam>
            <type>CItemConfiguration*</type>
            <parameter>pConfiguration</parameter>
        </methodparam>
        <methodparam>
            <type>bool</type> <parameter>dynamic</parameter>
                              <initializer>true</initializer>
        </methodparam>
    </methodsynopsis>
    <para>
        Attaches a configuration object <parameter>pConfiguration</parameter> to
        the object.  If <parameter>dynamic</parameter> is <literal>true</literal>,
        The destructor will delete this object if not, the configurationobject
        will not be
        deleted on destruction.
    </para>
    <para>
        The configuration object pointer is stored in
        <varname>m_pConfiguration</varname> which is protected, and therefore
        accessible from derived class instances.
    </para>
    <para>
        The <methodname>Attach</methodname> function will invoke the
        <methodname>onAttach</methodname> method.  That method usually
        sets up the configuration with parameter keywords and their constraints.
    </para>
    <para>
        If the <varname>m_pConfiguration</varname> member data is not null
        when this is called, and the value set was set with
        <parameter>dynamic</parameter> equal to <literal>true</literal>,
        the <classname>CItemConfiguration</classname> pointed to by the old
        pointer is <literal>delete</literal>d.  You can disconnect the
        object from any configuration it has by passing a null value for
        the <parameter>pConfiguration</parameter> parameter.
    </para>
    <methodsynopsis>
        <type>void</type> <methodname>configure</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
       <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <para>
        Delegates to <classname>CItemConfiguration</classname>'s
        <methodname>configure </methodname> method.  This attempts to set the
        configuration parameter <parameter>name</parameter>
        to the string <parameter>value</parameter>.
    </para>
    <methodsynopsis>
        <type>std::string</type> <methodname>getName</methodname>
                                 <void /> <modifier>const</modifier>
    </methodsynopsis>
    <para>
        Returns the name of the configuration.
    </para>
    <methodsynopsis>
        <type>std::string</type>
        <methodname>cget</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
    </methodsynopsis>
    <para>
        Returns the value of the configuration parameter <parameter>name</parameter>.
    </para>
    <methodsynopsis>
        <type>CItemConfiguration::ConfigurationArray</type>
        <methodname>cget</methodname>
        <void />
    </methodsynopsis>
    <para>
        Returns the entire contents of the configuration object as a
        <classname>CItemConfiguration::ConfigurationArray</classname> object.
        See "Types and public data" below for more information about that
        data type.
    </para>
    <methodsynopsis>
        <modifier>abstract virtual</modifier>
        <type>void</type> <methodname>onAttach</methodname>
                          <void />
    </methodsynopsis>
    <para>
        The concrete derived class will provide an implementation of this
        function.  That function will usually interact with the configuration
        to define configuration keywords, their initial values and valiators.
    </para>
  </refsect1>
    <refsect1>
        <title>Types and public data</title>
        <para>
            The <varname>m_pConfiguration</varname> member is a protected
            pointer to a <classname>CItemConfiguration</classname> object.
            If the <methodname>Attach</methodname> member has not yet been
            called with a non-null value, this pointer could be null.
        </para>
    </refsect1>

</refentry>

    <refentry id="manpage.cconfiguration">
      <refmeta>
         <refentrytitle>CConfiguration</refentrytitle>
         <manvolnum>3usbReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CConfiguration</refname>
	 <refpurpose>Provide a collection of <classname>CConfigurableObject</classname>s.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CConfiguration.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>Configuration</classname></ooclass>
            <constructorsynopsis>
                <methodname>CConfiguration</methodname>
                <void />
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~CConfiguration</methodname>
                                             <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>void</type>
                <methodname>processConfiguration</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>configFile</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addObject</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>type</parameter>
                </methodparam>
                <methodparam>
                    <type>CConfigurableObject*</type> <parameter>pObject</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setResult</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>result</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>std::vector&lt;ConfigItem&gt;</type>
                <methodname>getObjectsOfType</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>type</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>ConfigurationIterator</type>
                <methodname>findObjectByName</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>ConfigurationIterator</type>
                <methodname>end</methodname> <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addCommandM</methodname>
                <methodparam>
                    <type>CTCLObjectProcessor&amp;</type> <parameter>processor</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>clearConfiguration</methodname>
                                  <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>CTCLInterpreter*</type> <methodname>getInterpreter</methodname>
                                              <void />
            </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            This class contains a collection of pointers to <classname>CConfigurableObject</classname>s.
            Since these are pointers, derived classes can live in this collection as well.
            Each object has a name and type associated with it, that are simple text strings.
         </para>
         <para>
            Search functions are provided.  An object with a specific name
            can be searched for.   All objects of a specified type can also
            be found.
         </para>
         <para>
            A member function also exists to read in the configuration from
            a file, under the assumption that the serialized collection
            can be represented by a Tcl script that has been extended
            appropriately.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <methodsynopsis>
                <methodname>CConfiguration</methodname>
                <void />
            </methodsynopsis>
            <para>
                Constructs a configuration.  Note that it is at this point that
                a Tcl interpreter is constructed as well.  The same Tcl interpreter
                is re-used over and over again to process configuration files, if
                they the <methodname>processConfiguration</methodname> method is
                called several times.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <methodname>~CConfiguration</methodname>
                                             <void />
            </methodsynopsis>
            <para>Destructor</para>
            <methodsynopsis>
                <type>void</type>
                <methodname>processConfiguration</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>configFile</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Processes the file named <parameter>configFile</parameter>
                as a script in the object's interpreter.  Normally, this
                interpreter has been extended with commands that support
                the creation of configuration items, which are added via
                <methodname>addObject</methodname> and manipulation of those
                objects.  This allows the script to influence the contents of
                the configuration collection.
            </para>
            <para>
                Prior to processing the configuration script, the configuration
                is cleared.  The same interpreter is used over and over again,
                however placing the onus on the script writer to ensure that the
                interpreter state is reasonable. 
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>addObject</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>type</parameter>
                </methodparam>
                <methodparam>
                    <type>CConfigurableObject*</type> <parameter>pObject</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Adds an object pointed to by
                <parameter>pObject</parameter>
                to the configuration.  <parameter>name</parameter>
                provides a name that should be unique across all objects.
                Functions that call <methodname>addObject</methodname> should
                ensure that there are no objects that have that name already, or else
                the new object will be masked by the existing object.
            </para>
            <para>
                Objects also have a type.  The type is specified by the
                <parameter>type</parameter> parameter.  Generally objects
                that have the same final type should have the same textual type.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>setResult</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>result</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Sets the result string of the interpreter.  This method is deprecated
                in favor of the <methodname>CTCLInterpreter::setResult</methodname>
                method.
            </para>
            <methodsynopsis>
                <type>std::vector&lt;ConfigItem&gt;</type>
                <methodname>getObjectsOfType</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>type</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Returns a vector that allows you to locate all of the
                objects of type <parameter>type</parameter>.  See
                "Types and public data" for iformation about the
                <structname>CConfiguration::ConfigItem</structname> data type.
            </para>
            <methodsynopsis>
                <type>ConfigurationIterator</type>
                <methodname>findObjectByName</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Returns a <classname>CConfiguration::ConfigurationIterator</classname>
                that is a pointer like object to the the object that has the name
                <parameter>name</parameter>.  If the returned object is equal
                to the result of the <methodname>end</methodname> method, the item
                was not found.
            </para>
            <para>
                The returned item, can be used as if it were a pointer to a
                <structname>CConfiguration::ConfigItem</structname>.
            </para>
            <methodsynopsis>
                <type>ConfigurationIterator</type>
                <methodname>end</methodname> <void />
            </methodsynopsis>
            <para>
                Returns the value of the <classname>CConfiguration::ConfigurationIterator</classname>
                that would be returned by <methodname>findObjectByName</methodname>
                if the object requested does not exist.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>addCommand</methodname>
                <methodparam>
                    <type>CTCLObjectProcessor&amp;</type> <parameter>processor</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Adds a command to the set of commands the object will destroy
                when it is destroyed.  The <parameter>processor</parameter> should
                be a command processor that has been added to the
                object's interpreter.
            </para>
            <methodsynopsis>
                <type>void</type> <methodname>clearConfiguration</methodname>
                                  <void />
            </methodsynopsis>
            <para>
                Clears the configuration.
            </para>
            <methodsynopsis>
                <type>CTCLInterpreter*</type> <methodname>getInterpreter</methodname>
                                              <void />
            </methodsynopsis>
            <para>
                Returns a pointer to the interpreter object that will be used to
                process configuration scripts.
            </para>
        </refsect1>
      <refsect1>
         <title>Types and public data</title>
         <para>
            Each configuration item is stored in a <structname>ConfigItem</structname>
            structure. This structure has the following fields:
         </para>
            <variablelist>
                <varlistentry>
                    <term><type>std::string</type> <structfield>s_name</structfield></term>
                    <listitem>
                        <para>
                            The name of the item.  This is usually the name of
                            some module that can be independently configured.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>std::string</type> <structfield>s_type</structfield></term>
                    <listitem>
                        <para>
                            The type of the item.  This is assigned by the
                            creator of the configuration item.  Types group
                            configurable items into some taxonomy.  They are normally
                            used when ensuring that a module being manipulated is
                            of the correct underlying type.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><type>CConfigurableObject*</type> <structfield>s_pObject</structfield></term>
                    <listitem>
                        <para>
                            Pointer to the actual configurable object.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        <para>
            A <type>Configuration</type> is just a vector collection of
            <type>ConfigItem</type> objects:
            <type>std::vector&lt;ConfigItem&gt;</type>
        </para>
        <para>
            The search by name function an the <methodname>end</methodname>
            member function produce an <firstterm>iterator</firstterm>.
            An iterator in C++ is a pointer like object that can also
            step through a collection.  Since all of the standard template
            library collections support iterators, the
            <type>ConfigurationIterator</type> data type is just a typedef for:
            <type>Configuration::iterator</type>

         </para>
      </refsect1>
      <refsect1>
         <title>Exceptions</title>
         <para>
            While the<classname>CConfiguration</classname> object does not
            itself produce and throw exceptions, it will typically relay an
            exception to the caller after outputting an error message to
            <literal>stderr</literal>.
         </para>
      </refsect1>

   </refentry>

    <refentry id="manpage.cusbdevicedriver">
      <refmeta>
         <refentrytitle>CUSBDeviceDriver</refentrytitle>
         <manvolnum>3usbReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CUSBDeviceDriver</refname>
	 <refpurpose>Interface USB controllers must implement</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CAcquisitionThread.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CUSBDeviceDriver</classname></ooclass>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>usbToAutonomous</methodname>
                <modifier> = 0</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>int</type>
                <methodname>usbReadBuffer</methodname>
                <methodparam>
                    <type>void*</type> <parameter>pBuffer</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t</type>
                    <parameter>bytesToRead</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t*</type> <parameter>bytesRead</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>timeoutInSeconds</parameter>
                </methodparam>
                <modifier>=0</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>usbSetup</methodname>
                        <void />
                        <modifier> = 0</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>size_t</type>
                <methodname>usbGetBufferSize</methodname>
                <void /> <modifier> = 0 </modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>usbStopAutonomous</methodname>
                <void /> <modifier> = 0 </modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>bool</type>
                <methodname>isusbLastBuffer</methodname>
                <methodparam>
                    <type>DataBuffer*</type> <parameter>pBuffer</parameter>
                </methodparam>
                <modifier> = 0 </modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>usbGroinKick</methodname>
                <void />
                <modifier> = 0 </modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>usbFlushGarbage</methodname>
                <void />
                <modifier> = 0</modifier>
            </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            The data taking thread of the VM-USB readout framework requires a
            device driver object that performs the controller specific operations.
            <classname>CUSBDeviceDriver</classname> is an abstract base class that
            defines the interface this device driver must implement.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>usbToAutonomous</methodname>
                <modifier> = 0</modifier>
            </methodsynopsis>
            <para>
                Requests that the controller begin autonomous data taking.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>int</type>
                <methodname>usbReadBuffer</methodname>
                <methodparam>
                    <type>void*</type> <parameter>pBuffer</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t</type>
                    <parameter>bytesToRead</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t*</type> <parameter>bytesRead</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>timeoutInSeconds</parameter>
                </methodparam>
                <modifier>=0</modifier>
            </methodsynopsis>
            <para>
                Does what's needed to read a block of event data from the
                controller.   <parameter>pBuffer</parameter> is where the
                read data should be stored. <parameter>bytesToRead</parameter>
                are the maximum number of bytes to read.
                <parameter>bytesRead</parameter> points to a location into which
                should be stored the actual number of bytes read.
                <parameter>timeoutInSeconds</parameter> is exactly what it says
                it is.  The return value of the function should be:
                <itemizedlist>
                    <listitem>
                        <para><literal>0</literal> for success</para>
                    </listitem>
                    <listitem>
                        <para><literal> -1</literal> for failure and the
                        global <varname>errno</varname> will have the
                        detailed reason the call failed.
                        </para>
                    </listitem>
                </itemizedlist>
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>usbSetup</methodname>
                        <void />
                        <modifier> = 0</modifier>
            </methodsynopsis>
            <para>
                This is called to setup the USB device for data taking.
                In the case of intelligent devices, their readout programs
                must be loaded, and all of the data taking modules
                initialized and made ready to take data.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>size_t</type>
                <methodname>usbGetBufferSize</methodname>
                <void /> <modifier> = 0 </modifier>
            </methodsynopsis>
            <para>
                Returns the number of bytes that should be used to buffer data
                from the controller.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>usbStopAutonomous</methodname>
                <void /> <modifier> = 0 </modifier>
            </methodsynopsis>
            <para>
                Requests that the controller halt data taking.  Note that
                the actual halt is assumed to happen asynchronously.  The
                framework will continue to read buffers from the device
                until a buffer has been read that causes
                <methodname>isusbLastBuffer</methodname> to return
                <literal>true</literal>.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>bool</type>
                <methodname>isusbLastBuffer</methodname>
                <methodparam>
                    <type>DataBuffer*</type> <parameter>pBuffer</parameter>
                </methodparam>
                <modifier> = 0 </modifier>
            </methodsynopsis>
            <para>
                Returns <literal>true</literal> if the data buffer pointed to
                by <parameter>pBuffer</parameter> indicates that it is the last
                one from the controller for this run.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>usbGroinKick</methodname>
                <void />
                <modifier> = 0 </modifier>
            </methodsynopsis>
            <para>
                If the USB controller times out on device reads when it has
                been halted, and no end buffer has been received, this will be
                called to attempt whatever voodoo is required to unfreeze
                the controller.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>void</type> <methodname>usbFlushGarbage</methodname>
                <void />
                <modifier> = 0</modifier>
            </methodsynopsis>
            <para>
                Prior to settting up for data taking, this is called to
                remove any trash that may be stuck in the device's FIFO.
            </para>
            
      </refsect1>
   </refentry>

    <refentry id="manpage.cacquisitionthread">
      <refmeta>
         <refentrytitle>CAcquisitionThread</refentrytitle>
         <manvolnum>3usbReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CAcquisitionThread</refname>
	 <refpurpose>Thread that handles data taking</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CAcquisitionThread.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CAcquisitionThread</classname></ooclass>
            <methodsynopsis>
                <modifier>static</modifier> <type>CAcquisitionThread*</type>
                    <methodname>getInstance</methodname>
                    <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier> <type>void</type>
                <methodname>Start</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier> <type>bool</type>
                <methodname>isRunning</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>static</modifier> <type>void</type>
                    <methodname>waitExit</methodname>
                    <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type>
                <methodname>setDriver</methodname>
                <methodparam>
                    <type>CUSBDeviceDriver*</type> <parameter>pDriver</parameter>
                </methodparam>
            </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            Represents the acquisition thread.  The acquisition thread is
            used to take data from the controller.  It is created using the singleton
            pattern.  This ensures that at any time there is only one acquisition thread.
         </para>
         <para>
            To get a pointer to the acquisition thread object, you must invoke
            the static member function
            <methodname>CAcquisitionThread::getInstance</methodname>.  If necessary, this member
            function will create the thread object (but not start it).
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
         <para>
            Note that since the singleton pattern is used, the constructors for
            this class are all private.  The
            <methodname>CAcquisitionThread::getInstance</methodname> method must
            be called to get a thread instance.
         </para>
           <methodsynopsis>
                <modifier>static</modifier> <type>CAcquisitionThread*</type>
                    <methodname>getInstance</methodname>
                    <void />
            </methodsynopsis>
           <para>
            Returns the instance of the singleton acquisition thread object.
            If the object does not exist yet, it is first created.  A
            pointer to the existing object is returned.  Note that creation
            of the thread object does not imply that the thread has been
            started.
           </para>
            <methodsynopsis>
                <modifier>static</modifier> <type>void</type>
                <methodname>Start</methodname>
                <void />
            </methodsynopsis>
            <para>
                Starts the thread.  This should not be called if the thread is
                running as it will generate a second instance of the thread running
                within the same object.
            </para>
            <methodsynopsis>
                <modifier>static</modifier> <type>bool</type>
                <methodname>isRunning</methodname>
                <void />
            </methodsynopsis>
            <para>
                Returns <literal>true</literal> if the thread is running.
            </para>
            <methodsynopsis>
                <modifier>static</modifier> <type>void</type>
                    <methodname>waitExit</methodname>
            </methodsynopsis>
            <para>
                Waits for the readout thread to exit. The calling thread is
                blocked until the readout thread exits.
            </para>
            <methodsynopsis>
                <type>void</type>
                <methodname>setDriver</methodname>
                <methodparam>
                    <type>CUSBDeviceDriver*</type> <parameter>pDriver</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Sets the device driver object to the object pointed to by
                <parameter>pDriver</parameter>.
            </para>
      </refsect1>

   </refentry>
    <refentry id="manpage.ccontrolqueues">
      <refmeta>
         <refentrytitle>CControlQueues</refentrytitle>
         <manvolnum>3usbReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CControlQueues</refname>
	 <refpurpose>Singleton communication queues with <classname>CAcquisitionThread</classname></refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CControlQueues.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CControlQueues</classname></ooclass>
	    <methodsynopsis>
	       <modifier>static</modifier> <type>CControlQueues*</type>
	       <methodname> getInstance</methodname>
	       <void />
	    </methodsynopsis>
	    <methodsynopsis>
	       <type>void</type> <methodname>AcquireUsb</methodname>
               <void />
            </methodsynopsis>
	    <methodsynopsis>
               <type>void</type> <methodname>ReleaseUsb</methodname>
	       <void />
	    </methodsynopsis>
	    <methodsynopsis>
	       <type>void</type> <methodname>EndRun</methodname>
	       <void />
            </methodsynopsis>
	    <methodsynopsis>
	       <type>void</type> <methodname>PauseRun</methodname>
	       <void />
	    </methodsynopsis>
	    <methodsynopsis>
	       <type>void</type> <methodname>ResumeRun</methodname>
	       <void />
             </methodsynopsis>
 	     <methodsynopsis>
	        <type>void</type> <methodname>Acknowledge</methodname>
		<void />
	     </methodsynopsis>
 	     <methodsynopsis>
	        <type>opCode</type> <methodname>getRequest</methodname>
                <void />
             </methodsynopsis>
	     <methodsynopsis>
	        <type>bool</type> <methodname>testRequest</methodname>
                <methodparam>
		   <type>opCode&amp;</type> <parameter>code</parameter>
		</methodparam>
	     </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
	    The <classname>CControlQueues</classname>
	    is responsible for managing requests from other threads
	    for the acquisition thread.  This class provides a set of
	    specific functions that interact and synchronize with the
	    readout thread on behalf of requesting threads.
         </para>
	 <para>
	    This class represents another singleton object.  The
	    typical users of this class are the acquisition thread,
	    the main thread, and the tcl server thread. 
	 </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
	    <methodsynopsis>
	       <modifier>static</modifier> <type>CControlQueues*</type>
	       <methodname> getInstance</methodname>
	       <void />
	    </methodsynopsis>
	    <para>
	      Returns the instance of the control queues, constructing
	      one if needed.  This static function provides for lazy
	      instantiation of the singleton object.
            </para>
	    <methodsynopsis>
	       <type>void</type> <methodname>AcquireUsb</methodname>
               <void />
            </methodsynopsis>
	    <para>
	       Requests access to the USB controller. The readout thread
	       should respond to this by temporarily pausing acquisition
	       before acknowledging the request.  Once the function
	       returns, the USB controller can be used by the calling thread.
	    </para>
	    <methodsynopsis>
               <type>void</type> <methodname>ReleaseUsb</methodname>
	       <void />
	    </methodsynopsis>
	    <para>
	       Called after a call to <methodname>AcuiqreUsb</methodname>
               to allow the readout thread to continue data taking.
	       The calling thread is indicating that it is done using
	       the USB controller for some significatn period of time.
	    </para>
	    <methodsynopsis>
	       <type>void</type> <methodname>EndRun</methodname>
	       <void />
            </methodsynopsis>
	    <para>
	       Requests that the readout thread end a run.  
	       The method blocks until the readout software
	       acknowleges the command. The acknowledgement arrives
	       after data taking has been halted, but before the
	       end run record is emitted.
	    </para>
	    <methodsynopsis>
	       <type>void</type> <methodname>PauseRun</methodname>
	       <void />
	    </methodsynopsis>
	    <para>
	       Pauses data taking. Data taking may then be either ended
	       or resumed.  While waiting for one of those,
	       the software is live to requests to acquire the USB,
	       and grants them immediately.
	    </para>
	    <methodsynopsis>
	       <type>void</type> <methodname>ResumeRun</methodname>
	       <void />
             </methodsynopsis>
           <para>
                Called by the main thread to resume data taking after
                a pause.  The acquisition thread resumes data taking.
                Note that the configuration is re-read and the
                USB controller is asked to be set up from scratch.
            </para>

	     <methodsynopsis>
	        <type>void</type> <methodname>Acknowledge</methodname>
		<void />
	     </methodsynopsis>
            <para>
                Called by the readout thread to acknowledge a request.
                Usually request functions block until acknowledged.
             </para>

	     <methodsynopsis>
	        <type>opCode</type> <methodname>getRequest</methodname>
                <void />
             </methodsynopsis>
             <para>
                Called by the acquisition thread to dequeue a request from
                the control queues.  The function blocks until a request is
                present, if necessary.  The <type>opCode</type> returned
                indicates what the request was.
             </para>
	     <methodsynopsis>
	        <type>bool</type> <methodname>testRequest</methodname>
                 <methodparam>
		   <type>opCode&amp;</type> <parameter>code</parameter>
		</methodparam>
	     </methodsynopsis>
            <para>
                Polls the control queues. If a request is present,
                <literal>true</literal> is returned, and the request
                <type>opCode</type> is stored in <parameter>code</parameter>.
                Note that <methodname>getRequest</methodname> must still
                be called, in that case, to remove the queued request.
                If no request is present, <literal>false</literal>
                is returned and <parameter>code</parameter> is unmodified.
            </para>
    
      </refsect1>
      <refsect1>
         <title>Types and public data</title>
         <para>
            The <type>opCode</type> type is an <type>enum</type>
            type that describes the set of supported operation codes.
            These are:
         </para>
         <variablelist>
            <varlistentry>
                <term><literal>ACQUIRE</literal></term>
                <listitem>
                    <para>Acquire the usb controller from the acquisition
                        thread
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>RELEASE</literal></term>
                <listitem>
                    <para>
                        Release the USB controller after a successful
                        <literal>ACQUIRE</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>END</literal></term>
                <listitem>
                    <para>
                        Requests an end of run.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>PAUSE</literal></term>
                <listitem>
                    <para>
                        Requests a pause run.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>RESUME</literal></term>
                <listitem>
                    <para>
                        Requests that a pause run be resumed.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>ACK</literal></term>
                <listitem>
                    <para>
                        Acknowledge that a request is successful.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><literal>NAK</literal></term>
                <listitem>
                    <para>
                        Indicate that a request has failed.
                    </para>
                </listitem>
            </varlistentry>
         </variablelist>
            
      </refsect1>
   </refentry>
    <refentry id="manpage.ccontrolmodule">
      <refmeta>
         <refentrytitle>CControlModule</refentrytitle>
         <manvolnum>3usbReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CControlModule</refname>
	 <refpurpose>Base class for slow control module drivers.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CControlModule.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CControlModule</classname></ooclass>
            <constructorsynopsis>
                <methodname>CControlModule</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~CControlModule</methodname>
                                             <void />
            </destructorsynopsis>
            <constructorsynopsis>
                <methodname>CControlModule</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CControlModule&amp;</type>
                    <parameter>rhs</parameter>
                </methodparam>
            </constructorsynopsis>
            <methodsynopsis>
                <type>CControlModule&amp;</type>
                <methodname>operator=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CControlModule&amp;</type>
                                               <parameter>rhs</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>operator==</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CControlModule&amp;</type>
                                               <parameter>rhs</parameter>
                                                <modifier>const</modifier>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type>
                <methodname>0operator!=</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>CControlModule&amp;</type>
                                               <parameter>rhs</parameter>
                                               <modifier>const</modifier>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>Initialize</methodname>
                                             <void /> <modifier> = 0</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>onAttach</methodname>
                                             <void /> <modifier> = 0</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>std::string</type>
                <methodname>Update</methodname>
                <void /> <modifier> = 0</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>std::string</type>
                                             <methodname>Set</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>char*</type> <parameter>what</parameter>
                </methodparam>
                <methodparam>
                    <modifier>const</modifier> <type>char*</type> <parameter>value</parameter>
                </methodparam>
                <modifier> = 0 </modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>std::string</type> <methodname>Get</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>char*</type>
                                               <parameter>what</parameter>
                </methodparam>
                <modifier> = 0</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>CControlModule*</type>
                        <methodname>clone</methodname>
                        <void /> <modifier> = 0</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>std::string</type>        <methodname>getName</methodname>
                                                <void />
                                                <modifier>const</modifier>
            </methodsynopsis>

         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            This class is an abstract base class for extensions to the Tcl Server
            component of the USB readout software. The Tcl server is responsible
            for servicing requests for slow control by synchronizing with the
            readout thread, if active, and arbitrating with it for control of
            the usb Controller.
         </para>
         <para>
            Extensions to the software are device driver classes that implement
            setters and getters for control parameters for slow control modules.
            These extensions get registered with the Tcl server as prototype modules
            and used, via the Prototype pattern to create specific instances of
            device driver objects for actual modules.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
            <methodsynopsis>
                <methodname>CControlModule</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
            <para>
                Constructs a module and associates it with a name.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>Initialize</methodname>
                                             <void /> <modifier> = 0</modifier>
            </methodsynopsis>
            <para>
                This pure virtual method is called to initialize a new module.
                The method is pure virtual and must be provided by concrete
                sub-classes.  The function should locate the controller,
                and do what is necessary to prepare the module for use.
                The caller will take care of any required arbitration for the
                controller with the readout thread.
            </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>onAttach</methodname>
                                             <void /> <modifier> = 0</modifier>
            </methodsynopsis>
	    <para>
	       Called when the object is attached to the tcl server.  This
	       is normally called by the command that creates th object after
	       the construction.  
	    </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>std::string</type>
                <methodname>Update</methodname>
                <void /> <modifier> = 0</modifier>
            </methodsynopsis>
	    <para>
	       Called to initialize any shadow state of the device.  Some
	       devices are write only.  For those devices, this function
	       will set the device to match some intenal idea about the
	       state of the device.  
	    </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>std::string</type>
                                             <methodname>Set</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>char*</type> <parameter>what</parameter>
                </methodparam>
                <methodparam>
                    <modifier>const</modifier> <type>char*</type> <parameter>value</parameter>
                </methodparam>
                <modifier> = 0 </modifier>
            </methodsynopsis>
	    <para>
		   Called to set a parameter in the device.
		   <parameter>what</parameter> is a string that identifies what
		     part of the device shoul be modified,
		    <parameter>value</parameter>
		    provides a new value for that parameter.  The function
		    should return any string that should be passed back to the
		    client.  If the function returns a string that begins with
		    text <literal>ERROR</literal>
		    An error is presumed to hasve occured, and the
		    remainder of the string describes the error.
		    By convention successful operation returns the string
		    <literal>OK</literal>
	   </para>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type>std::string</type> <methodname>Get</methodname>
                <methodparam>
                    <modifier>const</modifier> <type>char*</type>
                                               <parameter>what</parameter>
                </methodparam>
                <modifier> = 0</modifier>
            </methodsynopsis>
	    <para>
	       Retrieves the value of the parameter <parameter>what</parameter>
	       from the device.  On success, the stringified value of the
              parameter
	      should be returned.  On failure, text that begins with the
	      string <literal>ERROR</literal> should be returned. 
	      On error returns, the remainder of the text shoulid be
	      the reason the error is being reported.
	    </para>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>CControlModule*</type>
                        <methodname>clone</methodname>
                        <void /> <modifier> = 0</modifier>
            </methodsynopsis>
	    <para>
	       Control modules are connected to real hardware via cloning.
	       A driver that is a template is associated with  a device type.
	       The commands to create modules locate the correct module type
                and clone another instance from the list of prototypes.
		The <methodname>clone</methodname> provides the virtual 
		copy constructor needed to perform this cloning.
	    </para>
            <methodsynopsis>
                <type>std::string</type>        <methodname>getName</methodname>
                                                <void />
                                                <modifier>const</modifier>
            </methodsynopsis>
	    <para>
	      Returns the name of the object.
	    </para>
      </refsect1>

   </refentry>
    <refentry id="manpage.tclserverclass">
      <refmeta>
         <refentrytitle>TclServer</refentrytitle>
         <manvolnum>3usbReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>TclServer</refname>
	 <refpurpose>Encapsulate the Tcl Server thread and extensions</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;TclServer.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>TclServer</classname></ooclass>
            <constructorsynopsis>
                <methodname>TclServer</methodname>
                <void />
            </constructorsynopsis>
            <destructorsynopsis>
                <methodname>~TclServer</methodname>
                <void />
            </destructorsynopsis>
            <methodsynopsis>
                <type>unsigned long</type>
                <methodname>start</methodname>
                <methodparam>
                    <type>int</type> <parameter>port</parameter>
                </methodparam>
                <methodparam>
                    <modifier>const</modifier> <type>char*</type>
                                               <parameter>configFile</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>CControlModule*</type>
                <methodname>findModule</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>name</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type>
                <methodname>addModule</methodname>
                <methodparam>
                    <type>CControlModule*</type> <parameter>pNewModule</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addPrototype</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>typeName</parameter>
                </methodparam>
                <methodparam>
                    <type>CControlModule*</type> <parameter>prototype</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>CControlModule*</type>
                <methodname>createModule</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>typeName</parameter>
                </methodparam>
            </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            This class encapsulates a  Tcl server thread.  The server listens for
            TCP/IP connection on a specific port and then executes commands on
            behalf of the client.  The server can be extended by a set of user
            commands in addition to including the commands
            <command>Set</command> <command>Get</command> <command>Module</command>
            and <command>Update</command>
            as built in commands that perform actions on slow control modules.
            
         </para>
         <para>
            The class holds a container for prototype device drivers.  A
            prototype device driver is a generic device driver for a slow control
            item.  Duplicating this item results in a driver for a specific device.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
        <methodsynopsis>
             <methodname>TclServer</methodname>
             <void />
         </methodsynopsis>
        <para>
            Construct the Tcl server thread.  Multiple distinct versions of this
            object can be created.  Each object should only be run once, in one
            thread however.  The USB readout framework only creates one instance.
            The specialized application is given a chance to add command and
            driver templates to this interpreter.
        </para>
         <methodsynopsis>
             <methodname>~TclServer</methodname>
             <void />
         </methodsynopsis>
         <para>
            Destroys the server.  The server should have exited before this
            can be done or very bad things are likely to happen.
         </para>
         <methodsynopsis>
             <type>unsigned long</type>
             <methodname>start</methodname>
             <methodparam>
                 <type>int</type> <parameter>port</parameter>
             </methodparam>
             <methodparam>
                 <modifier>const</modifier> <type>char*</type>
                                            <parameter>configFile</parameter>
             </methodparam>
         </methodsynopsis>
         <para>
            Starts the server.  The <parameter>port</parameter> parameter
            specifies the port on which the server will be listening for
            connections.  The framework allows this port to be specified on
            the command line or to request that the port manager allocate
            a port.
         </para>
         <para>
            The <parameter>configFile</parameter> script is sourced in
            once the interpreter is up and running on that port.  This
            is usually a configuration file that defines the slow controls
            hardware set up.
         </para>
         <methodsynopsis>
             <type>CControlModule*</type>
             <methodname>findModule</methodname>
             <methodparam>
                 <type>std::string</type> <parameter>name</parameter>
             </methodparam>
         </methodsynopsis>
         <para>
            Returns a pointer to the module named <parameter>name</parameter>.
            If no such module has been created, <literal>NULL</literal>
            is returned.
         </para>
         <methodsynopsis>
             <type>void</type>
             <methodname>addModule</methodname>
             <methodparam>
                 <type>CControlModule*</type> <parameter>pNewModule</parameter>
             </methodparam>
         </methodsynopsis>
         <para>
            Adds a new module to the server. The new module
            is <parameter>pNewModule</parameter> and must continue to live for
            the length of the server thread's lifetime.  This function is not
            threadsafe and is intended to be called from within the interpreter
            thread in response to a <command>module create</command> command.
         </para>
         <methodsynopsis>
             <type>void</type> <methodname>addPrototype</methodname>
             <methodparam>
                 <type>std::string</type> <parameter>typeName</parameter>
             </methodparam>
             <methodparam>
                 <type>CControlModule*</type> <parameter>prototype</parameter>
             </methodparam>
         </methodsynopsis>
         <para>
            Adds a prototype device driver to the server.  The <parameter>typeName</parameter>
            is used by the <command>module create</command> command processor to match
            a prototype with the desired module type.  The <parameter>prototype</parameter>
            is a pointer to  a prototype driver module.
         </para>
         <methodsynopsis>
             <type>CControlModule*</type>
             <methodname>createModule</methodname>
             <methodparam>
                 <type>std::string</type> <parameter>typeName</parameter>
             </methodparam>
         </methodsynopsis>
         <para>
            Returns a clone of the prototype module driver specified by
            the module type <parameter>typeName</parameter>.
         </para>
      </refsect1>
   </refentry>
    <refentry id="manpage.databufer">
      <refmeta>
         <refentrytitle>DataBuffer</refentrytitle>
         <manvolnum>3usbReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>DataBuffer</refname>
	 <refpurpose>Struct to contain a data buffer from the USB controller.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;DataBuffer.h&gt;
         </programlisting>

        <programlisting>
struct <structname>DataBuffer</structname> {
  <type>uint32_t</type>   <structfield>s_bufferSize</structfield>;
  <type>uint32_t</type>   <structfield>s_storageSize</structfield>;
  <type>uint32_t</type>   <structfield>s_bufferType</structfield>;
  <type>time_t</type>     <structfield>s_timeStamp</structfield>;
  <type>uint16_t</type>   <structfield>s_rawData[1]</structfield>;
};

        </programlisting>

      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            The <structname>DataBuffer</structname> struct encapsulates
            a data buffer from the hardware along with other information
            needed to format events in the ring buffer from that buffer.
         </para>
         <para>
            The fields have the following meaning:
         </para>
         <variablelist>
            <varlistentry>
                <term><structfield>s_bufferSize</structfield></term>
                <listitem>
                    <para>
                        The number of bytes of data that were actually read
                        into the buffer.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><structfield>s_storageSize</structfield></term>
                <listitem>
                    <para>
                        The number of bytes of storage allocated to the buffer.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><structfield>s_bufferType</structfield></term>
                <listitem>
                    <para>
                        An indicator of the buffer type.  This can be
                        <literal>TYPE_START</literal> to indicate a start in
                        data taking, <literal>TYPE_STOP</literal> to indicate
                        data taking has stopped, or <literal>TYPE_EVENTS</literal>
                        to indicate the buffer actually contains USB data.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><structfield>s_timeStamp</structfield></term>
                <listitem>
                    <para>
                        The UNIX timestamp for when the data buffer was received.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><structfield>s_rawData[]</structfield></term>
                <listitem>
                    <para>
                        Array of data from the controller.  This is really
                        <structfield>s_storageSize</structfield>*sizeof(uint16_t)
                        long.
                    </para>
                </listitem>
            </varlistentry>
         </variablelist>
      </refsect1>
   </refentry>
    <refentry id="manpage.coutputthread">
      <refmeta>
         <refentrytitle>COutputThread</refentrytitle>
         <manvolnum>3usbReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>COutputThread</refname>
	 <refpurpose>Abstract Base class for thread to output data to the daq system.</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;COutputThread&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>COutputThread</classname></ooclass>
            <constructorsynopsis>
                <methodname>COutputThread</methodname>
                <void />
            </constructorsynopsis>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~COutputThread()</methodname>
            </destructorsynopsis>
            <methodsynopsis>
                <modifier>protected virtual</modifier>
                <type>void</type> <methodname>run</methodname>
                                  <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>unsigned</type>
                <methodname>bodySize</methodname>
                <methodparam>
                    <type>DataBuffer&amp;</type> <parameter>buffer</parameter>
                </methodparam>
                <modifier> = 0</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>unsigned</type>
                <methodname>eventCount</methodname>
                <methodparam>
                    <type>DataBuffer&amp;</type> <parameter>buffer</parameter>
                </methodparam>
                <modifier> = 0</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>unsigned</type>
                <methodname>headerSize</methodname>
                <methodparam>
                    <type>DataBuffer&amp;</type> <parameter>buffer</parameter>
                </methodparam>
                <modifier> = 0</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>uint32_t</type>
                <methodname>eventSize</methodname>
                <methodparam>
                    <type>uint16_t*</type> <parameter>pEvent</parameter>
                </methodparam>
                <modifier> = 0 </modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>processEvent</methodname>
                <methodparam>
                    <type>time_t</type> <parameter>when</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>size</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t*</type> <parameter>pEvent</parameter>
                </methodparam>
                <modifier>= 0</modifier>
            </methodsynopsis>


         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            The output thread of the usb Readout program is responsible for
            adapting data from the USB controller to the format expected by the
            NSCL data acquisition systsem (ring buffer items).  The thread is
            implemented as a template method pattern. 
         </para>
         <para>
            The template method pattern represents a fixed algorithm that has
            varying parts.  Varying parts/steps in the algorithm are defined
            as pure virtual methods.  Concrete implementations of the algorithm
            define and implement those methods.
         </para>
         <para>
            In the USB Readout framework the varying parts
            have to do with the format of the data.  Therefore virtual member
            functions abstract knowledge of the USB data buffer from the
            output thread by placing that knowledge in pure virtual methods.
            For each controller, therefore, a specific output thread class must
            be written that implements those methods.
         </para>  
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
        <methodsynopsis>
            <methodname>COutputThread</methodname>
            <void />
        </methodsynopsis>
        <para>
            Creates an instance of the output thread.  Normaly this is done by
            the application object of the specific tailoring of the
            USB readout framework for an interface.  Constructing an output thread
            instance does not start it.  That must be done via the
            <methodname>start</methodname> method.
        </para>
        <destructorsynopsis>
            <modifier>virtual</modifier> <methodname>~COutputThread()</methodname>
        </destructorsynopsis>
        <para>
            Destructor for the thread.  Clients should not destroy tis until they
            are convinced that the output thread is no longer running.
        </para>
        <methodsynopsis>
            <modifier>protected virtual</modifier>
            <type>void</type> <methodname>run</methodname>
                              <void />
        </methodsynopsis>
        <para>
            The thread entry point.  This is called in the context of the
            new thread as a result of an invocation of the
            <methodname>Tread::start</methodname> method.  This can be overridden
            to meet special needs, but for the most part it is correct.
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier> <type>unsigned</type>
            <methodname>bodySize</methodname>
            <methodparam>
                <type>DataBuffer&amp;</type> <parameter>buffer</parameter>
            </methodparam>
            <modifier> = 0</modifier>
        </methodsynopsis>
        <para>
            Returns the number of words in the body of <parameter>buffer</parameter>.
            The software models the buffer as something that is encapsulated
            in some way.  This member returns the size of the encapsulated data
            (that is the number of words of data that contain events.
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier> <type>unsigned</type>
            <methodname>eventCount</methodname>
            <methodparam>
                <type>DataBuffer&amp;</type> <parameter>buffer</parameter>
            </methodparam>
            <modifier> = 0</modifier>
        </methodsynopsis>
        <para>
            Returns the number of events in the buffer.
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier> <type>unsigned</type>
            <methodname>headerSize</methodname>
            <methodparam>
                <type>DataBuffer&amp;</type> <parameter>buffer</parameter>
            </methodparam>
            <modifier> = 0</modifier>
        </methodsynopsis>
        <para>
            Returns the number of words in the header.  This can be used
            to locate the position of the first event in the buffer.
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier> <type>uint32_t</type>
            <methodname>eventSize</methodname>
            <methodparam>
                <type>uint16_t*</type> <parameter>pEvent</parameter>
            </methodparam>
            <modifier> = 0 </modifier>
        </methodsynopsis>
        <para>
            Given a pointer to an event in the body of the buffer, this
            returns the number of words that are in the event.
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier> <type>void</type>
            <methodname>processEvent</methodname>
            <methodparam>
                <type>time_t</type> <parameter>when</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>size</parameter>
            </methodparam>
            <methodparam>
                <type>uint16_t*</type> <parameter>pEvent</parameter>
            </methodparam>
            <modifier>= 0</modifier>
        </methodsynopsis>
        <para>
            Figures out how to process an event.  For the cases we know,
            that's just a matter of invoking either
            <methodname>scaler</methodname> or <methodname>even</methodname>.
            
        </para>
      </refsect1>
    </refentry>
    <refentry id="manpage.capplication">
      <refmeta>
         <refentrytitle>CApplication</refentrytitle>
         <manvolnum>3usbReadout</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>CApplication</refname>
	 <refpurpose>Provide templated main program flow</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
         <programlisting>
#include &lt;CApplication.h&gt;
         </programlisting>
         <classsynopsis>
            <ooclass><classname>CApplication</classname></ooclass>
            <destructorsynopsis>
                <modifier>virtual</modifier> <methodname>~CApplication</methodname>
                                             <void />
            </destructorsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>int</type>
                <methodname>main</methodname>
                <methodparam>
                    <type>int</type> <parameter>argc</parameter>
                </methodparam>
                <methodparam>
                    <type>char**</type> <parameter>argv</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>std::string</type>
                <methodname>selectDAQConfigFile</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>filespec</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>std::string</type>
                <methodname>selectControlConfigFile</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>filespec</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>createConfiguration</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>  <type>void</type>
                <methodname>createMainInterpreter</methodname>
                <methodparam>
                    <type>int</type> <parameter>argc</parameter>
                </methodparam>
                <methodparam>
                    <type>char**</type> <parameter>argv</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>createTclServer</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>port</parameter>
                </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>application</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>selectInterface</methodname>
                <methodparam>
                    <type>std::string</type> <parameter>specification</parameter>
                </methodparam>
                    <modifier>  = 0 </modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>setupConfiguration</methodname>
                <methodparam>
                    <type>CConfiguration&amp;</type> <parameter>configuration</parameter>
                </methodparam>
                <modifier> = 0 </modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>setupTclServer</methodname>
                <methodparam>
                    <type>TclServer&amp;</type> <parameter>server</parameter>
                </methodparam>
                <modifier>= 0</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                <methodname>startOutputThread</methodname>
                <void /> <modifier> = 0</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier> <type>void</type>
                                             <methodname>createBuffers</methodname>
                                             <void />
                                             <modifier> = 0</modifier>
            </methodsynopsis>
         </classsynopsis>
      </refsynopsisdiv>
      <refsect1>
         <title>Description</title>
         <para>
            The <classname>CApplication</classname> class is an abstract base
            class that uses the template method pattern to implement the
            startup of the framework.  The class consists calls both implemented
            and abstract methods as it processes command switches and starts
            the components of the software.
         </para>
      </refsect1>
      <refsect1>
         <title>
            Public member functions
         </title>
        <methodsynopsis>
            <modifier>virtual</modifier> <methodname>~CApplication</methodname>
                                         <void />
        </methodsynopsis>
        <para>
            Destroys the application object.  This should only be done when all
            threads are dead and the program exits.
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier> <type>int</type>
            <methodname>main</methodname>
            <methodparam>
                <type>int</type> <parameter>argc</parameter>
            </methodparam>
            <methodparam>
                <type>char**</type> <parameter>argv</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            The entry point.  This is usually called from the
            program's <function>main</function> function.
            The <parameter>argc</parameter> and
            <parameter>argv</parameter> are the count and array of pointers
            to the command parameters.
        </para>
        <para>
            While normally <parameter>argc</parameter> and
            <parameter>argv</parameter> are the same values as those passed
            to the program's entry point, there's certainly nothing to stop
            one from construting something different to pass to the
            function.  This may be necessary if the specialized program
            defines additional command options, in which case, it should
            filter those out of the <parameter>argc</parameter>/<parameter>argv</parameter>
            passed on to the <methodname>main</methodname> method.
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier> <type>std::string</type>
            <methodname>selectDAQConfigFile</methodname>
            <methodparam>
                <type>std::string</type> <parameter>filespec</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Chooses the DAQ cofiguration file.  If <parameter>filespec</parameter>
            is not an empty string it will be used as the DAQ configuration file
            and the string is stored in <varname>Globals::configurationFilename</varname>.
            If <parameter>filespec</parameter>  is empty, a default file name will
            be chosen.  Currently the default is
            <filename>~/config/daqconfig.tcl</filename>.
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier> <type>std::string</type>
            <methodname>selectControlConfigFile</methodname>
            <methodparam>
                <type>std::string</type> <parameter>filespec</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Identical in function to <methodname>selectDAQConfigFile</methodname>
            but chooses the script file that will be used to initialize the
            control configuration of the Tcl server except:
            <itemizedlist>
                <listitem>
                    <para>
                        The resulting file name string is stored in
                        <varname>Globals::controlConfigFilename</varname>
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The default file name is
                        <filename>~/config/ctlconfig.tcl</filename>
                    </para>
                </listitem>
            </itemizedlist>
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier> <type>void</type>
            <methodname>createConfiguration</methodname>
            <void />
        </methodsynopsis>
        <para>
            Creates the configuration object.  The cofiguration object
            (a <classname>CConfiguration</classname>) contains the
            data taking configuration.  The
            <methodname>setupConfiguration</methodname> pure virtual method
            is called and is expected to expand/extend and configure the configuration
            object for the specific application's needs.
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier>  <type>void</type>
            <methodname>createMainInterpreter</methodname>
            <methodparam>
                <type>int</type> <parameter>argc</parameter>
            </methodparam>
            <methodparam>
                <type>char**</type> <parameter>argv</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Creates the main interpreter. The main interpreter runs in the
            initial thread and reads commands from <literal>stdin</literal>.
            It is augmented with commands to control the run, and provides
            variables that have some special meanings to the software.
            This function invokes the <function>Tcl_Main</function>
            function requesting that the static member function
            <methodname>CApplication::tclAppInit</methodname> be called
            to complete the initialization of the interpreter.
        </para>  
        <methodsynopsis>
            <modifier>virtual</modifier> <type>void</type>
            <methodname>createTclServer</methodname>
            <methodparam>
                <type>std::string</type> <parameter>port</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>application</parameter>
            </methodparam>
        </methodsynopsis>
        <para>
            Creates the Tcl server program.
            The <parameter>port</parameter> parameter determines which port
            the server will use to listen for connections.  This can be a port
            number, an empty string or the string <literal>managed</literal>.
            If a number, that port will be used.  If an empty string or
            <literal>managed</literal>, the NSCLDAQ port manager will
            be used to allocate a port.
        </para>
        <para>
            The <parameter>application</parameter> parameter is only used
            if the port manager is used to allocated the port and, if not
            empty, will be the application name registered with the port
            manager.  If empty, the application name defaults to
            <literal>SlowControls</literal>.
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier> <type>void</type>
            <methodname>selectInterface</methodname>
            <methodparam>
                <type>std::string</type> <parameter>specification</parameter>
            </methodparam>
                <modifier>  = 0 </modifier>
        </methodsynopsis>
        <para>
            Pure virtual method that is called to select which of the
            supported interfaces should be used.  <parameter>specification</parameter>
            is either a device specific specification string or empty.  If
            empty, the function should select some default controller.
            If <parameter>specification</parameter> specifies a non-existent
            controller, the function should exit emitting an error messsage to
            <literal>stderr</literal>
        </para>
        <para>
            The <parameter>specification</parameter> string is device specific.
            For the VM-USB and CC-USB controllers, this is the serial number
            string of the device.  Both of those specializations will list the
            set of legal specification strings if a bad one is specified.
        </para>  
        <methodsynopsis>
            <modifier>virtual</modifier> <type>void</type>
            <methodname>setupConfiguration</methodname>
            <methodparam>
                <type>CConfiguration&amp;</type> <parameter>configuration</parameter>
            </methodparam>
            <modifier> = 0 </modifier>
        </methodsynopsis>
        <para>
            Pure virtual function called to setup the <parameter>configuration</parameter>.
            The function should add commands as needed to the configuration's interpreter.
        </para>  
        <methodsynopsis>
            <modifier>virtual</modifier> <type>void</type>
            <methodname>setupTclServer</methodname>
            <methodparam>
                <type>TclServer&amp;</type> <parameter>server</parameter>
            </methodparam>
            <modifier>= 0</modifier>
        </methodsynopsis>
        <para>
            Pure virtual function called to extend the Tcl <parameter>server</parameter>.
            Additional commands can be registered in its interpreter and prototype
            device drivers added to its list of driver.
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier> <type>void</type>
            <methodname>startOutputThread</methodname>
            <void /> <modifier> = 0</modifier>
        </methodsynopsis>
        <para>
            Pure virtual method that is supposed to create the specific concrete
            output thread object and start it.  Recall that the
            <classname>COutputThread</classname> is an abstract base class that
            also users the template method pattern to provide hooks for
            specialization.  As such it cannot be instantiated directly.
        </para>
        <para>
            This method can be thought of as a factory method for the output
            thread.
        </para>
        <methodsynopsis>
            <modifier>virtual</modifier> <type>void</type>
                                         <methodname>createBuffers</methodname>
                                         <void />
                                         <modifier> = 0</modifier>
        </methodsynopsis>
        <para>
            Creates the buffer pool that will be used by the acquisition and
            output threads.  Buffer sizes may be dependent on the contoller.
            Buffers should be of type <structname>DataBuffer</structname> with the
            size of the payload appropriately set for the controller.  Each
            buffers should be inserted into the buffer queue
            <varname>gFreeBuffers</varname> which is a global defined in
            <filename>&lt;DataBufferse.h&gt;</filename>.
        </para>
        <para>
            A sufficient number of buffers to deal with rate spikes etc. should
            be allocated by this function.
        </para>
      </refsect1>
      <refsect1>
         <title>EXAMPLES</title>
         <para>
            Normally one subclasses <classname>CApplication</classname>,
            instantiates the subclass and invokes its <methodname>main</methodname>
            method.  The sample code below is taken from the startup for the
            VM-USB specialization of this framework.  The application sublcass
            has been named <classname>App</classname>:
         </para>
         <example>
            <title>Using the usb Readout <classname>CApplication</classname> class</title>
            <programlisting>
int
main(int argc, char** argv)
{
  App theApp;
  return theApp.main(argc, argv);
}
            </programlisting>
         </example>
      </refsect1>
   </refentry>

<!-- /manpage -->

<!-- manpage 1usbReadout -->

<refentry id="manpage.usbReadout">
  <refmeta>
     <refentrytitle>xxusbReadout</refentrytitle>
     <manvolnum>1usbReadout</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>xxusbReadout</refname>
     <refpurpose>Document usb readout framework startup, commands and variables.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
xxReadout <optional>options...</optional>
	</command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
	Well there actually is no <command>xxReadout</command> command.
        All of the usb readout specializations share a common set of command
        options, Tcl command extensions and important global variables.
        This page describes those items.
     </para>
  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	<varlistentry>
	    <term><option>--help</option></term>
	    <listitem>
		<para>
                    Prints out a help message describing the software version,
                    the usage and the supported options. Note that while
                    this page documents the 'long form' options, short forms
                    exit.  The <option>--help</option> option will describe both
                    long and short form options.
		</para>
	    </listitem>
	</varlistentry>
        <varlistentry>
            <term><option>--version</option></term>
            <listitem>
                <para>
                    Prints out the version number of the application.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>--daqconfig</option>=<replaceable>>daqconfigpath</replaceable></term>
            <listitem>
                <para>
                    Overrides the default DAQ configuration script with
                    <replaceable>daqconfigpath</replaceable>.  By default, this
                    is <filename>~/config/daqconfig.tcl</filename>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>--ctlconfig</option>=<replaceable>ctlconfigpath</replaceable></term>
            <listitem>
                <para>
                    Overrides the default Tcl server slow controls configuration
                    file with <replaceable>ctlconfigpath</replaceable>.  The
                    default value for this is
                    <filename>~/config/ctlconfig.tcl</filename>
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>--device</option>=<replaceable>specification</replaceable></term>
            <listitem>
                <para>
                    Selects a specific interface. The <replaceable>specification</replaceable>
                    is a controller specific device specification string.  If not supplied,
                    each specialization of the framework has a default device it will
                    open.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>--port</option>=<replaceable>portspec</replaceable></term>
            <listitem>
                <para>
                    Supplies a port specification for the Tcl server component of
                    the framework.  <replaceable>portspec</replaceable> is either
                    an integer which will be the number of the port on which
                    the Tcl server will listen for connections, or
                    the string <literal>managed</literal> in which case the port
                    manager will be used to allocated a free server port.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>--application</option>=<replaceable>appname</replaceable></term>
            <listitem>
                <para>
                    If the port manager is used to allocate a listen port for the
                    Tcl server component, this option can be used to override
                    the default application name that is registered
                    with the port server (to <replaceable>appname</replaceable>).
                    The default application name is <literal>SlowControls</literal>.
                </para>
            </listitem>
        </varlistentry>
     </variablelist>
  </refsect1>
  <refsect1>
     <title>EXTENSION COMMANDS</title>
     <para>
        The USB Readout framework runs a Tcl interpreter to interpret commands
        from <literal>stdin</literal>. This section describes the additional
        commands added to this interpreter by the framework.
        Note that specializations are free to add additional commands as well.
     </para>
     <para>
        The commands listed in this section are sufficient to support the
        Readout GUI as a controller for this framework.
     </para>
     <variablelist>
	<varlistentry>
	    <term><command>begin</command></term>
	    <listitem>
		<para>
                    Starts a run.  If the run is active or paused, no change
                    will be made and an error  is emitted.
		</para>
	    </listitem>
	</varlistentry>
        <varlistentry>
            <term><command>end</command></term>
            <listitem>
                <para>
                    Ends a run.  If the run was neither active nor paused,
                    no change is made, and the command emits and error.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><command>pause</command></term>
            <listitem>
                <para>
                    Pauses a run. If the run was not active no action is taken
                    and the command emits an error.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><command>resume</command></term>
            <listitem>
                <para>
                    Resumes a paused run.  If the run was not paused no action
                    is taken and the command emits an error.
                </para>
            </listitem>
        </varlistentry>     
     </variablelist>
  </refsect1>
  <refsect1>
    <title>VARIABLES</title>
    <para>
        The usb framework uses a few global variables to hold information
        that can be set and queried from the command line:
    </para>
    <variablelist>
        <varlistentry>
            <term><varname>run</varname></term>
            <listitem>
                <para>
                    Holds a number that is used to set the run number of a run
                    that is starting.  Users should only write this when the
                    run is halted.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><varname>title</varname></term>
            <listitem>
                <para>
                    Holds a string that will be used for the run title string.
                    This variable should only be modified when the run is halted.
                </para>
            </listitem>
        </varlistentry>
    </variablelist>
  </refsect1>

</refentry>


<!-- /manpage -->
