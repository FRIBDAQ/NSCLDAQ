<!-- chapter utilities -->
<chapter>
    <title>CCUSB Readout framework</title>
    <para>
        The CCUSB Readout framework provides support for the Wiener-JTec
        CC-USB CAMAC controller.  The CC-USB is a USB CAMAC controller that
        uses a Xilinx gate array to implement a CAMAC list processor.
        The CCUSB Readout framework provides:
    </para>
    <itemizedlist>
        <listitem><para>
            A high level approach to the problem of data taking with the CC-USB
        </para></listitem>
        <listitem><para>
            Support for user written device support without any need to
            understand the format of list operations supported by the CC-USB
        </para></listitem>
        <listitem>
            <para>
                Direct insertion of data taken to an arbitrary destination
                ringbuffer.
            </para>
        </listitem>
    </itemizedlist>
    <para>
        This Chapter provides overview information that describes
    </para>
    <itemizedlist>
        <listitem>
            <para>
                The philosophy behind the CCUSB readout framework.
            </para>
        </listitem>
        <listitem>
            <para>
                How to write configuration files for the CCUSB readout
                framework.
            </para>
        </listitem>
        <listitem>
            <para>
                How to write device support and incorpoprate it into the
                CCUSB readout framework.
            </para>
        </listitem>
        <listitem>
            <para>
                How the slow controls framework operates.
            </para>
        </listitem>
    </itemizedlist>
    <para>
        Reference information is available in the <literal>3ccusb</literal>
        section of the referencae material.
    </para>
    <section>
        <title>How the CCUSB readout framework works</title>
        <para>
            The CCUSB readout framework provides a high level approach to
            configuring devices supported by the system.  A plugin architecture
            allows user written device support to be incorporated into
            the framework at run-time.  
        </para>
        <para>
            The framework supports both data taking devices and slow control
            devices that may require a control panel.  Naturally you can
            support relatively static slow control devices by using the
            data taking device support as well.
        </para>
        <para>
            The recurring concepts for both the data taking device support
            and slow controls device support are:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    A Tcl configuration file describes the devices used
                    by the experiment.
                </para>
            </listitem>
            <listitem>
                <para>
                    Each supported device class is represented in the
                    configuration file by a Tcl command ensemble. The
                    command ensemble provides subcommands that allow you to
                    create, configure and query the configuration of
                    physical devices (device instances).
                </para>
            </listitem>
            <listitem>
                <para>
                    The device configuration is represented in the configuration
                    file in manner analagous to the state of a Tk widget.
                    That is, you never actually program the device directly,
                    you simply specify the desired configuration. The actual
                    programming is done by the device class's device support
                    software.
                </para>
            </listitem>
            <listitem>
                <para>
                    In accordance with the way the CC-USB operates, you can create
                    two lists of <firstterm>stack</firstterm>s in CC-USB parlance.
                    One stack is an event stack and is intended to be used
                    to handle event triggers.  The second stack is a scaler stack
                    and typically is set to readout periodicalyl.
                </para>
                <para>
                    Each stack has, configuratino properties as well. One
                    configuration property is the set of modules managed
                    by that stack.  Modules managed by that stack are initialized
                    by the software, in accordance with their configuration,
                    and contribute to the readout list that executes in response
                    to that stack's trigger.
                </para>
            </listitem>
        </itemizedlist>

    </section>
    <section>
        <title>Writing DAQ configuration files</title>
        <para>
            The DAQ configuration file is processed at the beginning of each run.
            The configuratino file is processed in a fresh interpreter each time.
            You therefore cannot maintain any state across runs via your configuration
            file.
        </para>
        <para>
            To illustrate module creation and configuration,
            this let's look at a fragment from a configuration
            file:
        </para>
        <example>
            <title>Creating and configuring devices</title>
            <programlisting>
ph7xxx create tdc -slot 13 -id 0x7186 -sparse false
ph7xxx config tdc -readhits true -usellt false -usehlt false
            </programlisting>
        </example>
        <para>
            The ph7xxx driver supports the Phillips 7xxx series
            CAMAC 16 channel digitizers.  The <command>ph7xxx</command> command is the Tcl
            command this driver recognizes.  The <command>create</command>
            subcommand creates a new device instance and names it <literal>tdc</literal>.
            When you create a module any addition command words following the
            device name are interpreted as configuration options.
            In this case, the module is configured to be in slot 13,
            the driver is configured to emit a literal value (<option>-id</option>)
            <literal>0x7186</literal> prior to data from the device.
            The module is also configured to read all channels
            (<option>-sparse</option> <literal>false</literal>).
        </para>
        <para>
            The <command>config</command> subcommand allows you to further
            configure the options of a device instance.  The second line
            of the example continues specifying the configuration of the
            device named <literal>tdc</literal>.  The configuration parameters
            on that line request the driver to read the hit pattern register
            (<option>-readhits</option> <literal>true</literal>), to not
            enable  either the lower level threshold or the upler level threshold
            (<option>-usellt</option> and <option>usehlt</option>).
        </para>
        <para>
            The reference section <literal>3ccusb</literal> provides detailed
            information that describes each supported device and the
            configuration options it supports.
        </para>
        <para>
            Configuration files must also specify at least one stack and, if
            scaler modules are to be read periodically, a second scaler stack.
            See the <xref linkend="ccusb3-stack" /> command
            in the reference material for detailed information about how
            to create and configure stacks.
        </para>
        <para>
            To continue with the previous example:
        </para>
        <example>
            <title>Configuring an event stack</title>
            <programlisting>
stack create events
stack config events -modules [list tdc] -type event -delay 108
            </programlisting>
        </example>
        <para>
            Stacks are created and configured exactly like any other module.
            In this configuration file fragment, a stack named
            <literal>events</literal> is created.  It is configured to
            manage the <literal>tdc</literal> module (<option>-modules</option>).
            It is configured as the event stack (<option>-type</option>) which,
            by default is triggered by a nim pulse in the <literal>IN1</literal>
            input of the module. The <option>-delay </option> parameter
            specifies a delay of 108usec between the trigger input and stack
            execution.  This capability is provided to allow the digitizers
            in the stack time to convert.
        </para>
        <para>
            Finally here's a configuration file fragment that sets up an
            LRS 2551 scaler and the scaler stack:
        </para>
        <example>
            <title>Setting up a scaler stack</title>
            <programlisting>
stack create events
stack config events -modules [list testing tdc] -type event -delay 108
            </programlisting>
        </example>
    </section>
    <section>
        <title>Writing device support software</title>
        <para>
            This section describes how to write a device support module.
            Device support modules are built into shared object libraries
            that can be dynamically loaded into the readout software via
            the <command>load</command> command.
        </para>
        <para>
            The device support package is provided as a template driver
            source file and a Makefile that builds the shared object.
            If the DAQ software is installed in $DAQROOT, the following
            commands copy the template driver and its makefile:
        </para>
        <example>
            <title>Obtaining the ccusb driver development kit</title>
            <programlisting>
<command>cp $DAQROOT/ccusbdriver/drivertemplate.cpp .</command>
<command>cp $DAQROOT/ccusbdriver/Makefile .</command>
            </programlisting>
        </example>
        <para>
            The example below shows how to load a user written driver
            and use the driver that is created by an unmodified driver template:
        </para>
        <example>
            <title>Using a user written CCUSB driver</title>
            <programlisting>
set here [file nativename [file dirname [info script]]]
load [file join $here libtemplatedriver.so]
changeme create testing -value 0x1234
            </programlisting>
        </example>
        <para>
            The example assumes that you have built the driver in the same
            directory as your configuration file.  The first example line
            computes the full file path to the configuration file's directory.
            The second loads the driver, joining that path to the name of the
            shared object created by the Makefile.  Note that you typically will
            need to provide a full path to the driver shared object or the
            <command>load</command> command will claim the file cannot be located.
            The final command creates and configures a device instance
            named <literal>testing</literal> using the <command>changeme</command>
            command the unmodified driver creates.
        </para>
        <para>
            Let's look at the template driver you copied.
            The template consists of two main chunks.  The first chunk is a
            class derived from <classname>CReadoutHardware</classname> that is
            responsible for managing the driver itself. You will normally
            need to modify the <methodname>onAttach</methodname>,
            <methodname>Initialize</methodname> and <methodname>addReadoutList</methodname>
            methods of this class, as well as changing the class name to something
            more reasonable than <classname>CTemplateDriver</classname>.
        </para>
        <para>
            The second chunk is a Tcl package initialization function that
            must define the Tcl command that is associated twith the driver.
        </para>
        <para>
            While the driver template is heavily commented, and modification
            points are indicated, the next few sections are a guided tour
            of the main sections you will need to modify.
        </para>
        <section>
            <title>The driver onAttach method</title>
            <para>
                Each driver instance has a configuration database attached to it
                when it is created.  The configuration database holds configuration
                parameter definitions and their current values.  The framework
                takes care of managing the values for you, however you must
                define the set of configuration parameters supported by your
                driver.
            </para>
            <para>
                The template driver's code is (comments removed for brevity:
            </para>
            <informalexample>
                <programlisting>
void
CTemplateDriver::onAttach(CReadoutModule&amp; configuration)
{
  m_pConfiguration = &amp;configuration;                    <co id='ccusb-dtemplate-saveconfig' />
  m_pConfiguration->addIntegerParameter("-slot", 1, 23, 1); <co id='ccusb-dtemplate-slotparam' />

  m_pConfiguration->addIntegerParameter("-value"); // default is 0. <co id='ccusb-dtemplate-valueparam' />
}
                </programlisting>
            </informalexample>
            <calloutlist>
                <callout arearefs='ccusb-dtemplate-saveconfig'>
                    <para>
                        <methodname>onAttach</methodname> needs to be able
                        to access its configuration in other methods.
                        The <parameter>configuration</parameter> parameter is
                        a reference to that configuration.  This line
                        saves a pointer to that configuration in the
                        <varname>m_pConfiguration</varname> member variable.
                        Note that a <classname>CReadoutModule</classname>
                        is derived from a <classname>CConfigurableObject</classname>
                        and that base class holds the configuration.
                    </para>
                    <para>
                        This code is provided by the driver template.
                    </para>
                </callout>
                <callout arearefs='ccusb-dtemplate-slotparam'>
                    <para>
                        Virtually all of the device support you write will
                        need to know which slot in the CAMAC crate contains
                        your module.  This line creates an integer
                        parameter constrained to lie in the range
                        <literal>[1..23]</literal> named <literal>-slot</literal>.
                        The default value (if the user does not configure
                        this item) is <literal>1</literal> (the last parameter
                        of the <methodname>addIntegerParameter</methodname> call).
                    </para>
                    <para>
                        This code is provided by the driver template.
                    </para>
                </callout>
                <callout arearefs='ccusb-dtemplate-valueparam'>
                    <para>
                        This sample line shows how to create an unconstrained
                        integer parameter named <literal>-value</literal>.
                        The configuration subsystem will ensure the value
                        is a valid integer but will not contrain the range
                        of that integer.
                    </para>
                    <para>
                        This line is provided by the template driver but normally
                        is removed as you edit the code to define the
                        configuration options you actually need.
                    </para>
                </callout>
            </calloutlist>
            <para>
                Normally the <methodname>onAttach</methodname> method is simply
                defining the set of configuration parameters it needs to know
                how to initialize and read the device it manages.  Configuration
                parameters are named items (by convention the names start with the
                dash character) and are strongly typed. Integer, real, string,
                enumerated, and boolean simple parameters are supported.  In
                addtion collection (Tcl lists) are supported.
            </para>
            <para>
                Parameter values can have constraints placed on them (the
                range of <option>-slot</option> parameter values e.g.) which
                are checked by the configuration subsystem without any intervention
                by you.  Several pre-defined constraint checkers are available,
                as are convenience functions for defining configuration parameters.
                You can also define custom constraint checkers and register them
                with the configuration subsystem.
            </para>
            <para>
                See <xref linkend='ccusb3-CConfigurableObject' /> for
                detailed information about how to define configuration
                parameters.
            </para>
        </section>
        <section>
            <title>The driver Initialize method</title>
            <para>
                The <methodname>Initialize</methodname> method of each
                device instance that has been put in a stack is called
                after the configuration file is processed prior to loading
                the stack and prior to turning on data taking mode in the
                CC-USB.
            </para>
            <para>
                Typically in <methodname>Initialize</methodname> you must:
                <orderedlist>
                    <listitem>
                        <para>
                            Fetch the configuration parameters you need
                            to know how to initialize the device and prepare
                            it for data taking.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Issue method calls to the <parameter>controller</parameter>
                            <classname>CCCUSB</classname> object passed in to the
                            method.  Note that if your device requires a lot of
                            initialization, you can speed up that process
                            by creating <classname>CCCUSBReadoutList</classname>
                            objects, which are lists of instructions, using
                            its methods to create a list of operatinos and then
                            asking the controller to execute that list.
                        </para>
                    </listitem>
                </orderedlist>
            </para>
            <para>
                For detailed information about the methods supported by
                the <classname>CCCUSB</classname> and <classname>CCCUSBReadoutList</classname>,
                see <xref linkend='ccusb3-CCCUSB' /> and <xref linkend='ccusb3-CCCUSBReadoutList' />
            </para>
            <para>
                The template driver provides the following code (most
                comments removed for brevity).
            </para>
            <informalexample>
                <programlisting>
void
CTemplateDriver::Initialize(CCCUSB&amp; controller)
{

  int slot = m_pConfiguration->getIntegerParameter("-slot"); <co id='ccusb-dtemplate-init1' />

  /* MODIFY ME HERE */
                                                             <co id='ccusb-dtemplate-init2' />
  /* END MODIFICATIONS */

}


                </programlisting>
            </informalexample>
            <calloutlist>
                <callout arearefs='ccusb-dtemplate-init1'>
                    <para>
                        In most cases you need the slot number of the module
                        to initialize it.  This call obtains the value of the
                        <option>-slot</option> configuration parameter
                        from the configuration database for this module.
                    </para>
                </callout>
                <callout arearefs='ccusb-dtemplate-init2'>
                    <para>
                        You would add code here to fetch parameter values
                        as well as method calls for the <parameter>controller</parameter>
                        object to manipulate the CAMAC crate.  If initialization
                        requires a large number of CAMAC operations you could
                        also create a <classname>CCCUSBReadoutList</classname>,
                        manipulate it to store a set of operatiuons and then
                        use <parameter>controller.executeList(3ccusb)</parameter> to
                        execute that list.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section>
            <title>The driver addReadoutList method</title>
            <para>
                <methodname>addReadoutList</methodname> is called as a run is
                being intialized.  This method is expected to contribute items
                to the <classname>CCCUSBRedoutList</classname> that will be
                loaded into either a scaler or event stack.  Usuall this is done
                by fetching the set of configuration parameters that are required
                to know how to read the device and then invoking appropriate
                methods on the <parameter>list</parameter> parameter to
                add CAMAC operations to the stack.
            </para>
            <para>
                The template driver implements a marker 'device'. The marker
                device ignores its <option>-slot</option> configuration parameter
                (a production quality marker driver would probably not define
                a <option>-slot</option> parameter).  It adds an instrution
                to the <parameter>list</parameter> that inserts a  literal
                value into the event.  The value inserted is determined by
                the <option>-value</option> parameter.
            </para>
            <para>
                Here's the sample driver code for the <methodname>addReadoutList</methodname>
                method:
            </para>
            <informalexample>
                <programlisting>
void
CTemplateDriver::addReadoutList(CCCUSBReadoutList&amp; list)
{
  int slot = m_pConfiguration->getIntegerParameter("-slot");
  
  /* MODIFY ME HERE */
  
  int value = m_pConfiguration->getIntegerParameter("-value");  <co id='ccusb-dtemplate-read1' />
  list.addMarker(value);        // This is a longword marker.   <co id='ccusb-dtemplate-read2' />

  /* END MODIFICATIONS */
}

                </programlisting>
            </informalexample>
            <calloutlist>
                <callout arearefs='ccusb-dtemplate-read1'>
                    <para>
                        This line fetches the <option>-value</option>
                        cofiguration parameter.  This is the value
                        that we are going to insert into the event buffer
                    </para>
                </callout>
                <callout arearefs='ccusb-dtemplate-read2'>
                    <para>
                        The <methodname>addMarker</methodname> method adds
                        the CCUSB instructions to insert a literal value in the
                        output buffer to the list being built up. This
                        therefore instructs the CCUSB that the readout of this
                        'device' consists of inserting the value of the
                        <option>-value</option> configuration parameter.
                    </para>
                    <para>
                        Naturally a real device would add NAF instructions or
                        Q-Stop/C-Scan operations to the list via other
                        <classname>CCCUSBReadoutList</classname> methods.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section>
            <title>Initializing the driver with the framework.</title>
            <para>
                The Tcl <command>load</command> command searches the
                shared object for a specific function entry point that
                it will call to initialize the library.  The initialization function
                must follow the correct naming conventions or Tcl will complain
                about not being able to find the library's initialization function.
            </para>
            <para>
                The initialization entry point must be the name of the
                resulting library with the <literal>lib</literal> prefix stripped
                off and the first letter capitalized suffixed by <literal>_Init</literal>.
                Thus if you are building
                <filename>libmydriver.so</filename>, the initialation function
                must be called <function>Mydriver_Init</function>.
            </para>
            <para>
                The template driver provides the following code:
            </para>
            <informalexample>
                <programlisting>
extern "C" {                                    <co id='ccusb-dtemplate-dinit1' />
  int Templatedriver_Init(Tcl_Interp* pInterp)  <co id='ccusb-dtemplate-dinit2' />
  {
    Tcl_PkgProvide(pInterp, "Templatedriver", "1.0"); <co id='ccusb-dtemplate-dinit3' />
 
    CUserCommand::addDriver("changeme", new CTemplateDriver); <co id='ccusb-dtemplate-dinit4' />

    return TCL_OK;                               <co id='ccusb-dtemplate-dinit5' />

  }
}
                </programlisting>
            </informalexample>
            <calloutlist>
                <callout arearefs='ccusb-dtemplate-dinit1' >
                    <para>
                        Since C++ <firstterm>decorates</firstterm> function  names
                        with an encoding of the call signature, to support function
                        overloading, you must declare the initialization
                        functino using C linkage conventions.  The
                        <literal>extern "C" {}</literal> creates a block of
                        code whose externally visible symbols will use C
                        linkage conventions.
                    </para>
                </callout>
                <callout arearefs='ccusb-dtemplate-dinit2'>
                    <para>
                        In general you will need to modify the name of this
                        to work with the name of the library file you
                        create.  The discussion prior to this example
                        describes the naming conventions that are required.
                    </para>
                </callout>
                <callout arearefs='ccusb-dtemplate-dinit3'>
                    <para>
                        In our examples we used the Tcl <command>load</command>
                        command to load the driver.  This statement registers
                        the library as providing a Tcl loadable package.
                        You can use the Tcl command <command>pkg_mkIndex</command>
                        to build an auto load index file for loadable packages
                        including those in shared libraries.  This allows you
                        to collect several drivers into a directory added to the
                        auto load path, and use the <command>package require</command>
                        command to load them by package name.  You must
                        change the name of the package in this call
                        to be something unique and descriptive of your driver.
                    </para>
                </callout>
                <callout arearefs='ccusb-dtemplate-dinit4'>
                    <para>
                        The <classname>CUserCommand</classname>::<methodname>addDriver</methodname>
                        function associates a template device driver object
                        with its Tcl command ensemble name.  The template device driver
                        object is cloned for each <command>create</command> subcommand
                        issued for this driver in the configuration script.
                        You should change both the name of the driver command
                        from <literal>changeme</literal> and you should have
                        previously changted the class name of the
                        driver class from <classname>CTemplateDriverM</classname>
                    </para>
                </callout>
                <callout arearefs='ccusb-dtemplate-dinit5'>
                    <para>
                        If the library initialization was successful it
                        should return <literal>TCL_OK</literal> on failure
                        it shouild return <literal>TCL_ERROR</literal>.
                        In this case it is also customary to use
                        e.g. Tcl_SetResult or a similar function to set the
                        result of the load command to a descriptive error
                        message.
                    </para>
                </callout>
            </calloutlist>
        </section>
    </section>
    <section>
        <title>The slow controls subsystem</title>
        <para>
            There is nothing to stop you from creating device support that
            does not do anything in its <methodname>addReadoutList</methodname>.
            You could do this to implement static controls devices.  That is
            non data taking devices whose configuration is set up at the start of
            a run and cannot be dynamically modified.
        </para>
        <para>
            There are cases, however when you'd like to have some control
            panel associated with a device, that would provide a virtual knob
            allowing you to dynamically modify settings in the device.
            The slow controls subsystem supports this by offering a
            TCP/IP server which can accept commands to set and query
            devices.  
        </para>
        <para>
            If the run is halted, the slow controls server can directly
            manipulate the CCUSB to perform the desired device changes.
            If, however the CCUSB is in data taking mode, the slow controls
            server pauses the run, makes the setting and then resumes the run.
            You should avoid working with control panels during production runs
            for that reason.
        </para>
        <para>
            The philosophy of the slow controls subsystem is similar to that
            of the readout subsystem.  A controls configuration file defines
            the control modules present in the system and their unchanging
            configuration.  Note that the controls configuration file
            is read only as CCUSBReadout starts, not once per run as
            for the data acquisition configuration file.
        </para>
        <para>
            The <command>Module</command> command is used to create configure
            and query the configuration of slow controls devices known to the server.
            The example below shows how to a Phillips PH7106 leading edge
            discriminator:
        </para>
        <informalexample>
            <programlisting>
Module create ph7106  led
Module config led -slot 3
            </programlisting>
        </informalexample>
        <para>
            The <literal>3ccusb</literal> reference section describes the Module types available,
            the configuration options available, their control panels and
            the network protocol used to communicate with the controls server.
        </para>
    </section>
    <section>
        <title>Running CCUSBReadout</title>
        <para>
            <application>CCUSBReadout</application> is installed as:
            <filename>$DAQROOT/bin/CCUSBReadout</filename>.
        </para>
        <para>
            Several command options control the way CCUSBReadout operates:
        </para>
        <variablelist>
            <varlistentry>
                <term><option>-serialno</option></term>
                <listitem>
                    <para>
                        Specifies the serial number of the CCUSB the program
                        will use.  See <option>--enumerate</option> below.
                        If not provided, the first CCUSB located will be used.
                        If you only have one CCUSB connected to your system,
                        this is suitable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--ring</option></term>
                <listitem>
                    <para>
                        Specifies the ring buffer in which event data will
                        be put by the program.  By default this is the
                        same as the username you are logged in on .
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--daqconfig</option></term>
                <listitem>
                    <para>
                        Specifies the filename that contains the data acquisition
                        configuration script.  This defaults to
                        <filename>~/config/daqconfig.tcl</filename>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--ctlconfig</option></term>
                <listitem>
                    <para>
                        Specifies the filename that contains the slow controls
                        configuration script.  This defaults to
                        <filename>~/config/controlconfig.tcl</filename>. Note
                        that this file is required even if it is just an empty file.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--port</option></term>
                <listitem>
                    <para>
                        Specifies the port on which the slow controls server
                        listens for connections.  This default to
                        <literal>27000</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--enumerate</option></term>
                <listitem>
                    <para>
                        Requests that the software list the serial numbers of
                        the CCUSB devices currently attached to the system and
                        exit.  Note that the serial 'numbers' are actually strings
                        of the form <literal>CCnnnn</literal> where <replaceable>nnnn</replaceable>
                        is a number.  One of these strings can be handed to the
                        <option>--serialno </option> to select the CCUSB
                        to use.
                    </para>
                    <para>
                        Sample output:
                    </para>
                    <informalexample>
                        <programlisting>
/usr/opt/daq/10.1/bin/CCUSBReadout --enumerate
CC-USB scriptable readout version V2.0
[0] : CC0134

                        </programlisting>
                        <para>
                            This output says the system is attached to a single
                            CCUSB whose serial number string is
                            <literal>CC0134</literal>
                        </para>
                    </informalexample>
                </listitem>
            </varlistentry>
        </variablelist>
    </section>
</chapter>
<!-- /chapter -->

<!-- manpage 3ccusb -->
	 <refentry id="ccusb3-ad811">
	   <refmeta>
	      <refentrytitle>ad811</refentrytitle>
	      <manvolnum>3ccusb</manvolnum>
	   </refmeta>
	   <refnamediv>
	      <refname>ad811</refname>
	      <refpurpose>Support the Ortec AD811 ADC</refpurpose>
	   </refnamediv>
	   
	   <refsynopsisdiv>
	     <cmdsynopsis>
	     <command>
ad811 create <replaceable>module-name   ?option...?</replaceable>
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
ad811 config <replaceable>module-name ?option...?</replaceable>
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
ad811 cget <replaceable>module-name</replaceable>
	     </command>
	     </cmdsynopsis>
	   </refsynopsisdiv>
	   <refsect1>
	      <title>DESCRIPTION</title>
	      <para>
	       This command ensemble provides support for the ORTEC AD811
	       8 channel peak sensing ADC.  This module requires about 80
	       microseconds to convert.  All channels convert unconditionally.
	      </para>
	      <para>
		  <parameter>module-name</parameter> is either the name to be
		  given to an ADC in the <command>create</command> subcommand
		  or the name given to a previously created module in the
		  <command>config</command> or <command>cget</command> commands.
	      </para>
	      <para>
	       Both <command>create</command> and <command>config</command> take
	       configuration options.   Each option is a keyword value pair where
	       the keyword defines what the option is and the value is a value
	       associated with that option.  See OPTIONS below for more information
	       about the options supported by <command>ad811</command>.
	      </para>
	      <para>
	       The <command>cget</command> option returns the configuration options
	       for the named module as a Tcl list.  Each element of the list is
	       a two element sublist.  The first element of each sublist is
	       the configuration parameter name, and the second the value associated
	       with that name.
	      </para>
	   </refsect1>
	   <refsect1>
	    <title>
	       OPTIONS
	    </title>
	    <para>
	       The <command>ad811</command> configuration options are:
	    </para>
	    <variablelist>
	       <varlistentry>
		  <term><option>-id</option> <replaceable>vsn</replaceable></term>
		  <listitem>
		     <para>
			   Each module has an identifier which, for historical
			   reasons is called a <firstterm>virtual slot number</firstterm>,
			   or <firstterm>vsn</firstterm>.  To maximize the decode
			   error detection the virtual slot numbers for each
			   module should be unique.  This option allows you
			   to set the virtual slot number for the module.
		     </para>
		     </listitem>
	       </varlistentry>
	       <varlistentry>
		  <term><option>-slot</option> <replaceable>slotnum</replaceable></term>
		  <listitem>
		     <para>
			The value of this parameter tells the readout software
			which CAMAC crate slot houses the module.  Recall that
			CAMAC is slot addressable.  Slots number from 1 on the
			left, with an increasing slot number towards the right.
			The right two slots are reserved for the CAMAC Crate
			controller (in our case a CC-USB).
		     </para>
		  </listitem>
	       </varlistentry>
	    </variablelist>
	   </refsect1>
	   <refsect1>
	      <title>EXAMPLE</title>
	      <para>
	       The example below creates and configures an AD811 that is in
	       slot 2 of the CAMAC crate and, when read will have a virtual
	       slot number of 2:
	      </para>
	      <example>
		  <title>AD811 configuration file example</title>
		  <programlisting>
ad811  create adc -slot 2 -id 2
		  </programlisting>
	      </example>
	   </refsect1>
	 
	 </refentry>
         
<refentry id="ccusb3-c1205">
  <refmeta>
     <refentrytitle>c1205</refentrytitle>
     <manvolnum>3ccusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>c1205</refname>
     <refpurpose>Manage CAEN C1205 QDC modules.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
    <command>
c1205 create <replaceable>module-name ?option...?</replaceable>
    </command>
    </cmdsynopsis>
<cmdsynopsis>
<command>
c1205 config <replaceable>module-name ?option...?</replaceable>
</command>
</cmdsynopsis>
<cmdsynopsis>
<command>
c1205 config <replaceable>module-name</replaceable>
</command>
</cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
	      <para>
		  This command ensemble allows you to create and configure
		  CAEN model C1205 QDC modules.  The C1205 is a sixteen
		  channel charge integrating ADC.
	      </para>
	      <para>
		  The <command>create</command> command
		  allows you to create a new module and assign a
		  <parameter>module-name</parameter> to it so that it can
		  be referred to in subsequent configuration commands.
		  You may optionally include configuration switch value pairs
		  on the <command>create</command> command line.
	      </para>
	      <para>
		  The <command>config</command> subcommand allows you to
		  set the configuration parameters for an existing module.
		  <parameter>module-name</parameter> is the name assigned to
		  that module whe it was created.
	      </para>
	      <para>
		  The <command>cget</command> command returns as its value
		  the module configuration as a Tcl list where each list element
		  is a sublist containing the name and value of a configuration
		  parameter.
	      </para>
	      <para>
		  Configuration options are name/value pairs.   The name
		  of a configuration option is sometimes called a
		  <firstterm>switch</firstterm> because it resembles the
		  command line switches of command shell commands.
		  For a full description of these options see OPTIONS below.
	      </para>
  </refsect1>
  <refsect1>
      <title>OPTIONS</title>
      <para>
	 The CAEN C1205 supports the following configuration option switches.
	 The switches and values can be supplied to both the
	 <command>create</command> and the <command>config</command>
	 subcommands.
      </para>
      <variablelist>
	 <varlistentry>
	 <term><option>-slot</option> <replaceable>n</replaceable></term>
	 <listitem>
	    <para>
	       Specifies the slot in which the module is installed
	       to <literal>n</literal>.
	       If this is not set correctly, the Readout program will
	       not be able to communicate with the module and will emit
	       a warning, if the slot <literal>n</literal> is empty.
	       This parameter must be provided.
	    </para>
	 </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-id</option> <replaceable>n</replaceable></term>
	    <listitem>
	       <para>
		  Sets the id of the module to <literal>n</literal>.
		  The module id is placed as a marker word prior
		  to the data from the module.  It is used by the
		  unpacking software to unambiguously identify The
		  data from each module.  For the C1205, the id
		  value is also programmed into the lower 8 bits of the
		  control status register and will therefore also
		  appear in the bottom 8 bits of the header word
		  read from the module.
	       </para>
	       <para>
		  While the <option>-id</option> value defaults to
		  0, and need not be unique, your data is most
		  reliably decoded if each module in your system has
		  a unique id value.
	       </para>
	    </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-usepedestals</option> <replaceable>true|false</replaceable></term>
	    <listitem>
	       <para>
		  The value of this configuration parameter determines how
		  bit 12 of the control status register is initialized.
		  If <literal>true</literal> (default value), the bit is
		  set to one which enables pedestal subtraction from the input
		  signal.
	       </para>
	    </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-hires</option> <replaceable>true|false</replaceable></term>
	    <listitem>
	       <para>
		  The value of this configuration parameter determins how
		  bit 16 of the module control status register is
		  initialized.  If <literal>true</literal> (default value)
		  the bit is set to zero enabling high resolution mode.
		  If set <literal>false</literal> low resolution mode
		  is selected.
		  High resolution
		  mode provides 12 bits of data resolution while low
		  resolution mode provides only 10 bits of data resolution.
		  High resolution comes at a cost of an additional 1.5
		  microseconds of conversion time (5.5 microseconds compared
		  with 4 microseconds for low resolution).
	       </para>
	    </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-thresholds</option> <replaceable>threshold-list</replaceable></term>
	    <listitem>
	       <para>
		  Provides the channel threshold registers.  This is a Tcl
		  list of 16 integers in the range <literal>0-4095</literal>.
		  Data is read from a module only if the data value for the
		  module's low range is greater than the corresponding element
		  of the list.  The thresholds default to a list of 16 zeroes.
	       </para>
	    </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-lopedestals</option> <replaceable>pedestal-list</replaceable></term>
	    <listitem>
	       <para>
		  Provides a list of 16 integers (0-4095) which are subtracted
		  from the data values to  produce the low range value.
	       </para>
	    </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-midpedestals</option> <replaceable>pedestal-list</replaceable></term>
	    <listitem>
	       <para>
		  Same  as <option>-lopedestals</option> but the pedestals
		  are applied to the mid level conversion.
	       </para>
	    </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-hipedestal</option> <replaceable>pedestal-list</replaceable></term>
	    <listitem>
	       <para>
		  Same as <option>-lopedestals</option> but the pedestals
		  are applied to the low level conversion.
	       </para>
	    </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-rangemode</option> <replaceable>mode</replaceable></term>
	    <listitem>
	       <para>
		  Sets the module range mode.  The value for
		  <replaceable>mode</replaceable> must be one of the following:
		  <variablelist>
		     <varlistentry>
			<term><literal>all</literal></term>
			<listitem>
			   <para>
			      Conversions from all ranges appear in each event.
			      In this mode, some of the conversions will likely
			      have negative values.
			   </para>
			</listitem>
		     </varlistentry>
		     <varlistentry>
			<term><literal>auto</literal></term>
			<listitem>
			   <para>In this mode (default) only the  range
			      the conversion falls in will appear in the
			      data fromt he mdule.
			   </para>
			</listitem>
		     </varlistentry>
		     <varlistentry>
			<term><literal>sparse</literal></term>
			<listitem>
			   <para>Same as auto, but only data from channels
			      are above the channel thresholds set
			      via the <option>-thresholds</option> option
			      appear in the data from the module.
			   </para>
			</listitem>
		     </varlistentry>
			      
		  </variablelist>
	       </para>
	    </listitem>
	 </varlistentry>
	 
      </variablelist>
  </refsect1>
</refentry>

<refentry id="ccusb3-c257">
  <refmeta>
     <refentrytitle>Manage CAEN C257 scaler module.</refentrytitle>
     <manvolnum>cccusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>c257</refname>
     <refpurpose>Manages the C257 scaler module</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
    <command>
c257 create <replaceable>name ?options...?</replaceable>
    </command>
    </cmdsynopsis>
    <cmdsynopsis>
    <command>
c257 config <replaceable>name ?options...?</replaceable>   
    </command>
    </cmdsynopsis>
   <cmdsynopsis>
   <command>
c257 cget <replaceable>name</replaceable>   
   </command>
   </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
	 <para>
	     This command ensemble allows you to create and configure
	     CAEN model C257 scaler modules.  The C257 is a 16 channel
	     scaler module.  Support is intended to be used with the
	     scaler stack.  The C257 is capable of cascading channels
	     to produce very wide counters, however this mode is not supported
	     by this release of the software limiting the width of each
	     scaler to 24 bits.  Thus, to use the module with this
	     software requires that all of the module jumpers be set to the
	     <literal>SINGLE</literal> position rather than to
	     <literal>CASCADE</literal>.
	 </para>
	 <para>
	     The <command>create</command> command
	     allows you to create a new module and assign a
	     <parameter>module-name</parameter> to it so that it can
	     be referred to in subsequent configuration commands.
	     You may optionally include configuration switch value pairs
	     on the <command>create</command> command line.
	 </para>
	 <para>
	     The <command>config</command> subcommand allows you to
	     set the configuration parameters for an existing module.
	     <parameter>module-name</parameter> is the name assigned to
	     that module whe it was created.
	 </para>
	 <para>
	     The <command>cget</command> command returns as its value
	     the module configuration as a Tcl list where each list element
	     is a sublist containing the name and value of a configuration
	     parameter.
	 </para>
	 <para>
	     Configuration options are name/value pairs.   The name
	     of a configuration option is sometimes called a
	     <firstterm>switch</firstterm> because it resembles the
	     command line switches of command shell commands.
	     For a full description of these options see OPTIONS below.
	 </para>
  </refsect1>
  <refsect1>
   <title>
      OPTIONS
   </title>
   <para>
      The module is configured via the following set of options.
   </para>
   <variablelist>
      <varlistentry>
	 <term><option>-slot</option> <replaceable>slotnumber</replaceable></term>
	 <listitem>
	    <para>
	       Specifies <parameter>slotnumber</parameter> as the CAMAC
	       crate slot in which the module  is inserted.  This must
	       be correct or else the software will not be able to
	       communicate with the module.
	    </para>
	 </listitem>
      </varlistentry>
      <varlistentry>
	  <term><option>-id</option> <replaceable>module-id</replaceable></term>
	  <listitem>
	      <para>
	       Specifies a module id for the unit.  If the
	       <option>-insertid</option> configuration parameter is
	       <literal>true</literal> this id is inserted prior to the
	       scaler data readout by the stack.  This option, and
	       <option>-insertid</option> should not be used in the scaler
	       stack and is intended as latent support for using the
	       scaler in an event stack (e.g. for supplying an event
	       timestamp).
	      </para>
	  </listitem>
      </varlistentry>
      <varlistentry>
	  <term><option>-insertid</option> <replaceable>true|false</replaceable></term>
	  <listitem>
	      <para>
	       If this parameter is <literal>true</literal> the value specified
	       by the <option>-id</option> option will be inserted in the data
	       buffer prior to the
	       data from this module.
	       This should be <literal>false</literal> (the default) if
	       the module is used in the scaler stack.
	      </para>
	      <para>
		  <option>-id</option> and <option>-insertid</option>
		  are intended as latent support for using the scaler module
		  in the event stack (e.g. to supply an event timestamp).
	      </para>
	  </listitem>
      </varlistentry>
      <varlistentry>
	  <term><option>-readinhibit</option> <replaceable>true | false</replaceable></term>
	  <listitem>
	      <para>
	       If this parameter is <literal>true</literal> (the default), the
	       CAMAC crate is held inhibited while the scaler module is
	       being read, and the module is read with an F2 Q-scan.
	       If <literal>false</literal> the module is read via 16
	       F0's directed at specific subaddresses followed by an
	       F9 to reset the counters.
	      </para>
	  </listitem>
      </varlistentry>
   </variablelist>
  </refsect1>

</refentry>

	 <refentry id="lccusb3-rs2228">
	   <refmeta>
	      <refentrytitle>Manage LRS2228 LeCroy TDC</refentrytitle>
	      <manvolnum>3ccusb</manvolnum>
	   </refmeta>
	   <refnamediv>
	      <refname>lrs2228</refname>
	      <refpurpose>Manages the LRS2228 TDC</refpurpose>
	   </refnamediv>
	   
	   <refsynopsisdiv>
	     <cmdsynopsis>
	     <command>
lrs2228 create <replaceable>module-name ?option...?</replaceable>
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
lrs2228 config <replaceable>module-name ?option...?</replaceable>
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
lrs2228 cget <replaceable>module-name</replaceable>
	     </command>
	     </cmdsynopsis>
	     
	   </refsynopsisdiv>
	   <refsect1>
	      <title>DESCRIPTION</title>
	      <para>
		  This command ensemble allows you to create and configure
		  LeCroy model LRS 2228 TDC modules.  The LRS 2228 is an eight
		  channel Time digitizer.
	      </para>
	      <para>
		  The <command>create</command> command
		  allows you to create a new module and assign a
		  <parameter>module-name</parameter> to it so that it can
		  be referred to in subsequent configuration commands.
		  You may optionally include configuration switch value pairs
		  on the <command>create</command> command line.
	      </para>
	      <para>
		  The <command>config</command> subcommand allows you to
		  set the configuration parameters for an existing module.
		  <parameter>module-name</parameter> is the name assigned to
		  that module whe it was created.
	      </para>
	      <para>
		  The <command>cget</command> command returns as its value
		  the module configuration as a Tcl list where each list element
		  is a sublist containing the name and value of a configuration
		  parameter.
	      </para>
	      <para>
		  Configuration options are name/value pairs.   The name
		  of a configuration option is sometimes called a
		  <firstterm>switch</firstterm> because it resembles the
		  command line switches of command shell commands.
		  For a full description of these options see OPTIONS below.
	      </para>
	   </refsect1>
	   <refsect1>
	    <title>OPTIONS</title>
	    <para>
	       The following options are recognized by the
	       <command>lrs2228 create</command> and
	       <command>lrs2228 config</command> commands.
	    </para>
	    <variablelist>
	       <varlistentry>
		  <term><option>-id</option> <replaceable>vsn</replaceable></term>
		  <listitem>
		     <para>
			Each module should be assigned a unique virtual
		        number.  If not assigned this will be 0.  The data packet
			returned by the module will be prefixed by the ID.
			This provides error checking for the code that wil be
			unpacking the raw data.
		     </para>
		  </listitem>
	       </varlistentry>
	       <varlistentry>
		  <term><option>-slot</option> <replaceable>camac-slot</replaceable></term>
		  <listitem>
		     <para>
			Provides the number of the slot in which the CAMAC
			module has been installed (<parameter>camac_slot</parameter>).
			This must match the physical slot the module has been
			stuffed in in order to ensure the proper module is
			initialized and reads.
		     </para>
		  </listitem>
	       </varlistentry>
	    </variablelist>
	   </refsect1>
	   <refsect1>
	      <title>EXAMPLES</title>
	      <para>
		  The following is an example of the <command>create</command>
		  command for the LRS2228:
	      </para>
	      <example>
	       <title>LRS2228 creation example</title>
	       <programlisting>
lrs2228 create tdc -slot 6 -id 4		  
	       </programlisting>
	      </example>
	   </refsect1>
	 </refentry>
	 <refentry id="ccusb3-lrs2249">
	   <refmeta>
	      <refentrytitle>lrs2249</refentrytitle>
	      <manvolnum>3ccusb</manvolnum>
	   </refmeta>
	   <refnamediv>
	      <refname>lrs2249</refname>
	      <refpurpose>Manage LeCroy 2249 QDC modules</refpurpose>
	   </refnamediv>
	   
	   <refsynopsisdiv>
	     <cmdsynopsis>
	     <command>
lrs2249 create <replaceable>module-name ?option...?</replaceable>
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
lrs2249 config <replaceable>module-name ?option...?</replaceable>
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
lrs2249 cget <replaceable>module-name</replaceable>
	     </command>
	     </cmdsynopsis>
	   </refsynopsisdiv>
	   <refsect1>
	      <title>DESCRIPTION</title>
	      <para>
	       The <command>lrs2249</command> command ensemble
	       allows you to read out
	       LeCroy model LRS 2249 modules.  The LRS 2249 is a charge integrating
	       ADC (QDC).
	      </para>
	      <para>
	       The <command>create</command> subcommand creates
	       a new module assigning it the <parameter>module-name</parameter>
	       you supply.  The <parameter>module-name</parameter> can be used
	       to refer to the module in future commands.  You may optionally
	       provide cofiguration information when creating the module.
	      </para>
	      <para>
	       The <command>config</command> subcommand configures an existing
	       module by providing configuration options for an existing
	       <parameter>module-name</parameter> (created via the
	       <command>create</command> subcommand).  Configuration options are
	       name/value pairs that are also sometimes called switches because
	       of their resemblance to shell command switches.  For a list of
	       the valid configuration options for the LRS 2249 module, see
	       the OPTIONS section below.
	      </para>
	      <para>
	       The <command>cget</command> subcommand returns the configuration
	       parameters for <parameter>module-name</parameter> as a Tcl list
	       of items.  Each item is itself a two element sublist containing
	       in order the name and value of a configuration option.
	      </para>
	   </refsect1>
	   <refsect1>
	    <title>OPTIONS</title>
	    <para>
	       The <command>lrs2249</command> command has the following configuration
	       options:
	    </para>
	    <variablelist>
	       <varlistentry>
		  <term><option>-id</option> <replaceable>vsn</replaceable></term>
		  <listitem>
		     <para>
			Sets the module virtual slot number to <parameter>vsn</parameter>.
			The virtual slot number prefixes the data packet read from this
			module and is used by SpecTcl as a check on the validity
			the event.  Each module should have a unique <parameter>vsn</parameter>.
			If the <option>-id</option> option does not set the virtual
			slot it defaults to 0.
		     </para>
		  </listitem>
	       </varlistentry>
	       <varlistentry>
		  <term><option>-slot</option> <replaceable>slot</replaceable></term>
		  <listitem>
		     <para>
			Provides the module <parameter>slot</parameter>.  This
			parameter must match the number of the slot in the
			CAMAC crate in which the module is installed.
		     </para>
		  </listitem>
	       </varlistentry>
	    </variablelist>
	       
	   </refsect1>
        </refentry>
	 <refentry id="ccusb3-lrs2551">
	   <refmeta>
	      <refentrytitle>lrs2551</refentrytitle>
	      <manvolnum>3ccusb</manvolnum>
	   </refmeta>
	   <refnamediv>
	      <refname>lrs2551</refname>
	      <refpurpose>Manage LRS 2551 modules</refpurpose>
	   </refnamediv>
	   
	   <refsynopsisdiv>
	     <cmdsynopsis>
	     <command>
lrs2551 create <replaceable>module-name ?options...?</replaceable> 
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
lrs2551 config <replaceable>module-name ?options...?</replaceable> 	     
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
lrs2551 cget <replaceable>module-name</replaceable> 	     
	     </command>
	     </cmdsynopsis>
	   </refsynopsisdiv>
	   <refsect1>
	      <title>DESCRIPTION</title>
	      <para>
	       The <command>lrs2551</command> command allows you to create and
	       configure LeCroy LRS 2551 scaler modules.  The LRS 2551 is a
	       12 channel scaler.  While it is normally read in the periodic
	       scaler stack, it is also possible to read it in the event
	       stack when properly configured.
	      </para>
	      <para>
	       The <command>create</command> subcommand creates a new module
	       assigning it the name <parameter>module-name</parameter>.
	       <parameter>module-name</parameter> should be used to refer
	       to the module in future commands. Optional configuration data
	       can also be appended to the <command>create</command> subcommand.
	      </para>
	      <para>
	       The <command>config</command> subcommand configures an existing
	       <parameter>module-name</parameter>.  The configuration items are
	       name value pairs.  See OPTIONS below for more information about
	       the options supported by the <command>lrs2551</command> command.
	      </para>
	      <para>
	       The <command>cget</command> subcommand returns the current
	       module configuration.  The configuration is returned as a Tcl list.
	       Each element of the list is a two element sublist that contains
	       the configuration name and value in that order.
	      </para>
	   </refsect1>
	   <refsect1>
	    <title>OPTIONS</title>
	    <para>
	        The <command>lrs2551</command> command supports the following
		configuration options:
	    </para>
	    <variablelist>
	       <varlistentry>
		  <term><option>-cumulative</option> <replaceable>on|off</replaceable></term>
		  <listitem>
		     <para>
			If <option>-cumulative</option> is false (default),
			the scaler module is cleared after each readout providing
			the counts between each readout as the value of each
			channel. This shoulid be false when used with the NSCLDAQ
			scaler display program in the scaler stack.
		     </para>
		  </listitem>
	       </varlistentry>
	       <varlistentry>
		  <term><option>-id</option> <replaceable>vsn</replaceable></term>
		  <listitem>
		     <para>
			Supplies the virtual slot number; <replaceable>vsn</replaceable>
			for the module.  This only needs to be supplied if the
			module is going to be read in the event stack.
			Note that currently unpacking scaler data from the event
			stack is not supported.
		     </para>
		  </listitem>
	       </varlistentry>
	       <varlistentry>
		  <term><option>-insertid</option> <replaceable>true|false</replaceable></term>
		  <listitem>
		     <para>
			If <literal>true</literal> (the default is <literal>false</literal>),
			the virtual slot number set by the <option>-id</option>
			configuration value is inserted in the data block from
			the scaler.  If <literal>false</literal> it is not.
			If used with the NSCLDAQ Scaler display in the scaler stack,
			this should be <literal>false</literal>.
		     </para>
		  </listitem>
	       </varlistentry>
	       <varlistentry>
		  <term><option>-slot</option> <replaceable>slot</replaceable></term>
		  <listitem>
		     <para>
			Sets the <parameter>slot</parameter> configuration.
			When installed in the CAMAC crate, the module should
			be inserted in the <parameter>slot</parameter> specified
			by this option.
		     </para>
		  </listitem>
		  </varlistentry>
	    </variablelist>
	    
	   </refsect1>
	   <refsect1>
	      <title>EXAMPLES</title>
	      <para>
	       This example creates an LRS 2551 scaler:
	      </para>
	      <example>
	       <title>The lrs2551 command</title>
	       <programlisting>
lrs2551 create counters -slot 4
	       </programlisting>
	      </example>
	   </refsect1> 
</refentry>
         <refentry id="ccusb3-ph7xxx">
           <refmeta>
              <refentrytitle>ph7xxx</refentrytitle>
              <manvolnum>3ccusb</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>ph7xxx</refname>
              <refpurpose>Define Phillips ADC/TDC/QDC modules</refpurpose>
           </refnamediv>
           
           <refsynopsisdiv>
             <cmdsynopsis>
         	<command>
ph7xxx create <replaceable>name</replaceable> <optional>?option value ...?</optional>         	
         	</command>
             </cmdsynopsis>
                 <cmdsynopsis>
                     <command>
ph7xxx config <replaceable>name  option value...</replaceable>
                     </command>
                 </cmdsynopsis>
                  <cmdsynopsis>
                      <command>
ph7xxx cget <replaceable>name</replaceable>
                      </command>
                  </cmdsynopsis>
                
           </refsynopsisdiv>
           <refsect1>
              <title>DESCRIPTION</title>
              <para>
               Creates, configures and interrogates the configuration of Philips
               CAMAC digitizers.
              </para>
              <para>
               The <command>create</command> command creates
               a new digitizer <replaceable>name</replaceable> configuration.
               The <replaceable>name</replaceable> parameter must be unique.
               The optional <optional>option value</optional> pairs that follow
               specify the configuration for that module.  This configuration
               can  be supplemented or overridden by subsequent
               <command>config</command> operations on the module.
              </para>
               <para>
                  The <command>config</command> subcommand configures the existing
                  module <replaceable>name</replaceable>.  The remainder of the
                  command line are option value pairs described in the section
                  OPTIONS below.  The module <replaceable>name</replaceable> must
                  have already been created via the <command>create</command>
                  subcommand.  Note that configuration options are processed
                  from left to right, if a configuration option appears more than
                  once, the last instance takes effect.
               </para>
               <para>
                  The <command>cget</command> subcommand returns the configuration
                  of the module.  This can be used in more advanced scripts to
                  analyze the configuration of the system.  The configuration of
                  a module <replaceable>name</replaceable> is returned as a
                  properly formatted Tcl list.  Each element of the list is itself
                  a pair (a two element sublist).  The first element of each pair
                  is the configuration parameter name, the second element the
                  value, which may itself be  a list (e.g. for the
                  <literal>-llt</literal> option.
               </para>
           </refsect1>
           <refsect1>
              <title>
         	OPTIONS
              </title>
              <variablelist>
         	<varlistentry>
         	    <term><option>-slot</option> <replaceable>slotnumber</replaceable></term>
         	    <listitem>
         		<para>
                           This option configures the slot in which the module
                           will be installed.  All modules must be in unique slots,
                           although that is not verified by the configuration manager.
                           The slot must be an integer number from one through 23
                           (slot 24/25 holds the CAMAC crate controller).
         		</para>
                        <para>
                           The default value for this parameter is illegal (0),
                           so you must specify this parameter.
                        </para>
         	    </listitem>
         	</varlistentry>
		<varlistentry>
		     <term><option>-id</option> <replaceable>vsn</replaceable></term>
		     <listitem>
			<para>
			   Each module has an identifier which, for historical
			   reasons is called a <firstterm>virtual slot number</firstterm>,
			   or <firstterm>vsn</firstterm>.  To maximize the decode
			   error detection the virtual slot numbers for each
			   module should be unique.  This option allows you
			   to set the virtual slot number for the module.
			</para>
		        <para>
			   If the <option>-id</option> is not supplied, it defaults
			   to zero.
			</para>
		     </listitem>
		</varlistentry>
                <varlistentry>
                  <term><option>-sparse</option> <replaceable>bool</replaceable></term>
                  <listitem>
                     <para>
                        If the value of this configuration is true, the module
                        is read in sparse readout mode (A Q-Stop of F4@A0).
                        SpecTcl expects this to be true and that is also the default
                        value.
                     </para>
                     <para>
                        The values
                        <literal>true</literal>,
                        <literal>yes</literal>,
                        <literal>1</literal>,
                        <literal>on</literal> and
                        <literal>enabled</literal> are all recognized as true
                        values while the values
                        <literal>false</literal>,
                        <literal>no</literal>,
                        <literal>0</literal>,
                        <literal>off</literal>, and
                        <literal>disabled</literal> are all recognized as false
                        values.
                     </para>
                  </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-readhits</option> <replaceable>bool</replaceable></term>
                     <listitem>
                        <para>
                           If the value of this configuration is true,the module's
                           hit register is read prior to the channels (F6@A1).
                           SpecTcl requires this parameter to be true, and that's the
                           default value.
                        </para>
                        <para>
                           SpecTcl will use this value to determine the number of
                           digitizer data words that follow for this module.
                        </para>
                        <para>
                        The values
                        <literal>true</literal>,
                        <literal>yes</literal>,
                        <literal>1</literal>,
                        <literal>on</literal> and
                        <literal>enabled</literal> are all recognized as true
                        values while the values
                        <literal>false</literal>,
                        <literal>no</literal>,
                        <literal>0</literal>,
                        <literal>off</literal>, and
                        <literal>disabled</literal> are all recognized as false
                        values.
                     </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-pedestals</option> <replaceable>int[16]</replaceable></term>
                     <listitem>
                        <para>
                           Supplies the pedestals for each channel.  This must be
                           a 16 element list of integers.  These values are
                           initialized to zero.  Note that the pedestals are
                           ignored unless <option>-usepdestals</option> is true.
                        </para>
                        <para>
                           The best way to construct this list of pedestals is to
                           use the Tcl <command>list</command> command for example:
                        </para>
                        <example>
                           <title>Using the <command>list</command> command to
                                  construct pedestals</title>
                           <programlisting>
                           <command>
ph7xxx config someadc -pedestals [list 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20]
                           </command>
                           </programlisting>
                        </example>
                        <para>
                           Note that pedestals can be specified as decimal values
                           (as shown in the example above), hexadecimal value
                           by preceding a number with the text <literal>0x</literal>
                           or octal by preceding the number with a leading <literal>0</literal>.
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-llt</option> <replaceable>int[16]</replaceable></term>
                     <listitem>
                        <para>
                           Supplies the low level thresholds for each channel.  This must
                           be a 16 element list of integers.  These values are initialized
                           to zero.  Note that the low level thresholds are ignored unless
                           <option>-usellt</option> is true.
                        </para>
                        <para>
                           See the description of <option>-pedestals</option> above
                           for more information about how to construct this list.
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-hlt</option> <replaceable>int[16]</replaceable></term>
                     <listitem>
                        <para>
                           Supplies the high level thresholds for each channel. This
                           must be a 16 element list of integers.  These values
                           are initialized to full scale (<literal>4095</literal>).
                           The high level thresholds are ignored unless the
                           parameter <option>-usehlt</option> is true.
                        </para>
                        <para>
                           See the description of <option>-pedestals</option>
                           above for more information about how to construct
                           this list.
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-usellt</option> <replaceable>boolean</replaceable></term>
                     <listitem>
                        <para>
                           Enables or disables the low level threshold (sets or clears
                           the <literal>LT Enable</literal> bit in the control
                           register).  This is useful if
                           <option>-llt</option> has been used to program
                           low level thresholds and <option>-sparse</option>
                           has been set to true.
                       </para>
                       <para>
                        The values
                        <literal>true</literal>,
                        <literal>yes</literal>,
                        <literal>1</literal>,
                        <literal>on</literal> and
                        <literal>enabled</literal> are all recognized as true
                        values while the values
                        <literal>false</literal>,
                        <literal>no</literal>,
                        <literal>0</literal>,
                        <literal>off</literal>, and
                        <literal>disabled</literal> are all recognized as false
                        values.
                     </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-usehlt</option> <replaceable>bool</replaceable></term>
                     <listitem>
                        <para>
                           Enables or disables the high level threshold (sets or
                           clears the <literal>UT Enable</literal> bit in the
                           module control register).  This is useful if
                           <option>-hlt</option> has been used to set the high
                           level thresholds and <option>-sparse</option> has
                           been set to true.
                        </para>
                       <para>
                        The values
                        <literal>true</literal>,
                        <literal>yes</literal>,
                        <literal>1</literal>,
                        <literal>on</literal> and
                        <literal>enabled</literal> are all recognized as true
                        values while the values
                        <literal>false</literal>,
                        <literal>no</literal>, 
                        <literal>0</literal>,
                        <literal>off</literal>, and
                        <literal>disabled</literal> are all recognized as false
                        values.
                     </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-usepedestals</option> <replaceable>bool</replaceable></term>
                     <listitem>
                        <para>
                           Enables or disables per chanel pedestal subtraction.
                           This is most useful when <option>-pedestals</option>
                           has been used to program a set of pedestals into
                           the module.
                        </para>
                       <para>
                        The values
                        <literal>true</literal>,
                        <literal>yes</literal>,
                        <literal>1</literal>,
                        <literal>on</literal> and
                        <literal>enabled</literal> are all recognized as true
                        values while the values
                        <literal>false</literal>,
                        <literal>no</literal>,
                        <literal>0</literal>,
                        <literal>off</literal>, and
                        <literal>disabled</literal> are all recognized as false
                        values.
                     </para>
                     </listitem>
                  </varlistentry>
              </variablelist>
           </refsect1>
           <refsect1>
              <title>EXAMPLES</title>
              <para>
                  The example below creates a Phillips module named
                  <literal>adc1</literal> and programs all of the configuration
                  options.  Note that in many cases you won't need to do this
                  (e.g. for ADC's the high level thresholds usually can be left
                  up at <literal>4095</literal>
              </para>
              <example>
                  <title>Sample <command>ph7xxx</command> commands</title>
                  <programlisting>
ph7xxx create adc1 -slot 5
ph7xxx config adc1 -sparse enabled -readhits true -usellt true -usehlt false
ph7xxx config adc1 -usepedestals enabled
ph7xxx config adc1 -pedestals [list 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 ]
ph7xxx config adc1 -llt [list 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10]
ph7xxx config adc1 -hlt [list 3000 3000 3000 3000 3000 3000 3000 \
                              3000 3000 3000 3000 3000 3000 3000 3000 3000 ]
                  </programlisting>
              </example>
           </refsect1>

         </refentry>
         <refentry id="ccusb3-stack">
           <refmeta>
              <refentrytitle>stack</refentrytitle>
              <manvolnum>3ccusb</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>stack</refname>
              <refpurpose>Create and configure CC-USB stacks.</refpurpose>
           </refnamediv>
           
           <refsynopsisdiv>
             <cmdsynopsis>
         	<command>
stack create <replaceable>name</replaceable>

         	</command>
             </cmdsynopsis>
               <cmdsynopsis>
                   <command>
stack config <replaceable>name option value...</replaceable>
                   </command>
               </cmdsynopsis>
            <cmdsynopsis>
                <command>
stack cget <replaceable>name</replaceable>
                </command>
            </cmdsynopsis>
           
           </refsynopsisdiv>
           <refsect1>
              <title>DESCRIPTION</title>
              <para>
         	Creates and configures CC-USB stacks.  Stacks are lists of
                CAMAC operations that are loaded into the CC-USB for autonomous
                execution.  There are two types of stacks; an
                <firstterm>event</firstterm> stack that is executed when
                a front panel trigger or a specified LAM is detected, and
                a <firstterm>scaler</firstterm> stack that can be periodically
                triggered.
              </para>
               <para>
                  Stacks contain lists of modules.  The modules themselves
                  determine the set of readout instructions that make up each
                  stack.  
               </para>
               <note>
                  <para>
                     In this version of the U. Mass. Lowell software, no
                     CAMAC scaler modules are supported, so the scaler stack
                     is not very useful.
                  </para>
               </note>
               <para>
                  The <command>create</command> subcommand creates a new stack.
                  The name of the new stack is <replaceable>name</replaceable>.
                  This <replaceable>name</replaceable> will be used to refer to
                  this stack in future configuration commands.
               </para>
               <para>
                  The <command>config</command> subcommand configures the stack
                  <replaceable>name</replaceable>.  The configuration is
                  specified as a set of option value pairs.  The options
                  are described in the section OPTIONS below.
               </para>
               <para>
                  The <command>cget</command> subcommand returns the configuration
                  of the stack <replaceable>name</replaceable> as its command value.
                  This subcommand is intended for advanced applications that may
                  analyze the configuration of the stack.  The configuration is
                  returned as a properly formatted Tcl list.  Each element of the list
                  is itself a two element sublist (pair).  The first element of each
                  pair is the name of a configuration parameter the second, that
                  configuration parameter's value.  Note that the value may itself
                  be a list.
               </para>
           </refsect1>
           <refsect1>
              <title>
         	OPTIONS
              </title>
               <para>
                  Options are used to configure the stack.  Each option has associated
                  with it a keyword that selects it and a value.  The option s supported
                  by the <command>stack</command> command are subdivided into three groups:
                  <orderedlist>
                     <listitem>
                        <para>Options used for both event and scaler stacks.</para>
                     </listitem>
                     <listitem>
                        <para>Options that are only used for event stacks and are ignored
                           for scaler stacks</para>
                     </listitem>
                     <listitem>
                        <para>Options that are only used for scaler stacks, and are
                           ignored for event stacks.
                        </para>
                     </listitem>
                  </orderedlist>
               </para>
               <formalpara>
                  <title>Options for all stack types</title>
                  <para>
                  </para>
               </formalpara>
               <variablelist>
                  <varlistentry>
         	     <term><option>-type</option> <replaceable>stack-type</replaceable></term>
         	     <listitem>
         		<para>
                           Defines the type of stack that is being used.  This
                           can be one of the keywords
                           <literal>event</literal> for event stacks or
                           <literal>scaler</literal> for scaler stacks.
                           The CC-USB only supports one scaler and one event stack.
                           The current version of the configuration engine allows
                           you to create more than one of each stack. In that case,
                           it is not well defined which stacks are actually loaded.
         		</para>
                        <para>
                           The default <option>-type</option> is <literal>event</literal>.
                        </para>
         	     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-modules</option> <replaceable>module-list</replaceable></term>
                     <listitem>
                        <para>
                           This option defines the set of modules that are added
                           to the stack.  <replaceable>module-list</replaceable> is a
                           properly formatted Tcl list of names of modules
                           (ph7xxx's in this implementation) that will be read
                           by this stack.  See the EXAMPLES section below
                           for more information.
                        </para>
                     </listitem>
                  </varlistentry>
               </variablelist>
               <formalpara>
                  <title>Event stack options</title>
                  <para>
                  </para>
               </formalpara>
               <variablelist>
                  <varlistentry>
                     <term><option>-lams</option>   <replaceable>mask</replaceable></term>
                     <listitem>
                        <para>
                           Specifies the mask of LAMs that can trigger the list.
                           I suggest leaving this value at zero, and deriving a
                           trigger signal for the NIM IN1 input as the readout
                           trigger.
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-lamtimeout</option> <replaceable>microseconds</replaceable></term>
                     <listitem>
                        <para>
                           The <command>ph7xxx</command> command delays the read
                           of the module until it is signalling a LAM.
                           <replaceable>microseconds</replaceable> specifies the
                           total number of microseconds the stack should wait for
                           this LAM.  The value should be on the order of the
                           conversion time of the module.  Defaults to zero.
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-delay</option> <replaceable>microseconds</replaceable></term>
                     <listitem>
                        <para>
                           Delays the execution of the stack for <replaceable>microseconds</replaceable>
                           microseconds after the trigger condition is detected.
                           This can be used to ensure the digitization hardware
                           has sufficient time to complete its digitization prior
                           to stack execution. Defaults to zero.
                        </para>
                     </listitem>
                  </varlistentry>
               </variablelist>
               <formalpara>
                  <title>Options only available for scalers stacks</title>
                  <para>
                     The options below are only legal for stacks of
                     <option>-type</option> <literal>scaler</literal>
                  </para>
               </formalpara>
               <variablelist>
                  <varlistentry>
                     <term><option>-period</option> <replaceable>seconds</replaceable></term>
                     <listitem>
                        <para>
                           Number of seconds between execution of the scaler stack.
                           This defaults to 2.
                        </para>
                     </listitem>
                  </varlistentry>
               </variablelist>
            
           </refsect1>
           <refsect1>
               <title>EXAMPLES</title>
               <para>
                  The example below extends the example in the
                  <link linkend="ccusb3-ph7xxx">ph7xxx</link> command reference
                  reading the defined modules in an event stack:
               </para>
               <example>
                  <title>Example of the <command>stack</command> command.</title>
                  <programlisting>
ph7xxx create adc1 -slot 6
ph7xxx create adc2 -slot 7                                  <co id="defmodules" />


stack create events                                         <co id="stackdef" />
stack config events -type event -modules [list adc1 adc2]   <co id="typemods" />
stack config events -delay 10 -lamtimeout 8                 <co id ="timing" />
                  </programlisting>
               </example>
               <calloutlist>
                  <callout arearefs="defmodules">
                     <para>
                        These two lines define the modules that we will be using
                        for the experimental setup.
                     </para>
                  </callout>
                  <callout arearefs="stackdef">
                     <para>
                        Creates a new stack called <literal>events</literal>
                        In subsequent lines I'm going to configure this stack
                        to handle the event trigger.
                     </para>
                  </callout>
                  <callout arearefs="typemods">
                     <para>
                        The stack is configured to be the event stack, and
                        the two modules we created <literal>adc1</literal>
                        and <literal>adc2</literal> are added to the stack
                        in that order.  When the stack is loaded, it will
                        contain the instructions to read out these two modules.
                     </para>
                  </callout>
                  <callout arearefs="timing">
                     <para>
                        Configures the stack so that the CC-USB will start
                        stack execution 10 microseconds after the IN1 trigger.
                        Stack instructions that wait for a lam on their target
                        module will wait at most 8 microseconds.  Since the
                        <option>-lams</option> option is left to default to zero,
                        CAMAC lams will not be able to trigger the list.
                     </para>
                  </callout>
               </calloutlist>
               
                  
           </refsect1>
         </refentry>
      <refentry id="ccusb3-Module">
        <refmeta>
           <refentrytitle>Module</refentrytitle>
           <manvolnum>3ccusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>Module</refname>
           <refpurpose>Create and manipulate slow control device instances</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
         <command>
Module create <replaceable>type name</replaceable>
          </command>
          </cmdsynopsis>
          <cmdsynopsis>
            <command>
Module config <replaceable>name options....</replaceable>
            </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
Module cget <replaceable>name</replaceable>
                </command>
            </cmdsynopsis>
        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            The Module command creates and manipulates instances of slow
            control devices.  It must appear in the control configuration script
            rather than the daq configuration script.  The <command>create</command>
            subcommand creates an object with the specified <parameter>type</parameter>
            and <parameter>name</parameter>.  Currently the following device types
            are supported:
            <variablelist>
                <varlistentry>
                    <term>caen894</term>
                    <listitem>
                        <para>
                            A CAEN C894 16 channel leading edge discriminator.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>ph7106</term>
                    <listitem>
                        <para>
                            A Phillips Ph7106 leading edge discriminator.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </para>
           <para>
            The <command>config</command> subcommand configures the named module.
            In most cases the configuration of a slow control module is pretty
            minimal as the assumption is that there is a slow control
            panel associated with the device.  Typical configuration consists
            of a <option>-slot</option> which provides the CAMAC slot in which
            the module is installed and a <option>-file</option> which provides
            the initial settings of the device (the file is usually maintained
            by the control panel).  Note that the <literal>ph7106</literal>
            currently only supports the <option>-slot</option> option.
            (This code was contributed by Lakshmi SoundaraPandian of the
            University of Massachussets Lowell).
           </para>
           <para>
                The <command>cget</command> subcommand retrieves the
                configuration of the named modules as a
                well formatted Tcl list of name
                value pairs where the name is an option name and the value is
                the value of that option. e.g.
                <informalexample>
                    <programlisting>
{ {-slot 5} {-file /user/fox/config.camac/led.settings}}
                    </programlisting>
                </informalexample>
            </para>
        </refsect1>

      </refentry>
      <refentry id="ccusb3-ControlProtocol">
        <refmeta>
           <refentrytitle>Slow controls protocol</refentrytitle>
           <manvolnum>3ccusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>Slow controls protocol</refname>
           <refpurpose>TCP/IP slow control protocol</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
Update <replaceable>name</replaceable>               
            </command>
          </cmdsynopsis>
          <cmdsynopsis>
            <command>
Set <replaceable>name parameter value</replaceable>
            </command>
          </cmdsynopsis>
          <cmdsynopsis>
            <command>
Get <replaceable>name parameter</replaceable>
            </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            The protocol which communicates with the slow control server is
            a set of commands that are submitted to a Tcl interpreter that
            is running in the server.  Three commands result in
            dispatch to slow controls drivers.  If the run is active, the dispatch
            to the driver functions is preceeded by pausing the run and
            succeeded by resuming the run.  This allows driver functions
            unimpeded access to the CCUSB.
           </para>
           <para>
            Each driver is assumed to implement a set of named parameters.
            These parameters have values which are passed to and from the
            driver without interpretation.  Commands that result errors return
            strings to the client that begin with the text <literal>ERROR - </literal>
            with an english error message appended to that prefix.
           </para>
        </refsect1>
        <refsect1>
           <title>
              SUBCOMMANDS
           </title>
           <variablelist>
                <varlistentry>
                    <term>Update <replaceable>name</replaceable></term>
                    <listitem>
                        <para>
                            Asks the driver for the instance <replaceable>name</replaceable>
                            to update any internal state it maintains from the
                            device or, alternatively, depending on the driver
                            refresh any device state from internal state.
                            Normally this is used for devices that have write-only
                            registers, for those devices, typically the driver
                            must retain some concept of what it believes the
                            state of the physical device is.  This command is
                            then used to ensure the actual state of the device
                            matches the believed state.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Set <replaceable>name parameter-name value</replaceable></term>
                    <listitem>
                        <para>
                            Note the capital S in <command>Set</command> to
                            distinguish it from the similar Tcl command.
                            This command is used by a client to alter
                            a parameter value.  <replaceable>name</replaceable>
                            is the name of a Module instance,
                            <replaceable>parameter-name</replaceable> is the
                            name of a parameter maintained by the driver for
                            that device and <replaceable>value</replaceable> is
                            the new requested value for the parameter.
                        </para>
                        <para>
                            On success the client is returned a line containing
                            the string <literal>OK</literal> otherwise
                            <literal>ERROR -</literal> along with a message
                            is returned as describedin DESCRIPTION above.
                        </para>
                        <para>
                            Note that the legal parameter names and their legal
                            values are soley determined by the device driver.
                            See the device specific sections below for
                            more information.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Get <replaceable>name parameter-name</replaceable></term>
                    <listitem>
                        <para>
                            Returns the value of the parameter
                            <replaceable>parameter-name</replaceable> from
                            the Module instance <replaceable>name</replaceable>.
                            If this is successful, the value of the parameter
                            will be returned to the client.  Otherwise a line
                            beginnning with <literal>ERROR - </literal> will
                            be returned along with a textual error message.
                        </para>
                    </listitem>
                </varlistentry>
           </variablelist>
        </refsect1>
        <refsect1>
            <title>PARAMETERS FOR SUPPORTED DEVICES</title>
            <refsect2>
                <title>ph7106</title>
                <para>
                    The following parameters are supported by the
                    driver for the Phillips PH7106 leading edge
                    discriminator.  As this device has read/write
                    registers, <command>Update</command> is a no-op
                    and the <command>Get</command> operation fetches
                    state directly from the device.
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>threshold</literal></term>
                        <listitem>
                            <para>
                                Represents the single module threshold.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>mask</literal></term>
                        <listitem>
                            <para>
                                Represents the module mask parameter.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>mode</literal></term>
                        <listitem>
                            <para>
                                Represents the control mode of the device.
                                this can be one of <literal>camac</literal>
                                or <literal>local</literal>.  This parameter
                                is read-only and represents the state of a
                                switch on the module front panel.
                                If the module is in <literal>local</literal>
                                mode, no changes can be made by CAMAC
                                operations.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
        
            </refsect2>
            <refsect2>
                <title>caen894</title>
                <para>
                    The following parameters are suppoerted by the
                    CAEN C894 device support.  These are all read/write
                    parameters, although Get accesses internal driver
                    memory of the last settings done as the actual
                    hardware is write-only.
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>threshold</literal><replaceable>n</replaceable></term>
                        <listitem>
                            <para>
                                Represents the value of the threshold for
                                channel <replaceable>n</replaceable> e.g.
                                <literal>threshold10</literal> represents
                                the threshold value for channel 10.
                                Thresholds number from <literal>[0-15]</literal>
                                and have values between <literal>[0-255]</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>width</literal><replaceable>n</replaceable></term>
                        <listitem>
                            <para>
                                Represents the output width of channel
                                <replaceable>n</replaceable>.  Legal values
                                are in the range <literal>[0-255]</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>inhibits</literal></term>
                        <listitem>
                            <para>
                                Represents the module inhibits mask.
                                This 16 bit value has one bit for each channel.
                                The least significant bit represents channel 0
                                the most significant bit channel 15.
                                Set bits represent channnels that are inhibited.
                            </para>
                        </listitem>
                    </varlistentry> 
                    <varlistentry>
                        <term><literal>majority</literal></term>
                        <listitem>
                            <para>
                                Represents the majority level.  This value
                                is in the range <literal>[1-20]</literal>
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                </refsect2>
        </refsect1>
      </refentry>
         
	 <refentry id="ccusb3-CCCUSB">
       <refmeta>
          <refentrytitle>CCCUSB</refentrytitle>
          <manvolnum>3ccusb</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CCCUSB</refname>
          <refpurpose>Provide access to a CC-USB device.</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <programlisting>
        <synopsis>
            class <ooclass><classname>CCCUSB</classname></ooclass> {
            <methodsynopsis>
                <modifier>static</modifier>
                <type>std::vector&lt;struct usb_device*&gt;</type>
                <methodname>enumerate</methodname>
                <void />
            </methodsynopsis>
            
            <methodsynopsis>
                <modifier>static</modifier>
                <type>std::string</type>
                <methodname>serialNo</methodname>
                <methodparam>
                    <type>struct usb_device*</type><parameter>dev</parameter>
                </methodparam>
            </methodsynopsis>
            
           <constructorsynopsis>
          <methodname>CCCUSB</methodname>
          <methodparam>
            <type>struct usb_device*</type><parameter>vmUsbDevice</parameter>
          </methodparam>
           </constructorsynopsis>
            <methodsynopsis>
              <type>void</type>
              <methodname>writeActionRegister</methodname>
              <methodparam>
                <type>uint16_t</type> <parameter>value</parameter>
              </methodparam>
            </methodsynopsis>
            <methodsynopsis>
              <type>int</type>
              <methodname>simpleWrite16</methodname>
              <methodparam>
                <type>int</type><parameter>n</parameter>
              </methodparam>
              <methodparam>
                <type>int</type><parameter>a</parameter>
              </methodparam>
              <methodparam>
                <type>int</type><parameter>f</parameter>
              </methodparam>
              <methodparam>
                <type>uint16_t</type><parameter>data</parameter>
              </methodparam>
              <methodparam>
                <type>uint16_t&amp;</type><parameter>qx</parameter>
              </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>simpleWrite24</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>data</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t&amp;</type> <parameter>qx</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>simpleRead16</methodname>
                <methodparam>
                    <type>int</type><parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type><parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t&amp;</type> <parameter>data</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t&amp;</type> <parameter>qx</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>simpleRead24</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t&amp;</type><parameter>data</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t&amp;</type> <parameter>qx</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>simpleControl</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type><parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t&amp;</type> <parameter>qx</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readFirmware</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readGlobalMode</methodname>
                <methodparam>
                    <type>uint16_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeGlobalMode</methodname>
                <methodparam>
                    <type>uint16_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readDelays</methodname>
                <methodparam>
                    <type>uint16_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeDelays</methodname>
                <methodparam>
                    <type>uint16_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type>  <methodname>readScalerControl</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeScalerControl</methodname>
                <methodparam>
                    <type>uint32_t</type><parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readLedSelector</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeLedSelector</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readOutputSelector</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeOutputSelector</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readDeviceSourceSelectors</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type><parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeDeviceSourceSelectors</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readDGGA</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readDGGB</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readDGGExt</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeDGGA</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeDGGB</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeDGGExt</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readScalerA</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readScalerB</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readLamTriggers</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeLamTriggers</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readUSBBulkTransferSetup</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeUSBBulkTransferSetup</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>c</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>z</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>inhibit</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>uninhibit</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>executeList</methodname>
                <methodparam>
                    <type>CCCUSBReadoutList&amp;</type> <parameter>list</parameter>
                </methodparam>
                <methodparam>
                    <type>void*</type><parameter>pReadBuffer</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t</type><parameter>readBufferSize</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t*</type><parameter>bytesRead</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>loadList</methodname>
                <methodparam>
                    <type>uint8_t</type><parameter>listNumber</parameter>
                </methodparam>
                <methodparam>
                    <type>CCCUSBReadoutList&amp;</type><parameter>list</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>usbRead</methodname>
                <methodparam>
                    <type>void*</type> <parameter>data</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t</type> <parameter>bufferSize</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t*</type><parameter> transferCount</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>timeout</parameter>
                    <initializer> 2000</initializer>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setDefaultTimeout</methodname>
                <methodparam>
                    <type>int</type> <parameter>ms</parameter>
                </methodparam>
            </methodsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::ActionRegister::startDAQ</varname><initializer>1</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::ActionRegister::usbTrigger</varname><initializer>2</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::ActionRegister::clear</varname><initializer>4</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::ActionRegister::scalerDump</varname><initializer>0x10</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::FirmwareRegister::revisionMask</varname>
                <initializer>0xff</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::FirmwareRegister::revisionShift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::FirmwareRegister::yearMask</varname>
                <initializer>0xf00</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::FirmwareRegister::yearShift</varname>
                <initializer>8</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::FirmwareRegister::monthMask</varname>
                <initializer>0xf000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::FirmwareRegister::monthShift</varname><initializer> 12</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLenMask</varname>
                <initializer>0xf</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLenShift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLen4K</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLen2K</varname>
                <initializer>1</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLen1K</varname>
                <initializer>2</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLen512</varname>
                <initializer>3</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t </type>
                <varname>CCCUSB::GlobalModeRegister::bufferLen256</varname>
                <initializer>4</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLen128</varname>
                <initializer>5</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLen64</varname>
                <initializer>6</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLenSingle</varname>
                <initializer>7</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::mixedBuffers</varname>
                <initializer>0x20</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::doubleHeader</varname>
                <initializer>0x100</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::enableSecondary</varname>
                <initializer>0x1000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::DelayRegister::triggerDelayMask</varname>
                <initializer>0xff</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::DelayRegister::triggerDelayShift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::DelayRegister::lamTimeoutMask</varname>
                <initializer>0xff00</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::DelayRegister::lamTimeoutShift</varname>
                <initializer>8</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::ScalerControlRegister::eventsCountMask</varname>
                <initializer>0xffff</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::ScalerControlRegister::eventsCountShift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::ScalerControlRegister::timeIntervalMask</varname>
                <initializer>0xff0000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::ScalerControlRegister::timeIntervalShift</varname>
                <initializer>16</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier>  <type> uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::redEventTrigger</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::redBusy</varname>
                <initializer>1</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::redUSBTrigger</varname>
                <initializer>2</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::redUSBOutFifoNotEmpty</varname>
                <initializer>3</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::redUSBInFifoNotFull</varname>
                <initializer>4</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::redAcquire</varname>
                <initializer>6;</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::redCAMACF2</varname>
                <initializer>7</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::redInvert</varname>
                <initializer>0x10</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::redLatch</varname>
                <initializer>0x20</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::greenAcquire</varname>
                <initializer>0x000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::greenCAMACF1</varname>
                <initializer>0x100</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::greenEventTrigger</varname>
                <initializer>0x300</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname> CCCUSB::LedSourceRegister::greenCAMACN</varname>
                <initializer>0x400</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::greenI1</varname>
                <initializer>0x600</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::greenUSBInFifoNotEmpty</varname>
                <initializer>0x700</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::greenInvert</varname>
                <initializer>0x1000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::greenLatch</varname>
                <initializer>0x2000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::yellowI3</varname>
                <initializer>0x00000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::yellowBusy</varname>
                <initializer>0x10000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::yellowI2</varname>
                <initializer>0x20000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::yellowCAMACS1</varname>
                <initializer>0x30000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::yellowCAMACS2</varname>
                <initializer>0x40000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::yellowUSBInFifoNotEmpty</varname>
                <initializer>0x50000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::yellowScalerReadout</varname>
                <initializer>0x60000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::yellowUSBTrigger</varname>
                <initializer>0x70000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::yellowInvert</varname>
                <initializer>0x100000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::yellowLatch</varname>
                <initializer>0x200000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegisternimO1Busy</varname>
                <initializer>0x000000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegisternimO1EventTrigger</varname>
                <initializer>0x000001</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegisternimO1DGGA</varname>
                <initializer>0x000002</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegisternimO1DGGB</varname>
                <initializer>0x000003</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegisternimO1Latch</varname>
                <initializer>0x000010M</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier>    <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegisternimO1Invert</varname>
                <initializer>0x000020</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegisternimO2Acquire</varname>
                <initializer>0x000000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier>   <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegisternimO2Event</varname>
                <initializer>0x000200</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegisternimO2DGGA</varname>
                <initializer>0x000400</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegisternimO2DGGB</varname>
                <initializer>0x000600</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegisternimO2Latch</varname>
                <initializer>0x001000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegisternimO2Invert</varname>
                <initializer>0x002000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegisternimO3EndOfBusy</varname>
                <initializer>0x000000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegisternimO3Busy</varname>
                <initializer>0x020000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegisternimO3DGGA</varname>
                <initializer>0x040000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegisternim03DGGB</varname>
                <initializer>0x060000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegisternimO3Latch</varname>
                <initializer>0x100000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegisternimO3Invert</varname>
                <initializer>0x200000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerADisabled</varname>
                <initializer>0x00000000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAI1</varname>
                <initializer>0x00000001</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAI2</varname>
                <initializer>0x00000002</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAI3</varname>
                <initializer>0x00000003</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier>   <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAEvent</varname>
                <initializer>0x00000004</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerACarryB</varname>
                <initializer>0x00000005</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerADGGA</varname>
                <initializer>0x00000006</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerADGGB</varname>
                <initializer>0x00000007</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const </modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAEnable</varname>
                <initializer>0x00000010</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAScalerAReset</varname>
                <initializer>0x00000020</initializer>
            </fieldsynopsis> 
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAFreezReg</varname>
                <initializer>0x00000040</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBDisabled</varname>
                <initializer>0x00000000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBI1</varname>
                <initializer>0x00000100</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBI2</varname>
                <initializer>0x00000200</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBI3</varname>
                <initializer>0x00000300</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBEvent</varname>
                <initializer>0x00000400</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBCarryA</varname>
                <initializer>0x00000500</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBDGGA</varname>
                <initializer>0x00000600</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBDGGB</varname>
                <initializer>0x00000700</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBEnable</varname>
                <initializer>0x00001000</initializer>
                </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBReset</varname>
                <initializer>0x00002000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBFreezeReg</varname>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::dggADisabled</varname>
                <initializer>0x00000000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAI1</varname>
                <initializer>0x00010000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAI2</varname>
                <initializer>0x00020000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAI3</varname>
                <initializer>0x00030000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAEvent</varname>
                <initializer>0x00040000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAEndOfEvent</varname>
                <initializer>0x00050000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAUSBTrigger</varname>
                <initializer>0x00060000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAPulser</varname>
                <initializer>0x00070000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBDisabled</varname>
                <initializer>0x00000000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBI1</varname>
                <initializer>0x01000000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBI2</varname>
                <initializer>0x02000000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBI3</varname>
                <initializer>0x03000000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBEvent</varname>
                <initializer>0x04000000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBEndOfTrigger</varname>
                <initializer>0x05000000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBUSBTrigger</varname>
                <initializer>0x06000000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBPulser</varname>
                <initializer>0x07000000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DGGAndPulserRegister::dggFineDelayMask</varname>
                <initializer>0xffff</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DGGAndPulserRegister::dggFineDelayShift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DGGAndPulserRegister::dggGateWidthMask</varname>
                <initializer>0xffff0000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DGGAndPulserRegister::dggGateWidthShift</varname>
                <initializer>16</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DGGCoarseRegister::ACoarseMask</varname>
                <initializer>xffff;</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::DGGCoarseRegister::ACoarseShift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DGGCoarseRegister::BCoarseMask</varname>
                <initializer>0xffff0000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DGGCoarseRegister::BCoarseShift</varname>
                <initializer>16</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCCUSB::TransferSetupRegister::multiBufferCountMask</varname>
                <initializer>0xff</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t </type>
                <varname>CCCCUSB::TransferSetupRegister::multiBufferCountShift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCCUSB::TransferSetupRegister::timeoutMask</varname>
                <initializer>0xf00</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCCUSB::TransferSetupRegister::timeoutShift</varname>
                <initializer>8</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::Q</varname>
                <initializer>1</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::X</varname>
                <initializer>2</initializer>
            </fieldsynopsis>
            };
       </synopsis>
        </programlisting>   
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            The <classname>CCCUSB</classname> class represents a connection
            to a CC-USB controller.  The static members <methodname>enumerate</methodname>
            and <methodname>serialNo</methodname> allow programs to become
            aware of the set of interfaces that are currently plugged in
            and powered up, and to associated them with serial number strings.
          </para>
          <para>
            Constructing an object around a specific <classname>usb_device*</classname>
            allows you to interact with the device represented by that struct.
            The class exports a rich set of methods which are described in the
            METHODS section below.  Bits and bit fields are defined as class
            constants described in PUBLIC VARIABLES, TYPES and CONSTANTS below.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <para>
            In the functions listed below, any function that returns an <type>int</type>
            returns <literal>0</literal> on success, <literal>-1</literal> if
            the write operation to the device failed or <literal>-2</literal>
            if the read operation failed.  Negative values result in the
            <varname>errno</varname> variable set to the actual reason for the
            failure.
          </para>
            <variablelist>
                <varlistentry>
                    <term><methodsynopsis><modifier>static</modifier>
                    <type>std::vector&lt;struct usb_device*&gt;</type>
                    <methodname>enumerate</methodname>
                    <void /></methodsynopsis></term>
                    <listitem>
                        <para>
                            Enumerates the set of CC-USB devices that are attached
                            and powered up on the host.  The return value
                            is a vector of <classname>usb_device*</classname> pointers
                            each of which represents one of those devices.
                        </para>
                        <para>
                            You can use a <classname>usb_device*</classname> pointer
                            to construct a <classname>CCCUSB</classname> object
                            or to query the serial number of that device.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodsynopsis><modifier>static</modifier>
                        <type>std::string</type>
                        <methodname>serialNo</methodname>
                        <methodparam>
                            <type>struct usb_device*</type><parameter>dev</parameter>
                        </methodparam></methodsynopsis> </term>
                    <listitem>
                        <para>
                            Returns the serial number string for the CC-USB
                            represented by the <parameter>dev</parameter>
                            parameter.  <parameter>dev</parameter> should have
                            been gotten from a call to <function>CCCUSB::enumerate</function>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><constructorsynopsis>
                    <methodname>CCCUSB</methodname>
                    <methodparam>
                      <type>struct usb_device*</type><parameter>vmUsbDevice</parameter>
                    </methodparam>
                     </constructorsynopsis></term>
                    <listitem>
                        <para>
                            Constructs a <classname>CCCUSB</classname> object.
                            The resulting object can be used to communicate
                            with the CC-USB represented by the
                            <parameter>vmUsbDevice</parameter> object.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                        <type>void</type>
                        <methodname>writeActionRegister</methodname>
                        <methodparam>
                          <type>uint16_t</type> <parameter>value</parameter>
                        </methodparam>
                      </methodsynopsis></term>
                    <listitem>
                        <para>
                            Writes the CCUSB's action register. The class also
                            supplies symoblic definitions for bits in the action
                            register.  See the Action register section of 
                            PUBLIC VARIABLES, TYPES and CONSTANTS below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                         <type>int</type>
                         <methodname>simpleWrite16</methodname>
                         <methodparam>
                           <type>int</type><parameter>n</parameter>
                         </methodparam>
                         <methodparam>
                           <type>int</type><parameter>a</parameter>
                         </methodparam>
                         <methodparam>
                           <type>int</type><parameter>f</parameter>
                         </methodparam>
                         <methodparam>
                           <type>uint16_t</type><parameter>data</parameter>
                         </methodparam>
                         <methodparam>
                           <type>uint16_t&amp;</type><parameter>qx</parameter>
                         </methodparam>
                       </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a CAMAC write operations with a
                            16 bit wide data transfer.
                            The parameters <parameter>n,a,f</parameter>
                            specify the slot, subaddress and function code
                            respectively while the <parameter>data</parameter>
                            parameter provides the data to write.  The
                            <parameter>qx</parameter> parameter receives a
                            bit encoding of the Q and X responses of the
                            operation.  See PUBLIC VARIABLES, TYPES and CONSTANTS
                            for the <varname>CCCUSB::Q</varname> and
                            <varname>CCCUSB::X</varname> bit field definitions.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>simpleWrite24</methodname>
                            <methodparam>
                                <type>int</type> <parameter>n</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>a</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>f</parameter>
                            </methodparam>
                            <methodparam>
                                <type>uint32_t</type> <parameter>data</parameter>
                            </methodparam>
                            <methodparam>
                                <type>uint16_t&amp;</type> <parameter>qx</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>simpleWrite16</methodname> above,
                            however the least significant 24 bits of
                            <parameter>data</parameter> are written.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                           <type>int</type> <methodname>simpleRead16</methodname>
                           <methodparam>
                               <type>int</type><parameter>n</parameter>
                           </methodparam>
                           <methodparam>
                               <type>int</type> <parameter>a</parameter>
                           </methodparam>
                           <methodparam>
                               <type>int</type><parameter>f</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint16_t&amp;</type> <parameter>data</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint16_t&amp;</type> <parameter>qx</parameter>
                           </methodparam>
                       </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a 16 bit read from a CAMAC module.
                            <parameter>n,a,f</parameter> define the slot, subaddress and
                            function code respectively while <parameter>data</parameter>
                            will receive the data from the operation.
                            <parameter>qx</parameter> will contain a
                            bit encoding of the dataway Q and X responses.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                       <methodsynopsis>
                        <type>int</type> <methodname>simpleRead24</methodname>
                        <methodparam>
                            <type>int</type> <parameter>n</parameter>
                        </methodparam>
                        <methodparam>
                            <type>int</type> <parameter>a</parameter>
                        </methodparam>
                        <methodparam>
                            <type>int</type> <parameter>f</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t&amp;</type><parameter>data</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint16_t&amp;</type> <parameter>qx</parameter>
                        </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>simpleRead16</methodname>, however the data
                            transfer is 24 bits.  These are placed in the least
                            significant 24 bits of <parameter>data</parameter>.
                            The top 8 bits are zeroed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>simpleControl</methodname>
                            <methodparam>
                                <type>int</type> <parameter>n</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>a</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type><parameter>f</parameter>
                            </methodparam>
                            <methodparam>
                                <type>uint16_t&amp;</type> <parameter>qx</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs the non-data transfer operation (control
                            function) specified by <parameter>n,a,f</parameter>.
                            As usuall the dataway Q and X responses are stored
                            in the <parameter>qx</parameter> parameter.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readFirmware</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the firmware id register storing it in the
                            <parameter>value</parameter> parameter.  This field
                            is bit encoded.  See the Firmware Register
                            subsection of PUBLIC VARIABLES, TYPES and CONSTANTS
                            below for symbols that allow you to extract the
                            firmware register fields.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readGlobalMode</methodname>
                            <methodparam>
                                <type>uint16_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the global mode register of the CC-USB.
                            The value of that register is stored in the
                            <parameter>value</parameter> parameter.  The
                            global mode register consists of several bits and
                            bit fields.  See the Global Mode subsection of
                            PUBLIC VARIABLES, TYPES and CONSTANTS below for
                            symbolic definitions of those bits and bit fields.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeGlobalMode</methodname>
                            <methodparam>
                                <type>uint16_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes the global mode register so that it contains
                            <parameter>value</parameter>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readDelays</methodname>
                            <methodparam>
                                <type>uint16_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the delays register into <parameter>value</parameter>.
                            The delays register contains bit fields that control
                            the trigger delay and lam timeout of lam waits.
                            See the Delays Register section of
                            PUBLIC VARIABLES, TYPES and CONSTANTS below
                            for symbolic definitions of this register's contents.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type>
                        <methodname>writeDelays</methodname>
                        <methodparam>
                            <type>uint16_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> into the
                            CC-USB's delays register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type>  <methodname>readScalerControl</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the CC-USB scaler control register into
                            <parameter>value</parameter>.  This regtister contains
                            bit fields that are defined in the
                            Scaler Control Register subsection of
                            PUBLIC VARIABLES, TYPES and CONSTANTS
                            below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeScalerControl</methodname>
                            <methodparam>
                                <type>uint32_t</type><parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> into the
                            scaler control register of the CC-USB.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readLedSelector</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the value of the LED selector register
                            into <parameter>value</parameter>.  The
                            LED selector register defines the meaning of the
                            lights on the CC-USB front panel.  The bit field
                            definitions and values are described in
                            LED Selector Register below in
                            PUBLIC VARIABLES, TYPES and CONSTANTS
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeLedSelector</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> into the
                            LED selector register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readOutputSelector</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Read the value of the Output Selector register
                            into <parameter>value</parameter>.  The
                            Output selector register determines the functions
                            of the NIM output connectors on the front panel
                            of the CC-USB.  The bit field and code definitions
                            of this register have symbolic definitions that are
                            described in Output Selector Register in
                            PUBLIC VARIABLES, TYPES and CONSTANTS
                            below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeOutputSelector</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Write <parameter>value</parameter> into the
                            output selector register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readDeviceSourceSelectors</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type><parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Read the device source selectors register into
                            <parameter>value</parameter>.  This register
                            determines the input sources for various CC-USB
                            onboard resources, specifically the two scalers
                            and two gate generators.  The bit fields in this
                            register are described in
                            Device Source Selector register in
                            PUBLIC VARIABLES, TYPES and CONSTANTS below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeDeviceSourceSelectors</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> into the
                            device source selector register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readDGGA</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                        <methodsynopsis>
                            <type>int</type> <methodname>readDGGB</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                        <methodsynopsis>
                            <type>int</type> <methodname>readDGGExt</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            These functions read registers that set up the
                            parameters that control the two gate and delay
                            generators in the CC-USB into the <parameter>value</parameter>
                            parameter.  The bit fields definitions for these
                            registers are described in Gate and Delay Generators
                            below in
                            PUBLIC VARIABLES, TYPES and CONSTANTS
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeDGGA</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeDGGB</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeDGGExt</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> into the
                            registers that control the two gate and delay
                            generators in the CC-USB.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readScalerA</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                        <methodsynopsis>
                            <type>int</type> <methodname>readScalerB</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the current value of scaler A or B internal
                            to the CC-USB into the <parameter>value</parameter>
                            parameter.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readLamTriggers</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the contents of the lam trigger register
                            into <parameter>value</parameter>.
                            The LAM trigger register is a mask of LAMs which
                            if matched by the dataway LAM pattern will trigger
                            the event list.  If zero, readout is triggered by
                            front panel inputs.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeLamTriggers</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Write <parameter>value</parameter> to the LAM trigger
                            register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readUSBBulkTransferSetup</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the value of the USB Bulk transfer register
                            into <parameter>value</parameter>.  The bulk transfer
                            register contains two bit fields which are defined
                            in the USB Bulk Transfer Register under the
                            PUBLIC VARIABLES, TYPES and CONSTANTS section
                            below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeUSBBulkTransferSetup</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> into the
                            USB Bulk transfer register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>c</methodname>
                            <void />
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a dataway C cycle.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                           <type>int</type> <methodname>z</methodname>
                           <void />
                       </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a data way Z cycle.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>inhibit</methodname>
                            <void />
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Sets the dataway Inhibit line.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>uninhibit</methodname>
                            <void />
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Unsets the dataway Inhibit line.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>executeList</methodname>
                            <methodparam>
                                <type>CCCUSBReadoutList&amp;</type> <parameter>list</parameter>
                            </methodparam>
                            <methodparam>
                                <type>void*</type><parameter>pReadBuffer</parameter>
                            </methodparam>
                            <methodparam>
                                <type>size_t</type><parameter>readBufferSize</parameter>
                            </methodparam>
                            <methodparam>
                                <type>size_t*</type><parameter>bytesRead</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a CAMAC list operation in immediate mode.
                            In order to do this data taking mode must not
                            be on.   The <parameter>list</parameter> is built up
                            by constructing a <classname>CCCUSBReadoutList</classname>
                            (see <xref linkend='ccusb3-CCCUSBReadoutList' />)
                            object and using its methods to add the appropriate
                            set of instructions to the list.
                        </para>
                        <para>
                            <parameter>pReadBuffer</parameter> is a pointer to
                            a buffer you have prepared to receive the results
                            of the read operations in the list.  This buffer
                            has <parameter>readBufferSize</parameter> bytes
                            of data.  On successful return,
                            <parameter>bytesRead</parameter> will contain the
                            actual number of bytes transferred into your buffer.
                            On failure (return value other than <literal>0</literal>),
                            the value of <parameter>bytesRead</parameter> is not
                            well defined.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                           <type>int</type> <methodname>loadList</methodname>
                           <methodparam>
                               <type>uint8_t</type><parameter>listNumber</parameter>
                           </methodparam>
                           <methodparam>
                               <type>CCCUSBReadoutList&amp;</type><parameter>list</parameter>
                           </methodparam>
                       </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Loads a list into the CC-USB. The <parameter>listNumber</parameter>
                            must be 0 for the event list and 1 for the scaler list.
                            If it is any value other than this, the function
                            will return <literal>-4</literal>.
                            <parameter>list</parameter>   is the
                            <classname>CCCUSBReadoutList</classname> to load.
                            See <xref linkend='ccusb3-CCCUSBReadoutList' /> for
                            information about this parameter and how to build it.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>usbRead</methodname>
                            <methodparam>
                                <type>void*</type> <parameter>data</parameter>
                            </methodparam>
                            <methodparam>
                                <type>size_t</type> <parameter>bufferSize</parameter>
                            </methodparam>
                            <methodparam>
                                <type>size_t*</type><parameter> transferCount</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>timeout</parameter>
                                <initializer>2000</initializer>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Pefroms a bulk read on the data transfer endpoint
                            of the CC-USB.  Normally this only needs to be called
                            by the CCUSBReadout framework when in data taking mode.
                            <parameter>data</parameter> is a buffer
                            into which data read should be transferred.
                            <parameter>bufferSize</parameter> is the number
                            of bytes that can be stored in <parameter>buffer</parameter>
                            <parameter>transferCount</parameter> points to a
                            buffer that will contain the number of bytes actually
                            transferred to the buffer. <parameter>timeout</parameter>
                            is the number of milliseconds to wait for the transfer
                            to complete before ending with a timeout condition.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>setDefaultTimeout</methodname>
                            <methodparam>
                                <type>int</type> <parameter>ms</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Most of the immediate operations require a write to the
                            CC-USB followed by a read to get status and/or data.
                            This function allows you to override the default
                            timeout for the read. <parameter>ms</parameter> is
                            the number of milliseconds in the new timeout.
                            Normally you will not need to call this.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>  
       </refsect1>
        <refsect1>
           <title>PUBLIC VARIABLES, TYPES and CONSTANTS</title>
           <para>
                The <classname>CCCUSB</classname> class exports several
                public constants that provide symbolic constants that help you
                to build up the contents of CC-USB registers.  The subsections
                in this section describe these values for each register.
           </para>
           <refsect2>
            <title>Action Register</title>
            <para>
                The Action register is a write-only register. Setting bit
                patterns in the Action register cause the CC-USB to take
                specific actions.
            </para>
            <variablelist>
                    <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::ActionRegister::startDAQ</varname><initializer>1</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            When this bit is set, the CC-USB enters data taking
                            mode.  In data taking mode the CC-USB responds to triggers
                            for the Event and Scaler stacks by executing them
                            and buffering their data for read via
                            <methodname>usbRead</methodname>.  Prior
                            to executing immediate actions you must clear this
                            bit and drain any buffered event data from the
                            module.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                           <modifier>static const</modifier> <type>uint16_t</type>
                           <varname>CCCUSB::ActionRegister::usbTrigger</varname><initializer>2</initializer>
                       </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Setting this bit performs a one-time trigger
                            of the event readout list.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::ActionRegister::clear</varname><initializer>4</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This bit is "intended primarily for use during
                            firmware debugging" it should not be set by
                            ordinary users like us.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::ActionRegister::scalerDump</varname><initializer>0x10</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Setting this bit triggers execution of the scaler
                            list.
                        </para>
                    </listitem>
                </varlistentry>    
            </variablelist>
            <para>
                Note that all bits except the <varname>startDAQ</varname> are
                one-shots that automatically reset after 150ns.
            </para>
           </refsect2>
           <refsect2>
            <title>Firmware Register</title>
            <para>
                This register contains the current revision of the device
                firmware.  This is a set of bit fields in a 32 bit word:
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::FirmwareRegister::revisionMask</varname>
                            <initializer>0xff</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::FirmwareRegister::revisionShift</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            These two value define the revision field.
                            If <varname>d</varname> contains the
                            firmware revision register, you can extract
                            the revisionfield by performing:
                            <informalexample>
                                <programlisting>
uint32_t revision = (d &amp; CCCUSB::FirmwareRegister::revisionMask)
                    >> CCCUSB::FirmwareRegister::revisionShift;
                                </programlisting>
                            </informalexample>
                        </para>
                        <para>
                            The remaining fields are defined in this way,
                            by a mask and a shift count.  Analagous operations
                            can be used to extract  the value of the
                            field given the full firmware revision register
                            value.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::FirmwareRegister::yearMask</varname>
                            <initializer>0xf00</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::FirmwareRegister::yearShift</varname>
                            <initializer>8</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the field that gives the year in which the
                            firmware version was finalized.
                            The manual does not define what a <literal>0</literal>
                            in this field means.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::FirmwareRegister::monthMask</varname>
                            <initializer>0xf000</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::FirmwareRegister::monthShift</varname><initializer> 12</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the month field.  This field contains
                            the month in which the firmware was finalized.
                            Presumably this is a value between
                            <literal>[1..12]</literal>.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>Global Mode Register</title>
            <para>
                The global mode register is described in section 3.3.2 of the
                CC-USB manual.  This register can be built up by bitwise
                or-ing together the values described in this section.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLenMask</varname>
                            <initializer>0xf</initializer>
                        </fieldsynopsis>
                    </term>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLenShift</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            These values define the field in the global mode
                            register that sets the lengt of the data buffer
                            produced by the CC-USB.
                        </para>
                        <para>
                            For actual values you can or into the register
                            see the fields bufferLenxx below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLen4K</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects buffers that are <literal>4096</literal>
                            <classname>uint16_t</classname> units long.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLen2K</varname>
                            <initializer>1</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Use an output buffer length of <literal>2048</literal>
                            <classname>uint16_t</classname> units long.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLen1K</varname>
                            <initializer>2</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Use an output buffer length of
                            <literal>1024</literal>   <classname>uint16_t</classname>
                            units long.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLen512</varname>
                            <initializer>3</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Use an output buffer length of
                            <literal>512</literal> <classname>uint16_t</classname>
                            units long.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t </type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLen256</varname>
                            <initializer>4</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Use an output buffer length of
                            <literal>256</literal> <classname>uint16_t</classname>
                            units long.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLen128</varname>
                            <initializer>5</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Use  a <literal>128</literal> <classname>uint16_t</classname>
                            unit large output buffer.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLen64</varname>
                            <initializer>6</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Use a <literal>64</literal> <classname>uint16_t</classname>
                            unit large output buffer.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLenSingle</varname>
                            <initializer>7</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Use a buffer that holds only a single event.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::mixedBuffers</varname>
                            <initializer>0x20</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Mix scaler and event data together in the same scaler
                            buffer.  If zero, buffers are homogenous with respect
                            to the stack that contributes data to them.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::doubleHeader</varname>
                            <initializer>0x100</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            If set the buffer header will include a second
                            word that contains the number of words in the
                            buffer.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::enableSecondary</varname>
                            <initializer>0x1000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            If set, CAMAC bus arbitration is enabled, allowing
                            the use of an Auxiliary crate controller.
                            In this case you must cable the Aux controller
                            to request mastership via RQ, GIN, and GOUT
                            signals on the front of the controller.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>Delay Register</title>
            <para>
                This register has fields for controlling the delay between the trigger
                and stack execution as well as the LAM timeout interval.
                Both fields are in units of microseconds.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::DelayRegister::triggerDelayMask</varname>
                            <initializer>0xff</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::DelayRegister::triggerDelayShift</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                           Mask and shift counts for the trigger delay field.
                           This field controls the amount of time between
                           the receipt of a trigger and execution of the
                           event stack.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::DelayRegister::lamTimeoutMask</varname>
                            <initializer>0xff00</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::DelayRegister::lamTimeoutShift</varname>
                            <initializer>8</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Mask and shift counts for the lam timeout field.
                            This field controls the number of microseconds
                            stack lines with the <literal>LM</literal> (lam
                            wait mode) bit set will wait for a LM from the
                            station specified.
                        </para>
                    </listitem>
                </varlistentry>     
            </variablelist>
           </refsect2>
           <refsect2>
            <title>Scaler Control register</title>
            <para>
                The manual (3.3.4) refers to this as tyhe ACS control register,
                its function, however is to determine when the scaler
                (Auxilliary stack) is triggered.
                There are two fields. Both can be non-zero allowing for two
                trigger conditions.  One trigger condition allows scalers to
                be triggered after a fixed number of events have been read.
                The second condition allows readout of scalers at fixed time
                intervals.
            </para>
            <para>
                If a field is zero, that trigger condition is disabled.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::ScalerControlRegister::eventsCountMask</varname>
                            <initializer>0xffff</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::ScalerControlRegister::eventsCountShift</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Define the field that controls scaler triggers
                            every fixed number of events.  If this field is
                            non zero, it specifies the number of events
                            between scaler reads.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type> uint32_t</type>
                            <varname>CCCUSB::ScalerControlRegister::timeIntervalMask</varname>
                            <initializer>0xff0000</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::ScalerControlRegister::timeIntervalShift</varname>
                            <initializer>16</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the field that sets up the time periodic
                            trigger.  If this is nonzero, it represents the
                            scaler readout period in 0.5second units.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>LED Source Register</title>
            <para>
                This register contains a set of bit fields that describe
                the signal source that lights each of the LEDs on the front
                panel.  Normally this register will be written with a logical
                or of values of one item from each bit field.  The fields
                are named after the colors of the LED each field controls.
            </para>
            <note>
                <title>Firmware changes</title>
                <para>
                    It appears that these definitions are for firmware
                    revisions &lt; 1.01.  These definitions will be updated
                    in the future to reflect the updated definitions.
                </para>
            </note>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>  <type> uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redEventTrigger</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The red LED will light on an event trigger.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redBusy</varname>
                            <initializer>1</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The red led will light when the CC-USB is busy.
                            Busy means that the CC-USB is processing the event
                            or scaler stack.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redUSBTrigger</varname>
                            <initializer>2</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the red LED when the software requests a USB
                            trigger of the event stack by writing the
                            <varname>CCCUSB::ActionRegister::usbTrigger</varname>
                            bit to the action register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redUSBOutFifoNotEmpty</varname>
                            <initializer>3</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the red LED whenever the USB output fifo
                            is not empty.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redUSBInFifoNotFull</varname>
                            <initializer>4</initializer>
                        </fieldsynopsis>
                        </term>
                    <listitem>
                        <para>
                            Lights the red led whenever the USB input fifo is not
                            ful.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redAcquire</varname>
                            <initializer>6;</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the red LED when acquisition mode is turned on
                            (that is the last write to the action register
                            set the
                            <varname>CCCUSB::ActionRegister::startDAQ</varname> bit).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redCAMACF2</varname>
                            <initializer>7</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the red LED whenever the 2's bit is set in the
                            current CAAMC function being performed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redInvert</varname>
                            <initializer>0x10</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Inverts the state of the read LED.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redLatch</varname>
                            <initializer>0x20</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            When the trigger condition for the led exists, latches the
                            led on until this bit is toggled off then on.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::greenAcquire</varname>
                            <initializer>0x000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Sets the green LED when data acquisition is enabled.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::greenCAMACF1</varname>
                            <initializer>0x100</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Sets the green LED whe the F1 line is set on the last
                            CAMAC operation.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::greenEventTrigger</varname>
                            <initializer>0x300</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Turns on the green LED whenever the event trigger is
                            being processed.
                        </para>
                        </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname> CCCUSB::LedSourceRegister::greenCAMACN</varname>
                            <initializer>0x400</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the green LED whhen a CAMAC operation has occured.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::greenI1</varname>
                            <initializer>0x600</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the green LED if the I1 input has a NIM
                            true presented on it.
                        </para>
                    </listitem>
                    </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::greenUSBInFifoNotEmpty</varname>
                            <initializer>0x700</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the green LED if the input FIFO is not empty.
                        </para>
                    </listitem>
                    </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::greenInvert</varname>
                            <initializer>0x1000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Invert the sense of the green led.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::greenLatch</varname>
                            <initializer>0x2000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Latch the green led.  When the condition to light the
                            LED occurs, the led stays on until this bit is
                            toggled off (and then back on if the latch condition
                            should be re-established).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowI3</varname>
                            <initializer>0x00000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Light the yellow LED if the I3 input is active.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowBusy</varname>
                            <initializer>0x10000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Ligths the yellow  LED when the CC-USB is busy
                            executing one of the command stacks.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowI2</varname>
                            <initializer>0x20000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Light the Yellow LED when the I2 input is active.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowCAMACS1</varname>
                            <initializer>0x30000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the yellow LED when the S1 signal on the CAMAC
                            dataway is active.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowCAMACS2</varname>
                            <initializer>0x40000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the yellow LED when the CAMAC S2 dataway line
                            is active.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowUSBInFifoNotEmpty</varname>
                            <initializer>0x50000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the Yellow LED when the USB input FIFO
                            is not empty.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowScalerReadout</varname>
                            <initializer>0x60000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the Yellow led when the scaler stack is
                            being executed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowUSBTrigger</varname>
                            <initializer>0x70000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the yellow LED when event stack execution
                            has been requested by a USB write to the Action
                            register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowInvert</varname>
                            <initializer>0x100000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Inverts the sense of the Yellow LED.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowLatch</varname>
                            <initializer>0x200000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Enables latch mode for the yellow LED.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>Output source selection register.</title>
            <para>
                This register has several coded bit fields that select
                which signals are presented at the module nim outputs
                O1, O2, and O3.
            </para>
            <note>
                <title>Firmware &lt; 1.01</title>
                <para>
                    Thie definitions shwon here are only valid for firmware
                    revisions &lt; 1.01.  This section and the header files
                    themselves must be updated to reflect the current
                    reduced set of output functionality.
                </para>
            </note>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO1Busy</varname>
                            <initializer>0x000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            O1 is asserted when the CC-USB is executing a stack.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO1EventTrigger</varname>
                            <initializer>0x000001</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Ouptut 1 reflects that an event trigger has been
                            recently received.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO1DGGA</varname>
                            <initializer>0x000002</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            O1 reflets the output gate and delay generator A.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO1DGGB</varname>
                            <initializer>0x000003</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            O1 reflects the output of gate and delay generator
                            B.
                            </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO1Latch</varname>
                            <initializer>0x000010M</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            O1 is latched when set until this bit is toggled.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>    <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO1Invert</varname>
                            <initializer>0x000020</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            O1 is inverted relative to the code that selets its
                            output.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO2Acquire</varname>
                            <initializer>0x000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Asserts O1 when acquisition mode is turned on via
                            the action register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>   <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO2Event</varname>
                            <initializer>0x000200</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Turns O2 on when an event trigger has been recently
                            received.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO2DGGA</varname>
                            <initializer>0x000400</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reflects the output of gate and delay generator A
                            in the O2 output.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO2DGGB</varname>
                            <initializer>0x000600</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reflects the output of gate and delay generator B
                            to the O2 output.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO2Latch</varname>
                            <initializer>0x001000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Sets the O2 register in latching mode.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO2Invert</varname>
                            <initializer>0x002000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Inverts the sense of O2.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO3EndOfBusy</varname>
                            <initializer>0x000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Asserts O3 when busy ends.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO3Busy</varname>
                            <initializer>0x020000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Asserts O3 when the CC-USB is executing a stack.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO3DGGA</varname>
                            <initializer>0x040000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            O3 reflects the output of gate and delay generator A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternim03DGGB</varname>
                            <initializer>0x060000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            O3 reflects the state of gate and delay generator B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO3Latch</varname>
                            <initializer>0x100000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Latches the state of O3.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO3Invert</varname>
                            <initializer>0x200000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Inverts the sense of the O3 output.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>Device source register</title>
            <para>
                This register contains several fields that control the
                input sources to the scalers and gate and delay generators
                implemented in the CC-USB.  The register contains four fields
                which are called <literal>scalerA</literal>, <literal>scalerB</literal>
                <literal>dggA</literal>  and <literal>dggB</literal>. Typically
                you will bitwise or a code from each of the fields.  In the case
                of the scaler fields there are three bits, <literal>Enable</literal>,
                <literal>Reset</literal>, and <literal>FreezeReg</literal>
                that can also be ored into the codes.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerADisabled</varname>
                            <initializer>0x00000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Scale A has no input, effectively disabling it.
                            Note that if code is not use you will need
                            to set the enable bit as well to enable the scaler
                            to count.
                            </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAI1</varname>
                            <initializer>0x00000001</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects I1 as the input to Scaler A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAI2</varname>
                            <initializer>0x00000002</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects I2 as the input to scaler A.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAI3</varname>
                            <initializer>0x00000003</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects I3 to be the input to scalerA.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>   <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAEvent</varname>
                            <initializer>0x00000004</initializer>
                        </fieldsynopsis>
                        </term>
                    <listitem>
                        <para>
                            Selects the event trigger to be the source for
                            Scaler A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerACarryB</varname>
                            <initializer>0x00000005</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects the carry out of scalerB to increment
                            ScalerA  this allows you to gang ScalerB (LSBs)
                            and Scaler A (MSBs) into a single 48 bit scaler.
                        </para>
                    </listitem>
                    </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerADGGA</varname>
                            <initializer>0x00000006</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Scaler A will count when DGGA snds an output pulse.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerADGGB</varname>
                            <initializer>0x00000007</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Counts scaler A when when DGGB sends an output pulse.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const </modifier><type> uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAEnable</varname>
                            <initializer>0x00000010</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Enables Scaler A to count.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAScalerAReset</varname>
                            <initializer>0x00000020</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Resets scaler A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAFreezReg</varname>
                            <initializer>0x00000040</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Any operation that writes this register with this
                            bit set will not modify the effective code for selecting
                            the inputs for scaler A.  This allows you to enable/disable/clear
                            scaler A without needing to know the actual
                            scaler source.  Note that since there is no
                            corresponding freeze bit for the dggA/B sources this
                            capability is of limited utility.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBDisabled</varname>
                            <initializer>0x00000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Directs to inputs to Scaler B.  Note that if another
                            input is used it's still necessary to also set
                            the <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBEnable</varname>
                            bit to enable the scaler to count.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBI1</varname>
                            <initializer>0x00000100</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            I1 is the input to ScalerB.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBI2</varname>
                            <initializer>0x00000200</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects I2 as the input for Scaler B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBI3</varname>
                            <initializer>0x00000300</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selecst I3 as the input for Scaler B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBEvent</varname>
                            <initializer>0x00000400</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects the event trigger as the input for
                            scaler B.  Presumably using this allows the scaler
                            to count the number of events acquired.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBCarryA</varname>
                            <initializer>0x00000500</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects the carry from Scaler A as the input to
                            scalerB this enables the use of ScalerA/B as
                            a 48 bit scaler with the LSBs in ScalerA
                            and MSBs in ScalerB.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBDGGA</varname>
                            <initializer>0x00000600</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Enables the output of gate and delay generator A
                            to be the input to scaler B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBDGGB</varname>
                            <initializer>0x00000700</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Enables the output of gate and delay generator B
                            to be the input of scaler B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBEnable</varname>
                            <initializer>0x00001000</initializer>
                            </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This bit can be ored in with the selected Scaler B
                            code values.  It enables scaler B to count.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBReset</varname>
                            <initializer>0x00002000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Resets scaler B
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBFreezeReg</varname>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Freezes the scaler B input selector field.  This
                            allows one to write Reset and Enable bits without
                            disturbing the event source.  Note that you still
                            must regenerate the DGGA and DGGB source selectors.
                        </para>
                        </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggADisabled</varname>
                            <initializer>0x00000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Provides no input signal to Gate and delay generator
                            A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAI1</varname>
                            <initializer>0x00010000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Routes the I1 front panel input to the input of
                            gate and delay generator A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAI2</varname>
                            <initializer>0x00020000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Routes the I2 front panel input to the input of
                            gate and delay generator A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAI3</varname>
                            <initializer>0x00030000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Routes the I3 front panel input to the input of
                            gate and delay generator A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAEvent</varname>
                            <initializer>0x00040000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Routes the event trigger to the input of
                            gate and delay generator A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAEndOfEvent</varname>
                            <initializer>0x00050000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Pulses the inpt of gate and delay generator A when
                            event readout has completed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAUSBTrigger</varname>
                            <initializer>0x00060000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Pulses the input of gate and delay generator A
                            when a USB stack trigger is written to the
                            action register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAPulser</varname>
                            <initializer>0x00070000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Pulses the input of gate and delay generator A
                            from the output of the pulser.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBDisabled</varname>
                            <initializer>0x00000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Provides no input to gate and delay generator B.
                            </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBI1</varname>
                            <initializer>0x01000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Routes the I1 input signal to the input of
                            Gate and delay generator B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBI2</varname>
                            <initializer>0x02000000</initializer>
                        </fieldsynopsis>
                   </term>
                    <listitem>
                        <para>
                            Routes the I2 input signal to the input of
                            Gate and delay generator B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBI3</varname>
                            <initializer>0x03000000</initializer>
                        </fieldsynopsis>
                   </term>
                    <listitem>
                        <para>
                            Routes the I3 input signal to the input of
                            Gate and delay generator B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBEvent</varname>
                            <initializer>0x04000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Puses the input of gate and delay generator B
                            when an event trigger is processed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBEndOfTrigger</varname>
                            <initializer>0x05000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Pulses the input of DGGB at the end of processing
                            an event trigger.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBUSBTrigger</varname>
                            <initializer>0x06000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Pulses the input of gate and delay generator B
                            when a USB trigger is written to the Actino regsiter.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBPulser</varname>
                            <initializer>0x07000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Connects the pulser output to the input of gate
                            and delay generator B
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>Gate and delay generator and pulser set up registers.
            </title>
            <para>
                Several registers are used to set the timing of gate and
                delay registers.  The timing parameters for gate and delay
                generator A also determine the timing for the pulser as showin
                in section 3.3.7 of the CC-USB manual.
            </para>
            <para>
                This section describes the bit fields in these registers.
                Each field is descdribed as a mask and shift count.
                The mask removes all extraneous bits from the register except
                the desired field and the shift count, when used to shift the
                result right right justifies the field data.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DGGAndPulserRegister::dggFineDelayMask</varname>
                            <initializer>0xffff</initializer>
                        </fieldsynopsis>                            
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DGGAndPulserRegister::dggFineDelayShift</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the fine delay field.  See the course delays
                            below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DGGAndPulserRegister::dggGateWidthMask</varname>
                            <initializer>0xffff0000</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DGGAndPulserRegister::dggGateWidthShift</varname>
                            <initializer>16</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the gate width field.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DGGCoarseRegister::ACoarseMask</varname>
                            <initializer>xffff;</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DGGCoarseRegister::ACoarseShift</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the course delay fields for the a pulser.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DGGCoarseRegister::BCoarseMask</varname>
                            <initializer>0xffff0000</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DGGCoarseRegister::BCoarseShift</varname>
                            <initializer>16</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the B course delay field.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>Transfer setup register</title>
            <para>
                This regiseter allows you to read several buffers from the
                CC-USB in a single read, as well as setting a time bound
                on how long before the CC-USB terminates a multibuffer read.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCCUSB::TransferSetupRegister::multiBufferCountMask</varname>
                            <initializer>0xff</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type> uint32_t </type>
                            <varname>CCCCUSB::TransferSetupRegister::multiBufferCountShift</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the number of buffers that can be batched
                            into a single usb_bulk_read request.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type> uint32_t</type>
                            <varname>CCCCUSB::TransferSetupRegister::timeoutMask</varname>
                            <initializer>0xf00</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCCUSB::TransferSetupRegister::timeoutShift</varname>
                            <initializer>8</initializer>
                        </fieldsynopsis>
                        </term>
                    <listitem>
                        <para>
                            Determines the number of seconds after which
                            the CC-USB will terminate a bulk transfer if not
                            all of the buffers determined by themultiBuffer
                            count have been transferred.
                            </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>X and Q</title>
            <para>
                The <parameter>qx</parameter> parameter on the simple
                CAMAC operations allow you access to the dataway
                Q and X lines.  The bit encoding of that parameter is:
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::Q</varname>
                            <initializer>1</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            If this bit was set in the <parameter>qx</parameter>
                            parameter, the module asserted a Q on the dataway.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::X</varname>
                            <initializer>2</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            If this bit is set in the <parameter>qx</parameter>
                            parameter, the module asserted an X on the dataway.
                        </para>
                    </listitem>
                    </varlistentry>
            </variablelist>
           </refsect2>    
        </refsect1>
        <refsect1>
            <title>SEE ALSO</title>
            <para>
                <xref linkend='ccusb3-CCCUSBReadoutList' />
            </para>
        </refsect1>
     </refentry>
         
	 <refentry id="ccusb3-CCCUSBReadoutList">
       <refmeta>
          <refentrytitle>CCCUSBReadoutList</refentrytitle>
          <manvolnum>3ccusb</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CCCUSBReadoutList</refname>
          <refpurpose>Create lists of CAMAC commands for CC-USB controllers.</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>
            class <ooclass><classname>CCCUSBReadoutList</classname></ooclass> {          
           <constructorsynopsis>
          <methodname>CCCUSBReadoutList</methodname>
          <void />
           </constructorsynopsis>
           <constructorsynopsis>
            <methodname>CCCUSBReadoutList</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CCCUSBReadoutList&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
           </constructorsynopsis>
            <methodsynopsis>
                <type>std::vector&lt;uint16_t&gt;</type>
                <methodname>get</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>size_t</type> <methodname>size</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>clear</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type><methodname>addWrite16</methodname>
                <methodparam>
                    <type>int</type><parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t</type> <parameter>data</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addWrite24</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>data</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addRead16</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type><parameter>lamWait</parameter>
                    <initializer>false</initializer>
                </methodparam>
            </methodsynopsis>           
            <methodsynopsis>
                <type>void</type> <methodname>addRead24</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type><parameter>lamWait</parameter>
                    <initializer>false</initializer>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addControl</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addQStop</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t</type> <parameter>max</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type><parameter>lamWait</parameter>
                    <initializer>false</initializer>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addQStop24</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t</type> <parameter>max</parameter>
                </methodparam>

                <methodparam>
                    <type>bool</type><parameter>lamWait</parameter>
                    <initializer>false</initializer>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addQScan</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t</type> <parameter>max</parameter>
                </methodparam>                
                <methodparam>
                    <type>bool</type><parameter>lamWait</parameter>
                    <initializer>false</initializer>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addRepeat</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type><parameter>lamWait</parameter>
                    <initializer>false</initializer>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addMarker</methodname>
                <methodparam>
                    <type>uint16_t</type> <parameter>value</parameter>
                </methodparam>
           </methodsynopsis>
           };
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            <classname>CCCUSBReadoutList</classname> provides a class whose instances can
            build up lists (stacks) of CAMAC operations that can either be
            submitted to a CC-USB for direct execution via <methodname>CCCUSB::executeList</methodname>,
            or loaded as an event or scaler stack via <methodname>CCCUSB::loadStack</methodname>.
          </para>
       </refsect1>
       <refsect1>
          <title>METHODS</title>
            <variablelist>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                       <methodname>CCCUSBReadoutList</methodname>
                       <void />
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Constructs a new readout list.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                         <methodname>CCCUSBReadoutList</methodname>
                         <methodparam>
                             <modifier>const</modifier> <type>CCCUSBReadoutList&amp;</type>
                             <parameter>rhs</parameter>
                         </methodparam>
                        </constructorsynopsis>
                        </term>
                    <listitem>
                        <para>
                            Constructs a readout list that will be a duplicate
                            of the readout list in <parameter>rhs</parameter>
                            (Copy construction).
                        </para>
                        </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>std::vector&lt;uint16_t&gt;</type>
                             <methodname>get</methodname>
                             <void /><modifier>const</modifier>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns a <type>std::list&lt;uint16_t&gt;</type> where
                            each element of the list is a stack line that has
                            been built up so far.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>size_t</type> <methodname>size</methodname>
                             <void /><modifier>const</modifier>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the number of <type>uint16_t</type>
                            stack lines built so far.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>clear</methodname>
                             <void />
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Clears the stack.  Once this is performed, the object
                            represents an empty stack.
                            </para>
                        </listitem>
                </varlistentry>     
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type><methodname>addWrite16</methodname>
                             <methodparam>
                                 <type>int</type><parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>uint16_t</type> <parameter>data</parameter>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Adds a 16 bit CAMAC write opearation to the list.
                            <parameter>n,a,f</parameter> specify the
                            slot, subaddress and function code respectively.
                            The <parameter>data</parameter> parameter is transferred
                            to the device when the command is executed.
                            Note that this method does not perform any CAMAC operations.
                            The specified operation is simply encoded as stack lines
                            in the object.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addWrite24</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>uint32_t</type> <parameter>data</parameter>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>addWrite16</methodname> however
                            the least significant 24 bits of <parameter>data</parameter>
                            will be written when this stack line is executed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addRead16</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>bool</type><parameter>lamWait</parameter>
                                 <initializer>false</initializer>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            A 16 bit read operation whose slot, subaddress
                            and function code are specified by <parameter>n,a,f</parameter>
                            is encoded as a stack line and added to the list.
                            If the stack line is executed in immediate mode
                            (via <methodname>CCCUSB::executeList</methodname>),
                            the data read will be put in the input buffer passed
                            to that method.  IF the stack line loaded as a scaler
                            or event stack asnd executed in response to the appropriate
                            trigger condition, the data are put in the event buffer.
                        </para>
                        <para>
                            If the <parameter>lamWait</parameter>  parameter is
                            <literal>true</literal> the stack will stall until
                            either the lam timeout period is reached or the
                            slot the operation is directed to signals its LAM.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addRead24</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>bool</type><parameter>lamWait</parameter>
                                 <initializer>false</initializer>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>addRead16</methodname>, however a
                            <type>uint32_t</type>
                            is put in the buffer (event or buffer given to
                            <methodname>CCCUSB::executeStack</methodname> depending
                            on why the stack is being executed).  The format
                            of the uint32_t is shown in the figure just at the
                            end of chapter 4 of the CC-USB manual:
                            The bottom 24 bits are the data transferred from the
                            module.  Bit 24 is set if there was a Q response
                            and bit 25 is set if there was an X response
                            (bits are numbered from 0 least significant bit
                            is bit 0).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addControl</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Adds a non data transfer operation to the stack.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addQStop</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                            <methodparam>
                                <type>uint16_t</type> <parameter>max</parameter>
                            </methodparam>
                             <methodparam>
                                 <type>bool</type><parameter>lamWait</parameter>
                                 <initializer>false</initializer>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Adds a Q-stop block transfer to the stack.  Q-stop
                            operations perform the same <parameter>n,a,f</parameter>
                            read operation until either the module does not
                            return a Q response or until the <parameter>max</parameter>
                            number of transfers specified have been performed.
                            The <parameter>lamWait</parameter> parameter allows
                            you to wait for a LAM from the targe module before
                            doing the transfer.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addQStop24</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                            <methodparam>
                                <type>uint16_t</type> <parameter>max</parameter>
                            </methodparam>
                             <methodparam>
                                 <type>bool</type><parameter>lamWait</parameter>
                                 <initializer>false</initializer>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>addQStop</methodname> except
                            that 24 bits of data are transferred on each
                            operation.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addQScan</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                            <methodparam>
                                <type>uint16_t</type> <parameter>max</parameter>
                            </methodparam>
                             <methodparam>
                                 <type>bool</type><parameter>lamWait</parameter>
                                 <initializer>false</initializer>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a Q-scan (sometimes called an address
                            scan) operation.  <parameter>n,a,f</parameter>
                            specify a starting slot, subaddress and function code.
                            After each operation a is incremented.   The CC-USB
                            documentation does not make it clear if this is a
                            full Q-Scan (ACA) operation as defined by the ESONE
                            block transfer specification.  If this operation is
                            a full address scan, then after each operation, the
                            subaddress is incremented.  If A was 15 or a Q=0
                            response occured, the
                            subaddress should be set to 0 and the slot incremented.
                            This continues until either <parameter>max</parameter>
                            transfers have occured or both Q and X are zero.
                        </para>
                        <para>
                            The documentation only describes the subadress as
                            being incremented so that may be all you can count on
                            for this opertaion.  It also does not provide a statement
                            about what happens when Q=0 or X=0.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addRepeat</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                            <methodparam>
                                <type>uint16_t</type> <parameter>max</parameter>
                            </methodparam>                             
                             <methodparam>
                                 <type>bool</type><parameter>lamWait</parameter>
                                 <initializer>false</initializer>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a block repeat operation.  The specified
                            CAMAC operation is performed <parameter>max</parameter>
                            times regardless of the X/Q responses.
                        </para>
                    </listitem>
                    </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addMarker</methodname>
                             <methodparam>
                                 <type>uint16_t</type> <parameter>value</parameter>
                             </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The literal word <parameter>value</parameter> is
                            written to the output buffer.
                        </para>
                    </listitem>
                </varlistentry>             

            </variablelist>
       </refsect1>
        <refsect1>
           <title>SEE ALSO</title>
           <para>
            <xref linkend='ccusb3-CCCUSB' />
            </para>
        </refsect1>
    </refentry>
         
    <refentry id="ccusb3-CConfigurableObject">
       <refmeta>
          <refentrytitle>CConfigurableObject</refentrytitle>
          <manvolnum>3ccusb</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CConfigurableObject</refname>
          <refpurpose>base class for devices that have a configuration</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>
            class <ooclass><classname>CConfigurableObject</classname></ooclass> {
           <constructorsynopsis>
          <methodname>CConfigurableObject</methodname>
          <methodparam>
            <type>std::string</type> <parameter>name</parameter>    
          </methodparam>
        </constructorsynopsis>
        <methodsynopsis>
            <type>std::string </type> <methodname>getName</methodname>
            <void /><modifier> const</modifier>
            </methodsynopsis>
        <methodsynopsis>
            <type>std::string</type> <methodname>cget</methodname>
            <methodparam>
                <type>std::string</type>  <parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>ConfigurationArray</type> <methodname>cget</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>getIntegerParameter</methodname>
            <methodparam>
                <type>std::string</type><parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>unsigned int</type> <methodname> getUnsignedParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>bool</type> <methodname>getBoolParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>double</type> <methodname>getFloatParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>std::vector&lt;int&gt;</type><methodname>getIntegerList</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addParameter</methodname>
            <methodparam>
                <type>std::string</type><parameter> name</parameter>
            </methodparam>
            <methodparam>
                <type>typeChecker</type> <parameter>checker</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>defaultValue</parameter>
                <initializer>std::string("")</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>clearConfiguration</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>configure</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addIntegerParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>defaultVal</parameter>
                <initializer>0</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addIntegerParameter</methodname>
            <methodparam>
                <type>std::string</type>  <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>low</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>high</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>defaultVal</parameter>
                <initializer>0</initializer>
                </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addBooleanParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>bool</type> <parameter>defaultVal</parameter>
                <initializer> true</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type><methodname>addEnumParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <modifier>const</modifier> <type>char**</type>
                <parameter>pValues</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>defaultValue</parameter>
                <initializer>std::string("")</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type><methodname>addBoolListParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>unsigned</type><parameter>size</parameter>
            </methodparam>
            <methodparam>
                <type>bool</type>   <parameter> defaultVal</parameter>
                <initializer>true</initializer>
            </methodparam>
            </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addBoolListParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>unsigned</type> <parameter>minLength</parameter>
            </methodparam>
            <methodparam>
                <type>unsigned</type> <parameter>maxLength</parameter>
            </methodparam>
            <methodparam>
                <type>bool</type> <parameter>defaultVal</parameter>
                <initializer>true</initializer>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter> defaultSize</parameter>
                <initializer>-1</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addIntListParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>unsigned</type> <parameter>size</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>defaultVal</parameter>
                <initializer>0</initializer>
            </methodparam>
            </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addIntListParameter</methodname>
            <methodparam>
                <type>std::string</type>  <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>unsigned</type> <parameter>minlength</parameter>
            </methodparam>
            <methodparam>
                <type>unsigned</type> <parameter>maxLength</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>defaultVal</parameter>
                <initializer>0</initializer>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>defaultSize</parameter>
                <initializer>-1</initializer>
            </methodparam>
            </methodsynopsis>
        <methodsynopsis>
            <type>void</type><methodname>addBooleanParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>bool</type> <parameter>defaultVal</parameter>
                <initializer>true</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addEnumParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <modifier>const</modifier> <type>char**</type>
                <parameter>pValues</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>defaultValue</parameter>
                <initializer>std::string("")</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addBoolListParameter</methodname>
            <methodparam>
                <type>std::string</type>  <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>unsigned</type> <parameter>size</parameter>
            </methodparam>
            <methodparam>
                <type>bool</type> <parameter>defaultVal</parameter>
                <initializer>true</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
         <type> void</type> <methodname>addBoolListParameter</methodname>
         <methodparam>
           <type>std::string</type> <parameter>name</parameter>
         </methodparam>
         <methodparam>
           <type>unsigned</type> <parameter>minLength</parameter>
         </methodparam>
         <methodparam>
           <type>unsigned</type> <parameter>maxLength</parameter>
         </methodparam>
         <methodparam>
            <type>bool</type> <parameter>defaultVal</parameter> 
            <initializer>true</initializer>
         </methodparam>
         <methodparam>
            <type>int</type> <parameter>defaultSize</parameter>
            <initializer>-1</initializer>
         </methodparam>
       </methodsynopsis>
       <methodsynopsis>
         <type>void</type> <methodname>addIntListParameter</methodname>
         <methodparam>
            <type>std::string</type> <parameter>name</parameter>
         </methodparam>
         <methodparam>
            <type>unsigned</type> <parameter>size</parameter>
         </methodparam>
         <methodparam>
            <type>int</type> <parameter>defaultVal</parameter>
            <initializer>0</initializer>
         </methodparam>
      </methodsynopsis>
      <methodsynopsis>
         <type>void</type> <methodname>addIntListParameter</methodname>
         <methodparam>
            <type>std::string</type> <parameter>name</parameter>
         </methodparam>
         <methodparam>
            <type>unsigned</type> <parameter>minlength</parameter>
         </methodparam>
         <methodparam>
            <type>unsigned</type> <parameter>maxLength</parameter>
         </methodparam>
         <methodparam>
            <type>int</type> <parameter>defaultVal</parameter>
            <initializer>0</initializer>
         </methodparam>
         <methodparam>
            <type>int</type> <parameter>defaultSize</parameter> 
            <initializer>-1</initializer>
         </methodparam>
      </methodsynopsis>
      <methodsynopsis>
        <type>void</type> <methodname>addStringListParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>size</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>defaultVal</parameter>
            <initializer>""</initializer>
        </methodparam>
      </methodsynopsis>
      <methodsynopsis>
        <type>void</type> <methodname>addStringListParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>minLength</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>maxLength</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>defaultVal</parameter>
            <initializer>""</initializer>
        </methodparam>
        <methodparam>
            <type>int</type> <parameter>defaultLength</parameter>
            <initializer>-1</initializer>
        </methodparam>
      </methodsynopsis>
      <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isInteger</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type><parameter>arg</parameter>
        </methodparam>
      </methodsynopsis>
      <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isBool</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
      </methodsynopsis>
      <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isEnum</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isList</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isBoolList</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isIntList</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isStringList</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>isEnumParameter</type>
        <methodname>makeEnumSet</methodname>
        <methodparam>
            <modifier>const</modifier> <type>char**</type><parameter>values</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>strToBool</methodname>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <fieldsynopsis>
        <modifier>typedef</modifier> <type>std::pair&lt;typeChecker, void*&gt;</type>
        <varname>TypeCheckInfo</varname>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>typedef</modifier>
        <type>std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt;</type>
        <varname>ConfigurationArray</varname>
    </fieldsynopsis>
    

      struct  <type>limit</type> {
      <fieldsynopsis>
          <type>bool</type>   <varname>s_checkMe</varname>
      </fieldsynopsis>
      <fieldsynopsis>
          <type>long</type> <varname>s_value</varname>
      </fieldsynopsis>
      <constructorsynopsis>
          <methodname>limit</methodname>
          <void />
      </constructorsynopsis>
      <constructorsynopsis>
          <methodname>limit</methodname>
          <methodparam>
              <type>long</type>    <parameter>value</parameter>
          </methodparam>
      </constructorsynopsis>
    } ;
    <fieldsynopsis>
        <modifier>typedef</modifier>
        <type>std::pair&lt;limit, limit&gt;</type><varname>Limits</varname>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>typedef</modifier>
        <type>std::set&lt;std::string&gt;</type> <varname>isEnumParameter</varname>
    </fieldsynopsis>
    typedef struct <type>_ListSizeConstraint</type> {
        <fieldsynopsis>
            <type>limit</type> <varname>s_atLeast</varname>
        </fieldsynopsis>
        <fieldsynopsis>
            <type>limit</type> <varname>s_atMost</varname>
        </fieldsynopsis>
    } <type>ListSizeConstraint</type>
    typedef struct <type>_isListParameter</type> {
      <fieldsynopsis>
        <type>ListSizeConstraint</type> <varname>s_allowedSize</varname>
      </fieldsynopsis>
      <fieldsynopsis>
        <type>TypeCheckInfo</type> <varname>s_checker</varname>
      </fieldsynopsis>
    } <type>isListParameter</type>;
    <fieldsynopsis>
        <modifier>typedef</modifier>
            <type>void</type><varname>(*ConstraintFreer)(void*)</varname>
    </fieldsynopsis>

     typedef struct <type>_DynamicConstraint</type> { 
      <fieldsynopsis>
        <type>ConstraintFreer</type> <varname>s_Releaser</varname>
      </fieldsynopsis>
      <fieldsynopsis>
        <type>void*</type> <varname>s_pObject</varname>
      </fieldsynopsis>
    } <type>DynamicConstraint</type>, <type>*pDynamicConstraint</type>;
  
    struct  <type>flimit</type> {
      <fieldsynopsis>
        <type>bool</type>   <varname>s_checkMe</varname>
      </fieldsynopsis>
      <fieldsynopsis>
        <type>float</type> <varname>s_value</varname>
      </fieldsynopsis>
      <constructorsynopsis>
        <methodname>flimit</methodname><void />
      </constructorsynopsis>    
      <constructorsynopsis>
        <methodname>flimit</methodname>
        <methodparam>
            <type>float</type> <parameter>value</parameter>
        </methodparam>
      </constructorsynopsis>    
    };
    <fieldsynopsis>
        <modifier>typedef</modifier> <type>std::pair&lt;flimit, flimit&gt;</type>
        <varname>FloatingLimits</varname>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>typedef</modifier> <type>std::vector&lt;isEnumParameter*&gt;</type>
        <varname>EnumCheckers</varname>
    </fieldsynopsis>

};
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            This class is the ultimate base class of the <classname>CReadoutModule</classname>
            object passed to device driver <methodname>onAttach</methodname> methods.
            It manages the configuration database of a configurable object.
          </para>
          <para>
            The interaction of a configurable object or an object that embeds
            configuration via delegation is:
            <orderedlist>
                <listitem>
                    <para>
                        The object defines a configuration that consists of
                        a set of named parameters and initial values.  Each
                        configuration value can have a constraint function
                        attached to it that is called prior to allowing the
                        value to assume a new value.
                    </para>
                    <para>
                        Through these constraint functions parameter values can'
                        be very strongly typed (e.g. not just parameter
                        must be an integer but parameter must be an integer
                        in this range).
                    </para>
                    <para>
                        Pre packaged constraint functions and convenience functions
                        make it easy to set up most types of constraints, however
                        if something special is required client code can implement
                        a special constraint.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        At some point in the lifetime of a configurable object,
                        the object is configured.  This is usually done by creating
                        (the CCUSB framework does this for you) a command or
                        command ensemble that accepts configuration name/value
                        pairs and passes them to the <methodname>configure</methodname>
                        method.  This method will invoke the constraint checker
                        and, if successful, modify the value of the configuration
                        parameter.  If the new value fails the constraint, a
                        <type>std::string</type> exception is thrown and should
                        be caught and reported at some level by the caller.
                    </para>
                    <para>
                        Again for CCUSB device drivers this is transparent.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Configurable objects can query their configuration.
                        The constraint checkers ensure that each value has
                        the type and range constraints required of that parameter.
                        Semantics, however must be enforced and applied
                        by the object that
                        uses the configuration.
                    </para>
                    <para>
                        It is always possible to get a stringified value for
                        each configuration item (in fact configuration items
                        are stored as strings).  Convenience methods allow
                        for clients to fetch conversions of those strings to
                        a rich set of types.
                    </para>
                    <para>
                        CCUSB device drivers normally fetch and process their
                        configurations when their
                        <methodname>Initialize</methodname>
                        and <methodname>addReadoutList</methodname> methods
                        are invoked.
                    </para>
                </listitem>
            </orderedlist>
          </para>
          <para>
            For the full set of methods see the METHODS section below.  The
            pre-defined constraint checkers additionally make use of
            several data types which are described in
            PUBLIC VARIABLES, TYPES and CONSTANTS further below.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                   <methodname>CConfigurableObject</methodname>
                   <methodparam>
                     <type>std::string</type> <parameter>name</parameter>    
                   </methodparam>
                 </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a configurable object.  CCUSB device
                        drivers have this construction performed for them.
                        Configurable objects have names to allow them to be
                        placed in some sort of configuration dictionary by the
                        application. the <parameter>name</parameter>
                        parameter supplies the configuration name.
                    </para>
                    <para>
                        If names are used, it's likely a good thing to ensure
                        that unique names are chose for each configuration
                        namespace the application maintains.  This is not
                        enforced by the constructor, however.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>std::string </type> <methodname>getName</methodname>
                     <void /><modifier> const</modifier>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the name of the configuration. This is the
                        value of the parameter passed to the constructor.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>std::string</type> <methodname>cget</methodname>
                     <methodparam>
                         <type>std::string</type>  <parameter>name</parameter>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the string value of the configuration parameter
                        <parameter>name</parameter>.  If the parameter was
                        not defined a string exception is thrown.
                    </para>
                    <para>
                        In situations where you don't know the set of configuration
                        parameters that have been defined, see the overloaded
                        <methodname>cget</methodname> method described next.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>CConfigurableObject::ConfigurationArray</type>
                     <methodname>cget</methodname>
                     <void />
                 </methodsynopsis>
                 </term>
                 <listitem>
                    <para>
                        Gets the entire configuration of the module as name
                        value pairs.
                        <type>CConfigurableObject::ConfigurationArray</type> is
                        described fully in PUBLIC VARIABLES, TYPES and CONSTANTS
                        below, however you can think iof it as a vector of
                        <type>std::string</type> pairs of configuration
                        parameter name and value.
                    </para>
                 </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>int</type> <methodname>getIntegerParameter</methodname>
                     <methodparam>
                         <type>std::string</type><parameter>name</parameter>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Invokes <methodname>cget</methodname> on the
                        <parameter>name</parameter> configuration parameter.
                        The resulting string is converted to an integer and
                        returned, if possible.  If the string is not a valid integer,
                        a string exception is thrown.
                    </para>
                    <para>
                        Note that this and other convenience methods for
                        getting parameter values converted to specific data
                        types pass any exceptions from <methodname>cget</methodname>
                        on up to the caller.
                    </para>
                </listitem>
                </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>unsigned int</type> <methodname> getUnsignedParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                         </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Same as <methodname>getIntegerParameter</methodname>,
                        however the conversion to an unsigned value is attempted.
                        This is recommended for e.g. base addresses.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>bool</type> <methodname>getBoolParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Invokes <methodname>cget</methodname> and attempts
                        to convert the resulting string to a <type>bool</type>
                        value which is returned if successful.   A rather
                        rich set of values can be converted to bools.
                    </para>
                    <informaltable>
                        <tgroup cols="2">
                        <colspec colname='string' /> <colspec colname='value' />
                        <thead>
                            <row>
                                <entry>String</entry>
                                <entry>Bool Value</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>true</entry><entry>true</entry>
                            </row>
                            <row>
                                <entry>yes</entry><entry>true</entry>
                            </row>
                            <row><entry>1</entry><entry>true</entry></row>
                            <row><entry>on</entry><entry>true</entry></row>
                            <row><entry>enabled</entry><entry>true</entry></row>
                            <row><entry>false</entry><entry>false</entry></row>
                            <row><entry>no</entry><entry>false</entry></row>
                            <row><entry>0</entry><entry>false</entry></row>
                            <row><entry>off</entry><entry>false</entry></row>
                            <row><entry>disabled</entry><entry>false</entry></row>
                        </tbody>
                        </tgroup>
                    </informaltable>
                    <para>
                        Failure to convert to a <type>bool</type> throws
                        a string exception.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>double</type> <methodname>getFloatParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Uses <methodname>cget</methodname> to retrieve the
                        value of the <parameter>name</parameter> configuration
                        parameter.  The string is converted to a
                        <type>float</type> and
                        returned.  If the string is not a valid
                        <type>float</type>, a string exception is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>std::vector&lt;int&gt;</type><methodname>getIntegerList</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Uses the <methodname>cget</methodname> method to
                        obtain the configuration parameter <parameter>name</parameter>.
                        The string is treated as a Tcl list which is composed
                        entirely of integers.  If this assumption is correct,
                        a <type>std::vector</type> of the integers that made
                        up the list is returned.  If the string is either
                        an invalid list or not entirely composed of elements
                        that can be converted to <type>int</type>,
                        a string exception is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>addParameter</methodname>
                     <methodparam>
                         <type>std::string</type><parameter> name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>typeChecker</type> <parameter>checker</parameter>
                     </methodparam>
                     <methodparam>
                         <type>void*</type> <parameter>arg</parameter>
                     </methodparam>
                     <methodparam>
                         <type>std::string</type> <parameter>defaultValue</parameter>
                         <initializer>std::string("")</initializer>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is the base mechanism for defining a configuration
                        parameter. See the convenience methods below before using
                        this as they may be easier to use.
                    </para>
                    <para>
                        <parameter>name</parameter>  is the name of the parameter
                        being added.  By convention, this starts with the
                        <literal>-</literal> character (like options in Tk).
                        For example a module slot might be defined as a
                        <literal>-slot</literal> configuration parameter.
                    </para>
                    <para>
                        <parameter>checker</parameter> is a pointer to the
                        constraint checking function.  If no constraint checking
                        is required (e.g. the paramter is a pure string), pass
                        <literal>NULL</literal> for this parameter.
                    </para>
                    <para>
                        <parameter>arg</parameter>  is a parameter that is passed
                        without interpretation to the constraint checker.
                        See CONSTRAINT CHECKING below for more about how
                        constraint checkers are defined and called.
                        See also the descriptions of the built in constraint
                        checkers that are static members of this class, documented
                        later in this section.
                    </para>
                    <para>
                        <parameter>defaultValue</parameter> is the initial
                        value supplied to the parameter.  Note that this is
                        <emphasis>not</emphasis> constraint checked.  This is
                        intentional as it allows you to require a parameter
                        setting by providing an invalid initial parameter
                        value.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>clearConfiguration</methodname>
                     <void />
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Clear the configuration.  This removes any parameter
                        definitions as well as their value from the configuration
                        database.  In most cases this function is not necessary.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>configure</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>std::string</type> <parameter>value</parameter>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Attempts to configure a parameter <parameter>name</parameter>
                        should be a configuration parameter name that has been
                        defined by <methodname>addParameter</methodname> or its
                        convenience methods. <parameter>value</parameter>
                        is the new proposed value of the parameter.
                        The constraint checker, if any, is called for that parameter
                        and if it fails a string exception is thrown.  Otherwise,
                        the new parameter value replaces the old one.
                        </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>addIntegerParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter>defaultVal</parameter>
                         <initializer>0</initializer>
                     </methodparam>
                 </methodsynopsis>
                 </term>
                <listitem>
                    <para>
                        Convenience method to add an parameter
                        <parameter>name</parameter>  which is constrained
                        to be an integer parameter that has no range
                        requirements.  The initial value of this parameter
                        will be <parameter>defaultVal</parameter>
                        </para>
                    </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>addIntegerParameter</methodname>
                     <methodparam>
                         <type>std::string</type>  <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter>low</parameter>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter>high</parameter>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter>defaultVal</parameter>
                         <initializer>0</initializer>
                         </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Convenience methos that creates a parameter
                        (<parameter>name</parameter>) that is constrained
                        to be an integer in the range
                        [<parameter>low</parameter>..<parameter>high</parameter>].
                    </para>
                    <para>
                        The initial value of the parameters is set to
                        <parameter>defaultVal</parameter> which is not
                        checked against the limits.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>addBooleanParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>bool</type> <parameter>defaultVal</parameter>
                         <initializer> true</initializer>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a parameter <parameter>name</parameter> to the
                        configuration database which is contrained to be
                        a string that converts to a <type>bool</type>.
                        The initial value of the parameter will be
                        <parameter>defaultVal</parameter>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type><methodname>addEnumParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <modifier>const</modifier> <type>char**</type>
                         <parameter>pValues</parameter>
                     </methodparam>
                     <methodparam>
                         <type>std::string</type> <parameter>defaultValue</parameter>
                         <initializer>std::string("")</initializer>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a parameter <parameter>name</parameter>   that is
                        constrained to be one of the values pointed to by the
                        <parameter>pValues</parameter> array.
                        The initial value is <parameter>defaultValue</parameter>
                    </para>
                    <para>
                        The <parameter>pValues</parameter> parameter should
                        be a pointer to a null terminated set of character pointers.
                        This sounds much harder than it is:
                        <informalexample>
                            <programlisting>
const char* enumValues[] = {"red", "green", "blue", NULL};
                            </programlisting>
                        </informalexample>
                        In the code fragment above, <varname>enumValues</varname>
                        can be passed in as the <parameter>pValues</parameter>
                        argument and will constrain the values of the configuration
                        parameter to be in the set
                        {<literal>red</literal>, <literal>greeen</literal>, <literal>blue</literal>}.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type><methodname>addBoolListParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>unsigned</type><parameter>size</parameter>
                     </methodparam>
                     <methodparam>
                         <type>bool</type>   <parameter> defaultVal</parameter>
                         <initializer>true</initializer>
                     </methodparam>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a new configuration parameter
                        <parameter>name</parameter> that is constrained to be
                        a valid Tcl list of <type>bool</type> strings of
                        exactly <parameter>size</parameter> elements long.
                    </para>
                    <para>
                        The initial value will be set to <parameter>size</parameter>
                        elements of <parameter>defaultVal</parameter>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>addBoolListParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>unsigned</type> <parameter>minLength</parameter>
                     </methodparam>
                     <methodparam>
                         <type>unsigned</type> <parameter>maxLength</parameter>
                     </methodparam>
                     <methodparam>
                         <type>bool</type> <parameter>defaultVal</parameter>
                         <initializer>true</initializer>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter> defaultSize</parameter>
                         <initializer>-1</initializer>
                     </methodparam>
                 </methodsynopsis>
                 </term>
                <listitem>
                    <para>
                        Same as the previous method, however the
                        list size is constrained to be at least
                        <parameter>minLength</parameter> and at most
                        <parameter>maxLength</parameter> elements long.
                        The initial value is <parameter>defaultSize</parameter>
                        elements of <parameter>defaultVal</parameter>
                        If <parameter>defaultSize</parameter> is outside
                        the length limits, it is forced to the closest limit.
                    </para>
                </listitem>
                </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>addIntListParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>unsigned</type> <parameter>size</parameter>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter>defaultVal</parameter>
                         <initializer>0</initializer>
                     </methodparam>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a parameter that is constrained to be  a fixed
                        length Tcl list of <parameter>size</parameter>
                        integer values.
                        The initial value of the list is <parameter>size</parameter>
                        copies of <parameter>defaultValue</parameter>
                        </para>
                    <para>
                        The range of values in the list is unconstrained.
                        See the overloads below however.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>addIntListParameter</methodname>
                     <methodparam>
                         <type>std::string</type>  <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>unsigned</type> <parameter>minlength</parameter>
                     </methodparam>
                     <methodparam>
                         <type>unsigned</type> <parameter>maxLength</parameter>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter>defaultVal</parameter>
                         <initializer>0</initializer>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter>defaultSize</parameter>
                         <initializer>-1</initializer>
                     </methodparam>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Same as the previous method however the list can
                        have a size in the range
                        [<parameter>minlength</parameter>..<parameter>maxLength</parameter>].
                        the initial value of the list is <parameter>defaultSize</parameter>
                        elements of <parameter>defaultVal</parameter>.
                    </para>
                    <para>
                        As for <methodname>addBoolListParameter</methodname>,
                        if the <parameter>defaultSize</parameter> parameter
                        is outside the range of valid list length it is forced
                        to the closest value.  Thus the default value really
                        creates <parameter>minlength</parameter> elements.
                        </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>isInteger</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>name</parameter>
                      </methodparam>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                      <methodparam>
                          <type>void*</type><parameter>arg</parameter>
                      </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is a static method that can be used as a constraint
                        checker for integer parameters.  When it is used,
                        the constraint parameter shoule be <literal>NULL</literal>
                        if no range checking is desired or a pointer to a
                        <type>Limits</type> struct as described in
                        PUBLIC VARIABLES, TYPES and CONSTANTS to describe
                        which limits are desired and their values.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>isBool</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>name</parameter>
                      </methodparam>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                      <methodparam>
                          <type>void*</type> <parameter>arg</parameter>
                      </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is a static method that can be used as a constraint
                        checker for boolean parameters.  When used, the
                        constraint parameter should be <literal>NULL</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>isEnum</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>name</parameter>
                      </methodparam>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                      <methodparam>
                          <type>void*</type> <parameter>arg</parameter>
                      </methodparam>
                  </methodsynopsis>
                    </term>
                <listitem>
                    <para>
                        Constriaint checker fora n enumerated type.
                        When used, the constraint parameter should be
                        a pointer to an <type>std::set&lt;string&gt;</type>
                        which  has elements for each valid enumerator value.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                  <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>isList</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>name</parameter>
                      </methodparam>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                      <methodparam>
                          <type>void*</type> <parameter>arg</parameter>
                      </methodparam>
                  </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        General constraint checker for a parameter that must
                        look like a Tcl list.  The constraint parameter
                        is a pointer to an <type>isListParameter</type>
                        struct as defined in PUBLIC VARIABLES, TYPES and CONSTANTS
                        This structure should be filled in to provide limits on
                        the number of list elements the list can have.  A constraint
                        checker that is applied to each list element can also be
                        supplied.
                        </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                  <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>isBoolList</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>name</parameter>
                      </methodparam>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                      <methodparam>
                          <type>void*</type> <parameter>arg</parameter>
                      </methodparam>
                  </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Constraint checker for a Tcl formatted list of
                        booleans.  The constraint parameter shouild be a
                        pointer to a <type>ListSizeConstraint</type>
                        described in PUBLIC VARIABLES, TYPES and CONSTANTS.
                        This should set limits on the size of the list.
                        <methodname>isBoolList</methodname> will ensure
                        that the elements of the list are booleans.
                        </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                  <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>isIntList</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>name</parameter>
                      </methodparam>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                      <methodparam>
                          <type>void*</type> <parameter>arg</parameter>
                      </methodparam>
                  </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Constraint checker for a list of integers. The constraint
                        parameter should be a <type>ListSizeConstraint</type>
                        that describes the allowed list sizes.  The
                        checker will ensure that the elements fo the list are
                        all valid integers. At present, this checker does not
                        support checking the values of the list elemeents against
                        range limits.
                    </para>
                    <para>
                        You could manually construct the <type>isListParameter</type>
                        structure to do this and use <methodname>isList</methodname>
                        if required.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                  <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>isStringList</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>name</parameter>
                      </methodparam>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                      <methodparam>
                          <type>void*</type> <parameter>arg</parameter>
                      </methodparam>
                  </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Constraint checker for lists of strings.   The
                        constraint parametr is a <type>ListSizeConstraint</type>
                        that defines the allowed sizes of the list.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                  <methodsynopsis>
                      <modifier>static</modifier> <type>isEnumParameter</type>
                      <methodname>makeEnumSet</methodname>
                      <methodparam>
                          <modifier>const</modifier> <type>char**</type><parameter>values</parameter>
                      </methodparam>
                  </methodsynopsis>
                  </term>
                <listitem>
                    <para>
                        Helper function that converts a null terminated array
                        of pointers to strings into a
                        <type>isEnumParameter</type> constraint parameter.
                    </para>
                </listitem>
                </varlistentry>
            <varlistentry>
                <term>
                  <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>strToBool</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                  </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Convenience function that converts a string to a boolean
                        or throws an exception if the resulting string cannot
                        be converted.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
       </refsect1>
        <refsect1>
           <title>PUBLIC VARIABLES, TYPES and CONSTANTS</title>
           <para>
                The class definition in the SYNOPSIS section above shows a
                large number of type definitions for this class.
                Almost all of these types are structures used by the
                built in constraint checkers.In most cases,
                if you use the convenience functions to define your parameters
                you won't need to know the details of these types.
           </para>
           <para>
                The remainder of this section describes these types and the
                constraint checkers they belong to.
            </para>
            <variablelist>
                <varlistentry>    
                    <term>
                        <fieldsynopsis>
                            <modifier>typedef</modifier>
                            <type>std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt;</type>
                            <varname>ConfigurationArray</varname>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <type>ConfigurationArray</type> is returned from
                            one of the overloads of the <methodname>cget</methodname>
                            method.  This type is a vector of pair.  The first element of each pair
                            is the name of a parameter while the second element is it's current
                            value.
                        </para>
                        <para>
                            The following fragment of code shows how to use this
                            to dump the current configuration of a configurable
                            object pointed to by <varname>pConfig</varname>
                        </para>
                        <informalexample>
                            <programlisting>
ConfigurationArray config = pConfig-&gt;cget();
for (int i = 0; i &lt; config.size(); i++) {
   cout &lt;&lt; config[i].first &lt;&lt; " is set to " &lt;&lt; config[i].second &lt;&lt; endl;
}
                            </programlisting>
                        </informalexample>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        struct  <type>limit</type> {
                        <fieldsynopsis>
                            <type>bool</type>   <varname>s_checkMe</varname>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <type>long</type> <varname>s_value</varname>
                        </fieldsynopsis>
                        <constructorsynopsis>
                            <methodname>limit</methodname>
                            <void />
                        </constructorsynopsis>
                        <constructorsynopsis>
                            <methodname>limit</methodname>
                            <methodparam>
                                <type>long</type>    <parameter>value</parameter>
                            </methodparam>
                        </constructorsynopsis>
                      } ;
                    </term>
                    <term>
                      <fieldsynopsis>
                          <modifier>typedef</modifier>
                          <type>std::pair&lt;limit, limit&gt;</type><varname>Limits</varname>
                      </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            These data types are used with the
                            <methodname>isInteger</methodname> constraint
                            checker.  Each <type>limit</type> data type
                            represents a range limit that may or may  not be
                            checked according to the state of its
                            <varname>s_checkMe</varname> flag.
                        </para>
                        <para>
                            <type>Limits</type> is a pair of <type>limit</type>
                            structs where the first one represents the lower
                            limit and the second one the upper limit.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>                      
                        <fieldsynopsis>
                            <modifier>typedef</modifier>
                            <type>std::set&lt;std::string&gt;</type>
                            <varname>isEnumParameter</varname>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <type>isEnumParameter</type> is used by the
                            <methodname>isEnum</methodname> method
                            to validate parameters that are enumerate parameter.
                            The actual type is a set of the character strings
                            that are allowed to be assigned to the parameter value.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>typedef</modifier> <type>std::pair&lt;typeChecker, void*&gt;</type>
                            <varname>TypeCheckInfo</varname>
                        </fieldsynopsis>
                    </term> 
                    <term>
                        typedef struct <type>_ListSizeConstraint</type> {
                            <fieldsynopsis>
                                <type>limit</type> <varname>s_atLeast</varname>
                            </fieldsynopsis>
                            <fieldsynopsis>
                                <type>limit</type> <varname>s_atMost</varname>
                            </fieldsynopsis>
                        } <type>ListSizeConstraint</type>
                    </term>
                    <term>
                        typedef struct <type>_isListParameter</type> {
                          <fieldsynopsis>
                            <type>ListSizeConstraint</type> <varname>s_allowedSize</varname>
                          </fieldsynopsis>
                          <fieldsynopsis>
                            <type>TypeCheckInfo</type> <varname>s_checker</varname>
                          </fieldsynopsis>
                        } <type>isListParameter</type>;
                    </term>
                    <listitem>
                        <para>
                            This set of types are used to validate lists.
                            The <type>isListParameter</type>
                            is what is used to validate lists.  This consists
                            of two chunks;
                        </para>
                        <para>
                            <varname>s_allowedSize</varname> is used
                            to validate the size of a list.  It is a
                            <type>ListSizeConstraint</type> which allows you to
                            specify minimum and maximum list sizes.  The list
                            size limits are inclusive so you can specify a
                            fixed size list by setting both
                            <varname>s_atLeast</varname> and <varname>s_atMost</varname>
                            to be the same.
                        </para>
                        <para>
                            <varname>s_checker</varname> is a constraint
                            checker and its parameter used to validate each
                            item in the list.  This is applied after the
                            string is determined to be a valid list and
                            after the size of the list has been checked against
                            the limits defined by <varname>s_allowedSize</varname>
                            <varname>s_checker</varname>
                            <type>TypeCheckInfo</type> which is a pair whose
                            first element is a pointer to the actual constraint
                            checking function and whose second is a pointer to data
                            passed to the constraint checker without
                            interpretation. For more information about how
                            constratin checkers work see
                            CONSTRAINT CHECKING below.
                            </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>  
                        struct  <type>flimit</type> {
                          <fieldsynopsis>
                            <type>bool</type>   <varname>s_checkMe</varname>
                          </fieldsynopsis>
                          <fieldsynopsis>
                            <type>float</type> <varname>s_value</varname>
                          </fieldsynopsis>
                          <constructorsynopsis>
                            <methodname>flimit</methodname><void />
                          </constructorsynopsis>    
                          <constructorsynopsis>
                            <methodname>flimit</methodname>
                            <methodparam>
                                <type>float</type> <parameter>value</parameter>
                            </methodparam>
                          </constructorsynopsis>    
                        };
                    </term>
                    <term>
                        <fieldsynopsis>
                            <modifier>typedef</modifier> <type>std::pair&lt;flimit, flimit&gt;</type>
                            <varname>FloatingLimits</varname>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            These types specify floating point limits in a
                            mannger analgous to integer limits.
                            </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>           
        </refsect1>
        <refsect1>
            <title>CONSTRAINT CHECKING</title>
            <para>
                Constraint checking is the <classname>CConfigurableObject</classname>
                class's way to enforce type safety and other constraints on
                the values of configuration parameters.
                When a parameter is created with <methodname>addParameter</methodname>,
                The caller has an option to provide a constraint checker and
                a parameter that provides extra information to the constraint
                checker that can parameterize the constraints it checks.
            </para>
            <para>
                A constraint checker is just a function of the form:
                <informalexample>
                    <programlisting>
bool myConstraintChecker(std::string name, std::string newValue,
                        void* pClientData);
                    </programlisting>
                </informalexample>
            </para>
            <para>
                When the <methodname>configure</methodname> method is called
                for a parameter name that has a constraint checker
                attached to it, that checker is called and passed the parameters
                shown in the code fragment above:
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <parameter>name</parameter>
                    </term>
                    <listitem><para>
                        Is the name of the parameter being configured.
                        </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <parameter>newValue</parameter>
                    </term>
                    <listitem>
                        <para>Is the proposed new value for the parameter.
                        </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        pClientData
                    </term>
                    <listitem>
                        <para>
                            Is the constraint parameter passed to
                            <methodname>addParameter</methodname>
                            passed without interpretation or modification.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                The constraint checker is expected to return
                <literal>true</literal> if the proposed <parameter>newValue</parameter>
                is acceptable by the constraint checker and <literal>false</literal>
                if not.  If <literal>true</literal> is returned the parameter
                value is modified to <parameter>newValue</parameter> otherwise
                a string exception is thrown and the parameter value is not
                modified.
            </para>
            <para>
                The CCUSB framework catches string exceptions thrown by
                <classname>CConfigurableObject</classname> and converts those
                into configuration file processing error messages.  Any configuration
                file processing error is reported and aborts the start of the
                run that caused it.
            </para>
        </refsect1>
     </refentry>     
<!-- /manpage -->



