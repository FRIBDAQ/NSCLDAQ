<!-- chapter frameworks -->
<chapter>
    <title>CCUSB Readout framework</title>
    <para>
        The CCUSB Readout framework provides support for the Wiener-JTec
        CC-USB CAMAC controller.  The CC-USB is a USB CAMAC controller that
        uses a Xilinx gate array to implement a CAMAC list processor.
        The CCUSB Readout framework provides:
    </para>
    <itemizedlist>
        <listitem><para>
            A high level approach to the problem of data taking with the CC-USB
        </para></listitem>
        <listitem><para>
            Support for user written device support without any need to
            understand the format of list operations supported by the CC-USB.
            Drivers can be written in either C++ or in object oriented extensions
            to Tcl.
        </para></listitem>
        <listitem>
            <para>
                Direct insertion of data taken to an arbitrary destination
                ringbuffer.
            </para>
        </listitem>
        <listitem>
            <para>
                Support for use as a data source with the NSCL event builder.
            </para>
        </listitem>
    </itemizedlist>
    <para>
        This Chapter provides overview information that describes
    </para>
    <itemizedlist>
        <listitem>
            <para>
                The philosophy behind the CCUSB readout framework.
            </para>
        </listitem>
        <listitem>
            <para>
                How to write configuration files for the CCUSB readout
                framework.
            </para>
        </listitem>
        <listitem>
            <para>
                How to write device support modules in in C++ and incorpoprate
                those modules into the
                CCUSB readout framework 
            </para>
        </listitem>
        <listitem>
            <para>
                How to write device support modules in Tcl and incorporate
                those modules in the CCUSB readout framework.
            </para>
        </listitem>

        <listitem>
            <para>
                How the slow controls framework operates.
            </para>
        </listitem>
        <listitem>
            <para>
                How to write slow controls drivers in C++
            </para>
        </listitem>
        <listitem>
            <para>
                How to write slow controls drivers in Tcl
            </para>
        </listitem>
        <listitem>
            <para>
                How to integrate the CCUSBReadout program with the state
                manager.
            </para>
        </listitem>
    </itemizedlist>
    <para>
        Reference information is available in the <literal>3ccusb</literal>
        section of the referencae material.
    </para>
    <section>
        <title>How the CCUSB readout framework works</title>
        <para>
            The CCUSB readout framework provides a high level approach to
            configuring devices supported by the system.  A plugin architecture
            allows user written device support to be incorporated into
            the framework at run-time.  
        </para>
        <para>
            The framework supports both data taking devices and slow control
            devices that may require a control panel.  Naturally you can
            support relatively static slow control devices by using the
            data taking device support as well.
        </para>
        <para>
            The recurring concepts for both the data taking device support
            and slow controls device support are:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    A Tcl configuration file describes the devices used
                    by the experiment.
                </para>
            </listitem>
            <listitem>
                <para>
                    Each supported device class is represented in the
                    configuration file by a Tcl command ensemble. The
                    command ensemble provides subcommands that allow you to
                    create, configure and query the configuration of
                    physical devices (device instances).
                </para>
            </listitem>
            <listitem>
                <para>
                    The device configuration is represented in the configuration
                    file in manner analagous to the state of a Tk widget.
                    That is, you never actually program the device directly,
                    you simply specify the desired configuration. The actual
                    programming is done by the device class's device support
                    software.
                </para>
            </listitem>
            <listitem>
                <para>
                    In accordance with the way the CC-USB operates, you can create
                    two lists or <firstterm>stack</firstterm>s in CC-USB parlance.
                    One stack is an event stack and is intended to be used
                    to handle event triggers.  The second stack is a scaler stack
                    and typically is set to readout periodically.
                </para>
                <para>
                    Each stack has, configuration properties as well. One
                    configuration property is the set of modules managed
                    by that stack.  Modules managed by that stack are initialized
                    by the software, in accordance with their configuration,
                    and contribute to the readout list that executes in response
                    to that stack's trigger.
                </para>
            </listitem>
        </itemizedlist>

    </section>
    <section>
        <title>Writing DAQ configuration files</title>
        <para>
            The DAQ configuration file is processed at the beginning of each run.
            The configuration file is processed in a fresh interpreter each time.
            You therefore cannot maintain any state across runs via your configuration
            file.
        </para>
        <para>
            To illustrate module creation and configuration,
            this let's look at a fragment from a configuration
            file:
        </para>
        <example>
            <title>Creating and configuring devices</title>
            <programlisting>
ph7xxx create tdc -slot 13 -id 0x7186 -sparse false
ph7xxx config tdc -readhits true -usellt false -usehlt false
            </programlisting>
        </example>
        <para>
            The ph7xxx driver supports the Phillips 7xxx series
            CAMAC 16 channel digitizers.  The <command>ph7xxx</command> command is the Tcl
            command this driver recognizes.  The <command>create</command>
            subcommand creates a new device instance and names it <literal>tdc</literal>.
            When you create a module any addition command words following the
            device name are interpreted as configuration options.
            In this case, the module is configured to be in slot 13,
            the driver is configured to emit a literal value (<option>-id</option>)
            <literal>0x7186</literal> prior to data from the device.
            The module is also configured to read all channels
            (<option>-sparse</option> <literal>false</literal>).
        </para>
        <para>
            The <command>config</command> subcommand allows you to further
            configure the options of a device instance.  The second line
            of the example continues specifying the configuration of the
            device named <literal>tdc</literal>.  The configuration parameters
            on that line request the driver to read the hit pattern register
            (<option>-readhits</option> <literal>true</literal>), to not
            enable  either the lower level threshold or the upler level threshold
            (<option>-usellt</option> and <option>usehlt</option>).
        </para>
        <para>
            The reference section <literal>3ccusb</literal> provides detailed
            information that describes each supported device and the
            configuration options it supports.
        </para>
        <para>
            Configuration files must also specify at least one stack and, if
            scaler modules are to be read periodically, a second scaler stack.
            See the <xref linkend="ccusb3-stack" /> command
            in the reference material for detailed information about how
            to create and configure stacks.
        </para>
        <para>
            To continue with the previous example:
        </para>
        <example>
            <title>Configuring an event stack</title>
            <programlisting>
stack create events
stack config events -modules [list tdc] -type event -delay 108
            </programlisting>
        </example>
        <para>
            Stacks are created and configured exactly like any other module.
            In this configuration file fragment, a stack named
            <literal>events</literal> is created.  It is configured to
            manage the <literal>tdc</literal> module (<option>-modules</option>).
            It is configured as the event stack (<option>-type</option>) which,
            by default is triggered by a nim pulse in the <literal>IN1</literal>
            input of the module. The <option>-delay </option> parameter
            specifies a delay of 108usec between the trigger input and stack
            execution.  This capability is provided to allow the digitizers
            in the stack time to convert.
        </para>
        <para>
            Finally here's a configuration file fragment that sets up an
            LRS 2551 scaler and the scaler stack:
        </para>
        <example>
            <title>Setting up a scaler stack</title>
            <programlisting>

lrs2551 create counters -slot 5
stack create scaler
stack config scaler -type scaler -period 2 -modules [list counters]

            </programlisting>
        </example>
    </section>
    <section>
        <title>Writing device support software</title>
        <para>
            This section describes how to write a device support module.
            Device support modules are built into shared object libraries
            that can be dynamically loaded into the readout software via
            the <command>load</command> command.
        </para>
        <para>
            The device support package is provided as a template driver
            source file and a Makefile that builds the shared object.
            If the DAQ software is installed in $DAQROOT, the following
            commands copy the template driver and its makefile:
        </para>
        <example>
            <title>Obtaining the ccusb driver development kit</title>
            <programlisting>
<command>cp $DAQROOT/ccusbdriver/drivertemplate.cpp .</command>
<command>cp $DAQROOT/ccusbdriver/Makefile .</command>
            </programlisting>
        </example>
        <para>
            The example below shows how to load a user written driver
            and use the driver that is created by an unmodified driver template:
        </para>
        <example>
            <title>Using a user written CCUSB driver</title>
            <programlisting>
set here [file nativename [file dirname [info script]]]
load [file join $here libtemplatedriver.so]
changeme create testing -value 0x1234
            </programlisting>
        </example>
        <para>
            The example assumes that you have built the driver in the same
            directory as your configuration file.  The first example line
            computes the full file path to the configuration file's directory.
            The second loads the driver, joining that path to the name of the
            shared object created by the Makefile.  Note that you typically will
            need to provide a full path to the driver shared object or the
            <command>load</command> command will claim the file cannot be located.
            The final command creates and configures a device instance
            named <literal>testing</literal> using the <command>changeme</command>
            command the unmodified driver creates.
        </para>
        <para>
            Let's look at the template driver you copied.
            The template consists of two main chunks.  The first chunk is a
            class derived from <classname>CReadoutHardware</classname> that is
            responsible for managing the driver itself. You will normally
            need to modify the <methodname>onAttach</methodname>,
            <methodname>Initialize</methodname> and <methodname>addReadoutList</methodname>
            methods of this class, as well as changing the class name to something
            more reasonable than <classname>CTemplateDriver</classname>.
        </para>
        <para>
            The second chunk is a Tcl package initialization function that
            must define the Tcl command that is associated twith the driver.
        </para>
        <para>
            While the driver template is heavily commented, and modification
            points are indicated, the next few sections are a guided tour
            of the main sections you will need to modify.
        </para>
        <section>
            <title>The driver onAttach method</title>
            <para>
                Each driver instance has a configuration database attached to it
                when it is created.  The configuration database holds configuration
                parameter definitions and their current values.  The framework
                takes care of managing the values for you, however you must
                define the set of configuration parameters supported by your
                driver.
            </para>
            <para>
                The template driver's code is (comments removed for brevity:
            </para>
            <informalexample>
                <programlisting>
void
CTemplateDriver::onAttach(CReadoutModule&amp; configuration)
{
  m_pConfiguration = &amp;configuration;                    <co id='ccusb-dtemplate-saveconfig' />
  m_pConfiguration->addIntegerParameter("-slot", 1, 23, 1); <co id='ccusb-dtemplate-slotparam' />

  m_pConfiguration->addIntegerParameter("-value"); // default is 0. <co id='ccusb-dtemplate-valueparam' />
}
                </programlisting>
            </informalexample>
            <calloutlist>
                <callout arearefs='ccusb-dtemplate-saveconfig'>
                    <para>
                        <methodname>onAttach</methodname> needs to be able
                        to access its configuration in other methods.
                        The <parameter>configuration</parameter> parameter is
                        a reference to that configuration.  This line
                        saves a pointer to that configuration in the
                        <varname>m_pConfiguration</varname> member variable.
                        Note that a <classname>CReadoutModule</classname>
                        is derived from a <classname>CConfigurableObject</classname>
                        and that base class holds the configuration.
                    </para>
                    <para>
                        This code is provided by the driver template.
                    </para>
                </callout>
                <callout arearefs='ccusb-dtemplate-slotparam'>
                    <para>
                        Virtually all of the device support you write will
                        need to know which slot in the CAMAC crate contains
                        your module.  This line creates an integer
                        parameter constrained to lie in the range
                        <literal>[1..23]</literal> named <literal>-slot</literal>.
                        The default value (if the user does not configure
                        this item) is <literal>1</literal> (the last parameter
                        of the <methodname>addIntegerParameter</methodname> call).
                    </para>
                    <para>
                        This code is provided by the driver template.
                    </para>
                </callout>
                <callout arearefs='ccusb-dtemplate-valueparam'>
                    <para>
                        This sample line shows how to create an unconstrained
                        integer parameter named <literal>-value</literal>.
                        The configuration subsystem will ensure the value
                        is a valid integer but will not contrain the range
                        of that integer.
                    </para>
                    <para>
                        This line is provided by the template driver but normally
                        is removed as you edit the code to define the
                        configuration options you actually need.
                    </para>
                </callout>
            </calloutlist>
            <para>
                Normally the <methodname>onAttach</methodname> method is simply
                defining the set of configuration parameters it needs to know
                how to initialize and read the device it manages.  Configuration
                parameters are named items (by convention the names start with the
                dash character) and are strongly typed. Integer, real, string,
                enumerated, and boolean simple parameters are supported.  In
                addtion collection (Tcl lists) are supported.
            </para>
            <para>
                Parameter values can have constraints placed on them (the
                range of <option>-slot</option> parameter values e.g.) which
                are checked by the configuration subsystem without any intervention
                by you.  Several pre-defined constraint checkers are available,
                as are convenience functions for defining configuration parameters.
                You can also define custom constraint checkers and register them
                with the configuration subsystem.
            </para>
            <para>
                See <xref linkend='ccusb3-CConfigurableObject' /> for
                detailed information about how to define configuration
                parameters.
            </para>
        </section>
        <section>
            <title>The driver Initialize method</title>
            <para>
                The <methodname>Initialize</methodname> method of each
                device instance that has been put in a stack is called
                after the configuration file is processed prior to loading
                the stack and prior to turning on data taking mode in the
                CC-USB.
            </para>
            <para>
                Typically in <methodname>Initialize</methodname> you must:
                <orderedlist>
                    <listitem>
                        <para>
                            Fetch the configuration parameters you need
                            to know how to initialize the device and prepare
                            it for data taking.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Issue method calls to the <parameter>controller</parameter>
                            <classname>CCCUSB</classname> object passed in to the
                            method.  Note that if your device requires a lot of
                            initialization, you can speed up that process
                            by creating <classname>CCCUSBReadoutList</classname>
                            objects, which are lists of instructions, using
                            its methods to create a list of operatinos and then
                            asking the controller to execute that list.
                        </para>
                    </listitem>
                </orderedlist>
            </para>
            <para>
                For detailed information about the methods supported by
                the <classname>CCCUSB</classname> and <classname>CCCUSBReadoutList</classname>,
                see <xref linkend='ccusb3-CCCUSB' /> and <xref linkend='ccusb3-CCCUSBReadoutList' />
            </para>
            <para>
                The template driver provides the following code (most
                comments removed for brevity).
            </para>
            <informalexample>
                <programlisting>
void
CTemplateDriver::Initialize(CCCUSB&amp; controller)
{

  int slot = m_pConfiguration->getIntegerParameter("-slot"); <co id='ccusb-dtemplate-init1' />

  /* MODIFY ME HERE */
                                                             <co id='ccusb-dtemplate-init2' />
  /* END MODIFICATIONS */

}


                </programlisting>
            </informalexample>
            <calloutlist>
                <callout arearefs='ccusb-dtemplate-init1'>
                    <para>
                        In most cases you need the slot number of the module
                        to initialize it.  This call obtains the value of the
                        <option>-slot</option> configuration parameter
                        from the configuration database for this module.
                    </para>
                </callout>
                <callout arearefs='ccusb-dtemplate-init2'>
                    <para>
                        You would add code here to fetch parameter values
                        as well as method calls for the <parameter>controller</parameter>
                        object to manipulate the CAMAC crate.  If initialization
                        requires a large number of CAMAC operations you could
                        also create a <classname>CCCUSBReadoutList</classname>,
                        manipulate it to store a set of operatiuons and then
                        use <parameter>controller.executeList(3ccusb)</parameter> to
                        execute that list.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section>
            <title>The driver addReadoutList method</title>
            <para>
                <methodname>addReadoutList</methodname> is called as a run is
                being intialized.  This method is expected to contribute items
                to the <classname>CCCUSBRedoutList</classname> that will be
                loaded into either a scaler or event stack.  Usuall this is done
                by fetching the set of configuration parameters that are required
                to know how to read the device and then invoking appropriate
                methods on the <parameter>list</parameter> parameter to
                add CAMAC operations to the stack.
            </para>
            <para>
                The template driver implements a marker 'device'. The marker
                device ignores its <option>-slot</option> configuration parameter
                (a production quality marker driver would probably not define
                a <option>-slot</option> parameter).  It adds an instrution
                to the <parameter>list</parameter> that inserts a  literal
                value into the event.  The value inserted is determined by
                the <option>-value</option> parameter.
            </para>
            <para>
                Here's the sample driver code for the <methodname>addReadoutList</methodname>
                method:
            </para>
            <informalexample>
                <programlisting>
void
CTemplateDriver::addReadoutList(CCCUSBReadoutList&amp; list)
{
  int slot = m_pConfiguration->getIntegerParameter("-slot");
  
  /* MODIFY ME HERE */
  
  int value = m_pConfiguration->getIntegerParameter("-value");  <co id='ccusb-dtemplate-read1' />
  list.addMarker(value);        // This is a longword marker.   <co id='ccusb-dtemplate-read2' />

  /* END MODIFICATIONS */
}

                </programlisting>
            </informalexample>
            <calloutlist>
                <callout arearefs='ccusb-dtemplate-read1'>
                    <para>
                        This line fetches the <option>-value</option>
                        cofiguration parameter.  This is the value
                        that we are going to insert into the event buffer
                    </para>
                </callout>
                <callout arearefs='ccusb-dtemplate-read2'>
                    <para>
                        The <methodname>addMarker</methodname> method adds
                        the CCUSB instructions to insert a literal value in the
                        output buffer to the list being built up. This
                        therefore instructs the CCUSB that the readout of this
                        'device' consists of inserting the value of the
                        <option>-value</option> configuration parameter.
                    </para>
                    <para>
                        Naturally a real device would add NAF instructions or
                        Q-Stop/C-Scan operations to the list via other
                        <classname>CCCUSBReadoutList</classname> methods.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section>
            <title>Initializing the driver with the framework.</title>
            <para>
                The Tcl <command>load</command> command searches the
                shared object for a specific function entry point that
                it will call to initialize the library.  The initialization function
                must follow the correct naming conventions or Tcl will complain
                about not being able to find the library's initialization function.
            </para>
            <para>
                The initialization entry point must be the name of the
                resulting library with the <literal>lib</literal> prefix stripped
                off and the first letter capitalized suffixed by <literal>_Init</literal>.
                Thus if you are building
                <filename>libmydriver.so</filename>, the initialation function
                must be called <function>Mydriver_Init</function>.
            </para>
            <para>
                The template driver provides the following code:
            </para>
            <informalexample>
                <programlisting>
extern "C" {                                    <co id='ccusb-dtemplate-dinit1' />
  int Templatedriver_Init(Tcl_Interp* pInterp)  <co id='ccusb-dtemplate-dinit2' />
  {
    Tcl_PkgProvide(pInterp, "Templatedriver", "1.0"); <co id='ccusb-dtemplate-dinit3' />
 
    CUserCommand::addDriver("changeme", new CTemplateDriver); <co id='ccusb-dtemplate-dinit4' />

    return TCL_OK;                               <co id='ccusb-dtemplate-dinit5' />

  }
}
                </programlisting>
            </informalexample>
            <calloutlist>
                <callout arearefs='ccusb-dtemplate-dinit1' >
                    <para>
                        Since C++ <firstterm>decorates</firstterm> function  names
                        with an encoding of the call signature, to support function
                        overloading, you must declare the initialization
                        functino using C linkage conventions.  The
                        <literal>extern "C" {}</literal> creates a block of
                        code whose externally visible symbols will use C
                        linkage conventions.
                    </para>
                </callout>
                <callout arearefs='ccusb-dtemplate-dinit2'>
                    <para>
                        In general you will need to modify the name of this
                        to work with the name of the library file you
                        create.  The discussion prior to this example
                        describes the naming conventions that are required.
                    </para>
                </callout>
                <callout arearefs='ccusb-dtemplate-dinit3'>
                    <para>
                        In our examples we used the Tcl <command>load</command>
                        command to load the driver.  This statement registers
                        the library as providing a Tcl loadable package.
                        You can use the Tcl command <command>pkg_mkIndex</command>
                        to build an auto load index file for loadable packages
                        including those in shared libraries.  This allows you
                        to collect several drivers into a directory added to the
                        auto load path, and use the <command>package require</command>
                        command to load them by package name.  You must
                        change the name of the package in this call
                        to be something unique and descriptive of your driver.
                    </para>
                </callout>
                <callout arearefs='ccusb-dtemplate-dinit4'>
                    <para>
                        The <classname>CUserCommand</classname>::<methodname>addDriver</methodname>
                        function associates a template device driver object
                        with its Tcl command ensemble name.  The template device driver
                        object is cloned for each <command>create</command> subcommand
                        issued for this driver in the configuration script.
                        You should change both the name of the driver command
                        from <literal>changeme</literal> and you should have
                        previously changted the class name of the
                        driver class from <classname>CTemplateDriverM</classname>
                    </para>
                </callout>
                <callout arearefs='ccusb-dtemplate-dinit5'>
                    <para>
                        If the library initialization was successful it
                        should return <literal>TCL_OK</literal> on failure
                        it shouild return <literal>TCL_ERROR</literal>.
                        In this case it is also customary to use
                        e.g. Tcl_SetResult or a similar function to set the
                        result of the load command to a descriptive error
                        message.
                    </para>
                </callout>
            </calloutlist>
        </section>
    </section>
    <section>
        <title>Tcl device driver support</title>
        <para>
            This section describes how to provide support for device drivers
            as Tcl modules.  The first subsection will describe in general
            terms how to do this.  The second and third subsections will show
            sample drivers written in the snit and Incr-Tcl object oriented
            extensions of Tcl along with sample fragments of DAQ configuration
            files that show how to use these drivers. Note that while snit and
            Incr-Tcl drivers are shown any Tcl object oriented extension can
            probably be used as could a carefully crafted set of
            <command>namespace ensemble</command> commands.
        </para>
        <section>
            <title>Conceptual background</title>
            <para>
                If you have not read the section on writing C++ device drivers
                you should at least skim it.  Several of the concepts
                are important.  Specifically:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        A device support module provides a command that
                        generates device instances.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Device instances have to provide an
                        <methodname>Initialize</methodname> method that
                        initializes the device according to some configuration
                        of the instance.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Device instances have to provide a
                        <methodname>addReadoutList</methodname> method that
                        adds elements to the list of CAMAC operations
                        that are executed when the stack they live in
                        is triggered.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                All of this is a natural match to the way all of the object
                oriented extensions to Tcl work.  Specifically you write a
                class like thing.  Creating an instance of the class creates
                a new Tcl command <firstterm>ensemble</firstterm>.  The
                public methods of the instance become sub commands of the
                new Tcl command.  
            </para>
            <para>
                The CCUSB framework therefore provides a
                mechanism, the <command>addtcldriver</command> command to
                add an object instance command to the set of devices that
                can be added to a stack. The <command>addtcldriver</command>
                command registers the command name as a name of a  device
                that can be put in a stack.  The command ensemble is also
                wrapped in an actual driver that invokes
                <methodname>Initialize</methodname>, and
                <methodname>addReadoutList</methodname>
                methods at the appropriate times.
            </para>
            <para>
                The final piece of the puzzle is providing access to the
                CCUSB and CCUSBReadout list capabilities to Tcl drivers.
                This has been done by wrapping Tcl command ensembles around both
                of those classes using SWIG
                (see <ulink url='http://www.swig.org'>http://www.swig.org</ulink>).
            </para>
            <para>
                As we will see when we work our way through sample drivers,
                the C++ wrappers are not able to actually pass a SWIG wrapped
                object to the driver methods.  The driver must take the
                swig pointer like parameter and turn it into a SWIG object
                before it can be used.  A Tcl fragment that shows how to
                turn the CCCUSB pointer into a SWIG CCCUSB object is shown
                below:
            </para>
            <informalexample>
                <programlisting>
...
method Initialize ccusbPointer {
    cccusb::CCCUSB c -this $ccusbPointer
    ...
}
...
                </programlisting>
            </informalexample>
            <para>
                The example takes the <varname>ccusbPointer</varname> parameter
                which must be a swig like pointer to  a CCCUSB object and
                turns it in to a swig object named <literal>c</literal>
                which is a SWIG object representing the underlying CCCUSB
                passed in to the <methodname>Initialize</methodname> method.
            </para>
        </section>
        <section>
            <title>A sample snit Tcl CCUSB framework driver</title>
            <para>
                This section will go through a sample snit driver describing
                how it works.  To see this driver incorporated in a DAQ
                configuration file see
                <xref linkend='ccusb-general-tcldriver-usage' />.
            </para>
            <para>
                First a word or two about snit.  Snit is a pure Tcl object
                oriented framework for Tcl written by Will Duquette from
                the Jet Propulsion Laboratory in Pasadena.
                <ulink url='http://wiki.tcl.tk/3963'>
                    http://wiki.tcl.tk/3963</ulink>
                provides access to documentation and examples of snit in action.
            </para>
            <para>
                snit is part of the <literal>TclLib</literal> which is installed
                on all systems at the NSCL.
            </para>
            <para>
                Snit classes are created via the <command>snit::type</command>
                command.  Snit classes feature <command>method</command>s
                which are analagous to member functions in C++ classes.
            </para>
            <para>
                snit also
                provides all types with a <command>configure</command> and
                <command>cget</command> command and a mechanism for declaring
                options that can be manipulated by these commands. Using this
                capability allows you to configure snit device driver instances
                in a manner analagous to the C++ driver instances supported
                by the CCUSB framework.
            </para>
            <para>
                Below is a complete implementation of a snit driver that,
                at initialization time turns on the yellow LED and adds
                a marker to the readout list.  The marker value can be configured
                via the instances built in configure subcommand.
            </para>
            <example>
                <title>A snit CCUSB device driver module</title>
                <programlisting>
lappend auto_path /usr/opt/daq/10.1/lib  <co id='ccusb-snit-auto_path' />

package require snit                    
package require cccusb                  <co id='ccusb-snit-packages' />
package require cccusbreadoutlist


snit::type marker-snit {                <co id='ccusb-snit-type' />
    option -value 0                     <co id='ccusb-snit-option' />

    #
    # Called when the run is being started.  
    # 
    # @param driverPtr - 'pointer' to the CCUSB object.
    #
    method Initialize driverPtr {      <co id='ccusb-snit-Initializemethod' />

 
        cccusb::CCCUSB c -this $driverPtr; <co id='ccusb-snit-ccusbswigwrap' />

        # Get the led programming now
        # Yellow is the mask of FF0000
        # Clear out those bits and set that field to be 110000 which is source I3 and
        # inverted.

        set leds [c readLedSelector]      <co id='ccusb-snit-readleds' />
        set leds [expr {$leds &amp;  0xffff}]
        set leds [expr {$leds | 0x110000}]
        c writeLedSelector $leds         <co id='ccusb-snit-writeleds' />

    }
    # Called to contribute to the readout list
    #   
    # @param list - 'pointer' to the CCCUSBReadoutList which will be wrapped in a
    #                swig wrapper.
    #
    method addReadoutList list {       <co id='ccusb-snit-addReadoutListmethod' />

        #
        # Wrap the list so we can use it:
        #
        cccusbreadoutlist::CCCUSBReadoutList l -this $list; <co id='ccusb-snit-ccusbreadoutlist-swigwrap' />

        l addMarker $options(-value)                        <co id='ccusb-snit-addmarker' />

    }
}

                </programlisting>
            </example>
            <para>
                The numbers in the explanations below refer to the corresponding
                numbers in the example text.
            </para>
            <calloutlist>
                <callout arearefs='ccusb-snit-auto_path'>
                    <para>
                        The SWIG Tcl wrappers for the CCUSB and CCUSBReadoutList
                        classes are installed in the <filename>lib</filename>
                        subdirectory of the NSCLDAQ installation.  This
                        adds that directory for the 10.1 verssion of nslcdaq
                        to the package loads search path.  This allows those
                        packages to be loaded via the <command>package require</command>
                        package.
                    </para>
                </callout>
                <callout arearefs='ccusb-snit-packages'>
                    <para>
                        Incorporates the following packages into the
                        driver, if they have not been loaded elsewhere:
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term>snit</term>
                            <listitem><para>
                                The snit package.  This implements the
                                object oriented framework this example uses.
                                </para></listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>cccusb</term>
                            <listitem>
                                <para>
                                    The  swig wrapper for the
                                    CCUSB C++ class.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>cccusbreadoutlist</term>
                            <listitem>
                                <para>
                                    The swig wrapper for the CCCUSBReadoutList
                                    C++ class.
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </callout>
                <callout arearefs='ccusb-snit-type'>
                    <para>
                        The <command>snit::type</command> command
                        creates a new snit class like entity. The
                        type is named <command>marker-snit</command> and
                        the list of commands that follow define the
                        body of the class.  This creates a new command
                        <command>marker-snit</command> primarly used to
                        construct instances of the type.
                    </para>
                </callout>
                <callout arearefs='ccusb-snit-option'>
                    <para>
                        Snit objects all have a set of options that are
                        modified via their built in
                        <command>configure</command> sub command and accessed
                        externally via their <command>cget</command>
                        built in sub command.
                    </para>
                    <para>
                        The <command>option</command> command within a snit
                        type body defines a configurable option
                        (<option>-value</option> in this case), and optionally
                        provides an initial value.
                    </para>
                </callout>
                <callout arearefs='ccusb-snit-Initializemethod'>
                    <para>
                        Instance subcommands are created via the
                        snit <command>method</command> command.  This command
                        looks exactly like the <command>pro</command> command
                        except that methods generate subcommands.
                    </para>
                    <para>
                        The <methodname>Initialize</methodname> method must
                        be implemented by all device driver objecgt (do-nothing
                        implementations are fine).  The parameter to this method
                        is a pointer like entity which points to a
                        <classname>CCCUSB</classname> object that communuicates
                        with the selected CAMAC crate.
                    </para>
                    <para>
                        The <methodname>Initialize</methodname> method is
                        invoke for all object instances that are added to stacks.
                        It is suposed to look at the configuration items and
                        do what is necessary to program the module it supports
                        to prepare to take data in the specified configuration.
                    </para>
                </callout>
                <callout arearefs='ccusb-snit-ccusbswigwrap'>
                    <para>
                        Creates a swig wrapping of the <classname>CCCUSB</classname>
                        class whose underlying class is the class 'pointed to'
                        by the <parameter>driverPtr</parameter> parameter.
                    </para>
                    <para>
                        The wrapping creats a command <command>c</command>
                        Subcommands of that command are mapped to methods in the
                        <classname>CCCUSB</classname> C++ class.
                    </para>
                    <para>
                        You can also get Swig to name the new object after
                        the pointer that was passed in:
                        <informalexample>
                            <programlisting>
...
cccusb::CCCUSB -this $driverPtr
...
                            </programlisting>
                        </informalexample>
                        Where $driverPtr can be used as the CCCUSB object
                        command.
                    </para>
                </callout>
                <callout arearefs='ccusb-snit-readleds'>
                    <para>
                        This is an example of invoking a CCCUSB method.
                        The subcommand <methodname>readLedSelector</methodname>
                        reads the CC-USB LED selector register. The subsequent
                        code makes changes the fields that control the yellow
                        LED so that it's input is the NIM IN3 inpout and is lit
                        when there is no input (inverted state).  This should
                        normally light the yellow LED.
                    </para>
                </callout>
                <callout arearefs='ccusb-snit-writeleds'>
                    <para>
                        Invokes the CCCUSB <methodname>writeLedSelector</methodname>
                        so that the new value of the LED selector register
                        takes effect.
                    </para>
                </callout>
                <callout arearefs='ccusb-snit-addReadoutListmethod'>
                    <para>
                        The <methodname>addReadoutList</methodname>
                        is invoked for each driver instance that is in a stack
                        as the run is started.  It is is expected to contribute
                        elements to a <classname>CCCUSBReadoutList</classname>
                        object that read the supported module in the manner
                        defined by the object's configuration.
                    </para>
                    <para>
                        The <parameter>list</parameter> parameter is a pointer
                        like value to a <classname>CCCUSBReadoutList</classname>
                        object.
                    </para>
                </callout>
                <callout arearefs='ccusb-snit-ccusbreadoutlist-swigwrap'>
                    <para>
                        Wraps the pointer in a SWIG object analagous to what
                        was done for the ccusb pointer passed to
                        <methodname>Initialize</methodname>.
                    </para>
                </callout>
                <callout arearefs='ccusb-snit-addmarker'>
                    <para>
                        Adds a marker to the list.
                        The marker value will be value of the
                        <option>-value</option> option. In snit, options
                        are put in an array named <varname>options</varname>
                        indexed by the option name.
                    </para>
                </callout>

            </calloutlist>
        </section>
        <section>
            <title>A sample Incr-Tcl Tcl CCUSB framework driver</title>
            <para>
                Incr Tcl is an object oriented extension for Tcl.  It is installed
                on all NSCL systems.  It provides the ability to define
                <firstterm>classes</firstterm>. As with snit, creating a class
                 instance (object) creates a new command.  The public class
                 methods are then subcommands for the object command.
            </para>
            <para>
                As with snit, objects can have configurations that are manipulated
                and queried via built in <command>config</command> and
                <command>cget</command> object subcommands.  Unlike snit,
                all public member variables are considered to be
                configurable objects to Incr Tcl.
            </para>
            <para>
                The properties above make Incr Tcl a viable option for
                implementing driver support.
            </para>
            <para>
                <ulink url='http://incrtcl.sourceforge.net/itcl/'>
                    http://incrtcl.sourceforge.net/itcl/</ulink>
                provides information about Incr Tcl.
            </para>
            <para>
                The example below shows a marker driver identical in functionality
                to the snit driver shown in the previous section, but written
                with Incr Tcl.
            </para>
            <example>
                <title>CCUSB device support example writtin in Incr Tcl</title>
                <programlisting>
lappend auto_path /usr/opt/daq/10.1/lib
puts $auto_path
package require Itcl                       <co id='ccusb-itcl-header' />
package require cccusb
package require cccusbreadoutlist

itcl::class marker-itcl {                 <co id='ccusb-itcl-class' />
    public variable value 0               <co id='ccusb-itcl-options' />

    #
    # Called when the run is being started.  
    # 
    # @param driverPtr - 'pointer' to the CCUSB object.
    #
    public method Initialize driverPtr {  <co id='ccusb-itcl-initialize' />

        #  This turns the driver pointer into a CCUSB object which
        #  can make use of the SWIG wrappers for the CCUSB code:

        cccusb::CCCUSB c -this $driverPtr; # c is a CAMAC controller object.

        # Get the led programming now
        # Yellow is the mask of FF0000
        # Clear out those bits and set that field to be 110000 which is source I3 and
        # inverted.

        set leds [c readLedSelector]
        set leds [expr {$leds &amp;  0xffff}]
        set leds [expr {$leds | 0x110000}]
        c writeLedSelector $leds

    }
    # Called to contribute to the readout list
    #   
    # @param list - 'pointer' to the CCCUSBReadoutList which will be wrapped in a
    #                swig wrapper.
    #
    public method addReadoutList list {               <co id='ccusb-itcl-addreadoutlist' />

        #
        # Wrap the list so we can use it:
        #
        cccusbreadoutlist::CCCUSBReadoutList l -this $list; # l is now a swig wrapper over the list.

        l addMarker $value                          <co id='ccusb-itcl-addmarker' />

    }

                </programlisting>
            </example>
            <para>
                 The numbers in the explanations below refer to the numbers
                 in the example above.
            </para>
            <calloutlist>
                <callout arearefs='ccusb-itcl-header'>
                    <para>
                        This heading is easily  understandable from the
                        example in the previous section.  The only difference
                        is that the Itcl package is loaded instead of snit.
                    </para>
                </callout>
                <callout arearefs='ccusb-itcl-class'>
                    <para>
                        The <command>class</command> command creates an Incr
                        Tcl class. The class name <command>marker-itcl</command>
                        becomes the command name for creating class instances
                        (objects).
                    </para>
                </callout>
                <callout arearefs='ccusb-itcl-options'>
                    <para>
                        Unlike snit Incr Tcl does not have a separate facility
                        for creating options.  Any instance variable that is
                        declared <literal>public</literal> is treated as
                        a configuration parameter.
                    </para>
                    <para>
                        Therefore this line creates the
                        <option>-value</option>.   Configuring
                        <option>-value</option> will modify this variable.
                        Cgetting <option>-value</option> will read this
                        variable.
                    </para>
                </callout>
                <callout arearefs='ccusb-itcl-initialize'>
                    <para>
                        The <methodname>Initialize</methodname> method
                        has been described previously.  The body of this
                        method is identical to the body of the
                        correpondig <literal>snit::type</literal>.
                        method.
                    </para>
                </callout>
                <callout arearefs='ccusb-itcl-addreadoutlist'>
                    <para>
                        Creates a method to be called when the software
                        is building readout lists.  With the exception
                        shown below, this too is identical to the
                        contents of the same method in the snit example.
                    </para>
                </callout>
                <callout arearefs='ccusb-itcl-addmarker'>
                    <para>
                        In Incr Tcl, options are just member variables.
                        Therefore when the marker is added ot the stack,
                        <literal>$value</literal> substitutes the
                        selected value.
                    </para>
                </callout>
            </calloutlist>
        </section>
        <section id="ccusb-general-tcldriver-usage">
            <title>Using Tcl drivers in the DAQ configuration file.</title>
            <para>
                Using a Tcl driver in the DAQ configuration file requires that you
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        Incorporate the driver code into your DAQ configuration
                        script.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Create device instances for the hardware you want read
                        out by your experiment.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Register the device instances with the CCUSB frameowork
                        so that they can be referred to in
                        <command>stack</command> or other
                        module containing commands.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Add the instances to a stack
                    </para>
                </listitem>
            </itemizedlist>
            <formalpara>
                <title>Incorporating driver code into the DAQ configuration file</title>
                <para>
                    Tcl provides two suitable mechanisms for incorporating
                    device support code into your DAQ configuration script.  Note
                    that these mechanisms are not restricted to device support
                    code but could be used to incorporate any Tcl library code
                    you might need.
                </para>
            </formalpara>
            <para>
                The <command>source</command> command allows you to include
                a specific Tcl script file given a relative or absolute path
                directly to that script.  Suppose our device support
                file named <filename>mydriver.tcl</filename> is located
                in the same directory as the configuration script.  The
                code fragment below is an accepted way to source that file
                that doesn ot assume the current working directory is where the
                script is:
            </para>
            <informalexample>
                <programlisting>
set here [file dirname [info script]]
source [file join $here mydriver.tcl]
                </programlisting>
            </informalexample>
            <para>
                The first command determines the directory that holds the
                script while the second uses that to construct a path to the
                <filename>mydriver.tcl</filename> file for the <command>source</command>
                command.
            </para>
            <para>
                If you develop a library of device support code, or are using
                someone else's device support code, it is probably preferable
                to use the Tcl <command>package</command> command,
                <filename>pkgIndex.tcl</filename> and package search paths
                to load the driver code.
            </para>
            <para>
                The author of the driver code you are using must have cooperated
                to the extent of having a <command>package provide</command>
                command in their scripts, and creating a <filename>pkgIndex.tcl</filename>
                (through e.g. Tcl's <command>pkg_mkIndex</command> command) in the
                directories holding their packagtes.
            </para>
            <para>
                Once this is done you can append the script package directories
                to your <varname>auto_path</varname> variable and use
                <command>package require</command> to pull in the required
                files.
            </para>
            <para>
                Suppose, for example, <filename>/projects/mydetector/drivers</filename>
                is a directory that contains several device support scripts
                given package names like <literal>device1</literal>
                <literal>device2</literal>, suppose further that you are
                running in conjunction with another system that has
                <literal>device3</literal> in <filename>/projects/otherdetector/drivers</filename>.
                The following script fragment uses the Tcl package facility to load
                those drivers:
            </para>
            <informalexample>
                <programlisting>
lappend auto_path /projects/mydetector/drivers /projects/otherdetector/drivers
package require device1
package require device2
package require device3
                </programlisting>
            </informalexample>
            <para>
                Furthermore, by using the <literal>TCLLIBPATH</literal>
                rather than the <varname>auto_path</varname> variable you
                can make it so that your script does not need to know
                which directories have package files.
            </para>
            <formalpara>
                <title>Creating device instances</title>
                <para>
                    How you create device instances depends on how you the
                    driver was written.  In snit, for example you use the
                    <command>snit::type</command> type name's create
                    sub command.  For example for the previous example driver:
                </para>
            </formalpara>
            <informalexample>
                <programlisting>
marker-snit create snitmarker
                </programlisting>
            </informalexample>
            <para>
                creates an instance of the driver named <literal>snitmarker</literal>.
                The base name of the resulting command ensemble is also
                <command>snitmarker</command>.
                In the case of our Incr Tcl driver:
            </para>
            <informalexample>
                <programlisting>
marker-itcl itclmarker
                </programlisting>
            </informalexample>
            <para>
                Creates an instance whose name is <literal>itclmarker</literal>
                and whose instance command is
                <command>itclmarker</command>
            </para>
            <para>
                Once created, how you configure the device depends on the
                framework used to build the driver.  For both the
                snit and Incr Tcl examples, the <command>configure</command>
                command can be used to configure  the object instance:
            </para>
            <informalexample>
                <programlisting>
<replaceable>instance-command</replaceable> configure -value 0x1234
                </programlisting>
            </informalexample>
            <formalpara>
                <title>Registering device instances</title>
                <para>
                    Device instances must be registered.  Until they are,
                    they have an existence completely independent of the CCUSB
                    framework.  Registration makes their instance command
                    the name of a device that can be added to <command>stack</command>
                    <option>-module</option> lists.
                </para>
            </formalpara>
            <para>
                The <command>addtcldriver</command> command associated a Tcl
                instance command with a module name:
            </para>
            <informalexample>
                <programlisting>
addtcldriver snitmarker
                </programlisting>
            </informalexample>
            <para>
                Creates a module name <literal>snitmarker</literal> that is
                associated with the <command>snitmarker</command>
                instance of the <classname>marker-snit</classname> driver.
            </para>
            <para>
                Given this discussion, here is a fragment of a
                daq cofiguration script:
            </para>
            <example>
                <title>DAQ config script fragment with tcl drivers.</title>
                <programlisting>
...
set here [file dirname [info script]]

source [file join $here testdriver-snit.tcl]
marker-snit create snitmarker
snitmarker configure -value 0x5678
addtcldriver snitmarker

source [file join $here testdriver-itcl.tcl]
marker-itcl itclmarker
itclmarker configure -value 0xfafa
addtcldriver itclmarker


# testing and tdc were defined earlier by 'normal' commands.,

stack create events
stack config events -modules [list itclmarker snitmarker testing tdc] -type event -delay 108

                </programlisting>
            </example>
        </section>
            
    </section>
    <section>
        <title>The slow controls subsystem</title>
        <para>
            There is nothing to stop you from creating device support that
            does not do anything in its <methodname>addReadoutList</methodname>.
            You could do this to implement static controls devices.  That is
            non data taking devices whose configuration is set up at the start of
            a run and cannot be dynamically modified.
        </para>
        <para>
            There are cases, however when you'd like to have some control
            panel associated with a device, that would provide a virtual knob
            allowing you to dynamically modify settings in the device.
            The slow controls subsystem supports this by offering a
            TCP/IP server which can accept commands to set and query
            devices.  
        </para>
        <para>
            If the run is halted, the slow controls server can directly
            manipulate the CCUSB to perform the desired device changes.
            If, however the CCUSB is in data taking mode, the slow controls
            server pauses the run, makes the setting and then resumes the run.
            You should avoid working with control panels during production runs
            for that reason.
        </para>
        <para>
            The philosophy of the slow controls subsystem is similar to that
            of the readout subsystem.  A controls configuration file defines
            the control modules present in the system and their unchanging
            configuration.  Note that the controls configuration file
            is read only as CCUSBReadout starts, not once per run as
            for the data acquisition configuration file.
        </para>
        <para>
            The <command>Module</command> command is used to create configure
            and query the configuration of slow controls devices known to the server.
            The example below shows how to a Phillips PH7106 leading edge
            discriminator:
        </para>
        <informalexample>
            <programlisting>
Module create ph7106  led
Module config led -slot 3
            </programlisting>
        </informalexample>
        <para>
            The <literal>3ccusb</literal> reference section describes the Module types available,
            the configuration options available, their control panels and
            the network protocol used to communicate with the controls server.
        </para>
    </section>
    <section>
        <title>Running CCUSBReadout</title>
        <para>
            <application>CCUSBReadout</application> is installed as:
            <filename>$DAQROOT/bin/CCUSBReadout</filename>.
        </para>
        <para>
            Several command options control the way CCUSBReadout operates:
        </para>
        <variablelist>
            <varlistentry>
                <term><option>-serialno</option></term>
                <listitem>
                    <para>
                        Specifies the serial number of the CCUSB the program
                        will use.  See <option>--enumerate</option> below.
                        If not provided, the first CCUSB located will be used.
                        If you only have one CCUSB connected to your system,
                        this is suitable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--ring</option></term>
                <listitem>
                    <para>
                        Specifies the ring buffer in which event data will
                        be put by the program.  By default this is the
                        same as the username you are logged in on .
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--daqconfig</option></term>
                <listitem>
                    <para>
                        Specifies the filename that contains the data acquisition
                        configuration script.  This defaults to
                        <filename>~/config/daqconfig.tcl</filename>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--ctlconfig</option></term>
                <listitem>
                    <para>
                        Specifies the filename that contains the slow controls
                        configuration script.  This defaults to
                        <filename>~/config/controlconfig.tcl</filename>. Note
                        that this file is required even if it is just an empty file.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--init-script</option></term>
                <listitem>
                    <para>
                        Specifies the name of a script that will be run in the
                        interpreter just prior to starting the interpreter's
                        command/event loop.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--port</option></term>
                <listitem>
                    <para>
                        Specifies the port on which the slow controls server
                        listens for connections.  This defaults to
                        <literal>27000</literal>.  The value of thie parameter
                        can be either an intger port number or the special
                        string <literal>managed</literal>.
                    </para>
                    <para>
                        If the value is <literal>managed</literal> CCUSBReadout
                        will work with the NSCL port manager to allocate and
                        advertise itself on a managed port.  The port will
                        be advertised as <literal>CCUSBReadout:</literal><replaceable>controller</replaceable>
                        Where <replaceable>controller</replaceable> is the serial
                        number of the controller or <literal>FirstController</literal>
                        if no specific serial number was requested.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--enumerate</option></term>
                <listitem>
                    <para>
                        Requests that the software list the serial numbers of
                        the CCUSB devices currently attached to the system and
                        exit.  Note that the serial 'numbers' are actually strings
                        of the form <literal>CCnnnn</literal> where <replaceable>nnnn</replaceable>
                        is a number.  One of these strings can be handed to the
                        <option>--serialno </option> to select the CCUSB
                        to use.
                    </para>
                    <para>
                        Sample output:
                    </para>
                    <informalexample>
                        <programlisting>
/usr/opt/daq/10.1/bin/CCUSBReadout --enumerate
CC-USB scriptable readout version V2.0
[0] : CC0134

                        </programlisting>
                        <para>
                            This output says the system is attached to a single
                            CCUSB whose serial number string is
                            <literal>CC0134</literal>
                        </para>
                    </informalexample>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--sourceid</option></term>
                <listitem>
                    <para>
                        If a <option>--timestamplib</option> option is present,
                        events will have a full body header and the integer
                        value of this switch determines the value of the source
                        id.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--timestamplib</option></term>
                <listitem>
                    <para>
                        The value of this option is a path to a shared object
                        library.  If present, the library must have a C
                        compatible entry point named <function>getTimestamp</function>.
                        If not supplied all events will have abbreviated body
                        headers and no timestamps will be present.
                    </para>
                    <para>
                        The library is dynamically loaded into the readout
                        program and <function>getTimestamp</function> is called
                        for each event.  <function>getTimestamp</function>
                        receives a single null pointer parameter, which points
                        to the event and is supposed to return a
                        <type>uint64_t</type> value that is that event's
                        timestamp.
                    </para>
                    <para>
                        If the library has a further entry named
                        <function>onBeginRun</function>, taking no parametesr and
                        having no return value, this funtion is called when the run
                        starts.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </section>
    <section>
        <title>Writing C++ slow controls device drivers</title>
        <para>
            The slow controls system can make use of the Tcl <command>load</command>
            or <command>package require</command> commands to dynamically
            load compiled code in shared object modules.  This section provides a
            step by step tutorial that describes how to write, build and
            incorporate compiled slow controls drivers.
        </para>
        <para>
            It is also possible to write slow controls drivers in Tcl and
            <link linkend='sec-ccusb-tcl-slowcontrols-drivers'
                    endterm='sec-ccusb-tcl-slowcontrols-drivers-title' />
            describes how to do this.
        </para>
        <para>
            To build a slow controls driver you should
        </para>
        <orderedlist>
            <listitem><para>
                Obtain the sample driver and Makefile from the skeleton
                directories.
                </para></listitem>
            <listitem><para>
                Modify the sample driver and Makefile to meet your needs
                </para>
            </listitem>
            <listitem><para>
                Optionally make a <filename>pkgIndex.tcl</filename> package
                file to make the resulting shared library into a
                Tcl loadable package.
                </para></listitem>
        </orderedlist>
        <section>
            <title>Obtaining the sample driver and its Makefile</title>
            <para>
                The skeleton driver is in the <filename>ccusbdriver/example</filename>
                directory of the installation directory tree.  If, you have an
                environment variable <literal>DAQROOT</literal> defined,
                the following sequence of command makes a directory and copies
                the files into it:
            </para>
            <example>
                <title>Obtaining the sample CCUSB slow controls driver</title>
                <programlisting>
mkdir mydriver
cp $DAQROOT/ccusbdriver/example * mydriver
                </programlisting>
            </example>
            <para>
                The driver example contains the following files:
            </para>
            <variablelist>
                <varlistentry>
                    <term><filename>sampleDriver.cpp</filename></term>
                    <listitem><para>
                        The source code for the sample driver itself.
                        </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term><filename>Makefile</filename></term>
                    <listitem><para>
                        A Makefile that can build a shared library out of the
                        driver.  The Makefile will also build a <filename>pkgIndex.tcl</filename>
                        file that, when put on the package search path alog with
                        the driver shared library, allows the driver to be loaded
                        with the <command>package require</command> command.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                Note that both the sample driver and its makefile will need to
                be modified to be of any use to you.
            </para>
        </section>
        <section>
            <title>Modifying the sample driver and Makefile.</title>
            <para>
                This section will go step by step through the sample device
                driver sourc code.   The intent is to describe the classes and
                functions it contains, as well as the class methods and expections
                for those methods.
            </para>
            <para>
                It is assumed that you are familiar with the
                <link linkend='ccusb3-CCCUSB'>CCCUSB</link> and
                <link linkend='ccusb3-CCCUSBReadoutList'>CCCUSBReadoutList</link>
                classes.
            </para>
            <para>
                Before proceeding to a description of the sample driver it is
                important to know how driver instances (<command>Module</command>s)
                come into existence.  The <command>Module</command> makes use
                of an extensible driver factory.  A set of creator objects
                that know how to create an instance of a driver for a specific
                driver type.
            </para>
            <para>
                Thus the sampled driver contains the following code:
            </para>
            <itemizedlist>
                <listitem>
                    <para>
                        The driver code (a class definition and implementation).
                    </para>
                </listitem>
                <listitem>
                    <para>
                        A creator (class definition and implementation) the
                        extensible factory can use to creaste instances of our
                        driver.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Initialization code that registers the driver as a
                        package with the interpreter and registers the
                        creator with the extensible factory so that the
                        <command>Module</command> command can create
                        instances of our driver.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                Our driver will be a fairly abstract 'device' so that you can
                play with it without the need for any specific hardware.
                The driver will define several configuration options and
                these options can be set and gotten by slow control
                clients.
            </para>
            <section>
                <title>Driver Code</title>
                <para>
                    This section breaks down the code in the driver and annotates it.
                    As usual, the first part of the source file is a set of includes:
                </para>
                <example>
                    <title>Headers for the CCUSB sample slow controls driver</title>
                    <programlisting>

#include &lt;tcl.h&gt;                      <co id='ccusb-slowdriver-includes-tcl.h' />
#include &lt;CModuleFactory.h&gt;           <co id='ccusb-slowdriver-includes-CModuleFactory.h' />
#include &lt;CModuleCreator.h&gt;           <co id='ccusb-slowdriver-includes-CModuleCreator.h' />
#include &lt;CControlHardware.h&gt;         <co id='ccusb-slowdriver-includes-CControlHardware.h' />
#include &lt;CControlModule.h&gt;           <co id='ccusb-slowdriver-includes-CControlModule.h' />
#include &lt;string&gt;

                    </programlisting>
                </example>
                <calloutlist>
                    <callout arearefs='ccusb-slowdriver-includes-tcl.h' >
                        <para>
                            Since our driver will get loaded via the Tcl
                            <command>load</command> or <command>package require</command>
                            commands, we will need to interact a bit with the
                            Tcl interpreter that runs the slow control server.
                            This header includes the public Tcl definitions.
                        </para>
                    </callout>
                    <callout arearefs='ccusb-slowdriver-includes-CModuleFactory.h'>
                        <para>
                            The <classname>CModuleFactory</classname> class is
                            a singleton object that is the extensible module
                            factory that was described above.  We need to know
                            about it because we will need to register a
                            creator object with it and associate that creator
                            with a module type.
                        </para>
                        <para>
                            See:
                                <link linkend='ccusb3-cmodulefactory'
                                      endterm='ccusb3-cmodulefactory-title' />
                            for a reference page on the <classname>CModuleFactory</classname>
                            extensible factory class.
                        </para>
                    </callout>
                    <callout arearefs='ccusb-slowdriver-includes-CModuleCreator.h'>
                        <para>
                            This header defines the base class for all module
                            creators registered with the <classname>CModuleFactory</classname>.
                            Since we need to define a creator for our driver,
                            we need the base class definition so that we can derive
                            our own creator. (see
                            <link linkend='ccusb3-cmodulecreator'
                                  endterm='ccusb3-cmodulecreator-title' />
                            )
                        </para>
                    </callout>
                    <callout arearefs='ccusb-slowdriver-includes-CControlHardware.h'>
                        <para>
                            Drivers are classes that are derived from
                            the <classname>CControlHardware</classname> base class.
                            The base class defines the methods each driver must
                            implement as abstract methods.  This header makes
                            the definition of that base class available.
                            (see
                            <link linkend='ccusb3-ccontrolhardware'
                                  endterm='ccusb3-ccontrolhardware-title' />
                        </para>
                    </callout>
                    <callout arearefs='ccusb-slowdriver-includes-CControlModule.h'>
                        <para>
                            The makeup of a <classname>CControlHardware</classname>
                            derived class is very similar to that of a <classname>
                            CReadoutHardware</classname> derived class.  The driver
                            provides the code needed to interface with the device.
                            A <classname>CControlModule</classname> contains the
                            configurable aspects of the device as well as providing
                            Tcl parsing mechanisms for the module related commands.
                            Finally the <classname>CControlModule</classname> provides
                            the wrapper that translates client requests into
                            driver requests.
                        </para>
                        <para>
                            The <classname>CControlModule</classname> also, if
                            necessary interfaces with the readout thread to bracket
                            driver calls with run pause/resume operations so that
                            single shot operations can be performed by the driver
                            in the middle of a run (the CCUSB cannot perform single
                            shot operations when the device is in data taking
                            mode).
                        </para>
                        <para>
                            <filename>CControModule.h</filename> defines the
                            <classname>CControlModule</classname> class. Reference
                            documentation of that class is in
                            <link linkend='ccusb3-ccontrolmodule'
                                  endterm='ccusb3-ccontrolmodule-title' />.
                        </para>
                    </callout>
                </calloutlist>
                <para>
                    The remainder of this section is subdivided into sections
                    that describe  the driver class and its implementation,
                    the creator class and its implementation, the intialization
                    code.
                </para>
                <section>
                    <title>The driver class and its implementation</title>
                    <para>
                        Let's start by looking at the class definition for the
                        driver itself.  First we'll give a brief overview of the
                        methods the driver must define.  Then we will look at
                        the implementation of each method with an eye towards
                        what the method is expected to do.
                    </para>
                    <example><title>CCUSB Slow control driver class definition </title>
                        <programlisting>
class SampleDriver : public CControlHardware           <co id='ccusb-slowdriver-def-subclass' />
{
private:
  CControlModule* m_pConfig;                           <co id='ccusb-slowdriver-def-m_pConfig' />
public:
  SampleDriver(std::string name);
  virtual ~SampleDriver ();

  // Forbidden methods

private:                                              <co id='ccusb-slowdriver-def-noimplementation' />
  SampleDriver(const SampleDriver&amp; rhs);
  SampleDriver&amp; operator=(const SampleDriver&amp; rhs);
  int operator==(const SampleDriver&amp; rhs);	    
  int operator!=(const SampleDriver&amp; rhs);	    


public:
  virtual void onAttach(CControlModule&amp; configuration); <co id='ccusb-slowdriver-def-onattach' />
  virtual void Initialize(CCCUSB&amp; camac);	            <co id='ccusb-slowdriver-def-initialize' />
  virtual std::string Update(CCCUSB&amp; camac);            <co id='ccusb-slowdriver-def-update' />
  virtual std::string Set(CCCUSB&amp; camac,                <co id='ccusb-slowdriver-def-set' />
			  std::string parameter, 
			  std::string value);              
  virtual std::string Get(CCCUSB&amp; camac,                <co id='ccusb-slowdriver-def-get' />
			  std::string parameter);          
  virtual void clone(const CControlHardware&amp; rhs);	    <co id='ccusb-slowdriver-def-clone' />

};
                        </programlisting>
                    </example>
                    <para>
                        Note that all the methods that are labeled as
                        <literal>virtual</literal> are pure vitual in the base
                        class.  This means that actual, concrete, device drivers
                        must implement them.  If one of these methods does not
                        make much sense for your driver, you can implement it
                        as a method that does nothing, but you must implement
                        all virtual methods.
                    </para>
                    <calloutlist>
                        <callout arearefs='ccusb-slowdriver-def-subclass'>
                            <para>
                                As we mentioned earlier, all slow controls device
                                drivers are derived from the
                                <classname>CControlHardware</classname> class.
                                In writing your own driver you must choose
                                your own classname and substitute all
                                instances of <literal>SampleDriver</literal>
                                with the name you choose.
                            </para>
                        </callout>
                        <callout arearefs='ccusb-slowdriver-def-m_pConfig'>
                            <para>
                                Each driver class has associated with it a
                                <classname>CControlModule</classname> object.
                                This object, among other things, contains the database
                                of configurable parameters and their current
                                values.  Most drivers will have member
                                data to allow them to continue to use this
                                object to define and fetch their configuration.
                            </para>
                            <para>
                                For the sample driver. <varname>m_pConfig</varname>
                                will contain a pointer to that object.  The
                                object is associated with the driver instance
                                by a call to <methodname>OnAttach</methodname>
                                which is described below.
                            </para>
                        </callout>
                        <callout arearefs='ccusb-slowdriver-def-noimplementation'>
                            <para>
                                If not defined, the methods in this section will
                                get a default implementation from the compiler.
                                For CCUSBReadout, these operations don't make sense
                                and, in some circumstances, can be hard to implement
                                properly.
                            </para>
                            <para>
                                By declaring them to be <literal>private</literal>
                                no external client of the class can call them.
                                By not implementing them, internal, accidental
                                requirements will fail as well.
                                <footnote id='footnote-smprivate'>
                                    <para>This idea comes from Scott Meyers <citetitle>Effective C++</citetitle>
                                    book
                                </para>
                                </footnote>
                            </para>
                        </callout>
                        <callout arearefs='ccusb-slowdriver-def-onattach'>
                            <para>
                                The <methodname>OnAttach</methodname> method is
                                when the framework associates a
                                <classname>CControlModule</classname> with the
                                driver class.  Normally this method will
                                define configuration parameters and save a
                                pointer to the <classname>CControlModule</classname>
                                object so that the configuration parameters
                                can be fetched.
                            </para>
                            <para>
                                If real CAMAC hardware is involved, a slow control
                                driver will at least need a <literal>slot</literal>
                                configuration parameter so it knows how to address
                                the device.
                            </para>
                        </callout>
                        <callout arearefs='ccusb-slowdriver-def-initialize'>
                            <para>
                                Some devices require a one-time initialization
                                to place them into a known state.  This method is
                                called at a suitable time for drivers to provide that
                                initialization.
                            </para>
                        </callout>
                        <callout arearefs='ccusb-slowdriver-def-update'>
                            <para>
                                Some devices have write only registers and can
                                get in a state where the only knowledge of the
                                internal state of the device is a shadow state
                                maintained by the driver.  This method is
                                used by clients to force the device to match
                                that internal memorized state.
                            </para>
                        </callout>
                        <callout arearefs='ccusb-slowdriver-def-set'>
                            <para>
                                This method is called when a client wants to set
                                a parameter controlled by this driver instance.
                                Normally this means changing a register or set of
                                registers inside the physical device.
                            </para>
                        </callout>
                        <callout arearefs='ccusb-slowdriver-def-get'>
                            <para>
                                This method is called when a client wants to read
                                a parameter controlled by this driver instance.
                                Normally this means reading a register or set of
                                registers from the hardware.
                            </para>
                        </callout>
                        <callout arearefs='ccusb-slowdriver-def-clone'>
                            <para>
                                <methodname>clone</methodname> is intended to
                                implement virtual copy construction.  At this
                                time that facility is not yet used and it is
                                not likely it will be used in the future.
                            </para>
                        </callout>
                    </calloutlist>
                    <para>
                        Let's look at the implementation of each of the methods
                        of the class with an eye to the expectations placed on
                        each method by the framework and to what a real driver
                        might have to do to meet those expectations.
                    </para>
                    <formalpara>
                        <title>Construction and destruction</title>
                        <para>
                            See
                            <link linkend='ccusb-slowdriver-impl-condestruct'
                                  endterm='ccusb-slowdriver-impl-condestruct-title' />
                            for the actual implementation of these methods in the
                            sample driver.
                        </para>
                    </formalpara>
                    <example id='ccusb-slowdriver-impl-condestruct'>
                        <title id='ccusb-slowdriver-impl-condestruct-title'>
                            The constructor and destructor
                        </title>
                        <programlisting>

SampleDriver::SampleDriver(std::string name) :
  CControlHardware(name),             <co id='ccusb-slowdriver-impl-constr-baseinit' />
  m_pConfig(0)                        <co id='ccusb-slowdriver-impl-constr-configinit' />
{
  
}
SampleDriver::~SampleDriver()
{}                                   <co id='ccusb-slowdriver-impl-destruct' />

                        </programlisting>
                    </example>
                    <calloutlist>
                        <callout arearefs='ccusb-slowdriver-impl-constr-baseinit' >
                            <para>
                                The constructor must initialize the base
                                class to ensure that the framework knows this
                                object by its name.  The <parameter>name</parameter>
                                parameter passed to the constructor and relayed
                                to the base class constructor is the name given
                                to the instance in the <command>Module create</command>
                                command that resulted in creating this instance.
                            </para>
                        </callout>
                        <callout arearefs='ccusb-slowdriver-impl-constr-configinit' >
                            <para>
                                The <varname>m_pConfig</varname> member variable
                                will be used to hold a pointer to the
                                driver instance's configuration object.
                                In order to ensure that calls to this object
                                fail with a bus-error if made prior to this
                                attachment, the pointer is initialized to zero.
                            </para>
                        </callout>
                        <callout arearefs='ccusb-slowdriver-impl-destruct'>
                            <para>
                                If the driver needs to create any dynamic data
                                it would use this destructor to perform an
                                orderly free of that data.  Since our driver
                                is too simple to need dynamically allocated
                                data, this method does nothing.
                            </para>
                        </callout>
                    </calloutlist>
                    <formalpara>
                        <title>OnAttach</title>
                        <para>
                            This method is when the framework attaches a
                            <classname>CControlModule</classname> to our instance.
                            The <classname>CControlModule</classname>, among
                            other things is derived from a
                            <classname>CConfigurableObject</classname> and
                            therefore maintains our configuration data.
                        </para>
                    </formalpara>
                    <para>
                        Usually <methodname>OnAttach</methodname> saves a pointer
                        to the <classname>CControlModule</classname> and defines
                        configuration parameters and their constraints.
                        Our driver is no exception.  A normal driver will need to
                        at least define a <literal>slot</literal> parameter so
                        that the driver instance knows how to address the module
                        it is controlling.
                    </para>
                    <example><title>CCUSB Slow controls driver <methodname>OnAttach</methodname></title>
                        <programlisting>
void
SampleDriver::onAttach(CControlModule&amp; configuration) <co id='ccusb-slowdriver-impl-attach-params' />
{
  m_pConfig = &amp;configuration;                         <co id='ccusb-slowdriver-impl-attach-save' />
  m_pConfig->addIntegerParameter("anint");                <co id='ccusb-slowdriver-impl-attach-anint' />
  m_pConfig->addIntListParameter("test", 16);             <co id='ccusb-slowdriver-impl-attach-intlist' />
  m_pConfig->addBooleanParameter("abool");                <co id='ccusb-slowdriver-impl-attach-abool' />
}
                        </programlisting>
                    </example>
                    <calloutlist>
                        <callout arearefs='ccusb-slowdriver-impl-attach-params' >
                            <para>
                                Sincethe point of the call to <methodname>
                                OnAttach</methodname> is to provide the
                                <classname>CControlModule</classname> to the
                                driver, a reference is passed to the
                                driver (the <parameter>configuration</parameter>
                                parameter).
                            </para>
                        </callout>
                        <callout arearefs='ccusb-slowdriver-impl-attach-save' >
                            <para>
                                Since drivers, in general, define configuration
                                parameters maintained by <parameter>configuration</parameter>,
                                a pointer to the configuration is saved in
                                <varname>m_pConfig</varname>.  This allows the
                                values of configuration parameters to be
                                accessed.
                            </para>
                        </callout>
                        <callout arearefs='ccusb-slowdriver-impl-attach-anint'>
                            <para>
                                <methodname>OnAttach</methodname> is the method
                                that should be used to create configuration
                                parameters.  This line adds an integer
                                parameter that is named <literal>anint</literal>
                            </para>
                        </callout>
                        <callout arearefs='ccusb-slowdriver-impl-attach-intlist'>
                            <para>
                                Similarly this line adds a parameter that
                                consists of a list of 16 integers named
                                <literal>test</literal> to the configuration
                                parameters.
                            </para>
                        </callout>
                        <callout arearefs='ccusb-slowdriver-impl-attach-abool'>
                            <para>
                                This line creates a boolean parameter named
                                <literal>abool</literal>
                            </para>
                        </callout>
                    </calloutlist>
                    <formalpara>
                        <title>The <methodname>Initialize</methodname> method.</title>
                        <para>
                            Normally this method is used to place the
                            hardware controlled by a driver instance into
                            a known initial state.
                        </para>
                    </formalpara>
                    <para>
                        Since we have no hardware we don't need to do this:
                    </para>
                    <example>
                        <title>CCUSB Slow controls driver initialize method</title>
                        <programlisting>
void
SampleDriver::Initialize(CCCUSB&amp; camac)
{
}
                        </programlisting>
                    </example>
                    <para>
                        The only remark I want to make here is that the
                        parameter <parameter>camac</parameter> allows the
                        method to perform single short CAMAC operations.
                        It also allows the method to execute immediate lists
                        that were built up in a
                        <classname>CCCUSBReadoutList</classname> object.
                    </para>
                    <formalpara>
                        <title>The Update method</title>
                        <para>
                            The <methodname>Update</methodname> method is normally
                            used by clients of devices that have state that is partially
                            or entirely write only.
                            Such drivers often maintain a 'shadow' state that
                            attempts to maintain a knowledge of the hidden internal
                            state of the device itself.
                        </para>
                    </formalpara>
                    <para>
                        The implementation of <methodname>Update</methodname> is:
                    </para>
                    <example>
                        <title>CCUSB Slow controls driver Update</title>
                        <programlisting>
std::string
SampleDriver::Update(CCCUSB&amp; camac)
{
    return "OK";
}
                        </programlisting>
                    </example>
                    <para>
                        I want to clarify:
                    </para>
                    <orderedlist>
                        <listitem>
                            <para>
                                The <parameter>camac</parameter> parameter allows
                                this method to perform CAMAC operations. The
                                method can build immediate lists using
                                the <classname>CCCUSBReadoutList</classname>
                                and execute them with the <parameter>camac</parameter>
                                parameter as well.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                The return value of the method should either be
                                the string <literal>OK</literal> which is passed
                                back to the client and indicates the initialization
                                was successful or
                                <literal>ERROR </literal> which should be followed
                                by an error message that is human readable, indicating
                                the initialization failed.  The client usually
                                strips off the <literal>ERROR</literal> part and
                                displays the remainder.
                            </para>
                            <para>
                                A sample error return might be:
                                <literal>ERROR No X response, be sure the slot parameter is correct</literal>
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                Driver code can be assured that there is no active run
                                when this method is called.
                            </para>
                        </listitem>
                    </orderedlist>
                    <formalpara>
                        <title>The Set method</title>
                        <para>
                            The <methodname>Set</methodname> method is eventually called
                            to satisfy client <command>Set</command> requests that
                            are directed at this module name.  Normal drivers
                            will take the parameter name and value and use them
                            to set some device state.
                        </para>
                    </formalpara>
                    <para>
                        Our driver instance uses its configuration parameters
                        as the settable parameters rather than hardware.
                        Note that when called the <methodname>Set</methodname>
                        method can be assured that data taking is not active.
                        If there is an active run, the framework pauses it
                        before calling <methodname>Set</methodname> and
                        resumes it when that method returns.
                    </para>
                    <para>
                        Therefore the implemntation is:
                    </para>
                    <example>
                        <title>CCUSB Slow controls driver Set method</title>
                        <programlisting>
std::string
SampleDriver::Set(CCCUSB&amp; camac, std::string parameter, std::string value)
{
  try {
    m_pConfig->configure(parameter, value);   <co id='cccusb-slowdriver-impl-set-configure' />
  }
  catch(std::string msg) {
    std::string error = "ERROR ";             <co id='cccusb-slowdriver-impl-set-error' />
    error += msg;

    return error;
  }
  return "OK";                                 <co id='cccusb-slowdriver-impl-set-ok' />
}
                        </programlisting>
                    </example>
                    <calloutlist>
                        <callout arearefs='cccusb-slowdriver-impl-set-configure'>
                            <para>
                                Our driver uses the configuration database
                                as its 'device state'.  Instead of this
                                line, a real driver would use the
                                <parameter>parameter</parameter> argument to
                                select a bit of device state and set that
                                device state to what is desired by the
                                <parameter>value</parameter> parameter.
                            </para>
                            <para>
                                Normally this will involve CAMAC operations that
                                can be done via the <parameter>camac</parameter>
                                object.  Immediate lists can also be performed
                                using a <classname>CCCUSBReadoutList</classname>
                                to build the list and the <parameter>camac</parameter>
                                object to execute them.
                            </para>
                        </callout>
                        <callout arearefs='cccusb-slowdriver-impl-set-error'>
                            <para>
                                The string result of the method is used to report
                                both success and failure back to the client.
                                Srings that start with
                                <literal>ERROR </literal> are error returns and
                                the remainder of the string is a human readable
                                error message the client usually displays.
                            </para>
                            <para>
                                One example of an error return is:
                                <literal>ERROR There is no parameter 'junk'</literal>.
                            </para>
                            <para>
                                In the sample driver, errors in the
                                <methodname>configure</methodname>
                                method are reported by thrown strings.  These
                                exceptions are caught and the actual value of
                                the string is appended to the leading
                                <literal>ERROR</literal> word.  In practice you
                                will need to decide how to detect and communiate
                                errors between different sections of your driver.
                            </para>
                        </callout>
                        <callout arearefs='cccusb-slowdriver-impl-set-ok'>
                            <para>
                                On success, the <methodname>Set</methodname>
                                method is supposed to return
                                <literal>OK</literal>.
                            </para>
                        </callout>
                    </calloutlist>
                    <formalpara>
                        <title>CCUSB Slow controls Get method</title>
                        <para>
                            The <methodname>Get</methodname> method is eventually
                            called by the framework when a client requests an
                            item of device state.  As with other methods that
                            have a <parameter>camac</parameter> object as a
                            parameter, if necessary, an active run is paused
                            prior to the all and resumed after the method
                            returns.
                        </para>
                    </formalpara>
                    <para>
                        Our device uses its configuration parameters to simulate
                        a device state.  In a normal driver the driver would
                        interact with the hardware to return the desired state.
                    </para>
                    <para>
                        Here's our driver's <methodname>Get</methodname>
                        implementation:
                    </para>
                    <example>
                        <title>CCUSB slow controls Get method</title>
                        <programlisting>
std::string
SampleDriver::Get(CCCUSB&amp; camac, std::string parameter)
{
  try {
    return m_pConfig->cget(parameter);    <co id='ccusb-slowdriver-impl-get-cget' />
  } catch(std::string msg) {
    std::string error = "ERROR - ";       <co id='ccusb-slowdriver-impl-get-error' />
    error += msg;
    return error;
  }
  
}
                        </programlisting>
                    </example>
                    <calloutlist>
                        <callout arearefs='ccusb-slowdriver-impl-get-cget'>
                            <para>
                                Since our device uses its configuration parameters
                                as its 'device state', we just perform a
                                call to <methodname>cget</methodname> on our
                                configuration object.   This fetches the
                                configuration parameter named <parameter>parameter</parameter>
                                and returns its value.
                            </para>
                            <para>
                                On successful return the method is supposed to
                                return the stringified value of the device parameter
                                specified by its <parameter>parameter</parameter>
                                argument.  In a normal driver, the
                                <parameter>camac</parameter> object would be used
                                to interact with some physical device to
                                fetch the requested device state.
                            </para>
                        </callout>
                        <callout arearefs='ccusb-slowdriver-impl-get-error'>
                            <para>
                                The <methodname>cget</methodname> method throws
                                a string exception on error.  The framework and
                                client expect a string beginning with
                                <literal>ERROR - </literal> if the
                                <methodname>Get</methodname> method fails.
                                As usual, the tail of this string should be a
                                human readable error message.
                            </para>
                            <para>
                                The sample driver simply appends the string
                                exception value to the initial <literal>ERROR - </literal>
                                to generate the return string.  An example of
                                an error string might also be:
                                <literal>ERROR - Parameter junk does not exist</literal>
                            </para>
                        </callout>
                    </calloutlist>
                    <formalpara>
                        <title>The clone method</title>
                        <para>
                            The <methodname>clone</methodname> method is a
                            placeholder for future funtionality. It is intended
                            to support virtual copy construction if that is needed.
                            It is very likely this functionality will never be needed
                            and driver implementers can simply provide an empy
                            implementation of this method (that's what the sample
                            driver does).
                        </para>
                    </formalpara>
                    <example>
                        <title>CCUSB Slow controls clone method</title>
                        <programlisting>
void
SampleDriver::clone(const CControlHardware&amp; rhs)
{
}
                        </programlisting>
                    </example>
                    <para>
                        If you do try to take on a real implementation of
                        <methodname>clone</methodname> you will need to
                        set your internal state to be the same as the
                        object <parameter>rhs</parameter>, remember that
                        internal state includes the internal state of
                        superclasses.
                    </para>
                    <para>
                        The <parameter>rhs</parameter> is an object that is
                        guaranteed to be the type as your driver.
                    </para>         
                </section>
                <section>
                    <title>The creator class and its implementation</title>
                    <para>
                        The creator class is normally a very simple class.  It
                        has only two requirements:
                    </para>
                    <itemizedlist>
                        <listitem><para>
                            It must be derived from <classname>CModuleCreator</classname>
                            </para></listitem>
                        <listitem><para>
                            It must provide a functor method (<methodname>operator()</methodname>)
                            that creates a named instance of the driver object.
                            </para></listitem>
                    </itemizedlist>
                    <para>
                        Here is the entire creator for our driver:
                    </para>
                    <example>
                        <title>Module creator for the CCUSB Sample slow controls driver</title>
                        <programlisting>
class SampleCreator : public CModuleCreator {     <co id='ccusb-slowdriver-creatordef-derive' />
public:
  CControlHardware* operator()(std::string name);
};

CControlHardware*
SampleCreator::operator()(std::string name)
{
  return new SampleDriver(name);                <co id='ccusb-slowdriver-creatordef-functor' />
}
                        </programlisting>
                    </example>
                    <calloutlist>
                        <callout arearefs='ccusb-slowdriver-creatordef-derive'>
                            <para>
                                The <classname>SampleCreator</classname> class is
                                derived from <classname>CModuleCreator</classname>
                                and therefore meets the first requirement of
                                creators.
                            </para>
                        </callout>
                        <callout arearefs='ccusb-slowdriver-creatordef-functor'>
                            <para>
                                This method creates drivers instances and fulfils
                                the second requirement of creators.
                            </para>
                        </callout>
                    </calloutlist>
                </section>
                <section>
                    <title>Driver initialization</title>
                    <para>
                        Drive initialization is normally relatively simple:
                    </para>
                    <itemizedlist>
                        <listitem><para>
                            If you decide to make your driver an actual Tcl
                            package that can be loaded by the
                            <command>package require</command> command, the
                            package must be registered with the
                            Tcl interpreter via a call to
                            <function>Tcl_PkgProvide</function>
                            </para></listitem>
                        <listitem><para>
                            An instance of the creator must be registered
                            with the module factory.
                            </para></listitem>
                    </itemizedlist>
                    <para>
                        In addition, since at load time the Tcl interpreter
                        computes the name of the initialization function from
                        the name of the shared library or package, the
                        initialization function must:
                    </para>
                    <itemizedlist>
                        <listitem><para>
                            Conform to the naming conventions specified in
                            the documentation of the
                            <ulink url='http://www.tcl.tk/man/tcl8.5/TclCmd/load.htm'>
                                Tcl Load Command</ulink>.
                           </para></listitem>
                        <listitem><para>
                            Have a C binding via the <literal>extern "C"</literal>
                            construct so that C++ does not decorate the function
                            name with the function signature.
                            </para></listitem>
                    </itemizedlist>
                    <example>
                        <title>CCUSB Slow control driver initialization function</title>
                        <programlisting>
extern "C" {                                 <co id='ccusb-slowdriver-init-externc' />
int
Sampledriver_Init(Tcl_Interp* pInterp)       <co id='ccusb-slowdriver-init-name' />
{
  int status;
  
  status = Tcl_PkgProvide(pInterp, "Sampledriver", "1.0");    
  if (status != TCL_OK) {                   <co id='ccusb-slowdriver-init-provide' />
    return status;
  }
  
  CModuleFactory* pFact = CModuleFactory::instance(); <co id='ccusb-slowdriver-init-factinstance' />
  pFact->addCreator("sample", new SampleCreator);     <co id='ccusb-slowdriver-init-factadd' />
  
  return TCL_OK;
}
}
                        </programlisting>
                    </example>
                    <calloutlist>
                        <callout arearefs='ccusb-slowdriver-init-externc'>
                            <para>
                                This line and the closing brace at the end of
                                the example ensures that the function defined
                                inside this block are not decorated.  Normally
                                C++ mangles (decorates) the names of functions
                                and methods to encode the types of parameters
                                and return types in the function name.
                                This is how overloading is implemented.
                            </para>
                            <para>
                                Functions that are declared as
                                <literal>extern "C"</literal> are intended to
                                be called from C or other languages where this
                                decoration is not done.  This construction
                                therefore disables that decoration.
                            </para>
                        </callout>
                        <callout arearefs='ccusb-slowdriver-init-name'>
                            <para>
                                Since the driver will be encapsulated in a package
                                named <literal>Sampledriver</literal>, the initializer
                                must be named <function>Sampledriver_Init</function>.
                                Note that the slow controls interpreter is not a
                                safe interpreter so the
                                <function>Sampledriver_SafeInit</function> function
                                does not need to be implemented.
                            </para>
                        </callout>
                        <callout arearefs='ccusb-slowdriver-init-provide' >
                            <para>
                                This sectrion of code uses the
                                <function>Tcl_PkgProvide</function> function
                                to provide the package <literal>Sampledriver</literal>
                                with a version of <literal>1.0</literal> to the
                                interpreter.
                            </para>
                        </callout>
                            
                        <callout arearefs='ccusb-slowdriver-init-factinstance'>
                            <para>
                                The module creator factory (<classname>CModuleFactory</classname>)
                                is a singleton object and the call to
                                <methodname>CModuleFactory::instance</methodname>
                                returns a pointer to the singleton.  If this icall fails,
                                the failure status is returned from this function.
                            </para>
                        </callout>
                        <callout arearefs='ccusb-slowdriver-init-factadd' >
                            <para>
                                This line instantiates a creator for the sample
                                driver and registers it with the module factory.
                                This registration allows the <command>Module crate</command>
                                command to create instances of our driver.
                            </para>
                        </callout>
                    </calloutlist>
                </section>
            </section>

            <section>
                <title>The Makefile and typical modifications.</title>
                <para>
                    The Makefile has been written to be easily modified.
                    In many cases you just need to adjust the values of some
                    Makefile variables to get your driver built.
                </para>
                <para>
                    The Makefile has targets to build both the shared library
                    that contains your driver code, and a
                    <filename>pkgIndex.tcl</filename> file that tells Tcl
                    how to load your package.
                </para>
                <para>
                    The example below is the Makefile as it is distributed.
                </para>
                <example>
                    <title>CCUSB Slow controls driver Skeleton Makefile</title>
                    <programlisting>
INSTDIR=/usr/opt/nscldaq/11.0                     <co id='ccusb-slowdriver-makefile-instdir' />

HEADER_DIR=$(INSTDIR)/ccusbdriver/includes
LIB_DIR=$(INSTDIR)/lib


#
#  Modify the line below to include all of your driver files:

SOURCES=sampleDriver.cpp                        <co id='ccusb-slowdriver-makefile-sources' />


# Modify the lines below to be the name and version of your package
# in the call to Tcl_PkgProvide

PKGNAME=Sampledriver                          <co id='ccusb-slowdriver-makefile-pkginfo' />
PKGVER=1.0

#
# Modify the line below to be the name of the desired
# shared library:

SONAME=sampleDriver.so                     <co id='ccusb-slowdriver-makefile-libname ' />

# Don't touch these, use USERCXXFLAGS and USERLDFLAGS

CXXFLAGS=-I/usr/include/tcl8.5 -I/usr/include/tcl8.5
LDFLAGS= -L/usr/lib -ltcl8.5 -ldl  -lpthread -lieee -lm

# Add your flag defs here:

USERCXXFLAGS=                             <co id='ccusb-slowdriver-makefile-flags' />
USERLDFLAGS=


# Make the package index file if possible

pkgIndex.tcl: $(SONAME)
	echo "package ifneeded $(PKGNAME) $(PKGVER) [list load [file join \$$dir $(SONAME)]]" > pkgIndex.tcl


# linux specific!

$(SONAME):	$(SOURCES)
	$(CXX) -o$(SONAME) -I$(HEADER_DIR) -L$(LIB_DIR) $(CXXFLAGS) $(USERCXXFLAGS) -shared -fPIC \
	$(SOURCES) \
	$(USERLDFLAGS) $(LDFLAGS) -Wl,"-rpath=$(LIB_DIR)"
                    </programlisting>
                </example>
                <calloutlist>
                    <callout arearefs='ccusb-slowdriver-makefile-instdir'>
                        <para>
                            This line defines the top level directory of the NSCLDAQ
                            installation you are building against.  The minium
                            that supports custom slow control drivers is
                            11.0.  If you port your code to more recent versions
                            of nscldaq, or to systems that have NSCLDAQ
                            installed elsewhere you will need to modify this line.
                        </para>
                        <para>
                            This line is normally generated by the NSCLDAQ installation
                            process.
                        </para>
                    </callout>
                    <callout arearefs='ccusb-slowdriver-makefile-sources'>
                        <para>
                            This line should contain a space separated list
                            of the C/C++ sources that make up your driver.  These
                            sources will be compiled by the Makefile and bound
                            into the driver shared library.  If you neeed to continue
                            on multiple lines, use a <literal> \ </literal> at the
                            end of a line to indicate there is more.
                        </para>
                    </callout>
                    <callout arearefs='ccusb-slowdriver-makefile-pkginfo'>
                        <para>
                            The part of the Makefile that generates the
                            <filename>pgkIndex.tcl</filename> package index
                            file needs to know the name and version of your
                            package (as registered in the intialization function
                            via the call to <function>Tcl_Pkg_Provide</function>).
                        </para>
                    </callout>
                    <callout arearefs='ccusb-slowdriver-makefile-libname ' >
                        <para>
                            Similarly, the Makefile needs to know the name of
                            the shared library you will be creating.  This
                            is used when building the library and the package
                            index file.
                        </para>
                    </callout>
                    <callout arearefs='ccusb-slowdriver-makefile-flags'>
                        <para>
                            If you have additional compilation or
                            link flags, supply them here.
                        </para>
                    </callout>
                </calloutlist>
            </section>
              
        </section>
    </section>
    <section id='sec-ccusb-tcl-slowcontrols-drivers'>
        <title id ='sec-ccusb-tcl-slowcontrols-drivers-title'>
            Writing Tcl slow controls device drivers </title>
        <para>
            Using the SWIG generated Tcl wrappers and the <literal>tcl</literal>
            control module wrapper you can also write your slow controls drivers
            in pure Tcl.  This section describes:
        </para>
        <itemizedlist>
            <listitem><para>
                How to write a slow controls driver in Tcl
                </para></listitem>
            <listitem><para>
                How to use the <classname>Module create</classname> command
                to hook an instance of your driver into the slow controls
                framework.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            Before continuing with a detailed discussion of pure Tcl drivers,
            it is important to understand Tcl command ensembles.  A command
            ensemble is a command that has subcommands.  Traditionally, the
            subcommand is the second keyword on the command line.
            The Tcl
            <ulink url='http://www.tcl.tk/man/tcl8.5/TclCmd/string.htm'>
                string</ulink> command is an example ofa  command ensemble
            that is part of the core lanaguage.
        </para>
        <para>
            All Tcl slow controls drivers must be Tcl command ensembles that
            implement some pre-defined subcommands.  When writing Tcl drivers,
            it is useful to have an <firstterm>ensemble generator</firstterm>.
            An ensemble generator is a mechanism that generates command ensembles
            that follow the form of some template.  For example, all
            Tk user interface creation commands (e.g.
            <ulink url='http://www.tcl.tk/man/tcl8.5/TkCmd/canvas.htm'>canvas</ulink>)
            are ensemble generators.  The widget they create becomes a Tcl command
            that at least has the <command>config</command> and
            <command>cget</command> subcommands.
        </para>
        <para>
            Tcl object oriented extensions such as
            <ulink url='http://www.tcl.tk/man/itcl3.1/'>IncrTcl</ulink>,
            <ulink url='http://tcllib.sourceforge.net/doc/snit.html'>snit</ulink>
            and as we transition to Tcl6.0,
            <ulink url='http://wiki.tcl.tk/18152'>the Tcl6.0 tcloo object system</ulink>.
            Can serve as generators.
        </para>
        <para>
            For example, in instances of an incrTcl <literal>class</literal>,
            public methods of that class are ensemble subcommands for the name of
            the object.  Similarly, for objects generated by
            <literal>snit::type</literal> class commands, the methods of that
            type are ensemble methods of the generated command.
        </para>
        <para>
            The remainder of this section describes a sample Tcl driver written
            in Tcl that is similar in functionality to the sample driver written
            in C++ described in the previous section. We'll use this sample driver
            as a mechanism to describe and discuss the interfaces between the
            sample driver and the framework.
        </para>
        <para>
            Note that sample drivers perform CCUSB operations via the SWIG
            wrappers for the CCCUSB class.  They can generate and perform lists
            as well by using the SWIG wrapping of the CCUSBReadoutList class.
            This section assumes you are familiar with those wrappers.
        </para>
        <para>
            We are going to approach the description of the driver by first
            showing a skeletal <command>snit::type</command> and then filling
            in the body of each method.  Finally we'll show some script fragments
            that show how to create instances of the type and how to integrate those
            instances into the slow controls framework.
        </para>
        <para>
            The example below is a snit driver with all of the executable code
            stripped out.  This shows the general structure of the driverand
            its methods.
        </para>
        <example>
            <title>CCUSB Tcl slow controls driver skeleton</title>
            <programlisting>
package require cccusb             <co id='ccusb-tclslowdriver-skel-requires' />
snit::type SampleDriver {          <co id='ccusb-tclslowdriver-skel-snittype' />
    option -anint   -default 0    -configuremethod _CheckInt
    option -anintlist -default 0  -configuremethod _CheckIntList <co id='ccusb-tclslowdriver-skel-options' />
    option -abool   -default true -configuremethod _CheckBool
    
    
    construtor args {}             <co id='ccusb-tclslowdriver-skel-construct' />
    method Initialize crate {}     <co id='ccusb-tclslowdriver-skel-initialize' />
    method Update crate {}         <co id='ccusb-tclslowdriver-skel-update' />
    method Set {crate what value} {} <co id='ccusb-tclslowdriver-skel-set' />
    method Get {crate what}  {}      <co id='ccusb-tclslowdriver-skel-get' />
    
    method _CheckInt     {name value} {}
    method _CheckIntList {name value} {}
    method _CheckBool    {name value} {}
}
            </programlisting>
        </example>
        <para>
            It is no accident that there is a close parallel between the names of
            the methods for the Tcl driver and those of a C++ class that
            implements a slow control driver.
        </para>
        <calloutlist>
            <callout arearefs='ccusb-tclslowdriver-skel-requires' >
                <para>
                    The <literal>cccusb</literal> package is the SWIG wrapping
                    of the <classname>CCCUSB</classname> driver class.  In order
                    to successfully <command>package require</command> this,
                    the <filename>lib</filename> subdirectory of the NSCLDAQ
                    installation must be part of the package search path.
                </para>
                <para>
                    Some drivers may want to block up several CCUSB operations
                    into a list.  To do this will also require a
                    <command>package require cccusbreadoutlist</command>
                    command to incorporate the SWIG wrapper for the
                    <classname>CCCUSBReadoutList</classname>
                </para>
            </callout>
            <callout arearefs='ccusb-tclslowdriver-skel-snittype' >
                <para>
                    This line starts the definition of a <command>snit::type</command>.
                    The name of the type is <literal>SampleDriver</literal>.
                    The definition continues through the final closing
                    <literal>}</literal> in the example.
                </para>
                <para>
                    <command>snit::type</command> creates an ensemble generating
                    command (in this case <command>SampleDriver</command>) with
                    subcommands defined by the <command>method</command> definitions
                    within the body of the type.  The generated command ensembles
                    also automatically have configuration management commands;
                    <command>configure</command> which configures an object's
                    option database, and <command>cget</command> which obtains
                    information about that database.
                </para>
            </callout>
            <callout arearefs='ccusb-tclslowdriver-skel-options' >
                <para>
                    <command>snit::type</command> objects can have associated
                    configuration parameters.  These are maniuplated externally
                    via the <command>configure</command> and
                    <command>cget</command> subcommands much like for a Tk widget.
                    Internally, methods can manipulate these options via the
                    <varname>options</varname> array (indexed by option name).
                </para>
                <para>
                    This section of code defines three options much like the
                    C++ sample driver does. The <option>-default</option> option
                    provides a default value for the option, effectively initializing
                    that element of the <varname>options</varname> array.
                    The <option>-configuremethod</option> option provides a
                    method that is automatically called when an option is
                    configured via the <command>configure</command> sub-command.
                    We will use these methods to validate  a proposed new
                    value for the option.
                </para>
                <para>
                    Note that <command>snit::type</command> does not have
                    any concept of a private method.  By NSCLDAQ convention,
                    however, methods with names that begin with
                    <literal>_</literal> should be considered internal and
                    not called by external clients.
                </para>
            </callout>
            <callout arearefs='ccusb-tclslowdriver-skel-construct'>
                <para>
                    If a <command>snit::type</command> defines a
                    <command>constructor</command> this method is
                    called when a new object is being created.  One reason
                    most <command>snit::type</command>s need a constructor
                    is to configure the options that may be specified on the
                    end of the construction command (e.g.
                    <command>SampleDriver adriver -anint 1234</command>).
                </para>
            </callout>
            <callout arearefs='ccusb-tclslowdriver-skel-initialize'>
                <para>
                    This is called after the configuration script has been
                    full processed. It is intended to allow the driver
                    to perform one-time device initialization.  Note that
                    the <parameter>crate</parameter> parameter is a
                    SWIG wrapped <classname>CCCUSB</classname> controller that
                    can be used by the driver to perform CAMAC operations.
                </para>
            </callout>  
            <callout arearefs='ccusb-tclslowdriver-skel-update'>
                <para>
                    This is called in response to an Update request from a
                    client.  One common use of this is to ensure that a device
                    with write-only registers has a state that matches an
                    internal shadow state maintained by the driver.
                </para>
            </callout>
            <callout arearefs='ccusb-tclslowdriver-skel-set' >
                <para>
                    Called in response to a <command>Set</command> request by
                    a client.  <parameter>crate</parameter> is a SWIG wrapped
                    <classname>CCCUSB</classname> object and allows the
                    ensemble to perform CAMAC operations.  The driver is suppoed
                    define a set of named parameters the client can modify.
                    <parameter>what</parameter> identifies which parameter the
                    client wants to modify and <parameter>value</parameter> provides
                    the new proposed value for the parameter.
                </para>
                <para>
                    On success the method should return <literal>OK</literal>.
                    The simplest way to report an error is with the
                    Tcl <command>error</command> command.  The error text becomes
                    the string after the <literal>ERROR </literal> text of an
                    error return.
                </para>
            </callout>
            <callout arearefs='ccusb-tclslowdriver-skel-get'>
                <para>
                    Called in response to a <command>Get</command> request by
                    a client.  <parameter>crate</parameter> is a SWIG encapsulated
                    <classname>CCCUSB</classname> object that can be used to
                    perform CAMAC operations.
                </para>
                <para>
                    Drivers are expected to define a set of named parameters
                    that can be read.  These need not be the same as the set
                    that can be written. <parameter>what</parameter> should be
                    the name of one of these defined parameters.  On success, the
                    driver should return the value of that parameter. On failure
                    the driver should either execute an <command>error</command> comman
                    or return a string of the form
                    <literal>ERROR -</literal><replaceable>Error message</replaceable>
                </para>
                <para>
                    If the driver does use <command>error</command> to indicate an
                    error condition, the string passed to that command will
                    be concatenated to <literal>ERROR -</literal> and returned to
                    the client.
                </para>
            </callout>
        </calloutlist>
        <para>
            Let's now look at the implementations of these methods:
        </para>
        <formalpara>
            <title>construction</title>
            <para>
                Construction should be used to initialize the driver's internal
                state.  Furthermore, the <methodname>configurelist</methodname>
                predefined method can be used to process the configuration arguments
                passed to the constructor.
            </para>
        </formalpara>
        <example>
            <title>CCUSB Tcl slow controls driver construction</title>
            <programlisting>
construtor args {
    $self configurelist $args
}
            </programlisting>
        </example>
        <formalpara>
            <title>Initialization</title>
            <para>
                Since we have no hardware we have no one-type initialization
                of that hardware.  Note that if we did have to initialize
                hardware the <parameter>crate</parameter> parameter can be
                used to perform the CAMAC operations needed to do that
                initialization.
            </para>
        </formalpara>
        <example>
            <title>CCUSB Tcl slow controls initialization</title>
            <programlisting>
method Initialize crate {
}
            </programlisting>
        </example>
        <formalpara>
            <title>Update</title>
            <para>
                We don't have anything to do on Update.  In this case it's best
                to make Update signal and error because clients should be
                written not to use it for this device.
            </para>
            </formalpara>
        <example>
            <title>CCUSB Tcl Slow Controls Update</title>
            <programlisting>
method Update crate {
    error "This device does not support 'Update'"
}
            </programlisting>
        </example>
        <para>
            In this case we use the <command>error</command> command to signal
            the error.  The Tcl module will catch this error and turn it into
            the string
            <literal>ERROR - This device does not support 'Update'</literal>.
            We could have also directly returned that string.
        </para>
        <para>
            If the <command>Update</command> method was legal for this driver,
            and it executed successfully, we should return the string that we
            want the client to get.  This is normally <literal>OK</literal>
            indicating success.
        </para>
        <formalpara>
            <title>Set</title>
            <para>
                In our case, <command>Set</command> will treat
                <parameter>what</parameter> like a configuration
                parameter name and <parameter>value</parameter> like
                the value to use to set the parameter.
                We are just going to do a <command>$self configure</command>
                and let this produce an error if there are problems
                (illegal configuration options, illegal values).
                If we succeed, we'll return <literal>OK</literal> to indicate
                that.
            </para>
        </formalpara>
        <para>
            Normally we'd need to use the <parameter>crate</parameter> parameter
            to perform actual CAMAC operations.
        </para>
        <example>
            <title>CCUSB Tcl Slow controls driver Set</title>
            <programlisting>
method Set {crate what value} {
    $self configure $what $value
    return "OK"
}
            </programlisting>
        </example>
        <formalpara>
            <title>Get</title>
            <para>
                The <command>Get</command> will treat the <parameter>what</parameter>
                parameter as the name of a configuration option.  If that option
                exists it will be returned, otherwise an error message will be
                generated.
            </para>
        </formalpara>
        <example>
            <title>CCUSB Tcl Slow Control driver Get</title>
            <programlisting>
method Get {crate what} {
    if {[array names options $what] ne ""} {
        return $options($what)
    } else {
        error "No such parameter '$what'"
    }
}
            </programlisting>
        </example>
        <para>
            Note that in <command>snit::type</command>s, the <varname>options</varname>
            array contains the configuration options. The Tcl command
            <command>array names</command> returns the names of array indices
            that match a glob pattern.  We can get fooled into not emitting the
            correct error message if, for example, we are asked to get
            <literal>*anint</literal>.  In that case there will be a match with
            <literal>-anint</literal>, and the error produced will be:
            <literal>ERROR - can't read "options(*anint)": no such element in array</literal>
        </para>
        <formalpara>
            <title>Option value checking.</title>
            <para>
                In our C++ driver we used configuration constraints to enforce
                correctness in the form and values of the configuration options.
                Tcl rivers are not able to take advantage of the capabilities of
                a <classname>CConfigurableObject</classname>.  Therefore,
                the onus of ensuring that options are correct is placed on
                the driver.
            </para>
        </formalpara>
        <para>
            <command>snit::type</command> provides the ability to intercept
            the <command>configure</command> (and for that matter the <command>cget</command>)
            operations on an option by option basis.  This is done using the
            <option>-configuremethod</option> when defining an option.
        </para>
        <para>
            Configure methods are responsible for updating (or
            not) the appropriate element of the
            <varname>options</varname> array and can therefore
            reject proposed changes.
            Configure methods receive as parameters the name of
            the option being configured and the new proposed value.
            This allows options to share configuremethods.
        </para>
        <para>
            We are going to further share code by having a helper function
            that will throw an error if a string is not an integer.  This
            helper will be used by both <methodname>_CheckInt</methodname> and
            <methodname>_CheckIntList</methodname>.  For now we will assume
            that <methodname>_CheckIntList</methodname> needs to see a 16
            element list.  If this method needs to validate several lists
            that are of different lengths, we would define a <command>variable</command>
            for the object that would be an array indexed by option name whose
            values would be the lengths of the list.
        </para>            
        <example>
            <title>CCUSB Slow controls Tcl driver option validation</title>
            <programlisting>

method _CheckInt     {name value} {
    $self _IsInt $value
    set options($name) $value
}

method _CheckIntList {name value} {
    if {[string is list $value]} {
        if {[llength $value] == 16} {
            foreach element $value {
                $self _IsInt $element
            }
            set options($name) $value
        } else {
            error "$name option expects a list exactly 16 elements long"
        }
    } else {
        error "$name must be a valid Tcl list"
    }
}
method _CheckBool    {name value} {
    if {[string is boolean -strict $value]} {
        set options($name) $value
    } else {
        error "$name must be a boolean parameter, was: $value"
    }
}
method _IsInt        {value} {
    if {![string is integer -strict $value]} {
        error "Configuration value $value must be an integer and is not"
    }
}
            </programlisting>
        </example>
        <para>
            Once a driver class/type has been created it can be used in the slow
            controls configuration script by
            <orderedlist>
                <listitem><para>
                    Creating an instance of the class/type.
                    </para></listitem>
                <listitem><para>
                    Configuring any options for the instance
                    </para></listitem>
                <listitem><para>
                    Wrapping the object in an tcl driver type by specifying it's
                    name as the <option>-ensemble</option> option of the
                    object.
                    </para></listitem>
            </orderedlist>
        </para>
        <example>
            <title>Using the Tcl sample driver in a configuration script.</title>
            <programlisting>
set mydriver [SampleDriver %AUTO% -anint 1234 -abool false]
Module create mydriver tcl
Module config mydriver -ensemble $mydriver
            </programlisting>
        </example>
    </section>
    <section>
        <title>Integrating CCUSBReadout with the statemanager</title>
        <para>
            The state manager/boot manager are described in
            <link linkend='chap.statemgr' endterm='chap.statemgr.title' />
            and
            <link linkend='chap.boot' endterm='chap.boot.title' />.
            Used together with the experiment configuration editor
            (<link linkend='chap.expconfig' endterm='chap.expconfig.title' />), they
            provide the next generation of experiment definition and control.
        </para>
        <para>
            The <literal>ReadoutStateHook</literal> package provides a standard
            mechanism for Tcl based Readout programs with the normal run
            control commands to become aware of state manager state changes and
            react appropriately.  It also provides a mechanism to intiate a
            <literal>FAIL</literal> transition should CCUSBReadout suffer an
            unrecoverable error.
        </para>
        <para>
            To integrate <filename>CCUSBReadout</filename> with the state manager
            requires that you:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Write a small script that incorporates the
                    <literal>ReadoutStateHook</literal> into the
                    <filename>CCUSBReadout</filename>'s Tcl interpreter at start
                    time.
                </para>
            </listitem>
            <listitem>
                <para>
                    Configure the experiment to use the <option>--init-script</option>
                    option to load that small script at start time (when the
                    experiment is booted).
                </para>
            </listitem>
        </itemizedlist>
        <para>
            The script below shows what you need to do to load the
            <literal>ReadoutStateHook</literal> package into the CCUSBReadout
            interpreter:
        </para>
        <example>
            <title>Script to incorporate <literal>ReadoutStateHook</literal></title>
            <programlisting>
set pkgDirs [file join $env(DAQROOT) TclLibs]
lappend auto_path $pkgDirs

package require ReadoutStateHook
            </programlisting>
        </example>
        <para>
            Note that in the script above, the <literal>DAQROOT</literal> environment
            variable is set by the boot manager when it starts a program.
            Further environment variables are set by the boot manager to allow
            the programs it manages to know how to connect to the state manager
            server.
        </para>
    </section>  
</chapter>
<!-- /chapter -->

<!-- manpage 3ccusb -->
    <refentry id='ccusb3-addtcldriver'>
        <refmeta>
           <refentrytitle>addtcldriver</refentrytitle>
           <manvolnum>3ccusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>addtcldriver</refname>
           <refpurpose>Register Tcl command ensemble as a device module</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
addtcldriver <replaceable>tcl-command</replaceable>
            </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Registers the base of a Tcl command ensemble (e.g. an object
            instance command) as a device module that can be used in
            module lists such as the <option>-modules</option> option of a
            <command>stack</command> command.
           </para>
           <para>
                The <parameter>tcl-command</parameter> is the command
                to regsiter.
           </para>
        </refsect1>
        <refsect1>
            <title>EXAMPLE</title>
            <para>
                The command below:
            </para>
            <informalexample>
                <programlisting>
addtclcommand sometclinstance
                </programlisting>
            </informalexample>
            <para>
                Registers the Tcl command <command>sometclinstance</command>
                as a module.  The name of the module is the same as the
                name of the command (<literal>sometclinstance</literal>).
            </para>
            </refsect1>

      </refentry>


	 <refentry id="ccusb3-ad811">
	   <refmeta>
	      <refentrytitle>ad811</refentrytitle>
	      <manvolnum>3ccusb</manvolnum>
	   </refmeta>
	   <refnamediv>
	      <refname>ad811</refname>
	      <refpurpose>Support the Ortec AD811 ADC</refpurpose>
	   </refnamediv>
	   
	   <refsynopsisdiv>
	     <cmdsynopsis>
	     <command>
ad811 create <replaceable>module-name   ?option...?</replaceable>
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
ad811 config <replaceable>module-name ?option...?</replaceable>
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
ad811 cget <replaceable>module-name</replaceable>
	     </command>
	     </cmdsynopsis>
	   </refsynopsisdiv>
	   <refsect1>
	      <title>DESCRIPTION</title>
	      <para>
	       This command ensemble provides support for the ORTEC AD811
	       8 channel peak sensing ADC.  This module requires about 80
	       microseconds to convert.  All channels convert unconditionally.
	      </para>
	      <para>
		  <parameter>module-name</parameter> is either the name to be
		  given to an ADC in the <command>create</command> subcommand
		  or the name given to a previously created module in the
		  <command>config</command> or <command>cget</command> commands.
	      </para>
	      <para>
	       Both <command>create</command> and <command>config</command> take
	       configuration options.   Each option is a keyword value pair where
	       the keyword defines what the option is and the value is a value
	       associated with that option.  See OPTIONS below for more information
	       about the options supported by <command>ad811</command>.
	      </para>
	      <para>
	       The <command>cget</command> option returns the configuration options
	       for the named module as a Tcl list.  Each element of the list is
	       a two element sublist.  The first element of each sublist is
	       the configuration parameter name, and the second the value associated
	       with that name.
	      </para>
	   </refsect1>
	   <refsect1>
	    <title>
	       OPTIONS
	    </title>
	    <para>
	       The <command>ad811</command> configuration options are:
	    </para>
	    <variablelist>
	       <varlistentry>
		  <term><option>-id</option> <replaceable>vsn</replaceable></term>
		  <listitem>
		     <para>
			   Each module has an identifier which, for historical
			   reasons is called a <firstterm>virtual slot number</firstterm>,
			   or <firstterm>vsn</firstterm>.  To maximize the decode
			   error detection the virtual slot numbers for each
			   module should be unique.  This option allows you
			   to set the virtual slot number for the module.
		     </para>
		     </listitem>
	       </varlistentry>
	       <varlistentry>
		  <term><option>-slot</option> <replaceable>slotnum</replaceable></term>
		  <listitem>
		     <para>
			The value of this parameter tells the readout software
			which CAMAC crate slot houses the module.  Recall that
			CAMAC is slot addressable.  Slots number from 1 on the
			left, with an increasing slot number towards the right.
			The right two slots are reserved for the CAMAC Crate
			controller (in our case a CC-USB).
		     </para>
		  </listitem>
	       </varlistentry>
	    </variablelist>
	   </refsect1>
	   <refsect1>
	      <title>EXAMPLE</title>
	      <para>
	       The example below creates and configures an AD811 that is in
	       slot 2 of the CAMAC crate and, when read will have a virtual
	       slot number of 2:
	      </para>
	      <example>
		  <title>AD811 configuration file example</title>
		  <programlisting>
ad811  create adc -slot 2 -id 2
		  </programlisting>
	      </example>
	   </refsect1>
	 
	 </refentry>
         
<refentry id="ccusb3-c1205">
  <refmeta>
     <refentrytitle>c1205</refentrytitle>
     <manvolnum>3ccusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>c1205</refname>
     <refpurpose>Manage CAEN C1205 QDC modules.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
    <command>
c1205 create <replaceable>module-name ?option...?</replaceable>
    </command>
    </cmdsynopsis>
<cmdsynopsis>
<command>
c1205 config <replaceable>module-name ?option...?</replaceable>
</command>
</cmdsynopsis>
<cmdsynopsis>
<command>
c1205 config <replaceable>module-name</replaceable>
</command>
</cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
	      <para>
		  This command ensemble allows you to create and configure
		  CAEN model C1205 QDC modules.  The C1205 is a sixteen
		  channel charge integrating ADC.
	      </para>
	      <para>
		  The <command>create</command> command
		  allows you to create a new module and assign a
		  <parameter>module-name</parameter> to it so that it can
		  be referred to in subsequent configuration commands.
		  You may optionally include configuration switch value pairs
		  on the <command>create</command> command line.
	      </para>
	      <para>
		  The <command>config</command> subcommand allows you to
		  set the configuration parameters for an existing module.
		  <parameter>module-name</parameter> is the name assigned to
		  that module whe it was created.
	      </para>
	      <para>
		  The <command>cget</command> command returns as its value
		  the module configuration as a Tcl list where each list element
		  is a sublist containing the name and value of a configuration
		  parameter.
	      </para>
	      <para>
		  Configuration options are name/value pairs.   The name
		  of a configuration option is sometimes called a
		  <firstterm>switch</firstterm> because it resembles the
		  command line switches of command shell commands.
		  For a full description of these options see OPTIONS below.
	      </para>
  </refsect1>
  <refsect1>
      <title>OPTIONS</title>
      <para>
	 The CAEN C1205 supports the following configuration option switches.
	 The switches and values can be supplied to both the
	 <command>create</command> and the <command>config</command>
	 subcommands.
      </para>
      <variablelist>
	 <varlistentry>
	 <term><option>-slot</option> <replaceable>n</replaceable></term>
	 <listitem>
	    <para>
	       Specifies the slot in which the module is installed
	       to <literal>n</literal>.
	       If this is not set correctly, the Readout program will
	       not be able to communicate with the module and will emit
	       a warning, if the slot <literal>n</literal> is empty.
	       This parameter must be provided.
	    </para>
	 </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-id</option> <replaceable>n</replaceable></term>
	    <listitem>
	       <para>
		  Sets the id of the module to <literal>n</literal>.
		  The module id is placed as a marker word prior
		  to the data from the module.  It is used by the
		  unpacking software to unambiguously identify The
		  data from each module.  For the C1205, the id
		  value is also programmed into the lower 8 bits of the
		  control status register and will therefore also
		  appear in the bottom 8 bits of the header word
		  read from the module.
	       </para>
	       <para>
		  While the <option>-id</option> value defaults to
		  0, and need not be unique, your data is most
		  reliably decoded if each module in your system has
		  a unique id value.
	       </para>
	    </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-usepedestals</option> <replaceable>true|false</replaceable></term>
	    <listitem>
	       <para>
		  The value of this configuration parameter determines how
		  bit 12 of the control status register is initialized.
		  If <literal>true</literal> (default value), the bit is
		  set to one which enables pedestal subtraction from the input
		  signal.
	       </para>
	    </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-hires</option> <replaceable>true|false</replaceable></term>
	    <listitem>
	       <para>
		  The value of this configuration parameter determins how
		  bit 16 of the module control status register is
		  initialized.  If <literal>true</literal> (default value)
		  the bit is set to zero enabling high resolution mode.
		  If set <literal>false</literal> low resolution mode
		  is selected.
		  High resolution
		  mode provides 12 bits of data resolution while low
		  resolution mode provides only 10 bits of data resolution.
		  High resolution comes at a cost of an additional 1.5
		  microseconds of conversion time (5.5 microseconds compared
		  with 4 microseconds for low resolution).
	       </para>
	    </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-thresholds</option> <replaceable>threshold-list</replaceable></term>
	    <listitem>
	       <para>
		  Provides the channel threshold registers.  This is a Tcl
		  list of 16 integers in the range <literal>0-4095</literal>.
		  Data is read from a module only if the data value for the
		  module's low range is greater than the corresponding element
		  of the list.  The thresholds default to a list of 16 zeroes.
	       </para>
	    </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-lopedestals</option> <replaceable>pedestal-list</replaceable></term>
	    <listitem>
	       <para>
		  Provides a list of 16 integers (0-4095) which are subtracted
		  from the data values to  produce the low range value.
	       </para>
	    </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-midpedestals</option> <replaceable>pedestal-list</replaceable></term>
	    <listitem>
	       <para>
		  Same  as <option>-lopedestals</option> but the pedestals
		  are applied to the mid level conversion.
	       </para>
	    </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-hipedestal</option> <replaceable>pedestal-list</replaceable></term>
	    <listitem>
	       <para>
		  Same as <option>-lopedestals</option> but the pedestals
		  are applied to the low level conversion.
	       </para>
	    </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-rangemode</option> <replaceable>mode</replaceable></term>
	    <listitem>
	       <para>
		  Sets the module range mode.  The value for
		  <replaceable>mode</replaceable> must be one of the following:
		  <variablelist>
		     <varlistentry>
			<term><literal>all</literal></term>
			<listitem>
			   <para>
			      Conversions from all ranges appear in each event.
			      In this mode, some of the conversions will likely
			      have negative values.
			   </para>
			</listitem>
		     </varlistentry>
		     <varlistentry>
			<term><literal>auto</literal></term>
			<listitem>
			   <para>In this mode (default) only the  range
			      the conversion falls in will appear in the
			      data fromt he mdule.
			   </para>
			</listitem>
		     </varlistentry>
		     <varlistentry>
			<term><literal>sparse</literal></term>
			<listitem>
			   <para>Same as auto, but only data from channels
			      are above the channel thresholds set
			      via the <option>-thresholds</option> option
			      appear in the data from the module.
			   </para>
			</listitem>
		     </varlistentry>
			      
		  </variablelist>
	       </para>
	    </listitem>
	 </varlistentry>
	 
      </variablelist>
  </refsect1>
</refentry>

<refentry id="ccusb3-c257">
  <refmeta>
     <refentrytitle>c257</refentrytitle>
     <manvolnum>cccusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>c257</refname>
     <refpurpose>Manages the C257 scaler module</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
    <command>
c257 create <replaceable>name ?options...?</replaceable>
    </command>
    </cmdsynopsis>
    <cmdsynopsis>
    <command>
c257 config <replaceable>name ?options...?</replaceable>   
    </command>
    </cmdsynopsis>
   <cmdsynopsis>
   <command>
c257 cget <replaceable>name</replaceable>   
   </command>
   </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
	 <para>
	     This command ensemble allows you to create and configure
	     CAEN model C257 scaler modules.  The C257 is a 16 channel
	     scaler module.  Support is intended to be used with the
	     scaler stack.  The C257 is capable of cascading channels
	     to produce very wide counters, however this mode is not supported
	     by this release of the software limiting the width of each
	     scaler to 24 bits.  Thus, to use the module with this
	     software requires that all of the module jumpers be set to the
	     <literal>SINGLE</literal> position rather than to
	     <literal>CASCADE</literal>.
	 </para>
	 <para>
	     The <command>create</command> command
	     allows you to create a new module and assign a
	     <parameter>module-name</parameter> to it so that it can
	     be referred to in subsequent configuration commands.
	     You may optionally include configuration switch value pairs
	     on the <command>create</command> command line.
	 </para>
	 <para>
	     The <command>config</command> subcommand allows you to
	     set the configuration parameters for an existing module.
	     <parameter>module-name</parameter> is the name assigned to
	     that module whe it was created.
	 </para>
	 <para>
	     The <command>cget</command> command returns as its value
	     the module configuration as a Tcl list where each list element
	     is a sublist containing the name and value of a configuration
	     parameter.
	 </para>
	 <para>
	     Configuration options are name/value pairs.   The name
	     of a configuration option is sometimes called a
	     <firstterm>switch</firstterm> because it resembles the
	     command line switches of command shell commands.
	     For a full description of these options see OPTIONS below.
	 </para>
  </refsect1>
  <refsect1>
   <title>
      OPTIONS
   </title>
   <para>
      The module is configured via the following set of options.
   </para>
   <variablelist>
      <varlistentry>
	 <term><option>-slot</option> <replaceable>slotnumber</replaceable></term>
	 <listitem>
	    <para>
	       Specifies <parameter>slotnumber</parameter> as the CAMAC
	       crate slot in which the module  is inserted.  This must
	       be correct or else the software will not be able to
	       communicate with the module.
	    </para>
	 </listitem>
      </varlistentry>
      <varlistentry>
	  <term><option>-id</option> <replaceable>module-id</replaceable></term>
	  <listitem>
	      <para>
	       Specifies a module id for the unit.  If the
	       <option>-insertid</option> configuration parameter is
	       <literal>true</literal> this id is inserted prior to the
	       scaler data readout by the stack.  This option, and
	       <option>-insertid</option> should not be used in the scaler
	       stack and is intended as latent support for using the
	       scaler in an event stack (e.g. for supplying an event
	       timestamp).
	      </para>
	  </listitem>
      </varlistentry>
      <varlistentry>
	  <term><option>-insertid</option> <replaceable>true|false</replaceable></term>
	  <listitem>
	      <para>
	       If this parameter is <literal>true</literal> the value specified
	       by the <option>-id</option> option will be inserted in the data
	       buffer prior to the
	       data from this module.
	       This should be <literal>false</literal> (the default) if
	       the module is used in the scaler stack.
	      </para>
	      <para>
		  <option>-id</option> and <option>-insertid</option>
		  are intended as latent support for using the scaler module
		  in the event stack (e.g. to supply an event timestamp).
	      </para>
	  </listitem>
      </varlistentry>
      <varlistentry>
	  <term><option>-readinhibit</option> <replaceable>true | false</replaceable></term>
	  <listitem>
	      <para>
	       If this parameter is <literal>true</literal> (the default), the
	       CAMAC crate is held inhibited while the scaler module is
	       being read, and the module is read with an F2 Q-scan.
	       If <literal>false</literal> the module is read via 16
	       F0's directed at specific subaddresses followed by an
	       F9 to reset the counters.
	      </para>
	  </listitem>
      </varlistentry>
   </variablelist>
  </refsect1>

</refentry>
      <refentry id="ccusb3_ccusb_command">
        <refmeta>
           <refentrytitle id='ccusb3_ccusb_command_title'>ccusb (command)</refentrytitle>
           <manvolnum>3ccusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>ccusb (command)</refname>
           <refpurpose>Configure and read scalers from CC-USB module</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
          <command>
ccusb create name ?options?
          </command>
          </cmdsynopsis>
          <cmdsynopsis>
            <command>
ccusb config name ?options?
            </command>
          </cmdsynopsis>
          <cmdsynopsis>
            <command>
ccusb cget name
            </command>
            </cmdsynopsis>
        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            <command>ccusb</command> provides a readout module that allows you
            to configure many of the resources of the CCUSB as well as
            providing the capability of rerading the module internal scalers.
            Note that owing to the way the framework operates, you must include
            CCUSB modules in either the event or scaler stack in order to
            configure them, even if you don't intend to readout the scalers.
           </para>
           <para>
            For the configuration options see <literal>OPTIONS</literal>
            below.
           </para>
           <para>
            The resources you can control are the module internal gate and delay
            generators, the module internal scalers, the meaning of the
            Module NIM outputs and inputs and the meaning of the front panel
            LED displays.
           </para>
        </refsect1>
            <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
            <varlistentry>
                <term><option>-gdgasource</option></term>
                <listitem>
                    <para>
                        Defines the start of the module internal gate and delay
                        generator A.  This can be one of:
                        <literal>disabled, in1, in2, in3, event, eventend, usbtrigger, </literal>
                        or <literal>pulser</literal>.   Sections 3.3.6 and 3.3.7
                        of the CCUSB manual provide more information about the
                        Gate and delay generators.
                    </para>
                    <para>This option defaults to <literal>disabled</literal></para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-gdgbsource</option></term>
                <listitem>
                    <para>
                        Same as <option>-gdgasource</option>, however the
                        B gate and delay generator start is set.  The same set
                        of values accepted for <option>-gdgasource</option>
                        are accepted for this option.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-gdgawidth</option></term>
                <listitem>
                    <para>
                        Sets the output width of the A Gate and delay generator.
                        This can be a value from <literal>0</literal> through
                        <literal>0xffff</literal> and is in 10ns units.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-gdgbwidth</option></term>
                <listitem>
                    <para>
                        Sets the output width of the B gate and delay generator.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-gdgadelay</option></term>
                <listitem>
                    <para>
                        Sets the output delay on the A gdg output. This can be
                        in the range <literal>0</literal> through
                        <literal>0xffffffff</literal>.  It winds up setting both
                        a field in the
                        <literal>DGG_A</literal> register and the
                        <literal>DGG_Ext</literal> register.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-gdgbdelay</option></term>
                <listitem>
                    <para>
                        Sets the output delay on the B gdg output.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-red</option></term>
                <listitem>
                    <para>
                        Sets the signal that is reflected on the red LED on the
                        module front panel.  This is modified by the
                        <option>-redinvert</option> and <option>-redlatch</option>
                        options described below.
                    </para>
                    <para>
                        Legal values are
                        <literal>event, busy, usboutnotempty</literal> and
                        <literal>usbinnotfull</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-redinvert</option></term>
                <listitem>
                    <para>
                        This boolean parameter, if <literal>true</literal>
                        inverts the sense of the red front panel LED.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>-redlatch</term>
                <listitem>
                    <para>
                        If true, this boolean parameter latches the red front panel
                        LED on once the condition required to ligth it is met.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-green</option></term>
                <listitem>
                    <para>
                        This enumerated parmeter, together with
                        <option>-greeninvert</option> and <option>-greenlatch</option>,
                        determines when the green LED should be lit.  Valid values
                        are:
                        <literal>acquire, nimi1, nimi2, usbinnotemtpy</literal>
                        and <literal>usbtrigger</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-greeninvert</option></term>
                <listitem>
                    <para>
                        Inverts the sense of the green front panel LED.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-greenlatch</option></term>
                <listitem>
                    <para>
                        Latches the green LED on when the condition to light it
                        is met.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-yellow</option></term>
                <listitem>
                    <para>
                        Together with <option>-yellowinvert</option> and
                        <option>-yellowlatch</option> when the yellow front
                        panel LED is lit.  This can be one of the following values:
                        <literal>nimi1, nimi3, busy</literal> or
                        <literal>usbinfifionotempty</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-scalara</option></term>
                <listitem>
                    <para>
                        Defines what makes the A scaler count.  This can have
                        any of the following values:
                        <literal>disabled, nimi1, nimi2, nimi3, event, carryb, dgga</literal>
                        or <literal>dggb</literal>.  The <literal>carryb</literal>
                        increments the scaler when the B scale overflows.  This
                        provides the ability to make the A scaler the most significant
                        24 bits of a 48 bit scaler with the B scaler the least
                        significant 24 bits.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-scalerb</option></term>
                <listitem>
                    <para>
                        Defines what makes scaler B count.  This can have any of
                        the following values:
                         <literal>disabled, nimi1, nimi2, nimi3, event, carrya, dgga</literal>
                        or <literal>dggb</literal>. The <literal>carrya</literal>
                        increments the scaler when the A scale overflows.  This
                        provides the ability to make the B scaler the most significant
                        24 bits of a 48 bit scaler with the A scaler the least
                        significant 24 bits.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-out1</option></term>
                <listitem>
                    <para>
                        Together with <option>-out1invert</option>
                        and <option>-out1latch</option> determines the condition
                        that drives the O1 NIM output.  This can be one of the
                        following values:
                        <literal>busy, event, gdga</literal> or
                        <literal>gdgb</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-out1invert</option></term>
                <listitem>
                    <para>
                        Inverts the sense of the O1 NIM output.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-out1latch</option></term>
                <listitem>
                    <para>
                        Latches the state of O1 once the condition needed to
                        make it a logic true has been detected.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-out2</option></term>
                <listitem>
                    <para>
                        Together with <option>-out2invert</option> and
                        <option>-out2latch</option> determines when the
                        NIM O2 signal is asserted.  This can be one of the
                        following values:
                        <literal>acquire, event, gdga, </literal> or
                        <literal>gdgb</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-out2invert</option></term>
                <listitem>
                    <para>
                        Inverts the sense of the O2 NIM output.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-out2latch</option></term>
                <listitem>
                    <para>
                        Latches the NIM O2 state when the condition to assert
                        it has been met.  This condition is determined by
                        both <option>-out2</option> and
                        <option>-out2invert</option>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-out3</option></term>
                <listitem>
                    <para>
                        Together with <option>-out3invert</option>
                        and <option>-out3latch</option> determines the behavior
                        of the NIM O3 output.  This can be any of the following
                        values: <literal>busyend, busy, gdga, </literal> or
                        <literal>gdgb</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-o3invert</option></term>
                <listitem>
                    <para>
                        Inverts the condition that asserts O3.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-o3latch</option></term>
                <listitem>
                    <para>
                        Latches O3 in the asserted state when the condition
                        to assert it is met.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-readscalers</option></term>
                <listitem>
                    <para>
                        Boolean that when true enables the readout of the A and
                        B scalers in the stack this module is in.  The A scaler
                        is read first then the B scaler.  
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-incremental</option></term>
                <listitem>
                    <para>
                        This boolean parameters only matters when
                        <option>-readscalers</option> is true.  It causes
                        the scalers to be cleared once they have been read.
                        Note that in general some counts may be lost as there
                        is no way to atomically read and clear the scaler counters.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-bulktransfermode</option></term>
                <listitem>
                    <para>
                        This enum parameter provides user control over the 
                        criteria for a usb bulk transfers. This can be any
                        of the following: <literal>default, nbuffers, timeout</literal>.
                        The <literal>default</literal> provides the default behavior of 
                        timeout of 1 second. The nbuffers <literal>nbuffers</literal> 
                        allows the user to specify a number of data buffers to be 
                        bundled in a given USB bulk write. The user must specify the
                        <literal>-nbuffers2transfer</literal> options. The <literal>timeout</literal>
                        generate a packet end after the time specified for the timeout.
                        The user must specify the <literal>-bulktransfertimeout</literal>
                        option for this mode. 
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-nbuffers2transfer</option></term>
                <listitem>
                    <para>
                      This integer parameter specifies the number of buffers to 
                      bundle in a given usb bulk write. This must be a number between
                      1 and 255.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-bulktransfertimeout</option></term>
                <listitem>
                    <para>
                        Specifies the timeout value for a the usb bulk transfer mode.
                        Values are between 0 and 15 and specify the number of seconds 
                        beyond 1 second to timeout.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-bufferlength</option></term>
                <listitem>
                    <para>
                        Enum that specifies the buffer size used by the CCUSB. This can
                        be any of the following values: 4096, 2048, 1024, 512, 256, 128, 
                        64, singleevent
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>

      </refentry>

	 <refentry id="lccusb3-rs2228">
	   <refmeta>
	      <refentrytitle>lrs2228</refentrytitle>
	      <manvolnum>3ccusb</manvolnum>
	   </refmeta>
	   <refnamediv>
	      <refname>lrs2228</refname>
	      <refpurpose>Manages the LRS2228 TDC</refpurpose>
	   </refnamediv>
	   
	   <refsynopsisdiv>
	     <cmdsynopsis>
	     <command>
lrs2228 create <replaceable>module-name ?option...?</replaceable>
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
lrs2228 config <replaceable>module-name ?option...?</replaceable>
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
lrs2228 cget <replaceable>module-name</replaceable>
	     </command>
	     </cmdsynopsis>
	     
	   </refsynopsisdiv>
	   <refsect1>
	      <title>DESCRIPTION</title>
	      <para>
		  This command ensemble allows you to create and configure
		  LeCroy model LRS 2228 TDC modules.  The LRS 2228 is an eight
		  channel Time digitizer.
	      </para>
	      <para>
		  The <command>create</command> command
		  allows you to create a new module and assign a
		  <parameter>module-name</parameter> to it so that it can
		  be referred to in subsequent configuration commands.
		  You may optionally include configuration switch value pairs
		  on the <command>create</command> command line.
	      </para>
	      <para>
		  The <command>config</command> subcommand allows you to
		  set the configuration parameters for an existing module.
		  <parameter>module-name</parameter> is the name assigned to
		  that module whe it was created.
	      </para>
	      <para>
		  The <command>cget</command> command returns as its value
		  the module configuration as a Tcl list where each list element
		  is a sublist containing the name and value of a configuration
		  parameter.
	      </para>
	      <para>
		  Configuration options are name/value pairs.   The name
		  of a configuration option is sometimes called a
		  <firstterm>switch</firstterm> because it resembles the
		  command line switches of command shell commands.
		  For a full description of these options see OPTIONS below.
	      </para>
	   </refsect1>
	   <refsect1>
	    <title>OPTIONS</title>
	    <para>
	       The following options are recognized by the
	       <command>lrs2228 create</command> and
	       <command>lrs2228 config</command> commands.
	    </para>
	    <variablelist>
	       <varlistentry>
		  <term><option>-id</option> <replaceable>vsn</replaceable></term>
		  <listitem>
		     <para>
			Each module should be assigned a unique virtual
		        number.  If not assigned this will be 0.  The data packet
			returned by the module will be prefixed by the ID.
			This provides error checking for the code that wil be
			unpacking the raw data.
		     </para>
		  </listitem>
	       </varlistentry>
	       <varlistentry>
		  <term><option>-slot</option> <replaceable>camac-slot</replaceable></term>
		  <listitem>
		     <para>
			Provides the number of the slot in which the CAMAC
			module has been installed (<parameter>camac_slot</parameter>).
			This must match the physical slot the module has been
			stuffed in in order to ensure the proper module is
			initialized and reads.
		     </para>
		  </listitem>
	       </varlistentry>
	    </variablelist>
	   </refsect1>
	   <refsect1>
	      <title>EXAMPLES</title>
	      <para>
		  The following is an example of the <command>create</command>
		  command for the LRS2228:
	      </para>
	      <example>
	       <title>LRS2228 creation example</title>
	       <programlisting>
lrs2228 create tdc -slot 6 -id 4		  
	       </programlisting>
	      </example>
	   </refsect1>
	 </refentry>
	 <refentry id="ccusb3-lrs2249">
	   <refmeta>
	      <refentrytitle>lrs2249</refentrytitle>
	      <manvolnum>3ccusb</manvolnum>
	   </refmeta>
	   <refnamediv>
	      <refname>lrs2249</refname>
	      <refpurpose>Manage LeCroy 2249 QDC modules</refpurpose>
	   </refnamediv>
	   
	   <refsynopsisdiv>
	     <cmdsynopsis>
	     <command>
lrs2249 create <replaceable>module-name ?option...?</replaceable>
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
lrs2249 config <replaceable>module-name ?option...?</replaceable>
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
lrs2249 cget <replaceable>module-name</replaceable>
	     </command>
	     </cmdsynopsis>
	   </refsynopsisdiv>
	   <refsect1>
	      <title>DESCRIPTION</title>
	      <para>
	       The <command>lrs2249</command> command ensemble
	       allows you to read out
	       LeCroy model LRS 2249 modules.  The LRS 2249 is a charge integrating
	       ADC (QDC).
	      </para>
	      <para>
	       The <command>create</command> subcommand creates
	       a new module assigning it the <parameter>module-name</parameter>
	       you supply.  The <parameter>module-name</parameter> can be used
	       to refer to the module in future commands.  You may optionally
	       provide cofiguration information when creating the module.
	      </para>
	      <para>
	       The <command>config</command> subcommand configures an existing
	       module by providing configuration options for an existing
	       <parameter>module-name</parameter> (created via the
	       <command>create</command> subcommand).  Configuration options are
	       name/value pairs that are also sometimes called switches because
	       of their resemblance to shell command switches.  For a list of
	       the valid configuration options for the LRS 2249 module, see
	       the OPTIONS section below.
	      </para>
	      <para>
	       The <command>cget</command> subcommand returns the configuration
	       parameters for <parameter>module-name</parameter> as a Tcl list
	       of items.  Each item is itself a two element sublist containing
	       in order the name and value of a configuration option.
	      </para>
	   </refsect1>
	   <refsect1>
	    <title>OPTIONS</title>
	    <para>
	       The <command>lrs2249</command> command has the following configuration
	       options:
	    </para>
	    <variablelist>
	       <varlistentry>
		  <term><option>-id</option> <replaceable>vsn</replaceable></term>
		  <listitem>
		     <para>
			Sets the module virtual slot number to <parameter>vsn</parameter>.
			The virtual slot number prefixes the data packet read from this
			module and is used by SpecTcl as a check on the validity
			the event.  Each module should have a unique <parameter>vsn</parameter>.
			If the <option>-id</option> option does not set the virtual
			slot it defaults to 0.
		     </para>
		  </listitem>
	       </varlistentry>
	       <varlistentry>
		  <term><option>-slot</option> <replaceable>slot</replaceable></term>
		  <listitem>
		     <para>
			Provides the module <parameter>slot</parameter>.  This
			parameter must match the number of the slot in the
			CAMAC crate in which the module is installed.
		     </para>
		  </listitem>
	       </varlistentry>
	    </variablelist>
	       
	   </refsect1>
        </refentry>
	 <refentry id="ccusb3-lrs2551">
	   <refmeta>
	      <refentrytitle>lrs2551</refentrytitle>
	      <manvolnum>3ccusb</manvolnum>
	   </refmeta>
	   <refnamediv>
	      <refname>lrs2551</refname>
	      <refpurpose>Manage LRS 2551 modules</refpurpose>
	   </refnamediv>
	   
	   <refsynopsisdiv>
	     <cmdsynopsis>
	     <command>
lrs2551 create <replaceable>module-name ?options...?</replaceable> 
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
lrs2551 config <replaceable>module-name ?options...?</replaceable> 	     
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
lrs2551 cget <replaceable>module-name</replaceable> 	     
	     </command>
	     </cmdsynopsis>
	   </refsynopsisdiv>
	   <refsect1>
	      <title>DESCRIPTION</title>
	      <para>
	       The <command>lrs2551</command> command allows you to create and
	       configure LeCroy LRS 2551 scaler modules.  The LRS 2551 is a
	       12 channel scaler.  While it is normally read in the periodic
	       scaler stack, it is also possible to read it in the event
	       stack when properly configured.
	      </para>
	      <para>
	       The <command>create</command> subcommand creates a new module
	       assigning it the name <parameter>module-name</parameter>.
	       <parameter>module-name</parameter> should be used to refer
	       to the module in future commands. Optional configuration data
	       can also be appended to the <command>create</command> subcommand.
	      </para>
	      <para>
	       The <command>config</command> subcommand configures an existing
	       <parameter>module-name</parameter>.  The configuration items are
	       name value pairs.  See OPTIONS below for more information about
	       the options supported by the <command>lrs2551</command> command.
	      </para>
	      <para>
	       The <command>cget</command> subcommand returns the current
	       module configuration.  The configuration is returned as a Tcl list.
	       Each element of the list is a two element sublist that contains
	       the configuration name and value in that order.
	      </para>
	   </refsect1>
	   <refsect1>
	    <title>OPTIONS</title>
	    <para>
	        The <command>lrs2551</command> command supports the following
		configuration options:
	    </para>
	    <variablelist>
	       <varlistentry>
		  <term><option>-cumulative</option> <replaceable>on|off</replaceable></term>
		  <listitem>
		     <para>
			If <option>-cumulative</option> is false (default),
			the scaler module is cleared after each readout providing
			the counts between each readout as the value of each
			channel. This shoulid be false when used with the NSCLDAQ
			scaler display program in the scaler stack.
		     </para>
		  </listitem>
	       </varlistentry>
	       <varlistentry>
		  <term><option>-id</option> <replaceable>vsn</replaceable></term>
		  <listitem>
		     <para>
			Supplies the virtual slot number; <replaceable>vsn</replaceable>
			for the module.  This only needs to be supplied if the
			module is going to be read in the event stack.
			Note that currently unpacking scaler data from the event
			stack is not supported.
		     </para>
		  </listitem>
	       </varlistentry>
	       <varlistentry>
		  <term><option>-insertid</option> <replaceable>true|false</replaceable></term>
		  <listitem>
		     <para>
			If <literal>true</literal> (the default is <literal>false</literal>),
			the virtual slot number set by the <option>-id</option>
			configuration value is inserted in the data block from
			the scaler.  If <literal>false</literal> it is not.
			If used with the NSCLDAQ Scaler display in the scaler stack,
			this should be <literal>false</literal>.
		     </para>
		  </listitem>
	       </varlistentry>
	       <varlistentry>
		  <term><option>-slot</option> <replaceable>slot</replaceable></term>
		  <listitem>
		     <para>
			Sets the <parameter>slot</parameter> configuration.
			When installed in the CAMAC crate, the module should
			be inserted in the <parameter>slot</parameter> specified
			by this option.
		     </para>
		  </listitem>
		  </varlistentry>
	    </variablelist>
	    
	   </refsect1>
	   <refsect1>
	      <title>EXAMPLES</title>
	      <para>
	       This example creates an LRS 2551 scaler:
	      </para>
	      <example>
	       <title>The lrs2551 command</title>
	       <programlisting>
lrs2551 create counters -slot 4
	       </programlisting>
	      </example>
	   </refsect1> 
</refentry>
<refentry id="ccusb3-marker">
  <refentryinfo>
    <author>
            <personname>
                    <firstname>Ron</firstname>
                    <surname>Fox</surname>
            </personname>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='ccusb3-marker-title'>marker</refentrytitle>
     <manvolnum>ccusb3</manvolnum>
     <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>marker</refname>
     <refpurpose>Create/manipulate marker instances</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
        <command>
marker create <replaceable>name ?options?</replaceable>
   </command>
    </cmdsynopsis>
     <cmdsynopsis>
         <command>
marker config <replaceable>name options...</replaceable>
         </command>
     </cmdsynopsis>
     <cmdsynopsis>
         <command>
marker cget <replaceable>name</replaceable>
         </command>
     </cmdsynopsis>
     
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
         Markers are CCUSB stack objects that insert a constant
         16 bit value into the data. The <command>marker</command>
         command allows you to create and configure marker objects.
         As with all <filename>daqconfig.tcl</filename> objects
         the marker must be put in a stack (event or scaler) to
         contribute data to the output stream.
     </para>
  </refsect1>
  <refsect1>
     <title>
        OPTIONS
     </title>
     <variablelist>
         <varlistentry>
             <term><option>-value</option> <replaceable>uint16</replaceable></term>
             <listitem>
                 <para>
                     Defines the unsigned integer 16 value that will be
                     inserted into the buffer when the
                     marker is in a triggered stack.
                 </para>
             </listitem>
         </varlistentry>
         
     </variablelist>
  </refsect1>

</refentry>

         <refentry id="ccusb3-ph7xxx">
           <refmeta>
              <refentrytitle>ph7xxx</refentrytitle>
              <manvolnum>3ccusb</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>ph7xxx</refname>
              <refpurpose>Define Phillips ADC/TDC/QDC modules</refpurpose>
           </refnamediv>
           
           <refsynopsisdiv>
             <cmdsynopsis>
         	<command>
ph7xxx create <replaceable>name</replaceable> <optional>?option value ...?</optional>         	
         	</command>
             </cmdsynopsis>
                 <cmdsynopsis>
                     <command>
ph7xxx config <replaceable>name  option value...</replaceable>
                     </command>
                 </cmdsynopsis>
                  <cmdsynopsis>
                      <command>
ph7xxx cget <replaceable>name</replaceable>
                      </command>
                  </cmdsynopsis>
                
           </refsynopsisdiv>
           <refsect1>
              <title>DESCRIPTION</title>
              <para>
               Creates, configures and interrogates the configuration of Philips
               CAMAC digitizers.
              </para>
              <para>
               The <command>create</command> command creates
               a new digitizer <replaceable>name</replaceable> configuration.
               The <replaceable>name</replaceable> parameter must be unique.
               The optional <optional>option value</optional> pairs that follow
               specify the configuration for that module.  This configuration
               can  be supplemented or overridden by subsequent
               <command>config</command> operations on the module.
              </para>
               <para>
                  The <command>config</command> subcommand configures the existing
                  module <replaceable>name</replaceable>.  The remainder of the
                  command line are option value pairs described in the section
                  OPTIONS below.  The module <replaceable>name</replaceable> must
                  have already been created via the <command>create</command>
                  subcommand.  Note that configuration options are processed
                  from left to right, if a configuration option appears more than
                  once, the last instance takes effect.
               </para>
               <para>
                  The <command>cget</command> subcommand returns the configuration
                  of the module.  This can be used in more advanced scripts to
                  analyze the configuration of the system.  The configuration of
                  a module <replaceable>name</replaceable> is returned as a
                  properly formatted Tcl list.  Each element of the list is itself
                  a pair (a two element sublist).  The first element of each pair
                  is the configuration parameter name, the second element the
                  value, which may itself be  a list (e.g. for the
                  <literal>-llt</literal> option.
               </para>
           </refsect1>
           <refsect1>
              <title>
         	OPTIONS
              </title>
              <variablelist>
         	<varlistentry>
         	    <term><option>-slot</option> <replaceable>slotnumber</replaceable></term>
         	    <listitem>
         		<para>
                           This option configures the slot in which the module
                           will be installed.  All modules must be in unique slots,
                           although that is not verified by the configuration manager.
                           The slot must be an integer number from one through 23
                           (slot 24/25 holds the CAMAC crate controller).
         		</para>
                        <para>
                           The default value for this parameter is illegal (0),
                           so you must specify this parameter.
                        </para>
         	    </listitem>
         	</varlistentry>
		<varlistentry>
		     <term><option>-id</option> <replaceable>vsn</replaceable></term>
		     <listitem>
			<para>
			   Each module has an identifier which, for historical
			   reasons is called a <firstterm>virtual slot number</firstterm>,
			   or <firstterm>vsn</firstterm>.  To maximize the decode
			   error detection the virtual slot numbers for each
			   module should be unique.  This option allows you
			   to set the virtual slot number for the module.
			</para>
		        <para>
			   If the <option>-id</option> is not supplied, it defaults
			   to zero.
			</para>
		     </listitem>
		</varlistentry>
                <varlistentry>
                  <term><option>-sparse</option> <replaceable>bool</replaceable></term>
                  <listitem>
                     <para>
                        If the value of this configuration is true, the module
                        is read in sparse readout mode (A Q-Stop of F4@A0).
                        SpecTcl expects this to be true and that is also the default
                        value.
                     </para>
                     <para>
                        The values
                        <literal>true</literal>,
                        <literal>yes</literal>,
                        <literal>1</literal>,
                        <literal>on</literal> and
                        <literal>enabled</literal> are all recognized as true
                        values while the values
                        <literal>false</literal>,
                        <literal>no</literal>,
                        <literal>0</literal>,
                        <literal>off</literal>, and
                        <literal>disabled</literal> are all recognized as false
                        values.
                     </para>
                  </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-readhits</option> <replaceable>bool</replaceable></term>
                     <listitem>
                        <para>
                           If the value of this configuration is true,the module's
                           hit register is read prior to the channels (F6@A1).
                           SpecTcl requires this parameter to be true, and that's the
                           default value.
                        </para>
                        <para>
                           SpecTcl will use this value to determine the number of
                           digitizer data words that follow for this module.
                        </para>
                        <para>
                        The values
                        <literal>true</literal>,
                        <literal>yes</literal>,
                        <literal>1</literal>,
                        <literal>on</literal> and
                        <literal>enabled</literal> are all recognized as true
                        values while the values
                        <literal>false</literal>,
                        <literal>no</literal>,
                        <literal>0</literal>,
                        <literal>off</literal>, and
                        <literal>disabled</literal> are all recognized as false
                        values.
                     </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-pedestals</option> <replaceable>int[16]</replaceable></term>
                     <listitem>
                        <para>
                           Supplies the pedestals for each channel.  This must be
                           a 16 element list of integers.  These values are
                           initialized to zero.  Note that the pedestals are
                           ignored unless <option>-usepdestals</option> is true.
                        </para>
                        <para>
                           The best way to construct this list of pedestals is to
                           use the Tcl <command>list</command> command for example:
                        </para>
                        <example>
                           <title>Using the <command>list</command> command to
                                  construct pedestals</title>
                           <programlisting>
                           <command>
ph7xxx config someadc -pedestals [list 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20]
                           </command>
                           </programlisting>
                        </example>
                        <para>
                           Note that pedestals can be specified as decimal values
                           (as shown in the example above), hexadecimal value
                           by preceding a number with the text <literal>0x</literal>
                           or octal by preceding the number with a leading <literal>0</literal>.
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-llt</option> <replaceable>int[16]</replaceable></term>
                     <listitem>
                        <para>
                           Supplies the low level thresholds for each channel.  This must
                           be a 16 element list of integers.  These values are initialized
                           to zero.  Note that the low level thresholds are ignored unless
                           <option>-usellt</option> is true.
                        </para>
                        <para>
                           See the description of <option>-pedestals</option> above
                           for more information about how to construct this list.
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-hlt</option> <replaceable>int[16]</replaceable></term>
                     <listitem>
                        <para>
                           Supplies the high level thresholds for each channel. This
                           must be a 16 element list of integers.  These values
                           are initialized to full scale (<literal>4095</literal>).
                           The high level thresholds are ignored unless the
                           parameter <option>-usehlt</option> is true.
                        </para>
                        <para>
                           See the description of <option>-pedestals</option>
                           above for more information about how to construct
                           this list.
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-usellt</option> <replaceable>boolean</replaceable></term>
                     <listitem>
                        <para>
                           Enables or disables the low level threshold (sets or clears
                           the <literal>LT Enable</literal> bit in the control
                           register).  This is useful if
                           <option>-llt</option> has been used to program
                           low level thresholds and <option>-sparse</option>
                           has been set to true.
                       </para>
                       <para>
                        The values
                        <literal>true</literal>,
                        <literal>yes</literal>,
                        <literal>1</literal>,
                        <literal>on</literal> and
                        <literal>enabled</literal> are all recognized as true
                        values while the values
                        <literal>false</literal>,
                        <literal>no</literal>,
                        <literal>0</literal>,
                        <literal>off</literal>, and
                        <literal>disabled</literal> are all recognized as false
                        values.
                     </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-usehlt</option> <replaceable>bool</replaceable></term>
                     <listitem>
                        <para>
                           Enables or disables the high level threshold (sets or
                           clears the <literal>UT Enable</literal> bit in the
                           module control register).  This is useful if
                           <option>-hlt</option> has been used to set the high
                           level thresholds and <option>-sparse</option> has
                           been set to true.
                        </para>
                       <para>
                        The values
                        <literal>true</literal>,
                        <literal>yes</literal>,
                        <literal>1</literal>,
                        <literal>on</literal> and
                        <literal>enabled</literal> are all recognized as true
                        values while the values
                        <literal>false</literal>,
                        <literal>no</literal>, 
                        <literal>0</literal>,
                        <literal>off</literal>, and
                        <literal>disabled</literal> are all recognized as false
                        values.
                     </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-usepedestals</option> <replaceable>bool</replaceable></term>
                     <listitem>
                        <para>
                           Enables or disables per chanel pedestal subtraction.
                           This is most useful when <option>-pedestals</option>
                           has been used to program a set of pedestals into
                           the module.
                        </para>
                       <para>
                        The values
                        <literal>true</literal>,
                        <literal>yes</literal>,
                        <literal>1</literal>,
                        <literal>on</literal> and
                        <literal>enabled</literal> are all recognized as true
                        values while the values
                        <literal>false</literal>,
                        <literal>no</literal>,
                        <literal>0</literal>,
                        <literal>off</literal>, and
                        <literal>disabled</literal> are all recognized as false
                        values.
                     </para>
                     </listitem>
                  </varlistentry>
              </variablelist>
           </refsect1>
           <refsect1>
              <title>EXAMPLES</title>
              <para>
                  The example below creates a Phillips module named
                  <literal>adc1</literal> and programs all of the configuration
                  options.  Note that in many cases you won't need to do this
                  (e.g. for ADC's the high level thresholds usually can be left
                  up at <literal>4095</literal>
              </para>
              <example>
                  <title>Sample <command>ph7xxx</command> commands</title>
                  <programlisting>
ph7xxx create adc1 -slot 5
ph7xxx config adc1 -sparse enabled -readhits true -usellt true -usehlt false
ph7xxx config adc1 -usepedestals enabled
ph7xxx config adc1 -pedestals [list 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 ]
ph7xxx config adc1 -llt [list 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10]
ph7xxx config adc1 -hlt [list 3000 3000 3000 3000 3000 3000 3000 \
                              3000 3000 3000 3000 3000 3000 3000 3000 3000 ]
                  </programlisting>
              </example>
           </refsect1>

         </refentry>
         <refentry id="ccusb3-stack">
           <refmeta>
              <refentrytitle>stack</refentrytitle>
              <manvolnum>3ccusb</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>stack</refname>
              <refpurpose>Create and configure CC-USB stacks.</refpurpose>
           </refnamediv>
           
           <refsynopsisdiv>
             <cmdsynopsis>
         	<command>
stack create <replaceable>name</replaceable>

         	</command>
             </cmdsynopsis>
               <cmdsynopsis>
                   <command>
stack config <replaceable>name option value...</replaceable>
                   </command>
               </cmdsynopsis>
            <cmdsynopsis>
                <command>
stack cget <replaceable>name</replaceable>
                </command>
            </cmdsynopsis>
           
           </refsynopsisdiv>
           <refsect1>
              <title>DESCRIPTION</title>
              <para>
         	Creates and configures CC-USB stacks.  Stacks are lists of
                CAMAC operations that are loaded into the CC-USB for autonomous
                execution.  There are two types of stacks; an
                <firstterm>event</firstterm> stack that is executed when
                a front panel trigger or a specified LAM is detected, and
                a <firstterm>scaler</firstterm> stack that can be periodically
                triggered.
              </para>
               <para>
                  Stacks contain lists of modules.  The modules themselves
                  determine the set of readout instructions that make up each
                  stack.  
               </para>
               <para>
                  The <command>create</command> subcommand creates a new stack.
                  The name of the new stack is <replaceable>name</replaceable>.
                  This <replaceable>name</replaceable> will be used to refer to
                  this stack in future configuration commands.
               </para>
               <para>
                  The <command>config</command> subcommand configures the stack
                  <replaceable>name</replaceable>.  The configuration is
                  specified as a set of option value pairs.  The options
                  are described in the section OPTIONS below.
               </para>
               <para>
                  The <command>cget</command> subcommand returns the configuration
                  of the stack <replaceable>name</replaceable> as its command value.
                  This subcommand is intended for advanced applications that may
                  analyze the configuration of the stack.  The configuration is
                  returned as a properly formatted Tcl list.  Each element of the list
                  is itself a two element sublist (pair).  The first element of each
                  pair is the name of a configuration parameter the second, that
                  configuration parameter's value.  Note that the value may itself
                  be a list.
               </para>
           </refsect1>
           <refsect1>
              <title>
         	OPTIONS
              </title>
               <para>
                  Options are used to configure the stack.  Each option has associated
                  with it a keyword that selects it and a value.  The option s supported
                  by the <command>stack</command> command are subdivided into three groups:
                  <orderedlist>
                     <listitem>
                        <para>Options used for both event and scaler stacks.</para>
                     </listitem>
                     <listitem>
                        <para>Options that are only used for event stacks and are ignored
                           for scaler stacks</para>
                     </listitem>
                     <listitem>
                        <para>Options that are only used for scaler stacks, and are
                           ignored for event stacks.
                        </para>
                     </listitem>
                  </orderedlist>
               </para>
               <formalpara>
                  <title>Options for all stack types</title>
                  <para>
                  </para>
               </formalpara>
               <variablelist>
                  <varlistentry>
         	     <term><option>-type</option> <replaceable>stack-type</replaceable></term>
         	     <listitem>
         		<para>
                           Defines the type of stack that is being used.  This
                           can be one of the keywords
                           <literal>event</literal> for event stacks or
                           <literal>scaler</literal> for scaler stacks.
                           The CC-USB only supports one scaler and one event stack.
                           The current version of the configuration engine allows
                           you to create more than one of each stack. In that case,
                           it is not well defined which stacks are actually loaded.
         		</para>
                        <para>
                           The default <option>-type</option> is <literal>event</literal>.
                        </para>
         	     </listitem>
                  </varlistentry>
		  <varlistentry>
		    <term><option>-incremental</option> <replaceable>bool</replaceable></term>
		    <listitem>
		      <para>
			If <literal>true</literal> (the default), scaler ring items are marked as
			incremental.  If not they are marked as non-incremental.
		      </para>
		    </listitem>
		  </varlistentry>
                  <varlistentry>
                     <term><option>-modules</option> <replaceable>module-list</replaceable></term>
                     <listitem>
                        <para>
                           This option defines the set of modules that are added
                           to the stack.  <replaceable>module-list</replaceable> is a
                           properly formatted Tcl list of names of modules
                           (ph7xxx's in this implementation) that will be read
                           by this stack.  See the EXAMPLES section below
                           for more information.
                        </para>
                     </listitem>
                  </varlistentry>
               </variablelist>
               <formalpara>
                  <title>Event stack options</title>
                  <para>
                  </para>
               </formalpara>
               <variablelist>
                  <varlistentry>
                     <term><option>-lams</option>   <replaceable>mask</replaceable></term>
                     <listitem>
                        <para>
                           Specifies the mask of LAMs that can trigger the list.
                           I suggest leaving this value at zero, and deriving a
                           trigger signal for the NIM IN1 input as the readout
                           trigger.
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-lamtimeout</option> <replaceable>microseconds</replaceable></term>
                     <listitem>
                        <para>
                           The <command>ph7xxx</command> command delays the read
                           of the module until it is signalling a LAM.
                           <replaceable>microseconds</replaceable> specifies the
                           total number of microseconds the stack should wait for
                           this LAM.  The value should be on the order of the
                           conversion time of the module.  Defaults to zero.
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-delay</option> <replaceable>microseconds</replaceable></term>
                     <listitem>
                        <para>
                           Delays the execution of the stack for <replaceable>microseconds</replaceable>
                           microseconds after the trigger condition is detected.
                           This can be used to ensure the digitization hardware
                           has sufficient time to complete its digitization prior
                           to stack execution. Defaults to zero.
                        </para>
                     </listitem>
                  </varlistentry>
               </variablelist>
               <formalpara>
                  <title>Options only available for scalers stacks</title>
                  <para>
                     The options below are only legal for stacks of
                     <option>-type</option> <literal>scaler</literal>
                  </para>
               </formalpara>
               <variablelist>
                  <varlistentry>
                     <term><option>-period</option> <replaceable>seconds</replaceable></term>
                     <listitem>
                        <para>
                           Number of seconds between execution of the scaler stack.
                           This defaults to 2.
                        </para>
                     </listitem>
                  </varlistentry>
               </variablelist>
            
           </refsect1>
           <refsect1>
               <title>EXAMPLES</title>
               <para>
                  The example below extends the example in the
                  <xref linkend="ccusb3-ph7xxx" /> command reference
                  reading the defined modules in an event stack:
               </para>
               <example>
                  <title>Example of the <command>stack</command> command.</title>
                  <programlisting>
ph7xxx create adc1 -slot 6
ph7xxx create adc2 -slot 7                                  <co id="defmodules" />


stack create events                                         <co id="stackdef" />
stack config events -type event -modules [list adc1 adc2]   <co id="typemods" />
stack config events -delay 10 -lamtimeout 8                 <co id ="timing" />
                  </programlisting>
               </example>
               <calloutlist>
                  <callout arearefs="defmodules">
                     <para>
                        These two lines define the modules that we will be using
                        for the experimental setup.
                     </para>
                  </callout>
                  <callout arearefs="stackdef">
                     <para>
                        Creates a new stack called <literal>events</literal>
                        In subsequent lines I'm going to configure this stack
                        to handle the event trigger.
                     </para>
                  </callout>
                  <callout arearefs="typemods">
                     <para>
                        The stack is configured to be the event stack, and
                        the two modules we created <literal>adc1</literal>
                        and <literal>adc2</literal> are added to the stack
                        in that order.  When the stack is loaded, it will
                        contain the instructions to read out these two modules.
                     </para>
                  </callout>
                  <callout arearefs="timing">
                     <para>
                        Configures the stack so that the CC-USB will start
                        stack execution 10 microseconds after the IN1 trigger.
                        Stack instructions that wait for a lam on their target
                        module will wait at most 8 microseconds.  Since the
                        <option>-lams</option> option is left to default to zero,
                        CAMAC lams will not be able to trigger the list.
                     </para>
                  </callout>
               </calloutlist>
               
                  
           </refsect1>
         </refentry>
      <refentry id="ccusb3-Module">
        <refmeta>
           <refentrytitle>Module</refentrytitle>
           <manvolnum>3ccusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>Module</refname>
           <refpurpose>Create and manipulate slow control device instances</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
         <command>
Module create <replaceable>type name</replaceable>
          </command>
          </cmdsynopsis>
          <cmdsynopsis>
            <command>
Module config <replaceable>name options....</replaceable>
            </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
Module cget <replaceable>name</replaceable>
                </command>
            </cmdsynopsis>
        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            The Module command creates and manipulates instances of slow
            control devices.  It must appear in the control configuration script
            rather than the daq configuration script.  The <command>create</command>
            subcommand creates an object with the specified <parameter>type</parameter>
            and <parameter>name</parameter>.  Currently the following device types
            are supported:
            <variablelist>
                <varlistentry>
                    <term>caen894</term>
                    <listitem>
                        <para>
                            A CAEN C894 16 channel leading edge discriminator.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>ph7106</term>
                    <listitem>
                        <para>
                            A Phillips Ph7106 leading edge discriminator.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </para>
           <para>
            The <command>config</command> subcommand configures the named module.
            In most cases the configuration of a slow control module is pretty
            minimal as the assumption is that there is a slow control
            panel associated with the device.  Typical configuration consists
            of a <option>-slot</option> which provides the CAMAC slot in which
            the module is installed and a <option>-file</option> which provides
            the initial settings of the device (the file is usually maintained
            by the control panel).  Note that the <literal>ph7106</literal>
            currently only supports the <option>-slot</option> option.
            (This code was contributed by Lakshmi SoundaraPandian of the
            University of Massachussets Lowell).
           </para>
           <para>
                The <command>cget</command> subcommand retrieves the
                configuration of the named modules as a
                well formatted Tcl list of name
                value pairs where the name is an option name and the value is
                the value of that option. e.g.
                <informalexample>
                    <programlisting>
{ {-slot 5} {-file /user/fox/config.camac/led.settings}}
                    </programlisting>
                </informalexample>
            </para>
        </refsect1>
        </refentry>

        <refentry id="ccusb3-CamacCrate">
          <refmeta>
            <refentrytitle>CamacCrate</refentrytitle>
            <manvolnum>3ccusb</manvolnum>
          </refmeta>

          <refnamediv>
            <refname>CamacCrate</refname>
            <refpurpose>group modules into a crate</refpurpose>
          </refnamediv>

          <refsynopsisdiv>
            <cmdsynopsis>
              <command>
                CamacCrate create <replaceable>name base</replaceable>
              </command>
            </cmdsynopsis>
            
            <cmdsynopsis>
              <command>
                CamacCrate config <replaceable>name option value ...</replaceable>
              </command>
            </cmdsynopsis>
        
            <cmdsynopsis>
              <command>
                CamacCrate cget <replaceable>name</replaceable>
              </command>
            </cmdsynopsis>

          </refsynopsisdiv>
        
        <refsect1>
            <title>DESCRIPTION</title>
     <para>
The CamacCrate command defines a container-type driver that holds a registry of modules. It is designed to make it trivial to convert a daqconfig.tcl script that sets up a crate running on a CBD8210 branch to one being controlled by a CC-USB. Contrary to the CBDCamacCrate, this does not need to be registered to a CAMAC branch and can instead be loaded directly into a stack.
     </para>

  <para>
At the start of every run, the initialization procedures will be called for all of the registered modules in the order the modules were listed.
  </para>

  <para>
At the end of every run, the end of run procedures will be called for all of the registered module in the order the modules were listed.
  </para>

  <para>
During stack execution initiated by an event trigger, the event-wise procedures of each of the registered modules will be executed in the order that they were listed.
  </para>

  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	    <varlistentry>
	      <term><command>-crate</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
        Specifies the crate index. Default is 0.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-modules</command> <replaceable>list</replaceable></term>
	      <listitem>
		    <para>
        Specify a proper tcl list of modules to be registered with this crate. these must all be compatible with a CC-USB controller. The order in which modules are listed will be the order in which each module is serviced. A single module can be registered to multiple CamacCrates. Default is an empty list. 
		    </para>
	       </listitem>
	    </varlistentry>
  </variablelist>

  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
          <title>A simple crate setup containing a single scaler</title>
         <programlisting>
LeCroy2551 create sclr -slot 10

# Create a crate to stick it in
CamacCrate create crate0 -crate 1
CamacCrate config crate0 -modules [list sclr]
         </programlisting>
      </example>
      <para>
       Defines a camac crate with a single LeCroy2551 to operate on with a CBD8210 branch driver. This crate is labeled with index 1 on the branch and the branch is labeled with index 0.
      </para>
  </refsect1>
</refentry>

<refentry id="ccusb3-LeCroy4300B">
  <refmeta>
     <refentrytitle>LeCroy4300B</refentrytitle>
     <manvolnum>3ccusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>LeCroy4300B</refname>
     <refpurpose>control a LeCroy 4300B FERA</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
LeCroy4300B create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
    <command>
LeCroy4300B config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
LeCroy4300B cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
  <para>
  This provides control over a LeCroy 4300B FERA that lives in a crate controlled by a CC-USB. This is the counterpart to the CBDLeCroy4300B driver that is functional in the VMUSBReadout framework. The currently described driver needn't be registered to a CamacCrate to function. 
  </para>
  <para>
There are a number of options that are provided to ultimately control the command register of the device. The command register is what establishes how the FERA will read out its data. Two options must be specified to operate the device, -pedestals and slot. If either of these are not specified, the initialization of the module will fail. 
  </para>

  <para>
  During initialization the following operations occur:
    <orderedlist>
     <listitem> 
        <para> Clear the module </para>
     </listitem>
     <listitem>
      <para> Write all pedestals passed to the -pedestal option </para>
     </listitem>
     <listitem>
      <para> Compute the command register from user define options and write it to the module </para>
     </listitem>
  </orderedlist>
  </para>

  <para>
  At the end of the run, no actions are taken. 
  </para>

  <para>
  During stack execution initiated by an event trigger, this driver will operate based on the following logic:
  <programlisting>

  if "-camacclear" is true
      Clear the module

  </programlisting>
  
  </para>
  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	    <varlistentry>
	      <term><command>-slot</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
        Specifies the slot of the CAMAC crate the target module is occupying. DEFAULT is 1.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-pedestals</command> <replaceable>list</replaceable></term>
	      <listitem>
		    <para>
          A proper tcl list of 16 integer parameters defining the pedestals for each of the 16 channels. The first element of the list will configure the first channel of the FERA, the second element will configure the second channel, and so on. REQUIRED
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-vsn</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
The virtual station number to associate with the target device. This will be included in the header if data compression is enabled. 
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-eclpedsub</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
        	Specify whether to use pedestal subtraction in ECL port readout (aka. EPS). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-eclcompression</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specify whether to enable a data compression cycle before ECL port readout (aka. ECE). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-eclenable</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
        	Specify whether to enable ECL port readout (aka. EEN). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-camacpedsub</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specify whether to use pedestal subtraction in CAMAC readout (aka. CPS). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-camaccompression</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specify whether to enable a data compression cycle before CAMAC readout (aka. CCE). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-camacseqrdo</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specify whether to configure the device for sequential readout in CAMAC (aka. CSR). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-camaclam</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specify whether the allow the device to emit a LAM when data is available to be read (aka. CLE). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-overflowsuppress</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specify whether to suppress output of overflows as well as zeros (aka. OAFS). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
   </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
          <title>A simple setup of one FERA</title>
         <programlisting>
LeCroy4300B create fera -slot 10 
LeCroy4300B config fera -pedestals \
          [list 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]
LeCroy4300B config fera -eclenable on
LeCroy4300B config fera -eclpedsub on
LeCroy4300B config fera -eclcompression on
LeCroy4300B config fera -camacclear off
         </programlisting>
      </example>
      <para>
        Sets up a LeCroy 4300B module with all pedestals 1 to be read out by the ECL ports. The FERA resides in slot 10.
      </para>
  </refsect1>
</refentry>

<refentry id="ccusb3-LeCroy4434">
  <refmeta>
     <refentrytitle>LeCroy4434</refentrytitle>
     <manvolnum>3ccusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>LeCroy4434</refname>
     <refpurpose>control a LeCroy 4434 Scaler</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
LeCroy4434 create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
      <command>
LeCroy4434 config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
LeCroy4434 cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
    <para>
The LeCroy4434 is intended to control a LeCroy 4434 scaler situated on in a crate controlled by a CC-USB. It is the counterpart to the CBDLeCroy4434 module that is functional in the VMUSBReadout framework. 
  </para>

  <para>
The CBDLeCroy4434 can be registered directly to a stack or to a CamacCrate. 
  </para>

  <para>
  During initialization, all scalers are cleared and the auxiliary bus is disabled. 
  </para>

  <para>
  At the end of the run, no actions are taken. 
  </para>

  <para>
  During stack execution initiated by an event trigger, this driver will operate based on the following logic:
  <programlisting>

  Read all channels
  if "-incremental" is true
      Clear the module
  </programlisting>

  Just as a note, the latch and the clear are not atomic.
  </para>
  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	    <varlistentry>
	      <term><command>-slot</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
        Specifies the slot of the CAMAC crate the target module is occupying. Default is 1.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-incremental</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specifies whether to clear the scalers on each event after latching them. Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
   </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
         <title>A simple setup of one scaler</title>
         <programlisting>
LeCroy4434 create sclr -slot 10
         </programlisting>
      </example>
      <para>
        Sets up a LeCroy 4434 scaler module in slot 10.
      </para>
  </refsect1>
</refentry>
  
<refentry id="ccusb3-LeCroy2551">
  <refmeta>
     <refentrytitle>LeCroy2551</refentrytitle>
     <manvolnum>3ccusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>LeCroy2551</refname>
     <refpurpose>control a LeCroy 2551 Scaler</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
LeCroy2551 create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
      <command>
LeCroy2551 config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
LeCroy2551 cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
    <para>
The LeCroy2551 is intended to control a LeCroy 2551 scaler situated on a crate controlled by a CC-USB. It is the counterpart to the CBDLeCroy4434 driver that lives in the VMUSBReadout framework. In this case, the LeCroy2551 can be registered directly to a stack and does not need to be registered first to a CamacCrate. There is no reason you cannot register it to a CamacCrate though.
  </para>

  <para>
  During initialization, all scalers are cleared. 
  </para>

  <para>
  At the end of the run, no actions are taken. 
  </para>

  <para>
  During stack execution initiated by an event trigger, all 12 scaler channels are read individually.
  </para>

  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	    <varlistentry>
	      <term><command>-slot</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
        Specifies the slot of the CAMAC crate the target module is occupying. Default is 1.
		    </para>
	       </listitem>
	    </varlistentry>
   </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
          <title>A simple setup of a single scaler</title>
         <programlisting>
LeCroy2551 create sclr -slot 10
         </programlisting>
      </example>
      <para>
        Sets up a LeCroy 2551 scaler module in slot 10.
      </para>
  </refsect1>
</refentry>

<refentry id="ccusb3-ULMTrigger">
  <refmeta>
     <refentrytitle>ULMTrigger</refentrytitle>
     <manvolnum>3ccusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>ULMTrigger</refname>
     <refpurpose>control a LeCroy 2637 ULM running trigger firmware</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
ULMTrigger create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
ULMTrigger config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
ULMTrigger cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
    <para>
The ULMTrigger is intended to control a LeCroy 2367 ULM situated in a crate controlled by a CC-USB. It is the counterpart to the CBDULMTrigger driver that lives in the VMUSBReadout framework. In this case, the ULMTrigger does not need to be registered first to a CamacCrate, though it still can be. Instead, it can be directly registered to a stack.
  </para>

  <para>
Two options need to be specified to function properly. The first is firmware which defines the location of the firmware file to load. The second is the slot number in the camac crate it lives in. This will only work properly if running the usbtrig.bit firmware that Daniel Bazin has written. 
  </para>

  <para>
  On initialization the module will always be cleared and the GO bit set to 1.
  </para>

  <para>
  At the end of the run, the GO bit is set to 0.
  </para>

  <para>
  During stack execution initiated by an event trigger, the following logic is carried out:

  <programlisting>
if "-registerRead" is true
    Read the register

if "-eventwiseClear" is true
    Clear the register
  </programlisting>
  
  By default, both -registerRead and -eventwiseClear are set to false.
  </para>

  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	    <varlistentry>
	      <term><command>-slot</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
        Specifies the slot of the CAMAC crate the target module is occupying. Default is 1.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-firmware</command> <replaceable>path</replaceable></term>
	      <listitem>
		    <para>
        The path to the firmware file usbtrig.bit. Default is "".
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-readRegister</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
        Specifies whether to add a hit register read into the event stack. Defaults to true.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-eventwiseClear</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
        Specifies whether to send a clear command via the CAMAC dataway at the end of the event. Defaults to true.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-forceFirmwareLoad</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
        By default, the ULM will only load the firmware if it fails to validate the configuration. This occurs always after a bad firmware load or after a crate has been power cycled. Firmware loads take a bit of time so it is worthwhile to skip reloading the firmware on every run. However, sometimes it may be considered useful. This option causes the firmware to be loaded at the start of EVERY run. Defaults to false.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-configuration</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Specifies the number that will be used to validate a successful firmware configuration. This number is compared to the value returned by the function A=15 F=0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-pcDelay</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-pcWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-scDelay</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-scWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-ccWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-ssDelay</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-bypasses</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-pdFactor</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-sdFactor</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-triggerBox</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-inspect1</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-inspect2</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-inspect3</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-inspect4</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-adcWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-qdcWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-tdcWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-coincWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
   </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
         <title>A simple setup of a single ULM</title>
         <programlisting>
# Define values for each parameter in TRIGGER array
ULMTrigger create sclr -slot 23
ULMTrigger config ulm firmware /user/s800/server/fpga/usbtrig.bit
ULMTrigger config ulm -pcDelay $TRIGGER(PCDelay) \
                  -pcWidth $TRIGGER(PCWidth) \
                  -scDelay $TRIGGER(SCDelay) \
                  -scWidth $TRIGGER(SCWidth) \
                  -psDelay $TRIGGER(PSDelay) \
                  -ccWidth $TRIGGER(CCWidth) \
                  -ssDelay $TRIGGER(SSDelay) \
                  -bypasses $TRIGGER(Bypasses) \
                  -pdFactor $TRIGGER(PDFactor) \
                  -sdFactor $TRIGGER(SDFactor) \
                  -triggerBox $TRIGGER(TriggerBox) \
                  -inspect1 $TRIGGER(Inspect1) \
                  -inspect2 $TRIGGER(Inspect2) \
                  -inspect3 $TRIGGER(Inspect3) \
                  -inspect4 $TRIGGER(Inspect4) \
                  -adcWidth $TRIGGER(ADCWidth) \
                  -qdcWidth $TRIGGER(QDCWidth) \
                  -tdcWidth $TRIGGER(TDCWidth) \
                  -coincWidth $TRIGGER(CoincidenceWidth) \
                  -configuration $TRIGGER(configuration) 
ULMTrigger config trig -forceFirmwareLoad off
ULMTrigger config trig -readRegister on
ULMTrigger config trig -eventwiseClear off
         </programlisting>
      </example>
      <para>
        Sets up a ULM module in slot 23.
      </para>
  </refsect1>

      </refentry>
      <refentry id="ccusb3-ControlProtocol">
        <refmeta>
           <refentrytitle>Slow controls protocol</refentrytitle>
           <manvolnum>3ccusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>Slow controls protocol</refname>
           <refpurpose>TCP/IP slow control protocol</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
Update <replaceable>name</replaceable>               
            </command>
          </cmdsynopsis>
          <cmdsynopsis>
            <command>
Set <replaceable>name parameter value</replaceable>
            </command>
          </cmdsynopsis>
          <cmdsynopsis>
            <command>
Get <replaceable>name parameter</replaceable>
            </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            The protocol which communicates with the slow control server is
            a set of commands that are submitted to a Tcl interpreter that
            is running in the server.  Three commands result in
            dispatch to slow controls drivers.  If the run is active, the dispatch
            to the driver functions is preceeded by pausing the run and
            succeeded by resuming the run.  This allows driver functions
            unimpeded access to the CCUSB.
           </para>
           <para>
            Each driver is assumed to implement a set of named parameters.
            These parameters have values which are passed to and from the
            driver without interpretation.  Commands that result errors return
            strings to the client that begin with the text <literal>ERROR - </literal>
            with an english error message appended to that prefix.
           </para>
        </refsect1>
        <refsect1>
           <title>
              SUBCOMMANDS
           </title>
           <variablelist>
                <varlistentry>
                    <term>Update <replaceable>name</replaceable></term>
                    <listitem>
                        <para>
                            Asks the driver for the instance <replaceable>name</replaceable>
                            to update any internal state it maintains from the
                            device or, alternatively, depending on the driver
                            refresh any device state from internal state.
                            Normally this is used for devices that have write-only
                            registers, for those devices, typically the driver
                            must retain some concept of what it believes the
                            state of the physical device is.  This command is
                            then used to ensure the actual state of the device
                            matches the believed state.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Set <replaceable>name parameter-name value</replaceable></term>
                    <listitem>
                        <para>
                            Note the capital S in <command>Set</command> to
                            distinguish it from the similar Tcl command.
                            This command is used by a client to alter
                            a parameter value.  <replaceable>name</replaceable>
                            is the name of a Module instance,
                            <replaceable>parameter-name</replaceable> is the
                            name of a parameter maintained by the driver for
                            that device and <replaceable>value</replaceable> is
                            the new requested value for the parameter.
                        </para>
                        <para>
                            On success the client is returned a line containing
                            the string <literal>OK</literal> otherwise
                            <literal>ERROR -</literal> along with a message
                            is returned as describedin DESCRIPTION above.
                        </para>
                        <para>
                            Note that the legal parameter names and their legal
                            values are soley determined by the device driver.
                            See the device specific sections below for
                            more information.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Get <replaceable>name parameter-name</replaceable></term>
                    <listitem>
                        <para>
                            Returns the value of the parameter
                            <replaceable>parameter-name</replaceable> from
                            the Module instance <replaceable>name</replaceable>.
                            If this is successful, the value of the parameter
                            will be returned to the client.  Otherwise a line
                            beginnning with <literal>ERROR - </literal> will
                            be returned along with a textual error message.
                        </para>
                    </listitem>
                </varlistentry>
           </variablelist>
        </refsect1>
        <refsect1>
            <title>PARAMETERS FOR SUPPORTED DEVICES</title>
            <refsect2>
                <title>ph7106</title>
                <para>
                    The following parameters are supported by the
                    driver for the Phillips PH7106 leading edge
                    discriminator.  As this device has read/write
                    registers, <command>Update</command> is a no-op
                    and the <command>Get</command> operation fetches
                    state directly from the device.
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>threshold</literal></term>
                        <listitem>
                            <para>
                                Represents the single module threshold.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>mask</literal></term>
                        <listitem>
                            <para>
                                Represents the module mask parameter.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>mode</literal></term>
                        <listitem>
                            <para>
                                Represents the control mode of the device.
                                this can be one of <literal>camac</literal>
                                or <literal>local</literal>.  This parameter
                                is read-only and represents the state of a
                                switch on the module front panel.
                                If the module is in <literal>local</literal>
                                mode, no changes can be made by CAMAC
                                operations.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
        
            </refsect2>
            <refsect2>
                <title>caen894</title>
                <para>
                    The following parameters are suppoerted by the
                    CAEN C894 device support.  These are all read/write
                    parameters, although Get accesses internal driver
                    memory of the last settings done as the actual
                    hardware is write-only.
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>threshold</literal><replaceable>n</replaceable></term>
                        <listitem>
                            <para>
                                Represents the value of the threshold for
                                channel <replaceable>n</replaceable> e.g.
                                <literal>threshold10</literal> represents
                                the threshold value for channel 10.
                                Thresholds number from <literal>[0-15]</literal>
                                and have values between <literal>[0-255]</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>width</literal><replaceable>n</replaceable></term>
                        <listitem>
                            <para>
                                Represents the output width of channel
                                <replaceable>n</replaceable>.  Legal values
                                are in the range <literal>[0-255]</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>inhibits</literal></term>
                        <listitem>
                            <para>
                                Represents the module inhibits mask.
                                This 16 bit value has one bit for each channel.
                                The least significant bit represents channel 0
                                the most significant bit channel 15.
                                Set bits represent channnels that are inhibited.
                            </para>
                        </listitem>
                    </varlistentry> 
                    <varlistentry>
                        <term><literal>majority</literal></term>
                        <listitem>
                            <para>
                                Represents the majority level.  This value
                                is in the range <literal>[1-20]</literal>
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                </refsect2>
        </refsect1>
      </refentry>
         
	 <refentry id="ccusb3-CCCUSB">
       <refmeta>
          <refentrytitle>CCCUSB</refentrytitle>
          <manvolnum>3ccusb</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CCCUSB</refname>
          <refpurpose>Provide access to a CC-USB device.</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <programlisting>
        <synopsis>
            class <ooclass><classname>CCCUSB</classname></ooclass> {
            <methodsynopsis>
                <modifier>static</modifier>
                <type>std::vector&lt;struct usb_device*&gt;</type>
                <methodname>enumerate</methodname>
                <void />
            </methodsynopsis>
            
            <methodsynopsis>
                <modifier>static</modifier>
                <type>std::string</type>
                <methodname>serialNo</methodname>
                <methodparam>
                    <type>struct usb_device*</type><parameter>dev</parameter>
                </methodparam>
            </methodsynopsis>
            
           <constructorsynopsis>
          <methodname>CCCUSB</methodname>
          <methodparam>
            <type>struct usb_device*</type><parameter>vmUsbDevice</parameter>
          </methodparam>
           </constructorsynopsis>
            <methodsynopsis>
              <type>void</type>
              <methodname>writeActionRegister</methodname>
              <methodparam>
                <type>uint16_t</type> <parameter>value</parameter>
              </methodparam>
            </methodsynopsis>
            <methodsynopsis>
              <type>int</type>
              <methodname>simpleWrite16</methodname>
              <methodparam>
                <type>int</type><parameter>n</parameter>
              </methodparam>
              <methodparam>
                <type>int</type><parameter>a</parameter>
              </methodparam>
              <methodparam>
                <type>int</type><parameter>f</parameter>
              </methodparam>
              <methodparam>
                <type>uint16_t</type><parameter>data</parameter>
              </methodparam>
              <methodparam>
                <type>uint16_t&amp;</type><parameter>qx</parameter>
              </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>simpleWrite24</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>data</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t&amp;</type> <parameter>qx</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>simpleRead16</methodname>
                <methodparam>
                    <type>int</type><parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type><parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t&amp;</type> <parameter>data</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t&amp;</type> <parameter>qx</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>simpleRead24</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t&amp;</type><parameter>data</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t&amp;</type> <parameter>qx</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>simpleControl</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type><parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t&amp;</type> <parameter>qx</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readFirmware</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readGlobalMode</methodname>
                <methodparam>
                    <type>uint16_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeGlobalMode</methodname>
                <methodparam>
                    <type>uint16_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readDelays</methodname>
                <methodparam>
                    <type>uint16_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeDelays</methodname>
                <methodparam>
                    <type>uint16_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type>  <methodname>readScalerControl</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeScalerControl</methodname>
                <methodparam>
                    <type>uint32_t</type><parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readLedSelector</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeLedSelector</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readOutputSelector</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeOutputSelector</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readDeviceSourceSelectors</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type><parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeDeviceSourceSelectors</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readDGGA</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readDGGB</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readDGGExt</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeDGGA</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeDGGB</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeDGGExt</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readScalerA</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readScalerB</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readLamTriggers</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeLamTriggers</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readUSBBulkTransferSetup</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeUSBBulkTransferSetup</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>c</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>z</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>inhibit</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>uninhibit</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>executeList</methodname>
                <methodparam>
                    <type>CCCUSBReadoutList&amp;</type> <parameter>list</parameter>
                </methodparam>
                <methodparam>
                    <type>void*</type><parameter>pReadBuffer</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t</type><parameter>readBufferSize</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t*</type><parameter>bytesRead</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>loadList</methodname>
                <methodparam>
                    <type>uint8_t</type><parameter>listNumber</parameter>
                </methodparam>
                <methodparam>
                    <type>CCCUSBReadoutList&amp;</type><parameter>list</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>usbRead</methodname>
                <methodparam>
                    <type>void*</type> <parameter>data</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t</type> <parameter>bufferSize</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t*</type><parameter> transferCount</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>timeout</parameter>
                    <initializer> 2000</initializer>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setDefaultTimeout</methodname>
                <methodparam>
                    <type>int</type> <parameter>ms</parameter>
                </methodparam>
            </methodsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::ActionRegister::startDAQ</varname><initializer>1</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::ActionRegister::usbTrigger</varname><initializer>2</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::ActionRegister::clear</varname><initializer>4</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::ActionRegister::scalerDump</varname><initializer>0x10</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::FirmwareRegister::revisionMask</varname>
                <initializer>0xff</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::FirmwareRegister::revisionShift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::FirmwareRegister::yearMask</varname>
                <initializer>0xf00</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::FirmwareRegister::yearShift</varname>
                <initializer>8</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::FirmwareRegister::monthMask</varname>
                <initializer>0xf000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::FirmwareRegister::monthShift</varname><initializer> 12</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLenMask</varname>
                <initializer>0xf</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLenShift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLen4K</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLen2K</varname>
                <initializer>1</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLen1K</varname>
                <initializer>2</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLen512</varname>
                <initializer>3</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t </type>
                <varname>CCCUSB::GlobalModeRegister::bufferLen256</varname>
                <initializer>4</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLen128</varname>
                <initializer>5</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLen64</varname>
                <initializer>6</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLenSingle</varname>
                <initializer>7</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::mixedBuffers</varname>
                <initializer>0x20</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::doubleHeader</varname>
                <initializer>0x100</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::enableSecondary</varname>
                <initializer>0x1000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::DelayRegister::triggerDelayMask</varname>
                <initializer>0xff</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::DelayRegister::triggerDelayShift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::DelayRegister::lamTimeoutMask</varname>
                <initializer>0xff00</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::DelayRegister::lamTimeoutShift</varname>
                <initializer>8</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::ScalerControlRegister::eventsCountMask</varname>
                <initializer>0xffff</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::ScalerControlRegister::eventsCountShift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::ScalerControlRegister::timeIntervalMask</varname>
                <initializer>0xff0000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::ScalerControlRegister::timeIntervalShift</varname>
                <initializer>16</initializer>
            </fieldsynopsis>
            
            <!--
   // Red LED: -->
            <fieldsynopsis>
                <modifier>static const</modifier>
                <type>uint32_t</type> <varname>CCCUSB::LedSourceRegister::redEventTrigger</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::redBusy</varname>
                <initializer>1</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::redUSBOutFifoNotEmpty</varname>
                <initializer>2</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::redUSBInFifoNotEmpty</varname>
                <initializer>3</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::redInvert</varname>
                <initializer>0x10</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::redLatch</varname>
                <initializer>0x20</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::redShift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <!--
    // Green LED: -->
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::greenShift</varname>
                <initializer>8</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::greenAcquire</varname>
                <initializer>(0 &lt;&lt; greenShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::greenNimI1</varname>
                <initializer>(1 &lt;&lt; greenShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::greenUSBInFifoNotEmpty</varname>
                <initializer>(2 &lt;&lt; greenShift</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::greenUSBTrigger</varname>
                <initializer>(3 &lt;&lt; greenShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::greenInvert</varname>
                <initializer>(0x10 &lt;&lt; greenShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::greenLatch</varname>
                <initializer>(0x20 &lt;&lt; greenShift)</initializer>
            </fieldsynopsis>
            <!--
    // Red LED: -->
        
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::yellowShift</varname>
                <initializer>= 16</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::yellowNimI2</varname>
                <initializer>(0 &lt;&lt; yellowShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::yellowNimI3</varname>
                <initializer>(1 &lt;&lt; yellowShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::yellowBusy</varname>
                <initializer>(2 &lt;&lt; yellowShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::yellowUsbInFifoNotEmpty</varname>
                <initializer>(3 &lt;&lt; yellowShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::yellowInvert</varname>
                <initializer>(0x10 &lt;&lt; yellowShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::yellowLatch</varname>
                <initializer>(0x20 &lt;&lt; yellowShift)</initializer>
            </fieldsynopsis>
    
            <!-- Output source selection register -->
            

<!--    // NIM O1 source: -->

            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO1Shift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO1Busy</varname>
                <initializer>(0 &lt;&lt; nimO1Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO1Event</varname>
                <initializer>(1 &lt;&lt; nimO1Shift</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO1DGGA</varname>
                <initializer>(2 &lt;&lt; nimO1Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO1DGGB</varname>
                <initializer>(3 &lt;&lt; nimO1Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO1Invert</varname>
                <initializer>(0x10 &lt;&lt; nimO1Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO1Latch</varname>
                <initializer>(0x20 &lt;&lt; nimO1Shift)</initializer>
            </fieldsynopsis>

 <!--   // NIM O2 source:   -->
 
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO2Shift</varname>
                <initializer>8</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO2Acquire</varname>
                <initializer>(0 &lt;&lt;nimO2Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO2Event</varname>
                <initializer>(1 &lt;&lt; nimO2Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO2DGGA</varname>
                <initializer>(2 &lt;&lt; nimO2Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO2DGGB</varname>
                <initializer>3 &lt;&lt; nimO2Shift</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO2Invert</varname>
                <initializer>(0x10 &lt;&lt; nimO2Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO2Latch</varname>
                <initializer>(0x20 &lt;&lt; nimO2Shift)</initializer>
            </fieldsynopsis>

<!--    // NIM O3 source:  -->

            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO3Shift</varname>
                <initializer>16</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>nimO3BusyEnd</varname>
                <initializer>(0 &lt;&lt; nimO3Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO3Busy</varname>
                <initializer>(1 &lt;&lt; nimO3Shift</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO3DGGA</varname>
                <initializer>(2 &lt;&lt; nimO3Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO3DGGB</varname>
                <initializer>(3 &lt;&lt; nimO3Shift</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO3Invert</varname>
                <initializer>(0x10 &lt;&lt; nimO3Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO3Latch</varname>
                <initializer>(0x20 &lt;&lt; nimO3Shift)</initializer>
            </fieldsynopsis>         
    <!-- DeviceSourceSelectorsRegister - -->
    
   <!-- // Scaler A source/control -->
   
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAShift</varname>
                <initializer>0</initializer>
                </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerADisabled</varname>
                <initializer>(0 &lt;&lt; scalerAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerANimI1</varname>
                <initializer>(1 &lt;&lt; scalerAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerANimI2</varname>
                <initializer>(2 &lt;&lt; scalerAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerANimI3</varname>
                <initializer>(3 &lt;&lt; scalerAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAEvent</varname>
                <initializer>(4 &lt;&lt; scalerAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAScalerBCarry</varname>
                <initializer>(5 &lt;&lt; scalerAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier>
                <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerADGGA</varname>
                <initializer>(6 &lt;&lt; scalerAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerADGGB</varname>
                <initializer>(7 &lt;&lt; scalerAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAEnable</varname>
                <initializer>(0x10 &lt;&lt; scalerAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAReset</varname>
                <initializer>(0x20 &lt; scalerAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAFreeze</varname>
                <initializer>(0x40 &lt;&lt; scalerAShift)</initializer>
            </fieldsynopsis>
            
            <!-- // Scaler B source/control -->
            
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>scalerBShift</varname><initializer> 8</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBDisabled</varname>
                <initializer>(0 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t </type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBNimI1</varname>
                <initializer>(1 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBNimI2</varname>
                <initializer>(2 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBNimI3</varname>
                <initializer>(3 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBEvent</varname>
                <initializer>(4 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>int32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBScalerACarry</varname>
                <initializer>(5 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBDGGA</varname>
                <initializer>(6 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBDGGB </varname>
                <initializer>(7 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t </type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBEnable</varname>
                <initializer>(0x10 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBReset</varname>
                <initializer>(0x20 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBFreeze</varname>
                <initializer>(0x40 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            
            <!-- // DGGA source -->
            
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGAShift</varname>
                <initializer>16</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGADisabled</varname>
                <initializer>(0 &lt;&lt; DGGAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGANimI1</varname>
                <initializer>(1 &lt;&lt; DGGAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGANimI2</varname>
                <initializer>(2 &lt;&lt; DGGAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGANimI3</varname>
                <initializer>(3 &lt;&lt; DGGAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGAEvent</varname>
                <initializer>(4 &lt;&lt; DGGAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGABusyEnd</varname>
                <initializer>(5 &lt;&lt; DGGAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGAUSBTrigger</varname>
                <initializer>(6 &lt;&lt; DGGAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGAPulser</varname>
                <initializer>(7 &lt;&lt; DGGAShift)</initializer>
            </fieldsynopsis>

            <!--  // DGGB source -->
            
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGBShift</varname>
                <initializer>24</initializer>
                </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGBDisabled </varname>
                <initializer>(0 &lt;&lt; DGGBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGBNimI1</varname>
                <initializer>(1 &lt;&lt; DGGBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGBNimI2</varname>
                <initializer>(2 &lt;&lt; DGGBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGBNimI3</varname>
                <initializer>(3 &lt;&lt; DGGBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGBEvent</varname>
                <initializer>(4 &lt;&lt; DGGBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGBBusyEnd</varname>
                <initializer>(5 &lt;&lt; DGGBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGBUSBTrigger</varname>
                <initializer>(6 &lt;&lt; DGGBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGBPulser</varname>
                <initializer>(7 &lt;&lt; DGGBShift)</initializer>
            </fieldsynopsis>    



            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DGGAndPulserRegister::dggFineDelayMask</varname>
                <initializer>0xffff</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DGGAndPulserRegister::dggFineDelayShift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DGGAndPulserRegister::dggGateWidthMask</varname>
                <initializer>0xffff0000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DGGAndPulserRegister::dggGateWidthShift</varname>
                <initializer>16</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DGGCoarseRegister::ACoarseMask</varname>
                <initializer>xffff;</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::DGGCoarseRegister::ACoarseShift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DGGCoarseRegister::BCoarseMask</varname>
                <initializer>0xffff0000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DGGCoarseRegister::BCoarseShift</varname>
                <initializer>16</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCCUSB::TransferSetupRegister::multiBufferCountMask</varname>
                <initializer>0xff</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t </type>
                <varname>CCCCUSB::TransferSetupRegister::multiBufferCountShift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCCUSB::TransferSetupRegister::timeoutMask</varname>
                <initializer>0xf00</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCCUSB::TransferSetupRegister::timeoutShift</varname>
                <initializer>8</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::Q</varname>
                <initializer>1</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::X</varname>
                <initializer>2</initializer>
            </fieldsynopsis>
            };
       </synopsis>
        </programlisting>   
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            The <classname>CCCUSB</classname> class represents a connection
            to a CC-USB controller.  The static members <methodname>enumerate</methodname>
            and <methodname>serialNo</methodname> allow programs to become
            aware of the set of interfaces that are currently plugged in
            and powered up, and to associated them with serial number strings.
          </para>
          <para>
            Constructing an object around a specific <classname>usb_device*</classname>
            allows you to interact with the device represented by that struct.
            The class exports a rich set of methods which are described in the
            METHODS section below.  Bits and bit fields are defined as class
            constants described in PUBLIC VARIABLES, TYPES and CONSTANTS below.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <para>
            In the functions listed below, any function that returns an <type>int</type>
            returns <literal>0</literal> on success, <literal>-1</literal> if
            the write operation to the device failed or <literal>-2</literal>
            if the read operation failed.  Negative values result in the
            <varname>errno</varname> variable set to the actual reason for the
            failure.
          </para>
            <variablelist>
                <varlistentry>
                    <term><methodsynopsis><modifier>static</modifier>
                    <type>std::vector&lt;struct usb_device*&gt;</type>
                    <methodname>enumerate</methodname>
                    <void /></methodsynopsis></term>
                    <listitem>
                        <para>
                            Enumerates the set of CC-USB devices that are attached
                            and powered up on the host.  The return value
                            is a vector of <classname>usb_device*</classname> pointers
                            each of which represents one of those devices.
                        </para>
                        <para>
                            You can use a <classname>usb_device*</classname> pointer
                            to construct a <classname>CCCUSB</classname> object
                            or to query the serial number of that device.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodsynopsis><modifier>static</modifier>
                        <type>std::string</type>
                        <methodname>serialNo</methodname>
                        <methodparam>
                            <type>struct usb_device*</type><parameter>dev</parameter>
                        </methodparam></methodsynopsis> </term>
                    <listitem>
                        <para>
                            Returns the serial number string for the CC-USB
                            represented by the <parameter>dev</parameter>
                            parameter.  <parameter>dev</parameter> should have
                            been gotten from a call to <function>CCCUSB::enumerate</function>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><constructorsynopsis>
                    <methodname>CCCUSB</methodname>
                    <methodparam>
                      <type>struct usb_device*</type><parameter>vmUsbDevice</parameter>
                    </methodparam>
                     </constructorsynopsis></term>
                    <listitem>
                        <para>
                            Constructs a <classname>CCCUSB</classname> object.
                            The resulting object can be used to communicate
                            with the CC-USB represented by the
                            <parameter>vmUsbDevice</parameter> object.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                        <type>void</type>
                        <methodname>writeActionRegister</methodname>
                        <methodparam>
                          <type>uint16_t</type> <parameter>value</parameter>
                        </methodparam>
                      </methodsynopsis></term>
                    <listitem>
                        <para>
                            Writes the CCUSB's action register. The class also
                            supplies symoblic definitions for bits in the action
                            register.  See the Action register section of 
                            PUBLIC VARIABLES, TYPES and CONSTANTS below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                         <type>int</type>
                         <methodname>simpleWrite16</methodname>
                         <methodparam>
                           <type>int</type><parameter>n</parameter>
                         </methodparam>
                         <methodparam>
                           <type>int</type><parameter>a</parameter>
                         </methodparam>
                         <methodparam>
                           <type>int</type><parameter>f</parameter>
                         </methodparam>
                         <methodparam>
                           <type>uint16_t</type><parameter>data</parameter>
                         </methodparam>
                         <methodparam>
                           <type>uint16_t&amp;</type><parameter>qx</parameter>
                         </methodparam>
                       </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a CAMAC write operations with a
                            16 bit wide data transfer.
                            The parameters <parameter>n,a,f</parameter>
                            specify the slot, subaddress and function code
                            respectively while the <parameter>data</parameter>
                            parameter provides the data to write.  The
                            <parameter>qx</parameter> parameter receives a
                            bit encoding of the Q and X responses of the
                            operation.  See PUBLIC VARIABLES, TYPES and CONSTANTS
                            for the <varname>CCCUSB::Q</varname> and
                            <varname>CCCUSB::X</varname> bit field definitions.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>simpleWrite24</methodname>
                            <methodparam>
                                <type>int</type> <parameter>n</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>a</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>f</parameter>
                            </methodparam>
                            <methodparam>
                                <type>uint32_t</type> <parameter>data</parameter>
                            </methodparam>
                            <methodparam>
                                <type>uint16_t&amp;</type> <parameter>qx</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>simpleWrite16</methodname> above,
                            however the least significant 24 bits of
                            <parameter>data</parameter> are written.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                           <type>int</type> <methodname>simpleRead16</methodname>
                           <methodparam>
                               <type>int</type><parameter>n</parameter>
                           </methodparam>
                           <methodparam>
                               <type>int</type> <parameter>a</parameter>
                           </methodparam>
                           <methodparam>
                               <type>int</type><parameter>f</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint16_t&amp;</type> <parameter>data</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint16_t&amp;</type> <parameter>qx</parameter>
                           </methodparam>
                       </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a 16 bit read from a CAMAC module.
                            <parameter>n,a,f</parameter> define the slot, subaddress and
                            function code respectively while <parameter>data</parameter>
                            will receive the data from the operation.
                            <parameter>qx</parameter> will contain a
                            bit encoding of the dataway Q and X responses.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                       <methodsynopsis>
                        <type>int</type> <methodname>simpleRead24</methodname>
                        <methodparam>
                            <type>int</type> <parameter>n</parameter>
                        </methodparam>
                        <methodparam>
                            <type>int</type> <parameter>a</parameter>
                        </methodparam>
                        <methodparam>
                            <type>int</type> <parameter>f</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t&amp;</type><parameter>data</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint16_t&amp;</type> <parameter>qx</parameter>
                        </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>simpleRead16</methodname>, however the data
                            transfer is 24 bits.  These are placed in the least
                            significant 24 bits of <parameter>data</parameter>.
                            The top 8 bits are zeroed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>simpleControl</methodname>
                            <methodparam>
                                <type>int</type> <parameter>n</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>a</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type><parameter>f</parameter>
                            </methodparam>
                            <methodparam>
                                <type>uint16_t&amp;</type> <parameter>qx</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs the non-data transfer operation (control
                            function) specified by <parameter>n,a,f</parameter>.
                            As usuall the dataway Q and X responses are stored
                            in the <parameter>qx</parameter> parameter.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readFirmware</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the firmware id register storing it in the
                            <parameter>value</parameter> parameter.  This field
                            is bit encoded.  See the Firmware Register
                            subsection of PUBLIC VARIABLES, TYPES and CONSTANTS
                            below for symbols that allow you to extract the
                            firmware register fields.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readGlobalMode</methodname>
                            <methodparam>
                                <type>uint16_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the global mode register of the CC-USB.
                            The value of that register is stored in the
                            <parameter>value</parameter> parameter.  The
                            global mode register consists of several bits and
                            bit fields.  See the Global Mode subsection of
                            PUBLIC VARIABLES, TYPES and CONSTANTS below for
                            symbolic definitions of those bits and bit fields.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeGlobalMode</methodname>
                            <methodparam>
                                <type>uint16_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes the global mode register so that it contains
                            <parameter>value</parameter>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readDelays</methodname>
                            <methodparam>
                                <type>uint16_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the delays register into <parameter>value</parameter>.
                            The delays register contains bit fields that control
                            the trigger delay and lam timeout of lam waits.
                            See the Delays Register section of
                            PUBLIC VARIABLES, TYPES and CONSTANTS below
                            for symbolic definitions of this register's contents.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type>
                        <methodname>writeDelays</methodname>
                        <methodparam>
                            <type>uint16_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> into the
                            CC-USB's delays register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type>  <methodname>readScalerControl</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the CC-USB scaler control register into
                            <parameter>value</parameter>.  This regtister contains
                            bit fields that are defined in the
                            Scaler Control Register subsection of
                            PUBLIC VARIABLES, TYPES and CONSTANTS
                            below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeScalerControl</methodname>
                            <methodparam>
                                <type>uint32_t</type><parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> into the
                            scaler control register of the CC-USB.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readLedSelector</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the value of the LED selector register
                            into <parameter>value</parameter>.  The
                            LED selector register defines the meaning of the
                            lights on the CC-USB front panel.  The bit field
                            definitions and values are described in
                            LED Selector Register below in
                            PUBLIC VARIABLES, TYPES and CONSTANTS
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeLedSelector</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> into the
                            LED selector register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readOutputSelector</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Read the value of the Output Selector register
                            into <parameter>value</parameter>.  The
                            Output selector register determines the functions
                            of the NIM output connectors on the front panel
                            of the CC-USB.  The bit field and code definitions
                            of this register have symbolic definitions that are
                            described in Output Selector Register in
                            PUBLIC VARIABLES, TYPES and CONSTANTS
                            below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeOutputSelector</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Write <parameter>value</parameter> into the
                            output selector register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readDeviceSourceSelectors</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type><parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Read the device source selectors register into
                            <parameter>value</parameter>.  This register
                            determines the input sources for various CC-USB
                            onboard resources, specifically the two scalers
                            and two gate generators.  The bit fields in this
                            register are described in
                            Device Source Selector register in
                            PUBLIC VARIABLES, TYPES and CONSTANTS below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeDeviceSourceSelectors</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> into the
                            device source selector register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readDGGA</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                        <methodsynopsis>
                            <type>int</type> <methodname>readDGGB</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                        <methodsynopsis>
                            <type>int</type> <methodname>readDGGExt</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            These functions read registers that set up the
                            parameters that control the two gate and delay
                            generators in the CC-USB into the <parameter>value</parameter>
                            parameter.  The bit fields definitions for these
                            registers are described in Gate and Delay Generators
                            below in
                            PUBLIC VARIABLES, TYPES and CONSTANTS
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeDGGA</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeDGGB</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeDGGExt</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> into the
                            registers that control the two gate and delay
                            generators in the CC-USB.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readScalerA</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                        <methodsynopsis>
                            <type>int</type> <methodname>readScalerB</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the current value of scaler A or B internal
                            to the CC-USB into the <parameter>value</parameter>
                            parameter.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readLamTriggers</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the contents of the lam trigger register
                            into <parameter>value</parameter>.
                            The LAM trigger register is a mask of LAMs which
                            if matched by the dataway LAM pattern will trigger
                            the event list.  If zero, readout is triggered by
                            front panel inputs.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeLamTriggers</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Write <parameter>value</parameter> to the LAM trigger
                            register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readUSBBulkTransferSetup</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the value of the USB Bulk transfer register
                            into <parameter>value</parameter>.  The bulk transfer
                            register contains two bit fields which are defined
                            in the USB Bulk Transfer Register under the
                            PUBLIC VARIABLES, TYPES and CONSTANTS section
                            below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeUSBBulkTransferSetup</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> into the
                            USB Bulk transfer register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>c</methodname>
                            <void />
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a dataway C cycle.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                           <type>int</type> <methodname>z</methodname>
                           <void />
                       </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a data way Z cycle.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>inhibit</methodname>
                            <void />
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Sets the dataway Inhibit line.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>uninhibit</methodname>
                            <void />
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Unsets the dataway Inhibit line.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>executeList</methodname>
                            <methodparam>
                                <type>CCCUSBReadoutList&amp;</type> <parameter>list</parameter>
                            </methodparam>
                            <methodparam>
                                <type>void*</type><parameter>pReadBuffer</parameter>
                            </methodparam>
                            <methodparam>
                                <type>size_t</type><parameter>readBufferSize</parameter>
                            </methodparam>
                            <methodparam>
                                <type>size_t*</type><parameter>bytesRead</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a CAMAC list operation in immediate mode.
                            In order to do this data taking mode must not
                            be on.   The <parameter>list</parameter> is built up
                            by constructing a <classname>CCCUSBReadoutList</classname>
                            (see <xref linkend='ccusb3-CCCUSBReadoutList' />)
                            object and using its methods to add the appropriate
                            set of instructions to the list.
                        </para>
                        <para>
                            <parameter>pReadBuffer</parameter> is a pointer to
                            a buffer you have prepared to receive the results
                            of the read operations in the list.  This buffer
                            has <parameter>readBufferSize</parameter> bytes
                            of data.  On successful return,
                            <parameter>bytesRead</parameter> will contain the
                            actual number of bytes transferred into your buffer.
                            On failure (return value other than <literal>0</literal>),
                            the value of <parameter>bytesRead</parameter> is not
                            well defined.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                           <type>int</type> <methodname>loadList</methodname>
                           <methodparam>
                               <type>uint8_t</type><parameter>listNumber</parameter>
                           </methodparam>
                           <methodparam>
                               <type>CCCUSBReadoutList&amp;</type><parameter>list</parameter>
                           </methodparam>
                       </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Loads a list into the CC-USB. The <parameter>listNumber</parameter>
                            must be 0 for the event list and 1 for the scaler list.
                            If it is any value other than this, the function
                            will return <literal>-4</literal>.
                            <parameter>list</parameter>   is the
                            <classname>CCCUSBReadoutList</classname> to load.
                            See <xref linkend='ccusb3-CCCUSBReadoutList' /> for
                            information about this parameter and how to build it.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>usbRead</methodname>
                            <methodparam>
                                <type>void*</type> <parameter>data</parameter>
                            </methodparam>
                            <methodparam>
                                <type>size_t</type> <parameter>bufferSize</parameter>
                            </methodparam>
                            <methodparam>
                                <type>size_t*</type><parameter> transferCount</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>timeout</parameter>
                                <initializer>2000</initializer>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Pefroms a bulk read on the data transfer endpoint
                            of the CC-USB.  Normally this only needs to be called
                            by the CCUSBReadout framework when in data taking mode.
                            <parameter>data</parameter> is a buffer
                            into which data read should be transferred.
                            <parameter>bufferSize</parameter> is the number
                            of bytes that can be stored in <parameter>buffer</parameter>
                            <parameter>transferCount</parameter> points to a
                            buffer that will contain the number of bytes actually
                            transferred to the buffer. <parameter>timeout</parameter>
                            is the number of milliseconds to wait for the transfer
                            to complete before ending with a timeout condition.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>setDefaultTimeout</methodname>
                            <methodparam>
                                <type>int</type> <parameter>ms</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Most of the immediate operations require a write to the
                            CC-USB followed by a read to get status and/or data.
                            This function allows you to override the default
                            timeout for the read. <parameter>ms</parameter> is
                            the number of milliseconds in the new timeout.
                            Normally you will not need to call this.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>  
       </refsect1>
        <refsect1>
           <title>PUBLIC VARIABLES, TYPES and CONSTANTS</title>
           <para>
                The <classname>CCCUSB</classname> class exports several
                public constants that provide symbolic constants that help you
                to build up the contents of CC-USB registers.  The subsections
                in this section describe these values for each register.
           </para>
           <refsect2>
            <title>Action Register</title>
            <para>
                The Action register is a write-only register. Setting bit
                patterns in the Action register cause the CC-USB to take
                specific actions.
            </para>
            <variablelist>
                    <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::ActionRegister::startDAQ</varname><initializer>1</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            When this bit is set, the CC-USB enters data taking
                            mode.  In data taking mode the CC-USB responds to triggers
                            for the Event and Scaler stacks by executing them
                            and buffering their data for read via
                            <methodname>usbRead</methodname>.  Prior
                            to executing immediate actions you must clear this
                            bit and drain any buffered event data from the
                            module.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                           <modifier>static const</modifier> <type>uint16_t</type>
                           <varname>CCCUSB::ActionRegister::usbTrigger</varname><initializer>2</initializer>
                       </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Setting this bit performs a one-time trigger
                            of the event readout list.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::ActionRegister::clear</varname><initializer>4</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This bit is "intended primarily for use during
                            firmware debugging" it should not be set by
                            ordinary users like us.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::ActionRegister::scalerDump</varname><initializer>0x10</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Setting this bit triggers execution of the scaler
                            list.
                        </para>
                    </listitem>
                </varlistentry>    
            </variablelist>
            <para>
                Note that all bits except the <varname>startDAQ</varname> are
                one-shots that automatically reset after 150ns.
            </para>
           </refsect2>
           <refsect2>
            <title>Firmware Register</title>
            <para>
                This register contains the current revision of the device
                firmware.  This is a set of bit fields in a 32 bit word:
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::FirmwareRegister::revisionMask</varname>
                            <initializer>0xff</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::FirmwareRegister::revisionShift</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            These two value define the revision field.
                            If <varname>d</varname> contains the
                            firmware revision register, you can extract
                            the revisionfield by performing:
                            <informalexample>
                                <programlisting>
uint32_t revision = (d &amp; CCCUSB::FirmwareRegister::revisionMask)
                    >> CCCUSB::FirmwareRegister::revisionShift;
                                </programlisting>
                            </informalexample>
                        </para>
                        <para>
                            The remaining fields are defined in this way,
                            by a mask and a shift count.  Analagous operations
                            can be used to extract  the value of the
                            field given the full firmware revision register
                            value.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::FirmwareRegister::yearMask</varname>
                            <initializer>0xf00</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::FirmwareRegister::yearShift</varname>
                            <initializer>8</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the field that gives the year in which the
                            firmware version was finalized.
                            The manual does not define what a <literal>0</literal>
                            in this field means.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::FirmwareRegister::monthMask</varname>
                            <initializer>0xf000</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::FirmwareRegister::monthShift</varname><initializer> 12</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the month field.  This field contains
                            the month in which the firmware was finalized.
                            Presumably this is a value between
                            <literal>[1..12]</literal>.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>Global Mode Register</title>
            <para>
                The global mode register is described in section 3.3.2 of the
                CC-USB manual.  This register can be built up by bitwise
                or-ing together the values described in this section.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLenMask</varname>
                            <initializer>0xf</initializer>
                        </fieldsynopsis>
                    </term>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLenShift</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            These values define the field in the global mode
                            register that sets the lengt of the data buffer
                            produced by the CC-USB.
                        </para>
                        <para>
                            For actual values you can or into the register
                            see the fields bufferLenxx below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLen4K</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects buffers that are <literal>4096</literal>
                            <classname>uint16_t</classname> units long.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLen2K</varname>
                            <initializer>1</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Use an output buffer length of <literal>2048</literal>
                            <classname>uint16_t</classname> units long.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLen1K</varname>
                            <initializer>2</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Use an output buffer length of
                            <literal>1024</literal>   <classname>uint16_t</classname>
                            units long.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLen512</varname>
                            <initializer>3</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Use an output buffer length of
                            <literal>512</literal> <classname>uint16_t</classname>
                            units long.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t </type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLen256</varname>
                            <initializer>4</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Use an output buffer length of
                            <literal>256</literal> <classname>uint16_t</classname>
                            units long.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLen128</varname>
                            <initializer>5</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Use  a <literal>128</literal> <classname>uint16_t</classname>
                            unit large output buffer.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLen64</varname>
                            <initializer>6</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Use a <literal>64</literal> <classname>uint16_t</classname>
                            unit large output buffer.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLenSingle</varname>
                            <initializer>7</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Use a buffer that holds only a single event.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::mixedBuffers</varname>
                            <initializer>0x20</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Mix scaler and event data together in the same scaler
                            buffer.  If zero, buffers are homogenous with respect
                            to the stack that contributes data to them.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::doubleHeader</varname>
                            <initializer>0x100</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            If set the buffer header will include a second
                            word that contains the number of words in the
                            buffer.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::enableSecondary</varname>
                            <initializer>0x1000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            If set, CAMAC bus arbitration is enabled, allowing
                            the use of an Auxiliary crate controller.
                            In this case you must cable the Aux controller
                            to request mastership via RQ, GIN, and GOUT
                            signals on the front of the controller.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>Delay Register</title>
            <para>
                This register has fields for controlling the delay between the trigger
                and stack execution as well as the LAM timeout interval.
                Both fields are in units of microseconds.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::DelayRegister::triggerDelayMask</varname>
                            <initializer>0xff</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::DelayRegister::triggerDelayShift</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                           Mask and shift counts for the trigger delay field.
                           This field controls the amount of time between
                           the receipt of a trigger and execution of the
                           event stack.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::DelayRegister::lamTimeoutMask</varname>
                            <initializer>0xff00</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::DelayRegister::lamTimeoutShift</varname>
                            <initializer>8</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Mask and shift counts for the lam timeout field.
                            This field controls the number of microseconds
                            stack lines with the <literal>LM</literal> (lam
                            wait mode) bit set will wait for a LM from the
                            station specified.
                        </para>
                    </listitem>
                </varlistentry>     
            </variablelist>
           </refsect2>
           <refsect2>
            <title>Scaler Control register</title>
            <para>
                The manual (3.3.4) refers to this as tyhe ACS control register,
                its function, however is to determine when the scaler
                (Auxilliary stack) is triggered.
                There are two fields. Both can be non-zero allowing for two
                trigger conditions.  One trigger condition allows scalers to
                be triggered after a fixed number of events have been read.
                The second condition allows readout of scalers at fixed time
                intervals.
            </para>
            <para>
                If a field is zero, that trigger condition is disabled.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::ScalerControlRegister::eventsCountMask</varname>
                            <initializer>0xffff</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::ScalerControlRegister::eventsCountShift</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Define the field that controls scaler triggers
                            every fixed number of events.  If this field is
                            non zero, it specifies the number of events
                            between scaler reads.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type> uint32_t</type>
                            <varname>CCCUSB::ScalerControlRegister::timeIntervalMask</varname>
                            <initializer>0xff0000</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::ScalerControlRegister::timeIntervalShift</varname>
                            <initializer>16</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the field that sets up the time periodic
                            trigger.  If this is nonzero, it represents the
                            scaler readout period in 0.5second units.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>LED Source Register</title>
            <para>
                This register contains a set of bit fields that describe
                the signal source that lights each of the LEDs on the front
                panel.  Normally this register will be written with a logical
                or of values of one item from each bit field.  The fields
                are named after the colors of the LED each field controls.
            </para>
            <note>
                <title>Firmware changes</title>
                <para>
                    It appears that these definitions are for firmware
                    revisions &lt; 1.01.  These definitions will be updated
                    in the future to reflect the updated definitions.
                </para>
            </note>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>  <type> uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redEventTrigger</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The red LED will light on an event trigger.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redBusy</varname>
                            <initializer>1</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The red led will light when the CC-USB is busy.
                            Busy means that the CC-USB is processing the event
                            or scaler stack.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redUSBTrigger</varname>
                            <initializer>2</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the red LED when the software requests a USB
                            trigger of the event stack by writing the
                            <varname>CCCUSB::ActionRegister::usbTrigger</varname>
                            bit to the action register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redUSBOutFifoNotEmpty</varname>
                            <initializer>3</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the red LED whenever the USB output fifo
                            is not empty.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redUSBInFifoNotFull</varname>
                            <initializer>4</initializer>
                        </fieldsynopsis>
                        </term>
                    <listitem>
                        <para>
                            Lights the red led whenever the USB input fifo is not
                            ful.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redAcquire</varname>
                            <initializer>6;</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the red LED when acquisition mode is turned on
                            (that is the last write to the action register
                            set the
                            <varname>CCCUSB::ActionRegister::startDAQ</varname> bit).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redCAMACF2</varname>
                            <initializer>7</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the red LED whenever the 2's bit is set in the
                            current CAAMC function being performed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redInvert</varname>
                            <initializer>0x10</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Inverts the state of the read LED.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redLatch</varname>
                            <initializer>0x20</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            When the trigger condition for the led exists, latches the
                            led on until this bit is toggled off then on.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::greenAcquire</varname>
                            <initializer>0x000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Sets the green LED when data acquisition is enabled.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::greenCAMACF1</varname>
                            <initializer>0x100</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Sets the green LED whe the F1 line is set on the last
                            CAMAC operation.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::greenEventTrigger</varname>
                            <initializer>0x300</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Turns on the green LED whenever the event trigger is
                            being processed.
                        </para>
                        </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname> CCCUSB::LedSourceRegister::greenCAMACN</varname>
                            <initializer>0x400</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the green LED whhen a CAMAC operation has occured.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::greenI1</varname>
                            <initializer>0x600</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the green LED if the I1 input has a NIM
                            true presented on it.
                        </para>
                    </listitem>
                    </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::greenUSBInFifoNotEmpty</varname>
                            <initializer>0x700</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the green LED if the input FIFO is not empty.
                        </para>
                    </listitem>
                    </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::greenInvert</varname>
                            <initializer>0x1000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Invert the sense of the green led.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::greenLatch</varname>
                            <initializer>0x2000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Latch the green led.  When the condition to light the
                            LED occurs, the led stays on until this bit is
                            toggled off (and then back on if the latch condition
                            should be re-established).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowI3</varname>
                            <initializer>0x00000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Light the yellow LED if the I3 input is active.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowBusy</varname>
                            <initializer>0x10000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Ligths the yellow  LED when the CC-USB is busy
                            executing one of the command stacks.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowI2</varname>
                            <initializer>0x20000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Light the Yellow LED when the I2 input is active.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowCAMACS1</varname>
                            <initializer>0x30000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the yellow LED when the S1 signal on the CAMAC
                            dataway is active.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowCAMACS2</varname>
                            <initializer>0x40000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the yellow LED when the CAMAC S2 dataway line
                            is active.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowUSBInFifoNotEmpty</varname>
                            <initializer>0x50000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the Yellow LED when the USB input FIFO
                            is not empty.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowScalerReadout</varname>
                            <initializer>0x60000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the Yellow led when the scaler stack is
                            being executed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowUSBTrigger</varname>
                            <initializer>0x70000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the yellow LED when event stack execution
                            has been requested by a USB write to the Action
                            register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowInvert</varname>
                            <initializer>0x100000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Inverts the sense of the Yellow LED.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowLatch</varname>
                            <initializer>0x200000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Enables latch mode for the yellow LED.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>Output source selection register.</title>
            <para>
                This register has several coded bit fields that select
                which signals are presented at the module nim outputs
                O1, O2, and O3.
            </para>
            <note>
                <title>Firmware &lt; 1.01</title>
                <para>
                    Thie definitions shwon here are only valid for firmware
                    revisions &lt; 1.01.  This section and the header files
                    themselves must be updated to reflect the current
                    reduced set of output functionality.
                </para>
            </note>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO1Busy</varname>
                            <initializer>0x000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            O1 is asserted when the CC-USB is executing a stack.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO1EventTrigger</varname>
                            <initializer>0x000001</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Ouptut 1 reflects that an event trigger has been
                            recently received.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO1DGGA</varname>
                            <initializer>0x000002</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            O1 reflets the output gate and delay generator A.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO1DGGB</varname>
                            <initializer>0x000003</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            O1 reflects the output of gate and delay generator
                            B.
                            </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO1Latch</varname>
                            <initializer>0x000010M</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            O1 is latched when set until this bit is toggled.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>    <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO1Invert</varname>
                            <initializer>0x000020</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            O1 is inverted relative to the code that selets its
                            output.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO2Acquire</varname>
                            <initializer>0x000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Asserts O1 when acquisition mode is turned on via
                            the action register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>   <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO2Event</varname>
                            <initializer>0x000200</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Turns O2 on when an event trigger has been recently
                            received.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO2DGGA</varname>
                            <initializer>0x000400</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reflects the output of gate and delay generator A
                            in the O2 output.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO2DGGB</varname>
                            <initializer>0x000600</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reflects the output of gate and delay generator B
                            to the O2 output.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO2Latch</varname>
                            <initializer>0x001000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Sets the O2 register in latching mode.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO2Invert</varname>
                            <initializer>0x002000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Inverts the sense of O2.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO3EndOfBusy</varname>
                            <initializer>0x000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Asserts O3 when busy ends.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO3Busy</varname>
                            <initializer>0x020000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Asserts O3 when the CC-USB is executing a stack.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO3DGGA</varname>
                            <initializer>0x040000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            O3 reflects the output of gate and delay generator A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternim03DGGB</varname>
                            <initializer>0x060000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            O3 reflects the state of gate and delay generator B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO3Latch</varname>
                            <initializer>0x100000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Latches the state of O3.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO3Invert</varname>
                            <initializer>0x200000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Inverts the sense of the O3 output.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>Device source register</title>
            <para>
                This register contains several fields that control the
                input sources to the scalers and gate and delay generators
                implemented in the CC-USB.  The register contains four fields
                which are called <literal>scalerA</literal>, <literal>scalerB</literal>
                <literal>dggA</literal>  and <literal>dggB</literal>. Typically
                you will bitwise or a code from each of the fields.  In the case
                of the scaler fields there are three bits, <literal>Enable</literal>,
                <literal>Reset</literal>, and <literal>FreezeReg</literal>
                that can also be ored into the codes.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerADisabled</varname>
                            <initializer>0x00000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Scale A has no input, effectively disabling it.
                            Note that if code is not use you will need
                            to set the enable bit as well to enable the scaler
                            to count.
                            </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAI1</varname>
                            <initializer>0x00000001</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects I1 as the input to Scaler A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAI2</varname>
                            <initializer>0x00000002</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects I2 as the input to scaler A.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAI3</varname>
                            <initializer>0x00000003</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects I3 to be the input to scalerA.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>   <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAEvent</varname>
                            <initializer>0x00000004</initializer>
                        </fieldsynopsis>
                        </term>
                    <listitem>
                        <para>
                            Selects the event trigger to be the source for
                            Scaler A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerACarryB</varname>
                            <initializer>0x00000005</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects the carry out of scalerB to increment
                            ScalerA  this allows you to gang ScalerB (LSBs)
                            and Scaler A (MSBs) into a single 48 bit scaler.
                        </para>
                    </listitem>
                    </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerADGGA</varname>
                            <initializer>0x00000006</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Scaler A will count when DGGA snds an output pulse.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerADGGB</varname>
                            <initializer>0x00000007</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Counts scaler A when when DGGB sends an output pulse.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const </modifier><type> uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAEnable</varname>
                            <initializer>0x00000010</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Enables Scaler A to count.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAScalerAReset</varname>
                            <initializer>0x00000020</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Resets scaler A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAFreezReg</varname>
                            <initializer>0x00000040</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Any operation that writes this register with this
                            bit set will not modify the effective code for selecting
                            the inputs for scaler A.  This allows you to enable/disable/clear
                            scaler A without needing to know the actual
                            scaler source.  Note that since there is no
                            corresponding freeze bit for the dggA/B sources this
                            capability is of limited utility.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBDisabled</varname>
                            <initializer>0x00000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Directs to inputs to Scaler B.  Note that if another
                            input is used it's still necessary to also set
                            the <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBEnable</varname>
                            bit to enable the scaler to count.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBI1</varname>
                            <initializer>0x00000100</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            I1 is the input to ScalerB.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBI2</varname>
                            <initializer>0x00000200</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects I2 as the input for Scaler B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBI3</varname>
                            <initializer>0x00000300</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selecst I3 as the input for Scaler B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBEvent</varname>
                            <initializer>0x00000400</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects the event trigger as the input for
                            scaler B.  Presumably using this allows the scaler
                            to count the number of events acquired.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBCarryA</varname>
                            <initializer>0x00000500</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects the carry from Scaler A as the input to
                            scalerB this enables the use of ScalerA/B as
                            a 48 bit scaler with the LSBs in ScalerA
                            and MSBs in ScalerB.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBDGGA</varname>
                            <initializer>0x00000600</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Enables the output of gate and delay generator A
                            to be the input to scaler B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBDGGB</varname>
                            <initializer>0x00000700</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Enables the output of gate and delay generator B
                            to be the input of scaler B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBEnable</varname>
                            <initializer>0x00001000</initializer>
                            </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This bit can be ored in with the selected Scaler B
                            code values.  It enables scaler B to count.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBReset</varname>
                            <initializer>0x00002000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Resets scaler B
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBFreezeReg</varname>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Freezes the scaler B input selector field.  This
                            allows one to write Reset and Enable bits without
                            disturbing the event source.  Note that you still
                            must regenerate the DGGA and DGGB source selectors.
                        </para>
                        </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggADisabled</varname>
                            <initializer>0x00000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Provides no input signal to Gate and delay generator
                            A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAI1</varname>
                            <initializer>0x00010000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Routes the I1 front panel input to the input of
                            gate and delay generator A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAI2</varname>
                            <initializer>0x00020000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Routes the I2 front panel input to the input of
                            gate and delay generator A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAI3</varname>
                            <initializer>0x00030000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Routes the I3 front panel input to the input of
                            gate and delay generator A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAEvent</varname>
                            <initializer>0x00040000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Routes the event trigger to the input of
                            gate and delay generator A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAEndOfEvent</varname>
                            <initializer>0x00050000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Pulses the inpt of gate and delay generator A when
                            event readout has completed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAUSBTrigger</varname>
                            <initializer>0x00060000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Pulses the input of gate and delay generator A
                            when a USB stack trigger is written to the
                            action register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAPulser</varname>
                            <initializer>0x00070000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Pulses the input of gate and delay generator A
                            from the output of the pulser.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBDisabled</varname>
                            <initializer>0x00000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Provides no input to gate and delay generator B.
                            </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBI1</varname>
                            <initializer>0x01000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Routes the I1 input signal to the input of
                            Gate and delay generator B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBI2</varname>
                            <initializer>0x02000000</initializer>
                        </fieldsynopsis>
                   </term>
                    <listitem>
                        <para>
                            Routes the I2 input signal to the input of
                            Gate and delay generator B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBI3</varname>
                            <initializer>0x03000000</initializer>
                        </fieldsynopsis>
                   </term>
                    <listitem>
                        <para>
                            Routes the I3 input signal to the input of
                            Gate and delay generator B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBEvent</varname>
                            <initializer>0x04000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Puses the input of gate and delay generator B
                            when an event trigger is processed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBEndOfTrigger</varname>
                            <initializer>0x05000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Pulses the input of DGGB at the end of processing
                            an event trigger.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBUSBTrigger</varname>
                            <initializer>0x06000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Pulses the input of gate and delay generator B
                            when a USB trigger is written to the Actino regsiter.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBPulser</varname>
                            <initializer>0x07000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Connects the pulser output to the input of gate
                            and delay generator B
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>Gate and delay generator and pulser set up registers.
            </title>
            <para>
                Several registers are used to set the timing of gate and
                delay registers.  The timing parameters for gate and delay
                generator A also determine the timing for the pulser as showin
                in section 3.3.7 of the CC-USB manual.
            </para>
            <para>
                This section describes the bit fields in these registers.
                Each field is descdribed as a mask and shift count.
                The mask removes all extraneous bits from the register except
                the desired field and the shift count, when used to shift the
                result right right justifies the field data.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DGGAndPulserRegister::dggFineDelayMask</varname>
                            <initializer>0xffff</initializer>
                        </fieldsynopsis>                            
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DGGAndPulserRegister::dggFineDelayShift</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the fine delay field.  See the course delays
                            below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DGGAndPulserRegister::dggGateWidthMask</varname>
                            <initializer>0xffff0000</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DGGAndPulserRegister::dggGateWidthShift</varname>
                            <initializer>16</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the gate width field.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DGGCoarseRegister::ACoarseMask</varname>
                            <initializer>xffff;</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DGGCoarseRegister::ACoarseShift</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the course delay fields for the a pulser.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DGGCoarseRegister::BCoarseMask</varname>
                            <initializer>0xffff0000</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DGGCoarseRegister::BCoarseShift</varname>
                            <initializer>16</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the B course delay field.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>Transfer setup register</title>
            <para>
                This regiseter allows you to read several buffers from the
                CC-USB in a single read, as well as setting a time bound
                on how long before the CC-USB terminates a multibuffer read.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCCUSB::TransferSetupRegister::multiBufferCountMask</varname>
                            <initializer>0xff</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type> uint32_t </type>
                            <varname>CCCCUSB::TransferSetupRegister::multiBufferCountShift</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the number of buffers that can be batched
                            into a single usb_bulk_read request.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type> uint32_t</type>
                            <varname>CCCCUSB::TransferSetupRegister::timeoutMask</varname>
                            <initializer>0xf00</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCCUSB::TransferSetupRegister::timeoutShift</varname>
                            <initializer>8</initializer>
                        </fieldsynopsis>
                        </term>
                    <listitem>
                        <para>
                            Determines the number of seconds after which
                            the CC-USB will terminate a bulk transfer if not
                            all of the buffers determined by themultiBuffer
                            count have been transferred.
                            </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>X and Q</title>
            <para>
                The <parameter>qx</parameter> parameter on the simple
                CAMAC operations allow you access to the dataway
                Q and X lines.  The bit encoding of that parameter is:
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::Q</varname>
                            <initializer>1</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            If this bit was set in the <parameter>qx</parameter>
                            parameter, the module asserted a Q on the dataway.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::X</varname>
                            <initializer>2</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            If this bit is set in the <parameter>qx</parameter>
                            parameter, the module asserted an X on the dataway.
                        </para>
                    </listitem>
                    </varlistentry>
            </variablelist>
           </refsect2>    
        </refsect1>
        <refsect1>
            <title>SEE ALSO</title>
            <para>
                <xref linkend='ccusb3-CCCUSBReadoutList' />
            </para>
        </refsect1>
     </refentry>
         
	 <refentry id="ccusb3-CCCUSBReadoutList">
       <refmeta>
          <refentrytitle>CCCUSBReadoutList</refentrytitle>
          <manvolnum>3ccusb</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CCCUSBReadoutList</refname>
          <refpurpose>Create lists of CAMAC commands for CC-USB controllers.</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>
            class <ooclass><classname>CCCUSBReadoutList</classname></ooclass> {          
           <constructorsynopsis>
          <methodname> CCCUSBReadoutList</methodname>
          <void />
           </constructorsynopsis>
           <constructorsynopsis>
            <methodname> CCCUSBReadoutList</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CCCUSBReadoutList&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
           </constructorsynopsis>
            <methodsynopsis>
                <type>std::vector&lt;uint16_t&gt;</type>
                <methodname>get</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>size_t</type> <methodname>size</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>clear</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type><methodname>addWrite16</methodname>
                <methodparam>
                    <type>int</type><parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t</type> <parameter>data</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addWrite24</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>data</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addRead16</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type><parameter>lamWait</parameter>
                    <initializer>false</initializer>
                </methodparam>
            </methodsynopsis>           
            <methodsynopsis>
                <type>void</type> <methodname>addRead24</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type><parameter>lamWait</parameter>
                    <initializer>false</initializer>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addControl</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addQStop</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t</type> <parameter>max</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type><parameter>lamWait</parameter>
                    <initializer>false</initializer>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addQStop24</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t</type> <parameter>max</parameter>
                </methodparam>

                <methodparam>
                    <type>bool</type><parameter>lamWait</parameter>
                    <initializer>false</initializer>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addQScan</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t</type> <parameter>max</parameter>
                </methodparam>                
                <methodparam>
                    <type>bool</type><parameter>lamWait</parameter>
                    <initializer>false</initializer>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addRepeat</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type><parameter>lamWait</parameter>
                    <initializer>false</initializer>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addMarker</methodname>
                <methodparam>
                    <type>uint16_t</type> <parameter>value</parameter>
                </methodparam>
           </methodsynopsis>
           };
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            <classname>CCCUSBReadoutList</classname> provides a class whose instances can
            build up lists (stacks) of CAMAC operations that can either be
            submitted to a CC-USB for direct execution via <methodname>CCCUSB::executeList</methodname>,
            or loaded as an event or scaler stack via <methodname>CCCUSB::loadStack</methodname>.
          </para>
       </refsect1>
       <refsect1>
          <title>METHODS</title>
            <variablelist>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                       <methodname>CCCUSBReadoutList</methodname>
                       <void />
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Constructs a new readout list.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                         <methodname>CCCUSBReadoutList</methodname>
                         <methodparam>
                             <modifier>const</modifier> <type>CCCUSBReadoutList&amp;</type>
                             <parameter>rhs</parameter>
                         </methodparam>
                        </constructorsynopsis>
                        </term>
                    <listitem>
                        <para>
                            Constructs a readout list that will be a duplicate
                            of the readout list in <parameter>rhs</parameter>
                            (Copy construction).
                        </para>
                        </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>std::vector&lt;uint16_t&gt;</type>
                             <methodname>get</methodname>
                             <void /><modifier>const</modifier>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns a <type>std::list&lt;uint16_t&gt;</type> where
                            each element of the list is a stack line that has
                            been built up so far.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>size_t</type> <methodname>size</methodname>
                             <void /><modifier>const</modifier>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the number of <type>uint16_t</type>
                            stack lines built so far.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>clear</methodname>
                             <void />
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Clears the stack.  Once this is performed, the object
                            represents an empty stack.
                            </para>
                        </listitem>
                </varlistentry>     
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type><methodname>addWrite16</methodname>
                             <methodparam>
                                 <type>int</type><parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>uint16_t</type> <parameter>data</parameter>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Adds a 16 bit CAMAC write opearation to the list.
                            <parameter>n,a,f</parameter> specify the
                            slot, subaddress and function code respectively.
                            The <parameter>data</parameter> parameter is transferred
                            to the device when the command is executed.
                            Note that this method does not perform any CAMAC operations.
                            The specified operation is simply encoded as stack lines
                            in the object.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addWrite24</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>uint32_t</type> <parameter>data</parameter>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>addWrite16</methodname> however
                            the least significant 24 bits of <parameter>data</parameter>
                            will be written when this stack line is executed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addRead16</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>bool</type><parameter>lamWait</parameter>
                                 <initializer>false</initializer>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            A 16 bit read operation whose slot, subaddress
                            and function code are specified by <parameter>n,a,f</parameter>
                            is encoded as a stack line and added to the list.
                            If the stack line is executed in immediate mode
                            (via <methodname>CCCUSB::executeList</methodname>),
                            the data read will be put in the input buffer passed
                            to that method.  IF the stack line loaded as a scaler
                            or event stack asnd executed in response to the appropriate
                            trigger condition, the data are put in the event buffer.
                        </para>
                        <para>
                            If the <parameter>lamWait</parameter>  parameter is
                            <literal>true</literal> the stack will stall until
                            either the lam timeout period is reached or the
                            slot the operation is directed to signals its LAM.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addRead24</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>bool</type><parameter>lamWait</parameter>
                                 <initializer>false</initializer>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>addRead16</methodname>, however a
                            <type>uint32_t</type>
                            is put in the buffer (event or buffer given to
                            <methodname>CCCUSB::executeStack</methodname> depending
                            on why the stack is being executed).  The format
                            of the uint32_t is shown in the figure just at the
                            end of chapter 4 of the CC-USB manual:
                            The bottom 24 bits are the data transferred from the
                            module.  Bit 24 is set if there was a Q response
                            and bit 25 is set if there was an X response
                            (bits are numbered from 0 least significant bit
                            is bit 0).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addControl</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Adds a non data transfer operation to the stack.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addQStop</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                            <methodparam>
                                <type>uint16_t</type> <parameter>max</parameter>
                            </methodparam>
                             <methodparam>
                                 <type>bool</type><parameter>lamWait</parameter>
                                 <initializer>false</initializer>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Adds a Q-stop block transfer to the stack.  Q-stop
                            operations perform the same <parameter>n,a,f</parameter>
                            read operation until either the module does not
                            return a Q response or until the <parameter>max</parameter>
                            number of transfers specified have been performed.
                            The <parameter>lamWait</parameter> parameter allows
                            you to wait for a LAM from the targe module before
                            doing the transfer.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addQStop24</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                            <methodparam>
                                <type>uint16_t</type> <parameter>max</parameter>
                            </methodparam>
                             <methodparam>
                                 <type>bool</type><parameter>lamWait</parameter>
                                 <initializer>false</initializer>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>addQStop</methodname> except
                            that 24 bits of data are transferred on each
                            operation.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addQScan</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                            <methodparam>
                                <type>uint16_t</type> <parameter>max</parameter>
                            </methodparam>
                             <methodparam>
                                 <type>bool</type><parameter>lamWait</parameter>
                                 <initializer>false</initializer>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a Q-scan (sometimes called an address
                            scan) operation.  <parameter>n,a,f</parameter>
                            specify a starting slot, subaddress and function code.
                            After each operation a is incremented.   The CC-USB
                            documentation does not make it clear if this is a
                            full Q-Scan (ACA) operation as defined by the ESONE
                            block transfer specification.  If this operation is
                            a full address scan, then after each operation, the
                            subaddress is incremented.  If A was 15 or a Q=0
                            response occured, the
                            subaddress should be set to 0 and the slot incremented.
                            This continues until either <parameter>max</parameter>
                            transfers have occured or both Q and X are zero.
                        </para>
                        <para>
                            The documentation only describes the subadress as
                            being incremented so that may be all you can count on
                            for this opertaion.  It also does not provide a statement
                            about what happens when Q=0 or X=0.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addRepeat</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                            <methodparam>
                                <type>uint16_t</type> <parameter>max</parameter>
                            </methodparam>                             
                             <methodparam>
                                 <type>bool</type><parameter>lamWait</parameter>
                                 <initializer>false</initializer>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a block repeat operation.  The specified
                            CAMAC operation is performed <parameter>max</parameter>
                            times regardless of the X/Q responses.
                        </para>
                    </listitem>
                    </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addMarker</methodname>
                             <methodparam>
                                 <type>uint16_t</type> <parameter>value</parameter>
                             </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The literal word <parameter>value</parameter> is
                            written to the output buffer.
                        </para>
                    </listitem>
                </varlistentry>             

            </variablelist>
       </refsect1>
        <refsect1>
           <title>SEE ALSO</title>
           <para>
            <xref linkend='ccusb3-CCCUSB' />
            </para>
        </refsect1>
    </refentry>
         
    <refentry id="ccusb3-CConfigurableObject">
       <refmeta>
          <refentrytitle id="ccusb3-CConfigurableObject-title">CConfigurableObject</refentrytitle>
          <manvolnum>3ccusb</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CConfigurableObject</refname>
          <refpurpose>base class for devices that have a configuration</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>
            class <ooclass><classname>CConfigurableObject</classname></ooclass> {
           <constructorsynopsis>
          <methodname>CConfigurableObject</methodname>
          <methodparam>
            <type>std::string</type> <parameter>name</parameter>    
          </methodparam>
        </constructorsynopsis>
        <methodsynopsis>
            <type>std::string </type> <methodname>getName</methodname>
            <void /><modifier> const</modifier>
            </methodsynopsis>
        <methodsynopsis>
            <type>std::string</type> <methodname>cget</methodname>
            <methodparam>
                <type>std::string</type>  <parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>ConfigurationArray</type> <methodname>cget</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>getIntegerParameter</methodname>
            <methodparam>
                <type>std::string</type><parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>unsigned int</type> <methodname> getUnsignedParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>bool</type> <methodname>getBoolParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>double</type> <methodname>getFloatParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>std::vector&lt;int&gt;</type><methodname>getIntegerList</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addParameter</methodname>
            <methodparam>
                <type>std::string</type><parameter> name</parameter>
            </methodparam>
            <methodparam>
                <type>typeChecker</type> <parameter>checker</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>defaultValue</parameter>
                <initializer>std::string("")</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>clearConfiguration</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>configure</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addIntegerParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>defaultVal</parameter>
                <initializer>0</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addIntegerParameter</methodname>
            <methodparam>
                <type>std::string</type>  <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>low</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>high</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>defaultVal</parameter>
                <initializer>0</initializer>
                </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addBooleanParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>bool</type> <parameter>defaultVal</parameter>
                <initializer> true</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type><methodname>addEnumParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <modifier>const</modifier> <type>char**</type>
                <parameter>pValues</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>defaultValue</parameter>
                <initializer>std::string("")</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type><methodname>addBoolListParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>unsigned</type><parameter>size</parameter>
            </methodparam>
            <methodparam>
                <type>bool</type>   <parameter> defaultVal</parameter>
                <initializer>true</initializer>
            </methodparam>
            </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addBoolListParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>unsigned</type> <parameter>minLength</parameter>
            </methodparam>
            <methodparam>
                <type>unsigned</type> <parameter>maxLength</parameter>
            </methodparam>
            <methodparam>
                <type>bool</type> <parameter>defaultVal</parameter>
                <initializer>true</initializer>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter> defaultSize</parameter>
                <initializer>-1</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addIntListParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>unsigned</type> <parameter>size</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>defaultVal</parameter>
                <initializer>0</initializer>
            </methodparam>
            </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addIntListParameter</methodname>
            <methodparam>
                <type>std::string</type>  <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>unsigned</type> <parameter>minlength</parameter>
            </methodparam>
            <methodparam>
                <type>unsigned</type> <parameter>maxLength</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>defaultVal</parameter>
                <initializer>0</initializer>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>defaultSize</parameter>
                <initializer>-1</initializer>
            </methodparam>
            </methodsynopsis>
        <methodsynopsis>
            <type>void</type><methodname>addBooleanParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>bool</type> <parameter>defaultVal</parameter>
                <initializer>true</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addEnumParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <modifier>const</modifier> <type>char**</type>
                <parameter>pValues</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>defaultValue</parameter>
                <initializer>std::string("")</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addBoolListParameter</methodname>
            <methodparam>
                <type>std::string</type>  <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>unsigned</type> <parameter>size</parameter>
            </methodparam>
            <methodparam>
                <type>bool</type> <parameter>defaultVal</parameter>
                <initializer>true</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
         <type> void</type> <methodname>addBoolListParameter</methodname>
         <methodparam>
           <type>std::string</type> <parameter>name</parameter>
         </methodparam>
         <methodparam>
           <type>unsigned</type> <parameter>minLength</parameter>
         </methodparam>
         <methodparam>
           <type>unsigned</type> <parameter>maxLength</parameter>
         </methodparam>
         <methodparam>
            <type>bool</type> <parameter>defaultVal</parameter> 
            <initializer>true</initializer>
         </methodparam>
         <methodparam>
            <type>int</type> <parameter>defaultSize</parameter>
            <initializer>-1</initializer>
         </methodparam>
       </methodsynopsis>
       <methodsynopsis>
         <type>void</type> <methodname>addIntListParameter</methodname>
         <methodparam>
            <type>std::string</type> <parameter>name</parameter>
         </methodparam>
         <methodparam>
            <type>unsigned</type> <parameter>size</parameter>
         </methodparam>
         <methodparam>
            <type>int</type> <parameter>defaultVal</parameter>
            <initializer>0</initializer>
         </methodparam>
      </methodsynopsis>
      <methodsynopsis>
         <type>void</type> <methodname>addIntListParameter</methodname>
         <methodparam>
            <type>std::string</type> <parameter>name</parameter>
         </methodparam>
         <methodparam>
            <type>unsigned</type> <parameter>minlength</parameter>
         </methodparam>
         <methodparam>
            <type>unsigned</type> <parameter>maxLength</parameter>
         </methodparam>
         <methodparam>
            <type>int</type> <parameter>defaultVal</parameter>
            <initializer>0</initializer>
         </methodparam>
         <methodparam>
            <type>int</type> <parameter>defaultSize</parameter> 
            <initializer>-1</initializer>
         </methodparam>
      </methodsynopsis>
      <methodsynopsis>
        <type>void</type> <methodname>addStringListParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>size</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>defaultVal</parameter>
            <initializer>""</initializer>
        </methodparam>
      </methodsynopsis>
      <methodsynopsis>
        <type>void</type> <methodname>addStringListParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>minLength</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>maxLength</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>defaultVal</parameter>
            <initializer>""</initializer>
        </methodparam>
        <methodparam>
            <type>int</type> <parameter>defaultLength</parameter>
            <initializer>-1</initializer>
        </methodparam>
      </methodsynopsis>
      <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isInteger</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type><parameter>arg</parameter>
        </methodparam>
      </methodsynopsis>
      <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isBool</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
      </methodsynopsis>
      <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isEnum</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isList</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isBoolList</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isIntList</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isStringList</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>isEnumParameter</type>
        <methodname>makeEnumSet</methodname>
        <methodparam>
            <modifier>const</modifier> <type>char**</type><parameter>values</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>strToBool</methodname>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <fieldsynopsis>
        <modifier>typedef</modifier> <type>std::pair&lt;typeChecker, void*&gt;</type>
        <varname>TypeCheckInfo</varname>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>typedef</modifier>
        <type>std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt;</type>
        <varname>ConfigurationArray</varname>
    </fieldsynopsis>
    

      struct  <type>limit</type> {
      <fieldsynopsis>
          <type>bool</type>   <varname>s_checkMe</varname>
      </fieldsynopsis>
      <fieldsynopsis>
          <type>long</type> <varname>s_value</varname>
      </fieldsynopsis>
      <constructorsynopsis>
          <methodname>limit</methodname>
          <void />
      </constructorsynopsis>
      <constructorsynopsis>
          <methodname>limit</methodname>
          <methodparam>
              <type>long</type>    <parameter>value</parameter>
          </methodparam>
      </constructorsynopsis>
    } ;
    <fieldsynopsis>
        <modifier>typedef</modifier>
        <type>std::pair&lt;limit, limit&gt;</type><varname>Limits</varname>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>typedef</modifier>
        <type>std::set&lt;std::string&gt;</type> <varname>isEnumParameter</varname>
    </fieldsynopsis>
    typedef struct <type>_ListSizeConstraint</type> {
        <fieldsynopsis>
            <type>limit</type> <varname>s_atLeast</varname>
        </fieldsynopsis>
        <fieldsynopsis>
            <type>limit</type> <varname>s_atMost</varname>
        </fieldsynopsis>
    } <type>ListSizeConstraint</type>
    typedef struct <type>_isListParameter</type> {
      <fieldsynopsis>
        <type>ListSizeConstraint</type> <varname>s_allowedSize</varname>
      </fieldsynopsis>
      <fieldsynopsis>
        <type>TypeCheckInfo</type> <varname>s_checker</varname>
      </fieldsynopsis>
    } <type>isListParameter</type>;
    <fieldsynopsis>
        <modifier>typedef</modifier>
            <type>void</type><varname>(*ConstraintFreer)(void*)</varname>
    </fieldsynopsis>

     typedef struct <type>_DynamicConstraint</type> { 
      <fieldsynopsis>
        <type>ConstraintFreer</type> <varname>s_Releaser</varname>
      </fieldsynopsis>
      <fieldsynopsis>
        <type>void*</type> <varname>s_pObject</varname>
      </fieldsynopsis>
    } <type>DynamicConstraint</type>, <type>*pDynamicConstraint</type>;
  
    struct  <type>flimit</type> {
      <fieldsynopsis>
        <type>bool</type>   <varname>s_checkMe</varname>
      </fieldsynopsis>
      <fieldsynopsis>
        <type>float</type> <varname>s_value</varname>
      </fieldsynopsis>
      <constructorsynopsis>
        <methodname>flimit</methodname><void />
      </constructorsynopsis>    
      <constructorsynopsis>
        <methodname>flimit</methodname>
        <methodparam>
            <type>float</type> <parameter>value</parameter>
        </methodparam>
      </constructorsynopsis>    
    };
    <fieldsynopsis>
        <modifier>typedef</modifier> <type>std::pair&lt;flimit, flimit&gt;</type>
        <varname>FloatingLimits</varname>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>typedef</modifier> <type>std::vector&lt;isEnumParameter*&gt;</type>
        <varname>EnumCheckers</varname>
    </fieldsynopsis>

};
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            This class is the ultimate base class of the <classname>CReadoutModule</classname>
            object passed to device driver <methodname>onAttach</methodname> methods.
            It manages the configuration database of a configurable object.
          </para>
          <para>
            The interaction of a configurable object or an object that embeds
            configuration via delegation is:
            <orderedlist>
                <listitem>
                    <para>
                        The object defines a configuration that consists of
                        a set of named parameters and initial values.  Each
                        configuration value can have a constraint function
                        attached to it that is called prior to allowing the
                        value to assume a new value.
                    </para>
                    <para>
                        Through these constraint functions parameter values can'
                        be very strongly typed (e.g. not just parameter
                        must be an integer but parameter must be an integer
                        in this range).
                    </para>
                    <para>
                        Pre packaged constraint functions and convenience functions
                        make it easy to set up most types of constraints, however
                        if something special is required client code can implement
                        a special constraint.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        At some point in the lifetime of a configurable object,
                        the object is configured.  This is usually done by creating
                        (the CCUSB framework does this for you) a command or
                        command ensemble that accepts configuration name/value
                        pairs and passes them to the <methodname>configure</methodname>
                        method.  This method will invoke the constraint checker
                        and, if successful, modify the value of the configuration
                        parameter.  If the new value fails the constraint, a
                        <type>std::string</type> exception is thrown and should
                        be caught and reported at some level by the caller.
                    </para>
                    <para>
                        Again for CCUSB device drivers this is transparent.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Configurable objects can query their configuration.
                        The constraint checkers ensure that each value has
                        the type and range constraints required of that parameter.
                        Semantics, however must be enforced and applied
                        by the object that
                        uses the configuration.
                    </para>
                    <para>
                        It is always possible to get a stringified value for
                        each configuration item (in fact configuration items
                        are stored as strings).  Convenience methods allow
                        for clients to fetch conversions of those strings to
                        a rich set of types.
                    </para>
                    <para>
                        CCUSB device drivers normally fetch and process their
                        configurations when their
                        <methodname>Initialize</methodname>
                        and <methodname>addReadoutList</methodname> methods
                        are invoked.
                    </para>
                </listitem>
            </orderedlist>
          </para>
          <para>
            For the full set of methods see the METHODS section below.  The
            pre-defined constraint checkers additionally make use of
            several data types which are described in
            PUBLIC VARIABLES, TYPES and CONSTANTS further below.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                   <methodname>CConfigurableObject</methodname>
                   <methodparam>
                     <type>std::string</type> <parameter>name</parameter>    
                   </methodparam>
                 </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a configurable object.  CCUSB device
                        drivers have this construction performed for them.
                        Configurable objects have names to allow them to be
                        placed in some sort of configuration dictionary by the
                        application. the <parameter>name</parameter>
                        parameter supplies the configuration name.
                    </para>
                    <para>
                        If names are used, it's likely a good thing to ensure
                        that unique names are chose for each configuration
                        namespace the application maintains.  This is not
                        enforced by the constructor, however.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>std::string </type> <methodname>getName</methodname>
                     <void /><modifier> const</modifier>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the name of the configuration. This is the
                        value of the parameter passed to the constructor.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>std::string</type> <methodname>cget</methodname>
                     <methodparam>
                         <type>std::string</type>  <parameter>name</parameter>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the string value of the configuration parameter
                        <parameter>name</parameter>.  If the parameter was
                        not defined a string exception is thrown.
                    </para>
                    <para>
                        In situations where you don't know the set of configuration
                        parameters that have been defined, see the overloaded
                        <methodname>cget</methodname> method described next.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>CConfigurableObject::ConfigurationArray</type>
                     <methodname>cget</methodname>
                     <void />
                 </methodsynopsis>
                 </term>
                 <listitem>
                    <para>
                        Gets the entire configuration of the module as name
                        value pairs.
                        <type>CConfigurableObject::ConfigurationArray</type> is
                        described fully in PUBLIC VARIABLES, TYPES and CONSTANTS
                        below, however you can think iof it as a vector of
                        <type>std::string</type> pairs of configuration
                        parameter name and value.
                    </para>
                 </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>int</type> <methodname>getIntegerParameter</methodname>
                     <methodparam>
                         <type>std::string</type><parameter>name</parameter>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Invokes <methodname>cget</methodname> on the
                        <parameter>name</parameter> configuration parameter.
                        The resulting string is converted to an integer and
                        returned, if possible.  If the string is not a valid integer,
                        a string exception is thrown.
                    </para>
                    <para>
                        Note that this and other convenience methods for
                        getting parameter values converted to specific data
                        types pass any exceptions from <methodname>cget</methodname>
                        on up to the caller.
                    </para>
                </listitem>
                </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>unsigned int</type> <methodname> getUnsignedParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                         </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Same as <methodname>getIntegerParameter</methodname>,
                        however the conversion to an unsigned value is attempted.
                        This is recommended for e.g. base addresses.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>bool</type> <methodname>getBoolParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Invokes <methodname>cget</methodname> and attempts
                        to convert the resulting string to a <type>bool</type>
                        value which is returned if successful.   A rather
                        rich set of values can be converted to bools.
                    </para>
                    <informaltable>
                        <tgroup cols="2">
                        <colspec colname='string' /> <colspec colname='value' />
                        <thead>
                            <row>
                                <entry>String</entry>
                                <entry>Bool Value</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>true</entry><entry>true</entry>
                            </row>
                            <row>
                                <entry>yes</entry><entry>true</entry>
                            </row>
                            <row><entry>1</entry><entry>true</entry></row>
                            <row><entry>on</entry><entry>true</entry></row>
                            <row><entry>enabled</entry><entry>true</entry></row>
                            <row><entry>false</entry><entry>false</entry></row>
                            <row><entry>no</entry><entry>false</entry></row>
                            <row><entry>0</entry><entry>false</entry></row>
                            <row><entry>off</entry><entry>false</entry></row>
                            <row><entry>disabled</entry><entry>false</entry></row>
                        </tbody>
                        </tgroup>
                    </informaltable>
                    <para>
                        Failure to convert to a <type>bool</type> throws
                        a string exception.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>double</type> <methodname>getFloatParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Uses <methodname>cget</methodname> to retrieve the
                        value of the <parameter>name</parameter> configuration
                        parameter.  The string is converted to a
                        <type>float</type> and
                        returned.  If the string is not a valid
                        <type>float</type>, a string exception is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>std::vector&lt;int&gt;</type><methodname>getIntegerList</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Uses the <methodname>cget</methodname> method to
                        obtain the configuration parameter <parameter>name</parameter>.
                        The string is treated as a Tcl list which is composed
                        entirely of integers.  If this assumption is correct,
                        a <type>std::vector</type> of the integers that made
                        up the list is returned.  If the string is either
                        an invalid list or not entirely composed of elements
                        that can be converted to <type>int</type>,
                        a string exception is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>addParameter</methodname>
                     <methodparam>
                         <type>std::string</type><parameter> name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>typeChecker</type> <parameter>checker</parameter>
                     </methodparam>
                     <methodparam>
                         <type>void*</type> <parameter>arg</parameter>
                     </methodparam>
                     <methodparam>
                         <type>std::string</type> <parameter>defaultValue</parameter>
                         <initializer>std::string("")</initializer>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is the base mechanism for defining a configuration
                        parameter. See the convenience methods below before using
                        this as they may be easier to use.
                    </para>
                    <para>
                        <parameter>name</parameter>  is the name of the parameter
                        being added.  By convention, this starts with the
                        <literal>-</literal> character (like options in Tk).
                        For example a module slot might be defined as a
                        <literal>-slot</literal> configuration parameter.
                    </para>
                    <para>
                        <parameter>checker</parameter> is a pointer to the
                        constraint checking function.  If no constraint checking
                        is required (e.g. the paramter is a pure string), pass
                        <literal>NULL</literal> for this parameter.
                    </para>
                    <para>
                        <parameter>arg</parameter>  is a parameter that is passed
                        without interpretation to the constraint checker.
                        See CONSTRAINT CHECKING below for more about how
                        constraint checkers are defined and called.
                        See also the descriptions of the built in constraint
                        checkers that are static members of this class, documented
                        later in this section.
                    </para>
                    <para>
                        <parameter>defaultValue</parameter> is the initial
                        value supplied to the parameter.  Note that this is
                        <emphasis>not</emphasis> constraint checked.  This is
                        intentional as it allows you to require a parameter
                        setting by providing an invalid initial parameter
                        value.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>clearConfiguration</methodname>
                     <void />
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Clear the configuration.  This removes any parameter
                        definitions as well as their value from the configuration
                        database.  In most cases this function is not necessary.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>configure</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>std::string</type> <parameter>value</parameter>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Attempts to configure a parameter <parameter>name</parameter>
                        should be a configuration parameter name that has been
                        defined by <methodname>addParameter</methodname> or its
                        convenience methods. <parameter>value</parameter>
                        is the new proposed value of the parameter.
                        The constraint checker, if any, is called for that parameter
                        and if it fails a string exception is thrown.  Otherwise,
                        the new parameter value replaces the old one.
                        </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>addIntegerParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter>defaultVal</parameter>
                         <initializer>0</initializer>
                     </methodparam>
                 </methodsynopsis>
                 </term>
                <listitem>
                    <para>
                        Convenience method to add an parameter
                        <parameter>name</parameter>  which is constrained
                        to be an integer parameter that has no range
                        requirements.  The initial value of this parameter
                        will be <parameter>defaultVal</parameter>
                        </para>
                    </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>addIntegerParameter</methodname>
                     <methodparam>
                         <type>std::string</type>  <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter>low</parameter>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter>high</parameter>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter>defaultVal</parameter>
                         <initializer>0</initializer>
                         </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Convenience methos that creates a parameter
                        (<parameter>name</parameter>) that is constrained
                        to be an integer in the range
                        [<parameter>low</parameter>..<parameter>high</parameter>].
                    </para>
                    <para>
                        The initial value of the parameters is set to
                        <parameter>defaultVal</parameter> which is not
                        checked against the limits.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>addBooleanParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>bool</type> <parameter>defaultVal</parameter>
                         <initializer> true</initializer>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a parameter <parameter>name</parameter> to the
                        configuration database which is contrained to be
                        a string that converts to a <type>bool</type>.
                        The initial value of the parameter will be
                        <parameter>defaultVal</parameter>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type><methodname>addEnumParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <modifier>const</modifier> <type>char**</type>
                         <parameter>pValues</parameter>
                     </methodparam>
                     <methodparam>
                         <type>std::string</type> <parameter>defaultValue</parameter>
                         <initializer>std::string("")</initializer>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a parameter <parameter>name</parameter>   that is
                        constrained to be one of the values pointed to by the
                        <parameter>pValues</parameter> array.
                        The initial value is <parameter>defaultValue</parameter>
                    </para>
                    <para>
                        The <parameter>pValues</parameter> parameter should
                        be a pointer to a null terminated set of character pointers.
                        This sounds much harder than it is:
                        <informalexample>
                            <programlisting>
const char* enumValues[] = {"red", "green", "blue", NULL};
                            </programlisting>
                        </informalexample>
                        In the code fragment above, <varname>enumValues</varname>
                        can be passed in as the <parameter>pValues</parameter>
                        argument and will constrain the values of the configuration
                        parameter to be in the set
                        {<literal>red</literal>, <literal>greeen</literal>, <literal>blue</literal>}.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type><methodname>addBoolListParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>unsigned</type><parameter>size</parameter>
                     </methodparam>
                     <methodparam>
                         <type>bool</type>   <parameter> defaultVal</parameter>
                         <initializer>true</initializer>
                     </methodparam>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a new configuration parameter
                        <parameter>name</parameter> that is constrained to be
                        a valid Tcl list of <type>bool</type> strings of
                        exactly <parameter>size</parameter> elements long.
                    </para>
                    <para>
                        The initial value will be set to <parameter>size</parameter>
                        elements of <parameter>defaultVal</parameter>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>addBoolListParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>unsigned</type> <parameter>minLength</parameter>
                     </methodparam>
                     <methodparam>
                         <type>unsigned</type> <parameter>maxLength</parameter>
                     </methodparam>
                     <methodparam>
                         <type>bool</type> <parameter>defaultVal</parameter>
                         <initializer>true</initializer>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter> defaultSize</parameter>
                         <initializer>-1</initializer>
                     </methodparam>
                 </methodsynopsis>
                 </term>
                <listitem>
                    <para>
                        Same as the previous method, however the
                        list size is constrained to be at least
                        <parameter>minLength</parameter> and at most
                        <parameter>maxLength</parameter> elements long.
                        The initial value is <parameter>defaultSize</parameter>
                        elements of <parameter>defaultVal</parameter>
                        If <parameter>defaultSize</parameter> is outside
                        the length limits, it is forced to the closest limit.
                    </para>
                </listitem>
                </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>addIntListParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>unsigned</type> <parameter>size</parameter>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter>defaultVal</parameter>
                         <initializer>0</initializer>
                     </methodparam>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a parameter that is constrained to be  a fixed
                        length Tcl list of <parameter>size</parameter>
                        integer values.
                        The initial value of the list is <parameter>size</parameter>
                        copies of <parameter>defaultValue</parameter>
                        </para>
                    <para>
                        The range of values in the list is unconstrained.
                        See the overloads below however.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>addIntListParameter</methodname>
                     <methodparam>
                         <type>std::string</type>  <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>unsigned</type> <parameter>minlength</parameter>
                     </methodparam>
                     <methodparam>
                         <type>unsigned</type> <parameter>maxLength</parameter>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter>defaultVal</parameter>
                         <initializer>0</initializer>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter>defaultSize</parameter>
                         <initializer>-1</initializer>
                     </methodparam>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Same as the previous method however the list can
                        have a size in the range
                        [<parameter>minlength</parameter>..<parameter>maxLength</parameter>].
                        the initial value of the list is <parameter>defaultSize</parameter>
                        elements of <parameter>defaultVal</parameter>.
                    </para>
                    <para>
                        As for <methodname>addBoolListParameter</methodname>,
                        if the <parameter>defaultSize</parameter> parameter
                        is outside the range of valid list length it is forced
                        to the closest value.  Thus the default value really
                        creates <parameter>minlength</parameter> elements.
                        </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>isInteger</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>name</parameter>
                      </methodparam>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                      <methodparam>
                          <type>void*</type><parameter>arg</parameter>
                      </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is a static method that can be used as a constraint
                        checker for integer parameters.  When it is used,
                        the constraint parameter shoule be <literal>NULL</literal>
                        if no range checking is desired or a pointer to a
                        <type>Limits</type> struct as described in
                        PUBLIC VARIABLES, TYPES and CONSTANTS to describe
                        which limits are desired and their values.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>isBool</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>name</parameter>
                      </methodparam>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                      <methodparam>
                          <type>void*</type> <parameter>arg</parameter>
                      </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is a static method that can be used as a constraint
                        checker for boolean parameters.  When used, the
                        constraint parameter should be <literal>NULL</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>isEnum</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>name</parameter>
                      </methodparam>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                      <methodparam>
                          <type>void*</type> <parameter>arg</parameter>
                      </methodparam>
                  </methodsynopsis>
                    </term>
                <listitem>
                    <para>
                        Constriaint checker fora n enumerated type.
                        When used, the constraint parameter should be
                        a pointer to an <type>std::set&lt;string&gt;</type>
                        which  has elements for each valid enumerator value.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                  <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>isList</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>name</parameter>
                      </methodparam>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                      <methodparam>
                          <type>void*</type> <parameter>arg</parameter>
                      </methodparam>
                  </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        General constraint checker for a parameter that must
                        look like a Tcl list.  The constraint parameter
                        is a pointer to an <type>isListParameter</type>
                        struct as defined in PUBLIC VARIABLES, TYPES and CONSTANTS
                        This structure should be filled in to provide limits on
                        the number of list elements the list can have.  A constraint
                        checker that is applied to each list element can also be
                        supplied.
                        </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                  <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>isBoolList</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>name</parameter>
                      </methodparam>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                      <methodparam>
                          <type>void*</type> <parameter>arg</parameter>
                      </methodparam>
                  </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Constraint checker for a Tcl formatted list of
                        booleans.  The constraint parameter shouild be a
                        pointer to a <type>ListSizeConstraint</type>
                        described in PUBLIC VARIABLES, TYPES and CONSTANTS.
                        This should set limits on the size of the list.
                        <methodname>isBoolList</methodname> will ensure
                        that the elements of the list are booleans.
                        </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                  <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>isIntList</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>name</parameter>
                      </methodparam>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                      <methodparam>
                          <type>void*</type> <parameter>arg</parameter>
                      </methodparam>
                  </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Constraint checker for a list of integers. The constraint
                        parameter should be a <type>ListSizeConstraint</type>
                        that describes the allowed list sizes.  The
                        checker will ensure that the elements fo the list are
                        all valid integers. At present, this checker does not
                        support checking the values of the list elemeents against
                        range limits.
                    </para>
                    <para>
                        You could manually construct the <type>isListParameter</type>
                        structure to do this and use <methodname>isList</methodname>
                        if required.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                  <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>isStringList</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>name</parameter>
                      </methodparam>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                      <methodparam>
                          <type>void*</type> <parameter>arg</parameter>
                      </methodparam>
                  </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Constraint checker for lists of strings.   The
                        constraint parametr is a <type>ListSizeConstraint</type>
                        that defines the allowed sizes of the list.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                  <methodsynopsis>
                      <modifier>static</modifier> <type>isEnumParameter</type>
                      <methodname>makeEnumSet</methodname>
                      <methodparam>
                          <modifier>const</modifier> <type>char**</type><parameter>values</parameter>
                      </methodparam>
                  </methodsynopsis>
                  </term>
                <listitem>
                    <para>
                        Helper function that converts a null terminated array
                        of pointers to strings into a
                        <type>isEnumParameter</type> constraint parameter.
                    </para>
                </listitem>
                </varlistentry>
            <varlistentry>
                <term>
                  <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>strToBool</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                  </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Convenience function that converts a string to a boolean
                        or throws an exception if the resulting string cannot
                        be converted.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
       </refsect1>
        <refsect1>
           <title>PUBLIC VARIABLES, TYPES and CONSTANTS</title>
           <para>
                The class definition in the SYNOPSIS section above shows a
                large number of type definitions for this class.
                Almost all of these types are structures used by the
                built in constraint checkers.In most cases,
                if you use the convenience functions to define your parameters
                you won't need to know the details of these types.
           </para>
           <para>
                The remainder of this section describes these types and the
                constraint checkers they belong to.
            </para>
            <variablelist>
                <varlistentry>    
                    <term>
                        <fieldsynopsis>
                            <modifier>typedef</modifier>
                            <type>std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt;</type>
                            <varname>ConfigurationArray</varname>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <type>ConfigurationArray</type> is returned from
                            one of the overloads of the <methodname>cget</methodname>
                            method.  This type is a vector of pair.  The first element of each pair
                            is the name of a parameter while the second element is it's current
                            value.
                        </para>
                        <para>
                            The following fragment of code shows how to use this
                            to dump the current configuration of a configurable
                            object pointed to by <varname>pConfig</varname>
                        </para>
                        <informalexample>
                            <programlisting>
ConfigurationArray config = pConfig-&gt;cget();
for (int i = 0; i &lt; config.size(); i++) {
   cout &lt;&lt; config[i].first &lt;&lt; " is set to " &lt;&lt; config[i].second &lt;&lt; endl;
}
                            </programlisting>
                        </informalexample>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        struct  <type>limit</type> {
                        <fieldsynopsis>
                            <type>bool</type>   <varname>s_checkMe</varname>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <type>long</type> <varname>s_value</varname>
                        </fieldsynopsis>
                        <constructorsynopsis>
                            <methodname>limit</methodname>
                            <void />
                        </constructorsynopsis>
                        <constructorsynopsis>
                            <methodname>limit</methodname>
                            <methodparam>
                                <type>long</type>    <parameter>value</parameter>
                            </methodparam>
                        </constructorsynopsis>
                      } ;
                    </term>
                    <term>
                      <fieldsynopsis>
                          <modifier>typedef</modifier>
                          <type>std::pair&lt;limit, limit&gt;</type><varname>Limits</varname>
                      </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            These data types are used with the
                            <methodname>isInteger</methodname> constraint
                            checker.  Each <type>limit</type> data type
                            represents a range limit that may or may  not be
                            checked according to the state of its
                            <varname>s_checkMe</varname> flag.
                        </para>
                        <para>
                            <type>Limits</type> is a pair of <type>limit</type>
                            structs where the first one represents the lower
                            limit and the second one the upper limit.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>                      
                        <fieldsynopsis>
                            <modifier>typedef</modifier>
                            <type>std::set&lt;std::string&gt;</type>
                            <varname>isEnumParameter</varname>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <type>isEnumParameter</type> is used by the
                            <methodname>isEnum</methodname> method
                            to validate parameters that are enumerate parameter.
                            The actual type is a set of the character strings
                            that are allowed to be assigned to the parameter value.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>typedef</modifier> <type>std::pair&lt;typeChecker, void*&gt;</type>
                            <varname>TypeCheckInfo</varname>
                        </fieldsynopsis>
                    </term> 
                    <term>
                        typedef struct <type>_ListSizeConstraint</type> {
                            <fieldsynopsis>
                                <type>limit</type> <varname>s_atLeast</varname>
                            </fieldsynopsis>
                            <fieldsynopsis>
                                <type>limit</type> <varname>s_atMost</varname>
                            </fieldsynopsis>
                        } <type>ListSizeConstraint</type>
                    </term>
                    <term>
                        typedef struct <type>_isListParameter</type> {
                          <fieldsynopsis>
                            <type>ListSizeConstraint</type> <varname>s_allowedSize</varname>
                          </fieldsynopsis>
                          <fieldsynopsis>
                            <type>TypeCheckInfo</type> <varname>s_checker</varname>
                          </fieldsynopsis>
                        } <type>isListParameter</type>;
                    </term>
                    <listitem>
                        <para>
                            This set of types are used to validate lists.
                            The <type>isListParameter</type>
                            is what is used to validate lists.  This consists
                            of two chunks;
                        </para>
                        <para>
                            <varname>s_allowedSize</varname> is used
                            to validate the size of a list.  It is a
                            <type>ListSizeConstraint</type> which allows you to
                            specify minimum and maximum list sizes.  The list
                            size limits are inclusive so you can specify a
                            fixed size list by setting both
                            <varname>s_atLeast</varname> and <varname>s_atMost</varname>
                            to be the same.
                        </para>
                        <para>
                            <varname>s_checker</varname> is a constraint
                            checker and its parameter used to validate each
                            item in the list.  This is applied after the
                            string is determined to be a valid list and
                            after the size of the list has been checked against
                            the limits defined by <varname>s_allowedSize</varname>
                            <varname>s_checker</varname>
                            <type>TypeCheckInfo</type> which is a pair whose
                            first element is a pointer to the actual constraint
                            checking function and whose second is a pointer to data
                            passed to the constraint checker without
                            interpretation. For more information about how
                            constratin checkers work see
                            CONSTRAINT CHECKING below.
                            </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>  
                        struct  <type>flimit</type> {
                          <fieldsynopsis>
                            <type>bool</type>   <varname>s_checkMe</varname>
                          </fieldsynopsis>
                          <fieldsynopsis>
                            <type>float</type> <varname>s_value</varname>
                          </fieldsynopsis>
                          <constructorsynopsis>
                            <methodname>flimit</methodname><void />
                          </constructorsynopsis>    
                          <constructorsynopsis>
                            <methodname>flimit</methodname>
                            <methodparam>
                                <type>float</type> <parameter>value</parameter>
                            </methodparam>
                          </constructorsynopsis>    
                        };
                    </term>
                    <term>
                        <fieldsynopsis>
                            <modifier>typedef</modifier> <type>std::pair&lt;flimit, flimit&gt;</type>
                            <varname>FloatingLimits</varname>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            These types specify floating point limits in a
                            mannger analgous to integer limits.
                            </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>           
        </refsect1>
        <refsect1>
            <title>CONSTRAINT CHECKING</title>
            <para>
                Constraint checking is the <classname>CConfigurableObject</classname>
                class's way to enforce type safety and other constraints on
                the values of configuration parameters.
                When a parameter is created with <methodname>addParameter</methodname>,
                The caller has an option to provide a constraint checker and
                a parameter that provides extra information to the constraint
                checker that can parameterize the constraints it checks.
            </para>
            <para>
                A constraint checker is just a function of the form:
                <informalexample>
                    <programlisting>
bool myConstraintChecker(std::string name, std::string newValue,
                        void* pClientData);
                    </programlisting>
                </informalexample>
            </para>
            <para>
                When the <methodname>configure</methodname> method is called
                for a parameter name that has a constraint checker
                attached to it, that checker is called and passed the parameters
                shown in the code fragment above:
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <parameter>name</parameter>
                    </term>
                    <listitem><para>
                        Is the name of the parameter being configured.
                        </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <parameter>newValue</parameter>
                    </term>
                    <listitem>
                        <para>Is the proposed new value for the parameter.
                        </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <parameter>pClientData</parameter>
                    </term>
                    <listitem>
                        <para>
                            Is the constraint parameter passed to
                            <methodname>addParameter</methodname>
                            passed without interpretation or modification.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                The constraint checker is expected to return
                <literal>true</literal> if the proposed <parameter>newValue</parameter>
                is acceptable by the constraint checker and <literal>false</literal>
                if not.  If <literal>true</literal> is returned the parameter
                value is modified to <parameter>newValue</parameter> otherwise
                a string exception is thrown and the parameter value is not
                modified.
            </para>
            <para>
                The CCUSB framework catches string exceptions thrown by
                <classname>CConfigurableObject</classname> and converts those
                into configuration file processing error messages.  Any configuration
                file processing error is reported and aborts the start of the
                run that caused it.
            </para>
        </refsect1>
     </refentry>
       <refentry id="ccusb3-cccusb">
         <refmeta>
            <refentrytitle>cccusb</refentrytitle>
            <manvolnum>3ccusb</manvolnum>
         </refmeta>
         <refnamediv>
            <refname>cccusb</refname>
            <refpurpose>Swig wrapping of the CCCUSB C++ class.</refpurpose>
         </refnamediv>
         
         <refsynopsisdiv>
            <cmdsynopsis>
                <command>
cccusb::CCCUSB_enumerate
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
cccusb::usb_device_vector_get  <replaceable>CCCUSB-enumeration  index</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
cccusb::usb_device_vector_size <replaceable>CCUSB-enumeration</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::cccusb::CCCUSB <replaceable>name</replaceable> <replaceable>usb-device</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::cccusb::CCCUSB <replaceable>-args usb-device</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::cccusb::CCCUSB <replaceable>?name?</replaceable> -this <replaceable>ptrName</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> c
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> executeList <replaceable>readout-list maxread</replaceable>                
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> inhibit
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> loadList <replaceable>listNum readout-list</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readDGGA
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readDGGB
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readDGGExt
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readDelays
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readDeviceSourceSelectors
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readFirmware
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable>readGlobalMode
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readLamTriggers
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readLedSelector
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readOutputSelector
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readScalerA
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readScalerB
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readScalerControl
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readUSBBulkTransferSetup
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
cccusb::CCCUSB_serialNo <replaceable>usb-device</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> setDefaultTimeout <replaceable>ms</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> simpleControl <replaceable>n a f</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> simpleRead16 <replaceable>n a f</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> simpleRead24 <replaceable>n a f</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> simpleWrite16 <replaceable>n a f d</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> simpleWrite24 <replaceable>n a f d</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> uninhibit
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeActionRegister <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeDGGA <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeDGGB <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>

            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeDGGExt <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeDelays <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeDeviceSourceSelectors <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeGlobalMode <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeLamTriggers <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeLedSelector <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeOutputSelector <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeScalerControl <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeUSBBulkTransferSetup <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> Z
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> -delete
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
cccusb::string_to_char <replaceable>string-object</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::cccusb::uint16_vector_get <replaceable>vector-object index</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::cccusb::uint16_vector_size <replaceable>vector-object</replaceable>
                </command>
            </cmdsynopsis>
         </refsynopsisdiv>
         <refsect1>
            <title>DESCRIPTION</title>
            <para>
                This set of commands is a Tcl wrapper around the
                CCCUSB C++ class (see <xref linkend='ccusb3-CCCUSB' />.  The
                interface consists of several static methods and object sub
                commands.
            </para>
            <para>
                The static methods include methods that support
                device enumeration and construction.  Enumeration returns
                data types that require additional static methods to
                unpack.  See DEVICE ENUMERATION below.
            </para>
            <para>
                Command lists (see <xref linkend='ccusb3-cccusbreadoutlist' />)
                can be executed in immediate mode or loaded.  At present
                the usb bulk read function is not supported so a pure Tcl
                data taking system cannot yet be written.  If you want support
                for that, request it as that can be added easily enough.
            </para>
            <para>
                Immediate list execution also produces data types that require
                additional static member functions to unpack.  See
                LIST EXECUTION below for more information.
            </para>
         </refsect1>
         <refsect1>
            <title>COMMAND DETAILS</title>
            <variablelist>
                <varlistentry>
                    <term><command>cccusb::CCCUSB_enumerate</command></term>
                    <listitem>
                        <para>
                            Produces an enumeration of the powered up CC-USB
                            devices attached to the host.  The result of this
                            command is a wrapped std::vector&lt;usb_device*&gt;
                            See DEVICE ENUMERATION for recipes for using
                            this result.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>cccusb::usb_device_vector_get  <replaceable>CCCUSB-enumeration  index</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Gets a specific element of the return value from
                            <command>cccusb::CCCUSB_enumerate</command>.
                            <parameter>CCCUSB-enumeration</parameter> is the
                            value returned from that command.
                            <parameter>index</parameter>
                            is the index into the vector.
                            Indices start from 0.  See DEVICE ENUMERATION
                            below for some enumeration recipes.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>cccusb::usb_device_vector_size <replaceable>CCUSB-enumeration</replaceable></command></term>
                    <listitem>
                        <para>
                            Returns the size of the enumeration vector
                            <parameter>CCCUSB-enumeration</parameter>.
                            This parameter is a value returned from
                            <command>cccusb::CCCUSB_enumerate</command>
                        </para>
                        <para>
                            See DEVICE ENUMERATION below for some device enumeration
                            recipes.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::cccusb::CCCUSB <replaceable>name</replaceable> <replaceable>usb-device</replaceable>
                    </command></term>
                    <listitem>
                        <para>
                            Constructs a CCCUSB object whose command will be
                            <parameter>name</parameter>.
                            <parameter>usb-device</parameter> is an element
                            from a device enumeration that was gotten
                            from <command>cccusb::CCCUSB_enumerate</command>.
                        </para>
                        <para>
                            For recipes involving device enumeration and
                            construction see DEVICE ENUMERATION below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::cccusb::CCCUSB <replaceable>-args usb-device</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Constructs a CCCUSB object with a unique
                            object instance command name chosen
                            by the constructor.  <parameter>usb-device</parameter>
                            is an element of an enumeration returned from
                            <command>cccusb::CCCUSB_enumerate</command>.
                        </para>
                        <para>
                            Normally this is used in constructs like e.g:
                        </para>
                        <informalexample>
                            <programlisting>
set controller [cccusb::CCCUSB -args $device]
$controller c
$controller z
                            </programlisting>
                        </informalexample>
                        <para>
                            For more enumeration and construction recipes
                            see DEVICE ENUMERATION below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::cccusb::CCCUSB <replaceable>?name?</replaceable>
                    -this <replaceable>ptrName</replaceable></command></term>
                    <listitem>
                        <para>
                            Constructs  CCCUSB object from an object pointer
                            <parameter>ptrName</parameter>.
                            Object pointers are gotten either by requesting
                            the <option>-this</option> from another object or,
                            in the CCUSBReadout framework by being passed in
                            from the framework to a Tcl driver.
                        </para>
                        <para>
                            If the optional <parameter>name</parameter>
                            is provided it will be the object instance command.
                            If not the object instance command will be the
                            value of <parameter>ptrName</parameter>
                        </para>
                        <para>
                            For example.
                        </para>
                        <informalexample>
                            <programlisting>
proc example pointer {
   cccusb::CCCUSB controller -this $pointer
   controller c
   
   cccusb::CCCUSB -this $pointer
   $pointer z
}
                            </programlisting>
                        </informalexample>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> c </command></term>
                    <listitem>
                        <para>
                            Performs a C cyle on the dataway connected to
                            <parameter>object</parameter>.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> executeList
                    <replaceable>readout-list maxread</replaceable></command></term>
                    <listitem>
                        <para>
                            Executes a <classname>cccusbreadoutlist::CCCUSBReadoutList</classname>
                            (see <xref linkend='ccusb3-cccusbreadoutlist' />).
                            <parameter>readout-list</parameter> is the name
                            of the list and <parameter>maxread</parameter>
                            the maximum number of 16 bit words that can
                            be read by this list (written data is inline in the
                            list).  <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                        <para>
                            The return value is the name of an
                            encapsulated std::vector&lt;uint16_t&gt;.
                            See EXECUTING LISTS for recipes for executing lists
                            and getting data from the result.
                            See as well <command>cccusb::uint16_vector_get</command>,
                            <command>cccusb::uint16_vector_size</command>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> inhibit</command></term>
                    <listitem>
                        <para>
                            Sets the inhibit line on the CAMAC crate controlled
                            by <parameter>object</parameter>.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> loadList
                    <replaceable>listNum readout-list</replaceable></command>
                    </term>
                    <listitem>
                        <para>Loads a <classname>cccusbreadoutlist::CCCUSBReadoutList</classname>
                        object for later execution in response to an event or
                        scaler trigger.
                        </para>
                        <para>
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                            <parameter>listNum</parameter> is the number of the
                            list to be loaded.  The list numbers is either
                            <literal>0</literal> for the event list or
                            <literal>1</literal> for the scaler list.
                        </para>
                        <para>
                            <parameter>readout-list</parameter> is a
                            <classname>cccusbreadoutlist::CCUSBReadoutList</classname>
                            object instance name.  See
                            <xref linkend='ccusb3-cccusbreadoutlist' /> for
                            information about how to create these.
                        </para>
                        <para>
                            The command returns
                            <literal>0</literal> on successful completion,
                            a negative number is returned on failure.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readDGGA</command></term>
                    <listitem>
                        <para>
                            Reads the DGGA register of the CC-USB module
                            represented by <parameter>object</parameter>.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                            The DGGA register controls the width and
                            delay of one of the CC-USB's gate and delay generators.
                            See section 3.3.7 of the CC-USB manual for
                            more information about this register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readDGGB</command></term>
                    <listitem>
                        <para>
                            Same as <command>readDGGA</command> but reads the
                            B gate and delay register control register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readDGGExt</command></term>
                    <listitem>
                        <para>
                            Reads the CC-USB Gate and delay generated extended
                            range register.  See Section 3.3.7 of the CC-USB
                            manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readDelays</command></term>
                    <listitem>
                        <para>
                            Reads the delays register of the CC-USB.  See
                            Section 3.3.3 of the CC-USB manual for a
                            description of this register.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readDeviceSourceSelectors</command></term>
                    <listitem>
                        <para>
                            Reads the CCUSB device source selectors register.
                            This is described in section 3.3.6 of the CC-USB
                            manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readFirmware</command></term>
                    <listitem>
                        <para>
                            Reads the CC-USB firmware id register.
                            The bit fields of this register are described by
                            section 3.3.1 of the CC-USB manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>readGlobalMode</command></term>
                    <listitem>
                        <para>
                            Reads the CC-USB global mode register.  This register
                            iis described in section 3.3.2 of the CC-USB
                            manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readLamTriggers</command>
                    </term>
                    <listitem>
                        <para>
                            Reads the LAM trigger register.  The CC-USB
                            manual calls this register the LAM Mask register
                            and describes it in section 3.3.9.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readLedSelector</command>
                    </term>
                    <listitem>
                        <para>
                            Reads the LED Selector register.   This register is
                            descsribed in section 3.3.5 of the CC-USB manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readOutputSelector</command>
                    </term>
                    <listitem>
                        <para>
                            Reads the output selector register.   This register
                            is described in section 3.3.5 of the CC-USB manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readScalerA</command></term>
                    <listitem>
                        <para>
                            Read the counts in Scaler A.  The scalers are
                            described in Section 3.3.8 of the CC-USB manual
                            with how to define what makes them count described
                            in section 3.3.6.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readScalerB
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Same as <command>readScalerA</command> however
                            the B scaler is read.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readScalerControl
                        </command>
                        </term>
                    <listitem>
                        <para>
                            Read the Scaler readout control register.
                            The CC-USB manual refers to this as the
                            ACS (Auxiliary Camac Stack) register in some places
                            and the Scaler Readout Control register in others.
                            It is described in section 3.3.4 of the manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readUSBBulkTransferSetup</command>
                    </term>
                    <listitem>
                        <para>
                            Reads the USB Bulk transfer setup register.  This
                            is described in section 3.3.10 of the CC-USB
                            manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>cccusb::CCCUSB_serialNo <replaceable>usb-device</replaceable></command></term>
                    <listitem>
                        <para>
                            Reads the serial number of the device selected by
                            <parameter>usb-device</parameter>.  <parameter>usb-device</parameter>
                            is a usb device object that comes from one of the elements
                            of the enumerator returned by
                            <command>cccusb::CCCUSB_enumerate</command>.  The
                            serial number is returned as a string object handle
                            that must be converte via <command>cccusb::string_to_char</command>.
                            For more information about device enumeration and serial
                            number strings see DEVICE ENUMERATION below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> setDefaultTimeout <replaceable>ms</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Most CC-USB operations require a USB bulk transfer to
                            the CC-USB and a transfder from the CC-USB.  These
                            transfers are done with a timeout so that if
                            the target does not respond, the request eventually
                            does terminate. This sets the timeout for
                            those requests to be <parameter>ms</parameter>
                            milliseconds.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> simpleControl
                        <replaceable>n a f</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Performs a non-data transfer operation.
                            <parameter>n</parameter> specifies the CAMAC slot
                            that will be the target of this operation.
                            <parameter>a</parameter> specifies the subaddress
                            and <parameter>f</parameter> specifies the
                            function code.  The function code must be in one
                            of the ranges: <literal>[8..15] [24..31]</literal>.
                            The command returns a mask of the Q and X
                            responses from the dataway.  See VARIABLES below
                            for the Q and X bits in this mask.
                        </para>
                        <para>
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> simpleRead16
                        <replaceable>n a f</replaceable> </command>
                    </term>
                    <listitem>
                        <para>
                            Performs a 16 bit read from the module and sub
                            address specified by <parameter>n</parameter> and
                            <parameter>a</parameter>.  The CAMAC function
                            code <parameter>f</parameter> must be in the range
                            <literal>[0..7]</literal>.
                        </para>
                        <para>
                            The command returns the data in the lower 16 bits
                            of the value and the Q/X resonse in the upper byte
                            (bits 24 through 31).  Thus to extract the Q/X:    
                            <informalexample>
                                <programlisting>
set data [c simpleRead16 1 0 0]
set qx [expr {$data >> 24}]
set data [expr {$data &amp; 0xffff}]
                                </programlisting>
                            </informalexample>
                            See VARIABLES below for information about the
                            how to extract the Q and X bits from the
                            <varname>qx</varname> variable in the example
                            above.
                        </para>
                        <para>
                           <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> simpleRead24
                        <replaceable>n a f</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Same as <command>simpleRead16</command> above,
                            however the data transferred is 24 bits wide.
                            The Q/X response is still in bits 24 through 31.
                            The example below shows how to extract the data
                            and the Q/X resopnse:
                            <informalexample>
                                <programlisting>
set data [c simpleRead16 1 0 0]
set qx [expr {$data >> 24}]
set data [expr {$data &amp; 0xffffff}]
                                </programlisting>
                            </informalexample>
                        </para>
                        <para>
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> simpleWrite16
                        <replaceable>n a f d</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Performs a write of the 16 bit data <parameter>d</parameter>
                            to the module and subaddress specified by
                            <parameter>n</parameter> and <parameter>a</parameter>
                            via the CAMAC function code <parameter>f</parameter>.
                            <parameter>f</parameter> must be in the range
                            <literal>[16..23]</literal>.  The command returns
                            the Q and X mask. See VARIABLES below for information
                            about which bits are Q and which X.
                        </para>
                        <para>
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> simpleWrite24
                        <replaceable>n a f d</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Same as <command>simpleWrite16</command> however
                            the bottom 24 bits of <parameter>d</parameter>
                            are transferred.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> uninhibit</command></term>
                    <listitem>
                        <para>
                            Removes the dataway inhibit.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> writeActionRegister
                        <replaceable>value</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Writes the CC-USB action register.
                            This register is described in section 3.2.1
                            of the CC-USB manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> writeDGGA
                        <replaceable>value</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter>
                            to the control register for Gate and Delay
                            A.  This register is described in section
                            3.3.7 of the CC-USB manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> writeDGGB
                        <replaceable>value</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Same as <command>writeDGGA</command> however the
                            control register for gate and delay generator B
                            is written.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> writeDGGExt
                        <replaceable>value</replaceable></command></term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to
                            the gate and delay extended delay register.
                            See section 3.3.7 of the CC-USB manual for a description
                            of this registers.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> writeDelays
                    <replaceable>value</replaceable></command></term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to the delays
                            register.  This register is described in section
                            3.3.3 of the CC-USB manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        writeDeviceSourceSelectors <replaceable>value</replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to the
                            device source selector register.  This
                            register is described in section 3.3.6 of the
                            CC-USB manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        writeGlobalMode <replaceable>value</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to the global
                            mode register. See section 3.3.2 of the CC-USB
                            manual for a description of this register.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        writeLamTriggers <replaceable>value</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to the LAM
                            triggers register.  The CC-USB manual refers
                            to this register as the LAM Maks register
                            and describes it in section 3.3.9
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        writeLedSelector <replaceable>value</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to
                            the LED selector register. This register
                            is described in section 3.3.5 of the CC-USB manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                      writeOutputSelector <replaceable>value</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to the
                            output selectors register of the CC-USB.
                            This register is described in section 3.3.5 of
                            the CC-USB manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        writeScalerControl <replaceable>value</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to
                            the scaler control register/ACS Control
                            register.  This register is described in section
                            3.3.4 of the CC-USB manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        writeUSBBulkTransferSetup <replaceable>value</replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to the USB
                            bulk transfer setup register. Section 3.3.10 of
                            the CC-USB manual describes this register.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        Z</command>
                    </term>
                    <listitem>
                        <para>
                            Performs a Z cycle on the camac dataway.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> -delete</command></term>
                    <listitem>
                        <para>
                            Deletes a swig wrapper for a <classname>CCCUSB</classname>
                            wrapper.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>cccusb::string_to_char <replaceable>string-object</replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Returns a Tcl string equivalent of a
                            std::string object identifier
                            <parameter>string-objecdt</parameter>.
                            std::string
                            object identifiers are returned from the
                            <command>serialNo</command> method. See
                            DEVICE ENUMERATION below for more information.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::cccusb::uint16_vector_get
                        <replaceable>vector-object index</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Returns  element
                            <parameter>index</parameter>
                            of <parameter>vector-object</parameter>
                            where that is an object identifier for a
                            <type>std::vector&lt;uint16_t&gt;</type>.
                            This is required to fetch items out of the data
                            that comes back from the <command>executeList</command>
                            command.  For more information see EXECUTING LISTS
                            below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::cccusb::uint16_vector_size
                        <replaceable>vector-object</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Returns the size of <parameter>vector-object</parameter>
                            where <parameter>vector-object</parameter> is an
                            object identifier for a
                            <type>std::vector&lt;uint16_t&gt;</type>.  This
                            is typically used when processing data from running
                            a list.  See EXECUTING LISTS Below for more information.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
         </refsect1>
         <refsect1>
            <title>DEVICE ENUMERATION</title>
            <para>
                The USB bus is a hotplug bus.  Device enumeration is the
                process of determining the set of devices plugged into the USB
                bus at a point in time.  The goal of device enumeration is normally
                to access a specific device of the desired device type.
                In our case we are interested in creating a CCCUSB object
                connected to  CC-USB with a specific serial number.
            </para>
            <para>
                If you are using the CCUSBReadout framework, you normally don't
                need to do this.   The framework has already enumerated and
                opened the device and is passes you the appropriate object id.
                If you are writing a pure Tcl CC-USB application, you will need
                to read and understand this section.
            </para>
            <para>
                The starting point of device enumeration is the
                <command>cccusb::CCCUSB_enumerate</command>  command.
                This returns an object id for a
                <type>std::vector&lt;usb_device*&gt;</type>. This is unfortunately
                not directly accessible in Tcl.
            </para>
            <para>
                the cccusb package provides two commands to tear apart the
                return from a call to <command>cccusb::CCCUSB_enumerate</command>:
            </para>
            <variablelist>
                <varlistentry>
                    <term><command>cccusb::usb_device_vector_size</command></term>
                    <listitem><para>
                        which returns the size of the returned vector
                        </para></listitem>
                    </varlistentry>
                <varlistentry>
                    <term><command>cccusb::usb_device_vector_get</command></term>
                    <listitem><para>Which fetches a specific
                        <type>usb_device</type> pointer object id.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                Once you have a <type>usb_device</type> pointer object id
                you can do two things with it.  You can obtain the serial
                number string of the associated CC-USB controller or create
                a CCCUSB object with which you can perform operations on the
                controller and the CAMAC modules in its crate.
            </para>
            <para>
                Normally you want to do both, you want to enumerate the
                controllers and either match them against a desired serial
                number or display them for the user to choose.
                The example below enumerates the CC-USB's and displays
                their serial numbers on stdout:
            </para>
            <example>
                <title>Listing CC-USB Serial numbers (Tcl).</title>
                <programlisting>
lappend auto_path /usr/opt/daq/10.1/lib
package require cccusb

set e [cccusb::CCCUSB_enumerate]

set ccount [cccusb::usb_device_vector_size $e]
for {set i 0} {$i &lt; $ccount} {incr i} {
    set usbdev [cccusb::usb_device_vector_get $e $i]
    set serial [cccusb::string_to_char [cccusb::CCCUSB_serialNo $usbdev]]
    puts $serial
}
                </programlisting>
            </example>
            <para>
                Note how <command>cccusb::usb_device_vector_size</command>
                and <command>cccusb::usb_device_vector_get</command> are used
                to get <type>usb_device*</type> object ids.
                Note as well how a specific object id is then passed to
                <command>cccusb::CCCUBS_serialNo</command> and the output of
                that converted to a Tcl string via
                <command>cccusb::string_to_char</command>
           </para>
            <para>
                The next example demonstrates a Tcl proc that returns
                a CCCUSB object command name that is connected to a specific
                CC-USB specified by serial number or generates an error
                if that serial number does not exist.
            </para>
            <example>
                <title>Creating a CCCUSB object by serial number (Tcl).</title>
                <programlisting>
lappend auto_path /usr/opt/daq/10.1/lib
package require cccusb
...
proc openCamac serialNo {
    set e [cccusb::CCCUSB_enumerate]
    set ccount [cccusb::usb_device_vector_size $e]
    for {set i 0} {$i &lt; $ccount} {incr i} {
        set usbdev [cccusb::usb_device_vector_get $e $i]
        set serial [cccusb::string_to_char [cccusb::CCCUSB_serialNo $usbdev]]
        if {$serial eq $serialNo} {
            return [cccusb::CCCUSB -args $usbdev]
        }
    }
    error "No CC-USB with serial number $serialNo is available"
 
}
                </programlisting>
            </example>
            <para>
                The pattern of this code follows the pattern of the previous
                example.  The only difference is that when the serial number
                matches the requested <varname>serialNo</varname> parameter,
                a CCCUSB object is created.  SWIG is allowed to choose the
                object command (the <option>-args</option> option does that),
                which is returned to the caller.
            </para>
         </refsect1>
         <refsect1>
            <title>EXECUTING LISTS</title>
            <para>
                The CC-USB has the ability to execute list of camac instructions.
                Immediate list execution is supported by the cccusb package
                via the <command>executeList</command> command.  Lists can also
                be downloaded to CC-USB memory for execution in data acquisition
                mode in response to event and scaler triggers.  This is supported
                via the <command>loadList</command> command.
            </para>
            <para>
                This section describes how to use <command>executeList</command>
                and how to access any data read by those lists (written data
                is stored in the list itself).  Please refer to
                <xref linkend='ccusb3-CCCUSBReadoutList'/> for reference
                material on the Tcl package for constructing these lists.
            </para>
            <para>
                In order to execute a list on an existing CCCUSB class/command
                you must
            </para>
            <itemizedlist>
                <listitem>
                    <para>Construct the list of operations to perform</para>
                </listitem>
                <listitem>
                    <para>
                        Use <command>executeList</command> to perform the
                        operations in the list, specifying a maximum number of
                        16 bit words of data to be read by the list.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The value of the <command>executeList</command>
                        command is an object id for a
                        <type>std::vector&lt;uint16_t&gt;</type>.
                        Use the <command>cccusb::uint16_vector_size</command>
                        command to determine how many words were actually read.
                        Use the <command>cccusb::uint16_vector_get</command>
                        command to fetch elements of that vector.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                The code fragment below shows how to extract data from the
                returned data.  In it, assume that the variable
                <varname>c</varname> holds a
                CCCUSB object command and the variable <varname>l</varname>
                holds the object command of a CCCUSBReadoutList object.
                The creates a hexadecimal dump of the returned words:
            </para>
            <informalexample>
                <programlisting>
set result [$c executeList $l 1000];   # No more than 1000 wds to read.
set nRead [cccusb::uint16_vector_size $result]
for {set i 0} {$i &lt; $nRead} {incr i} {
     puts [format %x [cccusb::uint16_vector_get $result $i]]
}
                </programlisting>
                
            </informalexample>
            <para>
                Note that the <command>executeList</command> requires
                a number which is the maximum number of <type>uint16_t</type>
                values that will be read by the list.  This is used to allocate
                the read buffer.  The actual count of the words read is then
                used to fill the vector returned by that command.
            </para>
        </refsect1>
        <refsect1>
            <title>VARIABLES</title>
            <para>
                The cccusb package exports the following variables:
            </para>
            <variablelist>
                <varlistentry>
                    <term><varname>cccusb::CCCUSB_X</varname></term>
                    <listitem>
                        <para>
                            Contains the mask of the X response in a
                            Q/X word.   For the simple control and write
                            operations,
                            you can directly test these bits against the
                            command return value.  For simple read operations,
                            you need to take the return value and shift
                            right 24 bits before checking for this bit.
                            </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><varname>cccusb::CCCUSB_Q</varname></term>
                    <listitem>
                        <para>
                            Contain the max of the Q response.  See above
                            for how to use it to check for Q responses in operations.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
        <refsect1>
            <title>SEE ALSO</title>
            <para>
                <xref linkend='ccusb3-CCCUSB' />
                <xref linkend='ccusb3-cccusbreadoutlist' />
                <xref linkend='ccusb3-CCCUSBReadoutList'/>
            </para>
        </refsect1>
       </refentry>
       <refentry id="ccusb3-cccusbreadoutlist">
         <refmeta>
            <refentrytitle>cccusbreadoutlist</refentrytitle>
            <manvolnum>3ccusb</manvolnum>
         </refmeta>
         <refnamediv>
            <refname>cccusbreadoutlist</refname>
            <refpurpose>Tcl wrapping of <classname>CCCUSBReadoutList</classname></refpurpose>
         </refnamediv>
         
         <refsynopsisdiv>
            <cmdsynopsis>
                <command>
::cccusbreadoutlist::CCCUSBReadoutList <replaceable>name</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::cccusbreadoutlist::CCCUSBReadoutList -args
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::cccusbreadoutlist::CCCUSBReadoutList <replaceable>?name?</replaceable> -this <replaceable>ptr</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> -delete              
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> get
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable>  size
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable>  clear
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addWrite16 <replaceable>n a f d </replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable>  addWrite24 <replaceable>n a f d </replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRead16 <replaceable>n a f ?lamwait?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable>  addRead24 <replaceable>n a f ?lamwait</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addControl <replaceable>n a f</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addQStop <replaceable>n a f max ?lamwait?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addQStop24 <replaceable>n a f max ?lamwait? </replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable>  addQScan <replaceable>n a f max ?lamwait?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRepeat <replaceable>n a f count ?lamwait?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addMarker <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>

         </refsynopsisdiv>
         <refsect1>
            <title>DESCRIPTION</title>
            <para>
                This Tcl package is a SWIG wrapper around the
                <classname>CCCUSBReadoutList</classname> C++ package.
                The purpose of this class is to construct list of CC-USB
                operations which can either be executed immediately or
                loaded for execution in response to an event or scaler trigger
                in data taking mode.
            </para>
            <para>
                This extension is an object oriented package.  Users construct
                lists, they stock them with commands, execute or load them and
                then destroy the list.
            </para>
         </refsect1>
         <refsect1>
            <title>
               COMMAND DETAILS
            </title>
            <variablelist>
                <varlistentry>
                    <term><command>::cccusbreadoutlist::CCCUSBReadoutList
                        <replaceable>name</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Constructs a new readout list giving it the object
                            name/id <parameter>name</parameter>. The command
                            returns a wrapped pointer to the underlying
                            <classname>CCCUSBReadoutList</classname> object.
                        </para>
                    </listitem>
                </varlistentry>
               <varlistentry>
                    <term><command>::cccusbreadoutlist::CCCUSBReadoutList -args
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Creates a new readout list allowing SWIG to choose
                            the name of the command bound to it.  The
                            return value of the command is the object command e.g.:
                        </para>
                        <informalexample>
                            <programlisting>
...
set l [cccusbreadoutlist::CCCUSBReadoutList -args]
$l addWrite16 $n $a $f $d
...
                            </programlisting>
                        </informalexample>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::cccusbreadoutlist::CCCUSBReadoutList
                        <replaceable>?name?</replaceable> -this <replaceable>ptr</replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Wraps a SWIG object id for a readout list in a new
                            object.  If the optional <parameter>name</parameter>
                            parameter is supplied it specifies the object command
                            name, otherwise the object pointer will be the
                            name of the object command.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> -delete</command>
                    </term>
                    <listitem>
                        <para>
                            Destroys a CCCUSBReadoutList SWIG object.
                            <parameter>object</parameter> is the command name of
                            a SWIG CCCUSBReadoutList object that has been gotten
                            from one of the forms of
                            <command>cccusbreadoutlist::CCCUSBReadoutList</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> get</command>
                    </term>
                    <listitem>
                        <para>
                            Returns an object id for a
                            <type>std::vector&lt;uint16_t&gt;</type> that
                            contains the values of the list.  The elements
                            of this vector can gotten by using
                            <command>ccccusb::uint16_vector get</command>
                            See <xref linkend='ccusb3-cccusb' /> for more
                            information about that command.
                        </para>
                        <para>
                            <parameter>object</parameter> is the command name of
                            a SWIG CCCUSBReadoutList object that has been gotten
                            from one of the forms of
                            <command>cccusbreadoutlist::CCCUSBReadoutList</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> size</command>
                    </term>
                    <listitem>
                        <para>
                            Returns the number of 16 bit words currently in the list
                            <parameter>object</parameter> is the command name of
                            a SWIG CCCUSBReadoutList object that has been gotten
                            from one of the forms of
                            <command>cccusbreadoutlist::CCCUSBReadoutList</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> clear</command></term>
                    <listitem>
                        <para>
                            Clears the list making it emtpy.
                            <parameter>object</parameter> is the command name of
                            a SWIG CCCUSBReadoutList object that has been gotten
                            from one of the forms of
                            <command>cccusbreadoutlist::CCCUSBReadoutList</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        addWrite16 <replaceable>n a f d </replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Adds a 16 bit CAMAC write of <parameter>d</parameter>
                            to a list.
                            <parameter>n</parameter> and <parameter>
                            a</parameter> determine the module and subaddress
                            targeted by this opertion.  <parameter>f</parameter>
                            specifies the function code which must be in the range
                            <literal>[16..23]</literal>
                        </para>
                        <para>
                            <parameter>object</parameter> is the command name of
                            a SWIG CCCUSBReadoutList object that has been gotten
                            from one of the forms of
                            <command>cccusbreadoutlist::CCCUSBReadoutList</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        addWrite24 <replaceable>n a f d </replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Same as <command>addWrite16</command> but adds a
                            16 bit write to the list.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        addRead16 <replaceable>n a f ?lamwait?</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Adds a 16 bit read to the list.  The CAMAC read is
                            specified by <parameter>n</parameter> (slot),
                            <parameter>a</parameter> (subaddress) and
                            <parameter>f</parameter> (function code). Valid read
                            function codes must be in the range
                            <literal>[0..7]</literal>.
                            If the optional <parameter>lamwait</parameter>
                            parameter is present and true (nonzero)
                            it specifies that the CC-USB
                            should stall until either the module's slot signals
                            a LAM or the LAM times out.  This should not be true
                            for lists that are executed in immediate mode, but only
                            for lists that execute in data acquisition mode.
                        </para>
                        <para>
                            <parameter>object</parameter> is the command name of
                            a SWIG CCCUSBReadoutList object that has been gotten
                            from one of the forms of
                            <command>cccusbreadoutlist::CCCUSBReadoutList</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        addRead24 <replaceable>n a f ?lamwait</replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Same as <command>addRead16</command> above, however
                            24 bits of data and the Q, X will be transferred as
                            shown in section 4.6 of the CC-USB manual. Note that
                            the CCUSB Readout Framework will remove those bits
                            from data in the Scaler stack as it is assumed that
                            all of those transfers are 24 bits and that the
                            scaler stack will eventually be passed off to
                            scaler display programs that won't know the
                            Q/X bits are present.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        addControl <replaceable>n a f</replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Adds a CAMAC non data transfer (control) operation
                            to the list.  <parameter>n</parameter> and
                            <parameter>a</parameter> identify the module
                            slot and subaddress targeted by the operation and
                            <parameter>f</parameter> is the CAMAC function
                            code to be performed.  <parameter>f</parameter>
                            by CAMAC standard must be in the ranges
                            <literal>[8..15], [24..31]</literal>.
                        </para>
                        <para>
                            <parameter>object</parameter> is the command name of
                            a SWIG CCCUSBReadoutList object that has been gotten
                            from one of the forms of
                            <command>cccusbreadoutlist::CCCUSBReadoutList</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        addQStop <replaceable>n a f max ?lamwait?</replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Adds a Q-stop operation to the list.  Q-Stop operations
                            are block transfers that perform the Same operation
                            at the same target until a transfer count
                            is exhausted or an operation does not result in a
                            Q response from the module.
                        </para>
                        <para>
                            <parameter>n</parameter>, and <parameter>a</parameter>
                            identify the slot and subaddress to which the
                            function code <parameter>f</parameter> is addressed.
                            The assumption is that the operation is a
                            read, that is <parameter>f</parameter> is in the
                            range <literal>[0..7]</literal>.  <parameter>max</parameter>
                            is the maximum number of transfers allowed.
                            If the optional <parameter>lamwait</parameter> parameter
                            is true (default is false), the CC-USB will wait for
                            the module to signal a LAM (or LAM timeout) prior to
                            performing the operation.
                            <parameter>lamwait</parameter> should not be set to
                            true on lists performed in via <command>executeList</command>.
                        </para>
                        <para>
                            <parameter>object</parameter> is the command name of
                            a SWIG CCCUSBReadoutList object that has been gotten
                            from one of the forms of
                            <command>cccusbreadoutlist::CCCUSBReadoutList</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        addQStop24 <replaceable>n a f max ?lamwait? </replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Same as <command>addQStop</command> above but the
                            data transfers are 24 bits wide rather than 16 bits
                            wide.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        addQScan <replaceable>n a f max ?lamwait?</replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Same as <command>addQStop</command> however the
                            operation is a Q-Scan.  In a Q-Scan, after each
                            operation the subaddress is incremented.
                            If the subaddress would be <literal>16</literal>
                            the slot is incremented and the subaddress
                            reset to zero.
                        </para>
                        <para>
                            If there is no Q response, the sub address is
                            reset to zero and the slot incremented.  The
                            transfer terminates if either <parameter>max</parameter>
                            operations have taken place or if a transfer
                            results in a false X response (indicating the
                            scan advanced to an empty slot).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        addRepeat <replaceable>n a f count ?lamwait?</replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            This is the same as <command>addQStop</command>
                            however <parameter>count</parameter> operations
                            are unconditionally performed.
                        </para>
                        <para>
                            <parameter>object</parameter> is the command name of
                            a SWIG CCCUSBReadoutList object that has been gotten
                            from one of the forms of
                            <command>cccusbreadoutlist::CCCUSBReadoutList</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        addMarker <replaceable>value</replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Writes the 16 bit literal 
                            <parameter>value</parameter> to the output
                            buffer.  For immediate operations this is the
                            buffer of data returned by the <command>executeList</command>
                            operation.  For data acquisition lists, this is the
                            event buffer.
                        </para>
                        <para>
                            <parameter>object</parameter> is the command name of
                            a SWIG CCCUSBReadoutList object that has been gotten
                            from one of the forms of
                            <command>cccusbreadoutlist::CCCUSBReadoutList</command>
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
         </refsect1>
        <refsect1>
            <title>SEE ALSO</title>
            <para>
                <xref linkend='ccusb3-cccusb' />
                <xref linkend='ccusb3-CCCUSB' />
                <xref linkend='ccusb3-CCCUSBReadoutList' />
            </para>
        </refsect1>
       </refentry>

<!-- #include &lt;CModuleFactory.h&gt;           -->

	 <refentry id="ccusb3-cmodulefactory">
       <refmeta>
          <refentrytitle id="ccusb3-cmodulefactory-title">CModuleFactory</refentrytitle>
          <manvolnum>3ccusb</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CModuuleFactory</refname>
          <refpurpose>Creates specific slow control drivers</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>
            class <ooclass><classname>CModuleFactory</classname></ooclass> {
           <methodsynopsis>
            <modifier>static</modifier> 
            <type>CModuleFactory*</type>
             <methodname> instance</methodname>
             <void />
             
             <modifier></modifier>
           </methodsynopsis>
            <methodsynopsis>
                <modifier></modifier>
                <type>void </type>
                <methodname>addCreator</methodname>
                <methodparam>
                    <type>std::string</type><parameter> type</parameter>
                </methodparam>
                <methodparam>
                    <type> CModuleCreator*</type><parameter> pCreator</parameter>
                </methodparam>
                
                <modifier></modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>CControlHardware*</type>
                <methodname>create</methodname>
                <methodparam>
                    <type>std::string</type><parameter> type</parameter>
                </methodparam>
                <methodparam>
                    <type>std::string</type><parameter> name</parameter>
                </methodparam>
            </methodsynopsis>   
};
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            This class provides a factory that allows the
            <command>Module create</command> slow control server command to
            instantiate driver objects from the name of the class.
            The factory operates by matching a driver type with a
            <link linkend='ccusb3-cmodulecreator'>creator object</link>.
            The creator object then instantiates the actual object.
          </para>
          <para>
            Note that <classname>CModuleFactory</classname> is a
            <ulink url='http://en.wikipedia.org/wiki/Singleton_pattern'>
                singleton</ulink>.  See <methodname>instance</methodname>
                in METHODS below for information about how to get a
                pointer to the singleton instance of this class,.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                     <modifier>static</modifier> 
                     <type>CModuleFactory*</type>
                      <methodname> instance</methodname>
                      <void />
                      
                      <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the
                        <ulink url='http://en.wikipedia.org/wiki/Singleton_pattern'>
                        singleton</ulink> instance of this class.  The class
                        constructor and destructor are
                        private to the class so this is the only
                        clean C++ mechanism to gain access to a
                        <classname>CModuleFactory</classname> object.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                     <methodsynopsis>
                         <modifier></modifier>
                         <type>void </type>
                         <methodname>addCreator</methodname>
                         <methodparam>
                             <type>std::string</type><parameter> type</parameter>
                         </methodparam>
                         <methodparam>
                             <type> CModuleCreator*</type><parameter> pCreator</parameter>
                         </methodparam>
                         
                         <modifier></modifier>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Associates a new creator object with a module type.
                        <parameter>type</parameter> is the  name of the
                        module type.  When this type is used in a
                        <command>Module create</command> command,
                        the creator specified by <parameter>pCreator</parameter>
                        is used to generate the module object.
                    </para>
                    <para>
                        Note that the object pointed to by
                        <parameter>pCreator</parameter> must live for
                        the duration of the program.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                     <methodsynopsis>
                         <type>CControlHardware*</type>
                         <methodname>create</methodname>
                         <methodparam>
                             <type>std::string</type><parameter> type</parameter>
                         </methodparam>
                         <methodparam>
                             <type>std::string</type><parameter> name</parameter>
                         </methodparam>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates a specific <parameter>type</parameter> of
                        slow control driver named <parameter>name</parameter>.
                        The driver object is dynamically created.  If it is necessary
                        to destroy it that must be done with <literal>delete</literal>.
                    </para>
                </listitem>
            </varlistentry>
          </variablelist>
       </refsect1>
     </refentry>     


<!-- #include &lt;CModuleCreator.h&gt;     -->

	 <refentry id="ccusb3-cmodulecreator">
       <refmeta>
          <refentrytitle id="ccusb3-cmodulecreator-title">CModuleCreator</refentrytitle>
          <manvolnum>3ccusb</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CModuleCreator</refname>
          <refpurpose>Object creational ABC for <classname>CModuleFactory</classname></refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>
            class <ooclass><classname>CModuleCreator</classname></ooclass> {
           <methodsynopsis>
            <modifier>virtual</modifier>  
            <type>CControlHardware*</type>
             <methodname>operator()</methodname>
             <methodparam>
                <type>std::string</type> <parameter> name</parameter>
             </methodparam>
             
             <modifier> = 0</modifier>
           </methodsynopsis>
};
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            <classname>CModuleCreator</classname> provides an abstract base class
            for module creators.  Module creators are objects that are
            registered with the
            <link linkend='ccusb3-cmodulefactory'
                  endterm='ccusb3-cmodulefactory-title' />
            singleton.  Objects that are instances of a concrete derivation from
            this class are matched up with object type names (used in the
            <command>Module create</command> command) and are responsible for
            creating objects of the specified type.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>  
                        <type>CControlHardware*</type>
                         <methodname>operator()</methodname>
                         <methodparam>
                            <type>std::string</type> <parameter> name</parameter>
                         </methodparam>
                         
                         <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Pure virtual method that concrete classes must define/supply.
                        <parameter>name</parameter>  is the name of the item being
                        created by the <command>Module create</command> command
                        that caused this method to be called.
                    </para>
                </listitem>
            </varlistentry>
          </variablelist>
       </refsect1>
     </refentry>     

<!-- #include &lt;CControlHardware.h&gt;    -->
	 <refentry id="ccusb3-ccontrolhardware">
       <refmeta>
          <refentrytitle id="ccusb3-ccontrolhardware-title">CControlHardware</refentrytitle>
          <manvolnum>3ccusb</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CControlHardware</refname>
          <refpurpose>Base class (ABC) of a slow controls driver</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>
           class <ooclass><classname>CControlHardware</classname></ooclass> {
           <constructorsynopsis>
          <methodname>CControlHardware</methodname>
          <methodparam>
            <type>std::string</type> <parameter>name</parameter>
          </methodparam>
          
           </constructorsynopsis>
           <methodsynopsis>
                <modifier>virtual</modifier>
               <type>void </type>
               <methodname>onAttach</methodname>
               <methodparam>
                <type>CControlModule&amp;</type><parameter>configuration</parameter>
               </methodparam>
               
               <modifier> = 0</modifier>
             </methodsynopsis>
             <methodsynopsis>
                 <modifier>virtual </modifier>
                 <type>void</type>
                 <methodname> Initialize</methodname>
                 <methodparam>
                    <type>CCCUSB&amp;</type><parameter>crate</parameter>
                 </methodparam>
                 
                 <modifier></modifier>
             </methodsynopsis>  
             <methodsynopsis>
                 <modifier>virtual </modifier>
                 <type>std::string </type>
                 <methodname>Update</methodname>
                 <methodparam>
                    <type>CCCUSB&amp;</type><parameter>crate</parameter>
                 </methodparam>
                 
                 <modifier> = 0</modifier>
             </methodsynopsis>  
             <methodsynopsis>
                 <modifier> virtual </modifier>
                 <type>std::string </type>
                 <methodname>Set </methodname>
                 <methodparam>
                    <type>CCCUSB&amp;</type><parameter>crate</parameter>
                 </methodparam>
                 <methodparam>
                    <type>std::string</type><parameter> parameter</parameter>
                 </methodparam>
                 <methodparam>
                    <type>std::string</type><parameter> value</parameter>
                 </methodparam>
                 
                 <modifier> = 0</modifier>
             </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type> std::string</type>
                <methodname> Get</methodname>
                <methodparam>
                    <type>CCCUSB&amp;</type><parameter> crate</parameter>
                </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>parameter</parameter>
                </methodparam>
                
                <modifier> = 0</modifier>
            </methodsynopsis>
           <methodsynopsis>
               <modifier>virtual </modifier>
               <type>void </type>
               <methodname>clone</methodname>
               <methodparam>
                <modifier>const</modifier><type> CControlHardware&amp;</type>
                <parameter>rhs</parameter>
               </methodparam>
               
               <modifier> = 0</modifier>
           </methodsynopsis>  

};
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            <classname>CControlHardware</classname> is the abstract base class
            for slow controls drivers.  See METHODS below for the set of methods
            a driver must implement. See
            <link linkend='ccusb3-cmodulefactory' endterm='ccusb3-cmodulefactory-title' />
            and
            <link linkend='ccusb3-cmodulecreator' endterm='ccusb3-cmodulecreator-title' />
            for information about how to make the <command>Module create</command>
            command aware of your driver so that it instantiate it.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis> 
                        <methodname>CControlHardware</methodname>
                        <methodparam>
                          <type>std::string</type> <parameter>name</parameter>
                        </methodparam>
                        
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        The base class constructor is how a module name gets
                        associated with a module driver instance.  The
                        <parameter>name</parameter> parameter specifies
                        the name of the module.  This is normally passed in
                        from the name in the <command>Module create</command>
                        command.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                         <modifier>virtual</modifier>
                        <type>void </type>
                        <methodname>onAttach</methodname>
                        <methodparam>
                         <type>CControlModule&amp;</type><parameter>configuration</parameter>
                        </methodparam>
                        
                        <modifier> = 0</modifier>
                      </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Each driver instance has a configuration associated with
                        it wrapped inside a <classname>ControlModule</classname>
                        object.  This packaging provides the transparent configuration
                        and command dispatching required to decouple the
                        code required by the device driver from the code that
                        makes use of the device driver.
                    </para>
                    <para>
                        A driver instance and its <classname>CControlModule</classname>
                        get bound together soon after the driver instance and
                        <classname>CControlModule</classname> are created.  At that
                        time, the framework code invokes the
                        <methodname>OnAttach</methodname> method of the driver
                        passing in <parameter>configuration</parameter>, a
                        reference to the instance's <classname>CControlModule</classname>
                        object.
                    </para>
                    <para>
                        The driver normally needs to save <parameter>configuration</parameter>
                        so that it an access its configuration in later operations.
                        The driver also should create configuration parameters
                        when <methodname>OnAttach</methodname> is called.
                        In most cases a driver will at least neaed to define
                        a <literal>slot</literal> configuration parameter
                        that can be configured with the slot in which the hardware
                        has been installed.
                    </para>
                    <para>
                        This method is pure virtual in the base class and
                        therefore must be implemented in concrete derived classes.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                      <methodsynopsis>
                          <modifier>virtual </modifier>
                          <type>void</type>
                          <methodname> Initialize</methodname>
                          <methodparam>
                             <type>CCCUSB&amp;</type><parameter>crate</parameter>
                          </methodparam>
                          
                          <modifier></modifier>
                      </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is called after the control configuration
                        script has completely run.  It provides for one-time
                        initialiation to set the device into a known state.
                        The <parameter>crate</parameter> parameter is a
                        controller object that allows the method to
                        perform CAMAC operations.
                    </para>
                    <para>
                        The base class method does nothing but is defined.
                        Therefore concrete classes that do not require
                        device initialization may omit this method.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                      <methodsynopsis>
                          <modifier>virtual </modifier>
                          <type>std::string </type>
                          <methodname>Update</methodname>
                          <methodparam>
                             <type>CCCUSB&amp;</type><parameter>crate</parameter>
                          </methodparam>
                          
                          <modifier> = 0</modifier>
                      </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is intended for devices with write only
                        registers.  It allows internal shadow state to be
                        written to the device.  The <parameter>crate</parameter>
                        parameter is the controller object that allows the
                        method to perform CAMAC operations.
                    </para>
                    <para>
                        On success this method is supposed to return
                        <literal>OK</literal> while on failure, it should
                        return a string of the form:
                        <literal>ERROR - </literal>
                        <replaceable>Some human readable error message</replaceable>.
                        </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                      <methodsynopsis>
                          <modifier> virtual </modifier>
                          <type>std::string </type>
                          <methodname>Set </methodname>
                          <methodparam>
                             <type>CCCUSB&amp;</type><parameter>crate</parameter>
                          </methodparam>
                          <methodparam>
                             <type>std::string</type><parameter> parameter</parameter>
                          </methodparam>
                          <methodparam>
                             <type>std::string</type><parameter> value</parameter>
                          </methodparam>
                          
                          <modifier> = 0</modifier>
                      </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is called by the framework whena a client
                        has requested a slow control parameter be set.
                        The <parameter>crate</parameter> parameter
                        is the controller object that allows the driver to perform
                        CAMAC operations.
                    </para>
                    <para>
                        Each device defines a set of settable parameters.
                        These are given names by the driver.  The client
                        specifies the name of the parameter to be
                        set and its value.  These are transmitted to the driver's
                        <methodname>Set</methodname> method via the
                        <parameter>parameter</parameter> and
                        <parameter>value</parameter> parameters respectively.
                    </para>
                    <para>
                        The driver is supposed to set the named
                        <parameter>parameter</parameter> to
                        <parameter>value</parameter>.  On success,
                        the driver should return the string <literal>OK</literal>
                        If the driver detects an error it should return a string
                        of the form:
                        <literal>ERROR - </literal><replaceable>Some human readable error string</replaceable>
                    </para>
                    <para>
                        This method is pure virtual in this base class so it must
                        be defined in concrete drivers.  Device drivers that
                        manage devices without settable parameters can
                        simple return an error string.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                     <methodsynopsis>
                         <modifier>virtual</modifier>
                         <type> std::string</type>
                         <methodname> Get</methodname>
                         <methodparam>
                             <type>CCCUSB&amp;</type><parameter> crate</parameter>
                         </methodparam>
                         <methodparam>
                             <type>std::string</type> <parameter>parameter</parameter>
                         </methodparam>
                         
                         <modifier> = 0</modifier>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        The <methodname>Get</methodname> method is called when
                        a client requests a parameter from a device.  The
                        <parameter>crate</parameter> parameter is the controller
                        object and can be used to perform CAMAC operations.
                    </para>
                    <para>
                        As with <methodname>Set</methodname> the driver defines
                        a set of named parameters that can be read.  The
                        client provides this as the <parameter>parameter</parameter>
                        parameter.  The driver is supposed to retrive the value
                        of <parameter>parameter</parameter> from the hardware,
                        convert it to text and return that text as its value.
                        If the driver detects an error, it returns a string
                        of the form
                        <literal>ERROR</literal><replaceable>Some human readable error message</replaceable>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>clone</methodname>
                        <methodparam>
                         <modifier>const</modifier><type> CControlHardware&amp;</type>
                         <parameter>rhs</parameter>
                        </methodparam>
                        
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is used to support virtual copy construction.
                        The driver should copy the state of
                        the <parameter>rhs</parameter> objet into its own state.
                        The copy should be done safely so that destruction
                        of <parameter>rhs</parameter> won't implicitly destroy
                        parts of the copied state.
                    </para>
                    <para>
                        The driver is guaranteed that the actual type of
                        <parameter>rhs</parameter> is the same as the class
                        of the driver itself.
                    </para>
                </listitem>
            </varlistentry>
          </variablelist>
       </refsect1>
     </refentry>     
	 <refentry id="ccusb3-ccontrolmodule">
       <refmeta>
          <refentrytitle id="ccusb3-ccontrolmodule-title">CControlModule</refentrytitle>
          <manvolnum>3ccusb</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CControlModule</refname>
          <refpurpose>Configuration and wrapper for CControlHardware</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>
            class <ooclass><classname>CControlModule : public CConfigurableObject</classname></ooclass> {
           <constructorsynopsis>
          <methodname>CControlModule</methodname>
          <methodparam>
            <type>std::string</type><parameter> name</parameter>
          </methodparam>
          <methodparam>
            <type>CControlHardware&amp;</type><parameter>hardware</parameter>
          </methodparam>
          
           </constructorsynopsis>
           <methodsynopsis>
               <modifier></modifier>
               <type>void</type>
               <methodname>Initialize</methodname>
               <methodparam>
                <type>CCCUSB&amp;</type> <parameter>crate</parameter>
               </methodparam>
               
               <modifier></modifier>
           </methodsynopsis>
           <methodsynopsis>
               <modifier></modifier>
               <type>std::string</type>
               <methodname> Update</methodname>
               <methodparam>
                <type>CCCUSB&amp;</type><parameter> crate</parameter>   
               </methodparam>
               
               <modifier></modifier>
           </methodsynopsis>  
            <methodsynopsis>
                <modifier></modifier>
                <type>std::string</type>
                <methodname> Set</methodname>
                <methodparam>
                    <type>CCCUSB&amp;</type><parameter> crate</parameter>
                </methodparam>
                <methodparam>
                    <modifier>const</modifier><type> char*</type>
                    <parameter> what</parameter>
                </methodparam>
                <methodparam>
                    <modifier>const</modifier><type> char*</type>
                    <parameter>value</parameter>
                </methodparam>
                
                <modifier></modifier>
            </methodsynopsis>  
            <methodsynopsis>
                <modifier></modifier>
                <type>std::string </type>
                <methodname>Get</methodname>
                <methodparam>
                    <type>CCCUSB&amp;</type><parameter> crate</parameter>
                </methodparam>
                <methodparam>
                    <modifier>const</modifier><type> char*</type>
                    <parameter>what</parameter>
                </methodparam>
                
                <modifier></modifier>
            </methodsynopsis>  
};           
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            <classname>CControlModule</classname> objects serve a dual purpose.
            On the one hand, the methods supplied by them wrap the
            driver objects (
            <link linkend='ccusb3-ccontrolhardware' endterm='ccusb3-ccontrolhardware-title' />
            derived objects).
            On the other hand, by inheriting from
            <link linkend='ccusb3-CConfigurableObject'
                  endterm='ccusb3-CConfigurableObject-title' />, this object
            provides a configuration database for those driver object.
          </para>
       </refsect1>

     </refentry>     

<!-- /manpage -->



