<!-- chapter frameworks -->

<chapter>
    <title>VMUSB readout</title>
    <para>
        The VMUSB readout framework provides support for the Wiener-JTec
        VM-USB VME controller. The VM-USB is a USB VME controller that uses
        a Xilinx gate array to implement a VME list processor.  This allows
        events to be readout autonomously by the VM-USB without intervention
        by the host processor.
        The VMUSB Readout framework provides:
    </para>
    <itemizedlist>
        <listitem><para>
            A high level approach to the problem of data taking with the VM-USB
        </para></listitem>
        <listitem><para>
            Support for user written device support without any need to
            understand the format of list operations supported by the VM-USB.
            Drivers can be written in C++.
        </para></listitem>
        <listitem>
            <para>
                Direct insertion of data taken to an arbitrary destination
                ringbuffer.
            </para>
        </listitem>
        <listitem>
            <para>
                A potential data source for the NSCL event builder.
                </para>
        </listitem>
    </itemizedlist>
    <para>
        This chapter provides:
    </para>
    <itemizedlist>
        <listitem>
            <para>
                The philosophy behind the VMUSB readout framework.
            </para>
        </listitem>
        <listitem>
            <para>
                How to write configuration files for the VMUSB readout
                framework.
            </para>
        </listitem>
        <listitem>
            <para>
                How to write device support modules in in C++ and incorpoprate
                those modules into the
                VMUSB readout framework.
            </para>
        </listitem>
        <listitem>
            <para>
                How to write device support modules in Tcl and incorporate
                those modules into a VM-USB readout DAQ configuration file.
            </para>
        </listitem>
	<listitem>
	  <para>
	    How to write device support modules for the slow control server in C++
	  </para>
	</listitem>
	<listitem>
	  <para>
	    How to write device support modules for the slow control server in Tcl.
	  </para>
	</listitem>
        <listitem>
            <para>
                The slow controls protocol and its primitives.
            </para>
        </listitem>
        <listitem>
            <para>
                Variable monitoring.
            </para>
        </listitem>
        <listitem>
            <para>
                Information on how to run VMUSBReadout under the state/boot
                managers that were introduced with NSCLDAQ-11.0
            </para>
        </listitem>
    </itemizedlist>
    <para>
        Reference information is available in the
        <literal>3vmusb</literal> section of the reference material.
    </para>
    <section>
        <title>How the VMUSB readout framework works</title>
        <para>
            The VM-USB readout framework taks a high level approach to
            specifying and configuring a readout case.   Users write a
            configuration file that specifies at a very high level which
            devices are used, their configuration and which ones need to be
            read under which circumstances (The VM-USB supports up to 8 lists
            with differing trigger conditions).
        </para>
        <para>
            The framework supports data taking (physics and scaler triggers), as
            well as a mechanism for building and integrating control panels
            for slow controls devices.  A plugin architecture supports the addition
            of user support for devices that are not now supported by internal
            drivers.
        </para>
        <para>
            The recurring concepts for configuring data taking and slow controls
            devices are:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    A Tcl configuration file describes the devices used
                    by the experiment.
                </para>
            </listitem>
            <listitem>
                <para>
                    Each supported device class is represented in the
                    configuration file by a Tcl command ensemble. The
                    command ensemble provides subcommands that allow you to
                    create, configure and query the configuration of
                    physical devices (device instances).
                </para>
            </listitem>
            <listitem>
                <para>
                    The device configuration is represented in the configuration
                    file in manner analagous to the state of a Tk widget.
                    That is, you never actually program the device directly,
                    you simply specify the desired configuration. The actual
                    programming is done by the device class's device support
                    software.
                </para>
            </listitem>
            <listitem>
                <para>
                    In accordance with the way the VM-USB operates, you can create
                    8 lists or <firstterm>stack</firstterm>s in VM-USB parlance.
                    Some of these stacks have special meaning to either the
                    framework or to the VM-USB.  One stack is reserved by the
                    VM-USB as the target of periodic triggers and is used to
                    support scaler readout/display.  A second stack is reserved
                    for a software periodic trigger and is used to support
                    devices that require periodic monitoring (e.g. detector
                    bias supplies which may trip during operation due to interlock
                    conditions).   Of the remaining 6 stacks one can be triggered
                    by a VM-USB front panel input and the remaining 5 can
                    be triggered by VME backplane interrupts.
                </para>
                <para>
                    Each stack has, configuration properties as well. One
                    configuration property is the set of modules managed
                    by that stack.  Modules managed by that stack are initialized
                    by the software, in accordance with their configuration,
                    and contribute to the readout list that executes in response
                    to that stack's trigger.
                </para>
            </listitem>
        </itemizedlist>
    </section>
    <section>
        <title>Writing DAQ configuration files</title>
        <para>
            The DAQ configuration file is processed at the beginning of each run.
            The configuration file is processed in a fresh interpreter each time.
            You therefore cannot maintain any state across runs via your configuration
            file.
        </para>
        <para>
            To illustrate module creation and configuration,
            this let's look at a fragment from a configuration
            file:
        </para>
        <example>
            <title>Creating and configuring devices</title>
            <programlisting>
adc create myadc 0x11000000
adc config myadc -geo 15
            </programlisting>
        </example>
        <para>
            The <command>adc</command> command implements base support for the
            CAEN 32 channel digitizer family (V775, V785, V792, V862).  The first
            command creates an instance of one of those modules with a base address
            <literal>0x11000000</literal>.  The instance is given the name
            <literal>myadc</literal> to distinguish it from other digitizers
            of that or other types.
        </para>
        <para>
            The second line sets a configuration parameter, the geographical
            address of the  module, for the instance created by the first line.
            Each device type supports a set of configuration parameters much in the
            same way Tk objects support configuration options.
            The reference ssection <literal>3vmusb</literal> provides detailed
            information about the configuration options supported by each
            device class.
        </para>
        <para>
            Configuration files must also specify at least one stack and, if
            scaler modules are to be read periodically, a second scaler stack.
            See the <xref linkend="ccusb3-stack" /> command
            in the reference material for detailed information about how
            to create and configure stacks.
        </para>
        <para>
            To continue with the previous example:
        </para>
        <example>
            <title>Configuring an event stack</title>
            <programlisting>
stack create events
stack config event -trigger nim1 -modules [list myadc]
            </programlisting>
        </example>
        <para>
            Stacks are created and configured exactly like any other module.
            In this configuration file fragment, a stack named
            <literal>events</literal> is created.  It is configured to
            manage the <literal>myadc</literal> module (<option>-modules</option>).
            It is configured to use the IN 1 input of the VM-USB
            (<literal>-trigger nim1</literal>) to trigger the stack.
        </para>
        <para>
            Finally here is a configuration file fragment that sets up an
            SIS 3820 scaler and a scaler stack to read it every 2 seconds:
        </para>
        <example>
            <title>Configuring a VM-USB scaler stack</title>
            <programlisting>
sis3820 create sisscaler 0x38000000

stack create scaler 
stack config scaler -modules [list sisscaler] -trigger scaler -period 2
            </programlisting>
        </example>
        <para>
            The reference pages in <literal>3vmusb</literal> describe, among other
            things the commands that implement device support that are supported
            by the NSCL programming group.  In addtion to user device drivers
            that are described later in this chapter, two device drivers support
            modules have been contributed by Washington University at St. Louis.
            These modules support XLMs used to read out the ASIC systems they
            have developed for managing large detector arrays.
        </para>
        <para>
            For information about how to use those modules, contact
            Lee Sobotka or Jon Elson at Washington University directly.
        </para>
    </section>
    
    <section>
        <title>Writing C++ device support software</title>
        <para>
            This section describes how to write C++ software support for new
            data taking devices and how to integrate that support into the
            system.  Device support modules are built into shared images.
            Tcl provides the <command>load</command> command which loads
            a shared object into an application and invokes an initialization
            function.  This provicdes a plugin scheme that the framework
            leverages to support externally written device drivers.
        </para>
        <para>
            A device driver therefore consists of a C++ program that provides
            a new device class and an initialization function that associates
            this class with a Tcl command in the interpreter that reads the
            configuration file.  Since each time the configuration file is read,
            a new interpreter is used, this also means that the current version
            of the device driver shared image is loaded at the start of each
            run.
        </para>
        <para>
            The device driver support package is supplied as a driver development
            kit that consists of a template driver and a Makefile.  These are two
            files in the <filename>vmusbdriver</filename> directory of the
            NSCLDAQ installation.  The example below shows how to create
            a new directory and prepare it for driver development.  In the example
            we are assuming that the environment variable <literal>DAQROOT</literal>
            points to the top level of the installation directory.
        </para>
        <example>
            <title>Obtaning the VM-USB device driver development kit</title>
            <programlisting>
mkdir mydriver
cd mydriver
cp $DAQROOT/vmusbdriver/drivertemplate.cpp .
cp $DAQROOT/vmusbdriver/Makefile .
            </programlisting>
        </example>
        <para>
            The template driver is a complete example that builds a
            marker driver which inserts  constant word into the event.
            You can do a <command>make</command> to build the driver if you like.
            The template driver then defines a command <command>changeme</command>
            for the configuration file interpreter and a configuration parameter
            <option>-value</option> which allows you to set the value of the
            markrer.
        </para>
        <para>
            The script fragment below shows how to load the driver, create and
            configure a module instance using it. The fragment assumes that the
            driver shared object <filename>libtemplatedriver.so</filename>
            is in the same directory as the DAQ configuration script but that
            that directory my not be the current working directory when
            the configuration script is sourced.
        </para>
        <example>
            <title>Using a user written VMUSB driver</title>
            <programlisting>
set here [file nativename [file dirname [info script]]]
load [file join $here libtemplatedriver.so]
changeme cdreate testing -value -0x1234
            </programlisting>
        </example>
        <para>
            The work done by the <command>set here...</command> command builds
            the full path to the directory the driver is in.  This is necessary
            beause the <command>load</command> command normally only uses directories
            that are in the dynamic loader search path to look for shared objects.
            Note finally that once the driver is loaded, it registers the
            <command>changeme</command> command with the interpreter and that
            this command operates exactly like any other driver command.
        </para>
        <para>
            The next sections will examine the driver elements in detail. Before
            doing that, let's take a broad brush overview look at the driver
            template.
        </para>
        <para>
            The template consists of two sections.  The first section is the
            definition and implementation of a class which derives from
            <classname>CReadoutHardware</classname> the base class for
            all DAQ device support.  The methods of this class define
            configuration parameters, initialize the module as the run
            is starting and provides the appropriate commands to the
            VME list that is being generated for the stack this module
            is an element of.  Finally virtual duplication
            (<methodname>clone</methodname>) is also defined.
        </para>
        <para>
            The second section  is an initialization
            function that the Tcl <command>load</command> command automatically
            locates and calls.  This function creates an instance of the
            driver which is cloned for each device instance the user creates.
            It also associates a Tcl command with the device driver so that
            the DAQ configuration script can create and manipulate new instances.
        </para>
        <para>
            While the driver template is heavily commmented, and modification
            points indicated, the next few sectinos are a guided tour
            of the driver in detail, pointing out what needs to be modified
            to make the driver work with a specific device.
        </para>
        <section>
            <title>The driver <methodname>onAttach</methodname> method</title>
            <para>
                Each driver instance has a configuration database attached to it
                when it is created.  The configuration database holds configuration
                parameter definitions and their current values.  The framework
                takes care of managing the values for you, however you must
                define the set of configuration parameters supported by your
                driver.
            </para>
            <para>
                The template driver's code is (comments removed for brevity:
            </para>
            <informalexample>
                <programlisting>
void
CTemplateDriver::onAttach(CReadoutModule&amp; configuration)
{
  m_pConfiguration = &amp;configuration;     <co id='vmusb-dtemplate-saveconfig' />

  m_pConfiguration->addIntegerParameter("-base");  <co id='vmusb-dtemplate-baseparam' />
  m_pConfiguration->addIntegerParameter("-id", 0, 0xffff, 0); <co id='vmusb-dtemplate-idparam' />


}
                </programlisting>
            </informalexample>
            <para>
                In the discussion below, the numbers refer to the same numbers
                in the example above.
            </para>
            <calloutlist>
                <callout arearefs='vmusb-dtemplate-saveconfig'>
                
                    <para>
                        The method is passed a reference to its instance
                        configuration database.  This will be used here,
                        to establish configuration parameters, in the
                        <methodname>Initialize</methodname> method to know
                        how to set up the module and  in
                        <methodname>addReadoutList</methodname> to know
                        how to read the module.
                    </para>
                    <para>
                        This line saves a pointer to the configuration
                        database for this instance in member data where it
                        can be accessed in those other methods.
                    </para>
                </callout>
                <callout arearefs='vmusb-dtemplate-baseparam'>
                    
                    <para>
                        Most if not all VME modules must be addressed relative
                        to some base address that is set via jumpers or switches
                        on the module itself.  Therefore the template driver
                        provides a definition for a <option>-base</option>
                        option to hold this value.  The specific version of
                        <methodname>addIntegerParameter</methodname> used
                        only requires that the value passed to <option>-base</option>
                        be a valid integer.  No constraint on the range is
                        imposed.
                    </para>
                    
                </callout>
                <callout arearefs='vmusb-dtemplate-idparam'>
                    
                    <para>
                        Since the template driver inserts a marker
                        the <option>id</option> parameter is defined
                        to provide the value of the marker.  The VM-USB
                        only supports 16 bit markers, therefore the
                        version of <methodname>addIntegerParameter</methodname>
                        constrains the range of values to be in the range
                        <literal>[0..0xffff]</literal>.
                    </para>
                    <para>
                        If a constraint is specified, and a daq configuration
                        script violates it, the configuration file interpreter
                        outputs an error message and refuses to start the run.
                        Using constraints allows error checking to be done
                        by the configuration subsystem without intervention
                        by user code.
                    </para>
                    <para>
                        Constraint checking comes from the
                        <classname>CConfigurableObject</classname> class.
                        See <xref linkend='vmusb3-CConfigurableObject' />
                        for pre-defined constraints.  That manpage also shows
                        you how to create your own constraints if the pre-defined
                        ones don't work for you.
                    </para>
                    
                </callout>
            </calloutlist>
        </section>
        <section>
            <title>The driver <methodname>Initialize</methodname> method</title>
            <para>
                When a run is starting, each stack invokes the
                <methodname>Initialize</methodname> method for each element in
                its <option>-modules</option> list.  Each driver is supposed
                to query its configuration and do any initialization demanded
                by the configuration.  For example the <command>adc</command>
                command queries the set of pedestal values and programs them
                into its module (using the <option>-base</option> of course)
                at this time.
            </para>
            <para>
                The <methodname>Initialize</methodname> method is passed a
                reference to a <classname>CVMUSB</classname> object.  Methods
                on that object allow you to perform single or block VME
                operations.  You can also create and stock a
                <classname>CVMUSBReadoutList</classname> with several VME
                operations and ask the controller to execute that list in
                immediate mode.
            </para>
            <para>
                See <xref linkend='vmusb3-CVMUSB' /> and
                <xref linkend='vmusb3-CVMUSBReadoutList'
                        endterm='vmusb3-CVMUSBReadoutList-title'/> for reference
                information about those two classes.
            </para>
            <para>
                The template driver is a marker and does not perform any
                VME operations.  Since, however your driver will most likely
                need the <option>-base</option> parameter value, it shows
                how to obtain that from the configuration database:
            </para>
            <example>
                <title>The template driver <methodname>Initialize</methodname> method</title>
                <programlisting>
void
CTemplateDriver::Initialize(CVMUSB&amp; controller)
{

  uint32_t base = m_pConfiguration->getUnsignedParameter("-base");


}
                </programlisting>
            </example>
            <para>
                The configuration database stores all parameter values as
                strings after validating them however it also provides a rich
                set of member function to convert the string to some other
                format.  Since the <option>-base</option> parameter can take values
                greater than <literal>0x80000000</literal> it must be converted
                and treated as an unsigned integer.
                <methodname>getUnsignedParameter</methodname> converts the
                value of the configuration parameter given to an unsigned integer.
            </para>
        </section>
        <section>
            <title>The driver <methodname>addReadoutList</methodname> method</title>
            <para>
                The <methodname>addReadoutList</methodname> method is called
                by stacks containing a driver instance when the stack is
                building its list of VME operations to download into the VM-USB.
                <methodname>addReadoutList</methodname> is passed a
                <classname>CVMUSBReadoutList</classname> object and is expected
                to add entries to that object.
            </para>
            <para>
                The template ddriver fetches the <option>-base</option>
                and <option>-id</option> option values and adds a marker
                instruction to the stack with the value of the
                <option>-id</option> option.
            </para>
            <example>
                <title>Template Driver <methodname>addReadoutList</methodname> method</title>
                <programlisting>
void
CTemplateDriver::addReadoutList(CVMUSBReadoutList&amp; list)
{

  uint32_t base  = m_pConfiguration->getUnsignedParameter("-base"); 
  int      id    = m_pConfiguration->getIntegerParameter("-id"); <co id='vmusb-dtemplate-getid' />

  list.addMarker(id);                                            <co id='vmusb-dtemplate-addmarker' />
}

                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='vmusb-dtemplate-getid'>
                
                    <para>
                        The <option>-id</option> option is an integer
                        in the range <literal>[0 .. 0xffff]</literal>.
                        This line
                        fetches its current value from the configuration
                        database.
                    </para>
                    
                </callout>
                <callout arearefs='vmusb-dtemplate-addmarker'>
                    
                    <para>
                        This line adds a marker instruction to the
                        stack.  The value of the marker to be
                        inserted in the event is the value of the
                        <option>-id</option> configuration parameter.
                    </para>
                    
                </callout>
            </calloutlist>
        </section>
        <section>
            <title>Driver initialization <methodname>xxxx_init</methodname></title>
            <para>
                The driver will build to a shared object of the name
                <filename>libxxxx.so</filename> where you will choose
                <literal>xxxx</literal> when you edit the driver Makefile.
                When the <command>load</command> command loads this library,
                it will look for a function named
                <methodname>Xxxx_Init</methodname> (note the capitalization).
                and call it with a pointer to the running Tcl Interptreter.
            </para>
            <para>
                You must make sure the initialization entry point name is
                correct for the driver name.  For exmample:
                <filename>libmyvmedriver.so</filename> requires an initialization
                function entry point of
                <methodname>Myvmedriver_Init</methodname>.
            </para>
            <para>
                Let's pick apart the template driver's implementation of its
                initialization function.
            </para>
            <example>
                <title>
                    The VMUSB driver <methodname>Xxxx_Init</methodname>
                    function.
                </title>
                <programlisting>
extern "C" {                                     <co id="vmusb-dtemplate-ccall" />
  int Templatedriver_Init(Tcl_Interp* pInterp)   <co id="vmusb-dtemplate-initname" />
  {

    Tcl_PkgProvide(pInterp, "Templatedriver", "1.0"); <co id='vmusb-dtemplate-package' />

    CUserCommand::addDriver("changeme", new CTemplateDriver); <co id='vmusb-dtemplate-adddriver' />

    return TCL_OK;     <co id='vmusb-dtemplate-initsuccess' />
    
  }
}                      <co id='vmusb-dtemplate-endccall' />
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs="vmusb-dtemplate-ccall">
                    
                    <para>
                        The Tcl <command>load</command> command will be
                        looking for a specific function name to call
                        to initialize the library it just loaded.
                        C++ <firstterm>decorates</firstterm> or
                        <firstterm>mangles</firstterm> function names adding
                        information about the return type and the
                        type of parameters expected by the function.
                        This is how it implements function/operator overloading.
                    </para>
                    <para>
                        Using the <literal>extern "C"</literal> block shown
                        tells the GNU C++ compiler to use <literal>C</literal>
                        language call methods which disable this function
                        name mangling.  Without this, the <command>load</command>
                        command would not find the initialization function.
                    </para>
                
                </callout>
                <callout arearefs="vmusb-dtemplate-initname">
                
                    <para>
                        As described above, the initialization function
                        name must be precisely chosen to match both the
                        library and the package name (see below).
                        The function name used here must be modified to
                        match your changes to the  Makefile.  The
                        initialization function here is correct for
                        the package <literal>TemplateDriver</literal>
                        and the library file
                        <filename>libtemplatedriver.so</filename>.
                    </para>
                
                </callout>
                <callout arearefs='vmusb-dtemplate-package'>
                
                    <para>
                        This line also allows you to use the
                        Tcl <command>package require</command> command to
                        load the driver if you have created a
                        <filename>pkgIndex.tcl</filename> file using e.g.
                        <command>pkg_mkIndex</command> and added the diretory
                        the driver lives in to the Tcl package load path
                        (<varname>auto_path</varname>) or the
                        <varname>TCLLIBPATH</varname> environment variable.
                    </para>
                    <para>
                        The package name must match the part of the
                        function name prior to <literal>_Init</literal>, as it
                        is used to located the name of the package initialzation
                        function by <command>package require</command>
                    </para>
                
                </callout>
                <callout arearefs='vmusb-dtemplate-adddriver'>
                
                    <para>
                        This line associates the tcl command
                        <command>changeme</command> with the
                        driver by creating a <firstterm>prototype</firstterm>
                        instance of the driver object that will be cloned
                        to produce driver instances.  Normally you would change
                        the name of the command to be a meaningful command
                        name for your driver.
                    </para>
                    <para>
                        This is part of an implementation of the
                        <firstterm>prototype pattern</firstterm>. For more
                        about the prototype pattern see e.g.
                        <ulink url='http://en.wikipedia.org/wiki/Prototype_pattern'>
                            http://en.wikipedia.org/wiki/Prototype_pattern
                        </ulink>
                    </para>
                
                </callout>
                <callout arearefs='vmusb-dtemplate-initsuccess'>
                
                    <para>
                        The <command>load</command> or
                        <command>package require</command> command expects
                        the initialization function to return
                        <literal>TCL_OK</literal> on success or
                        <literal>TCL_ERROR</literal> if  it is not able
                        to successfully initialize. This line indicates
                        a successful installation/initialization of the library.
                    </para>
               
                </callout>
                <callout arearefs='vmusb-dtemplate-endccall'>
                    <para>
                        Ends the <literal>extern "C" { </literal> block.
                    </para>
                </callout>
            </calloutlist>
        </section>
    </section>
    <section>
        <title>Writing device support software in Tcl</title>
        <para>
            The <command>addtcldriver</command> command allows you to
            add a Tcl command ensemble as a module which can then be
            added to the <option>-modules</option> list of modules read out
            by a stack.  In Tcl a <firstterm>command ensemble</firstterm> is
            a command that has subcommands.  The <command>addtcldriver</command>
            command registers  the base command of a command ensemble
            as a module.  In turn, the command ensemble is required to provide
            at least two subcommands; <command>Initialize</command> and
            <command>addReadoutList</command> which perform functions
            analagous to methods with the same name in a C++ driver.
        </para>
        <para>
            Possibly the simplest way to build command ensembles that can be
            re-used to support more than one module is to use a
            Tcl object oriented extension.  When you do this, a driver
            is a class and instances of those classes are modules.  Almost all
            Tcl object oriented extensions make objects (class instances) command
            ensembles where the base name is the object names and methods of the
            class are  subcommands.
        </para>
        <para>
            Driver modules will also need to access the VM-USB during
            initialization and create lists of VME operations in their
            <methodname>addReadoutList</methodname> method.  This
            is accomplished by wrappgin the <classname>CVMUSB</classname>
            and <classname>CVMUSBReadoutList</classname> classes using the
            <firstterm>Simplified Wrapper and Interface Generator</firstterm> or
            SWIG.  SWIG wrappers are provided as loadable Tcl modules in the
            <filename>lib</filename> directory of the NSCLDAQ software
            installation.
        </para>
        <para>
            This chapter will look at two trivial drivers that put a
            marker in the buffer and, at initialization time, turn on the
            bottom yellow LED.  One of these drivers is written using
            <firstterm>Incr-Tcl</firstterm> (itcl) the other using
            <firstterm>Snit Is Not Incr Tcl</firstterm> (snit).
            While trivial these examples illustrate most of the
            key concepts you need to understand when writing device support
            software in Tcl.
        </para>
        <para>
            Finally, a configuration file fragment is shown that illustrates
            loading and using these two drivers.
        </para>
        <section>
            <title>An Incr-Tcl (itcl) driver</title>
            <para>
                The example below is a complete itcl driver class.  When the run
                is initialized, it lights to bottom yellow LED of the VM-USB.
                For each event it inserts a programmable marker (literal)
                value in the event.
            </para>
            <example>
                <title>Itcl VM-USB device driver</title>
                <programlisting>
lappend auto_path /usr/opt/daq/10.1/lib   <co id='vmusb-itcldrv-auto-path' />
package require Itcl                      <co id='vmusb-itcldrv-itclpkg' />
package require cvmusb                    <co id='vmusb-itcldrv-cvmusbpkg' />
package require cvmusbreadoutlist         <co id='vmusb-itcldrv-cvmusbrlistpkg' />

itcl::class marker-itcl {                 <co id='vmusb-itcldrv-class' />
    public variable value 0               <co id='vmusb-itcldrv-option' />

    constructor args {                    <co id='vmusb-itcldrv-constructor' />
        eval configure $args
    }

    public method Initialize driverPtr { <co id='vmusb-itcldrv-initialize' />

        cvmusb::CVMUSB c -this $driverPtr;  <co id='vmusb-itcldrv-wrapvmusb' />

        set leds [c readLEDSource]          <co id='vmusb-itcldrv-vmusbreadled' />

        set leds [expr {$leds &amp;  0xffff}]
        set leds [expr {$leds | 0x110000}]

        c writeLEDSource $leds             <co id='vmusb-itcldrv-vmusbwriteled' />

    }
    
    public method addReadoutList list {   <co id='vmusb-itcldrv-addrdolist' />

        cvmusbreadoutlist::CVMUSBReadoutList l -this $list; <co id='vmusb-itcldrv-wraplist' />

        l addMarker $value                 <co id='vmusb-itcldrv-addmarker' />

    }
}
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='vmusb-itcldrv-auto-path'>
                    <para>
                        In order to locate the SWIG wrappers of the
                        <classname>CVMUSB</classname> and
                        <classname>CVMUSBReadoutList</classname>, the Tcl
                        variable <varname>auto_path</varname> must be extended
                        to include the <filename>lib</filename> subdirectory
                        of the NSCLDAQ installation directory.  In this case,
                        NSCLDAQ is installed in <filename>/usr/opt/daq/10.1</filename>.
                        You will need to check your installation and use
                        the appropriate value here.
                    </para>
                </callout>
                <callout arearefs='vmusb-itcldrv-itclpkg'>
                    <para>
                        This loads the Incr-Tcl extension.  Incr-Tcl provides
                        object oriented constructs for Tcl.
                    </para>
                </callout>
                <callout arearefs='vmusb-itcldrv-cvmusbpkg'>
                    <para>
                        The <literal>cvmusb</literal> package is the
                        SWIG wrapping of the <classname>CVMUSB</classname>
                        C++ class.
                    </para>
                </callout>
                <callout arearefs='vmusb-itcldrv-cvmusbrlistpkg'>
                    <para>
                        The <literal>cvmusbreadoutlist</literal> package
                        is the SWIG wrapping of the
                        <classname>CVMUSBReadoutList</classname> C++ class.
                    </para>
                </callout>
                <callout arearefs='vmusb-itcldrv-class'>
                    <para>
                        This command creates an Incr-Tcl class.  A class itself
                        is a command ensemble whose main purpose is to create
                        instances (objects) of the class, which are also command
                        ensembles whose subcommands are the <firstterm>method</firstterm>s
                        of the class.  The class name <classname>marker-itcl</classname>
                        is used to generate instances of the class.
                    </para>
                    <para>
                        As with all object oriented languages, classes wrap
                        behavior and data into a single package.
                    </para>
                </callout>
                <callout arearefs='vmusb-itcldrv-option'>
                    <para>
                        C++ device support modules provide a set of
                        configuration options.  We want our driver to do that
                        as well.  In Incr-Tcl, instance variables that are
                        declared as <literal>public</literal> can be set
                        both at object construction time, and via an object's
                        built in <command>configure</command> method.
                    </para>
                    <para>
                        This makes Incr-Tcl objects very much like Tk widgets.
                        The example below shows how you can set the
                        <varname>value</varname>
                        variable at both construction and configuration time:
                        <informalexample>
                            <programlisting>
marker-itcl obj -value 0x1234;  # Set value to 0x1234 at construction time.
obj configure -value 0x4321;    # use <command>configure</command> to modify value.
                            </programlisting>
                        </informalexample>
                    </para>
                </callout>
                <callout arearefs='vmusb-itcldrv-constructor'>
                    <para>
                        Constructor methods are analagous to C++ constructors.
                        They are called when a class instance is created.
                        the <command>eval configure $args</command> takes
                        the arguments passed to the construtor and uses them
                        to configure public variables.
                    </para>
                    <para>
                        This constructor does nothing except allow the use
                        of configuration option settings when an object
                        is constructed.
                    </para>
                </callout>
                <callout arearefs='vmusb-itcldrv-initialize'>
                    <para>
                        <methodname>Initialize</methodname> implements
                        device initialization that is done at the start of the
                        run.  The <parameter>driverPtr</parameter> is a SWIG
                        <emphasis>pointer</emphasis> that represents the address
                        of the <classname>CVMUSB</classname> object normally
                        passed to C++ <methodname>Initialize</methodname>
                        driver methods.
                    </para>
                </callout>
                <callout arearefs='vmusb-itcldrv-wrapvmusb'>
                    <para>
                        This linexcomp contructs a SWIG wrapping of a
                        <classname>CVMUSB</classname> object.  The
                        <option>-this</option> option tells SWIG to build its
                        wrapping around an existing SWIG pointer.  The
                        end result of this line is that the object named
                        <literal>c</literal> is created that talks to the
                        same VM-USB as the object normally passed in to a
                        C++ device support class/object.
                    </para>
                </callout>
                <callout arearefs='vmusb-itcldrv-vmusbreadled'>
                    <para>
                        Invokes the <methodname>readLEDSource</methodname>
                        method of the <classname>CVMUSB</classname> object.
                        This reads the current value of the VM-USB LED source
                        register.  The arithmetic that follows modifies the
                        bottom Yellow LED selector to use the inverse of the
                        <literal>Not Slot one</literal> state as the
                        source of the LED.
                    </para>
                </callout>
                <callout arearefs='vmusb-itcldrv-vmusbwriteled'>
                    <para>
                        Writes the new value back to the LED register.
                        Using the inverse of the <literal>Not Slot one</literal>
                        source ensures that as long as the VM-USB is being
                        used as a slot 1 controller, it will have its
                        bottom yellow LED lit.
                    </para>
                </callout>
                <callout arearefs='vmusb-itcldrv-addrdolist'>
                    <para>
                        The <methodname>addReadoutList</methodname> method
                        is intended to provide a list of VME operations that
                        are executed in response to each event trigger.
                        The <parameter>list</parameter> is a SWIG pointer to the
                        <classname>CVMUSBReadoutList</classname> normally passed
                        to a C++ driver's <methodname>addReadoutList</methodname>
                        method.
                    </para>
                    <para>
                        The first command in this method wraps the
                        list in a SWIG object named <literal>l</literal>
                        so that it can be used from within Tcl to manipulate
                        the list.
                    </para>
                </callout>
                <callout arearefs='vmusb-itcldrv-addmarker'>
                    <para>
                        Adds a marker to the list.  A marker is a literal value.
                        The value of the marker comes from the
                        <varname>value</varname> object instance variable.
                        As previously discussed, since this is a public variable
                        it is hooked to the <option>-value</option> configuration
                        option for the object.
                    </para>
                </callout>
            </calloutlist>
            <para>
                In general you will need to look at the reference information
                on the SWIG wrappers for
                <link linkend='vmusb3-cvmusb-swig'>CVMUSB</link>
                <link linkend='vmusb3-cvmusbreadoutlist-swig'>CVMUSBReadoutList</link>
            </para>
        </section>
        <section>
            <title>A Snit Is Not Incr Tcl (snit) driver</title>
            <para>
                Snit is a pure Tcl object oriented extension to Tcl. In this
                section we will look at an annotated sample Snit Tcl driver.
                The sample driver will just turn on the VM-USB's bottom yellow
                LED at initialization time and inserts a configurable marker into
                each event in response to a trigger.
            </para>
            <para>
                While this driver is realtively trivial, it illustrates many
                of the key points you will need to understand to write Tcl
                drivers in snit.  If you have looked at the Incr-Tcl driver
                in the previous section there will be very little that is new
                here other than Snit syntactical differences from Incr-Tcl.
            </para>
            <example>
                <title>A Snit VM-USB driver.</title>
                <programlisting>
lappend auto_path /usr/opt/daq/10.1/lib   <co id='vmusb-snit-apath' />

package require snit                      <co id='vmusb-snit-snitpkg' />

package require cvmusb                   <co id='vmusb-snit-cvmusbpkg' />
package require cvmusbreadoutlist        <co id='vmusb-snit-cvmusbreadoutlist' />

snit::type marker-snit {                 <co id='vmusb-snit-type' />
    option -value 0;                     <co id='vmusb-snit-option' />

    constructor args {                   <co id='vmusb-snit-constructor' />
        $self configurelist $args        
    }

    method Initialize driverPtr {       <co id='vmusb-snit-init' />

        cvmusb::CVMUSB v -this $driverPtr; <co id='vmusb-snit-wrapcvmusb' />

        set leds [v readLEDSource]     <co id='vmusb-snit-readleds' />
        
        set leds [expr {$leds &amp; 0xf0ffffff}]; 
        set leds [expr {$leds | 0x08000000}]; 

        v writeLEDSource $leds         <co id='vmusb-snit-writelds' />
    }

    method addReadoutList list {       <co id='vmusb-snit-addreadoutlist' />
        cvmusbreadoutlist::CVMUSBReadoutList l  -this $list; <co id='vmusb-snit-wrapreadoutlist' />

        l addMarker $options(-value)   <co  id='vmusb-snit-addmarker' />

    }
}
                   
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='vmusb-snit-apath'>
                    <para>
                        In order to load the packages that wrap the
                        <classname>CVMUSB</classname> and
                        <classname>CVMUSBReadoutList</classname> you must
                        add the directory in which they are installed to the
                        <varname>auto_path</varname> variable.  This is the
                        <filename>lib</filename> directory below the top
                        level of your NSCLDAQ installation.  You may need
                        to change the directory in the example script to match
                        your installation.
                    </para>
                </callout>
                <callout arearefs='vmusb-snit-snitpkg'>
                    <para>
                        This line loads the
                        <literal>snit</literal> package.  Snit provides definitions
                        of the commands that make up the Snit is Not
                        Incr Tcl package.
                    </para>
                </callout>
                <callout arearefs='vmusb-snit-cvmusbpkg' >
                    <para>
                        Loads the <literal>cvmusb</literal> package.  This package
                        provides the Tcl wrapping of the
                        <classname>CVMUSB</classname> class.
                    </para>
                </callout>
                <callout arearefs='vmusb-snit-cvmusbreadoutlist'>
                    <para>
                        Loads the <literal>cvmusbreadoutlist</literal> package.
                        This package provides the Tcl wrapping of the
                        <classname>CVMUSBReadoutList</classname>.
                    </para>
                </callout>
                <callout arearefs='vmusb-snit-type'>
                    <para>
                        Snit allows you to create three types of
                        'classes', types, widgets,and widgetadaptors.  The latter
                        two have to do with creating widgets in snit's Tk
                        megawidget framework.  The first, the type,
                        is the most suited class type for a VMUSB driver.
                    </para>
                    <para>
                        This line creates a new snit::type named
                        <literal>marker-snit</literal>. Each instance of this
                        class can be registered as a module allowing it to be
                        included in a stack.
                    </para>
                </callout>
                <callout arearefs='vmusb-snit-option'>
                    <para>
                        Snit objects all have a built in
                        <command>configure</command>  sub-command much like the
                        one that Tk objects have.  The snit
                        <command>option</command> defines an option that is a
                        target for the <command>configure</command> sub-command.
                        Snit options are stord in an array accessible to all
                        methods named <varname>options</varname> the indices
                        of this array are the option names, the values of the
                        array are the values of the options.
                    </para>
                    <para>
                        The purpose of the <option>-value</option> option
                        is to hold the value of the marker that will be inserted
                        by this driver into each event.
                    </para>
                </callout>
                <callout arearefs='vmusb-snit-constructor'>
                    <para>
                        <command>constructor</command> methods are called
                        by snit when an object of a specified type is
                        created.  The body of this constructor invokes the
                        <command>configurelist</command> built in
                        sub-command (<varname>self</varname> is like the
                        C++ <varname>this</varname> pointer).
                    </para>
                    <para>
                        The call to <command>configurelist</command> processes
                        the parameters to the constructor as a set of option/value
                        pairs.  This allows objects to be constructed and
                        configured in a single step (again like
                        Tk widgets).
                    </para>
                </callout>
                <callout arearefs='vmusb-snit-init'>
                    <para>
                        The <methodname>Initialize</methodname> method
                        of an object is called by the readout framework
                        when a run is being started.  It is expected to
                        interact with the hardware to initialize the
                        device it manages in accordance with its configuration.
                    </para>
                    <para>
                        The <parameter>driverPtr</parameter> is a
                        <firstterm>SWIG Pointer</firstterm>.  Swig pointers
                        are text strings that provide a strongly typed pointer
                        to a C++ object.
                    </para>
                </callout>
                <callout arearefs='vmusb-snit-wrapcvmusb' >
                    <para>
                        This line creates a new SWIG object that wraps the
                        C++ object represented by <varname>driverPtr</varname>.
                        The resulting object is called <varname>v</varname>
                    </para>
                </callout>
                <callout arearefs='vmusb-snit-readleds'>
                    <para>
                        This invokes the <methodname>readLEDSource</methodname>
                        method on the SWIG object <varname>v</varname>.
                        That method reads the current value of the
                        LED Source register, a register internal to the VM-USB
                        that controls what makes the front panel LED's light.
                    </para>
                    <para>
                        The arithmetic that follows sets the field responsible
                        for controlling the bottom yellow LED such that it
                        will light on the inverse of the case when the VM-USB
                        is not a slot one controller.  This means that if the
                        VM-USB is in slot one, it will have the bottom
                        yellow LED lit.
                    </para>
                </callout>
                <callout arearefs='vmusb-snit-writelds'>
                    <para>
                        Once the new value of the LED source register is
                        computed this line writes then ew value back into the
                        LED source register.
                    </para>
                </callout>
                <callout arearefs='vmusb-snit-addreadoutlist' >
                    <para>
                        This method is normally called as a run is starting.
                        <varname>list</varname> is a SWIG pointer to a
                        <classname>CVMUSBReadoutList</classname>. The method is
                        expected to add the entries to that list it needs to
                        execute for each event trigger.
                    </para>
                </callout>
                <callout arearefs='vmusb-snit-wrapreadoutlist'>
                    <para>
                        Wraps the <parameter>list</parameter> parameter in a
                        SWIG object named <varname>l</varname> in a mannner
                        analagous to what was done in <methodname>Initialize</methodname>
                    </para>
                </callout>
                <callout arearefs='vmusb-snit-addmarker'>
                    <para>
                        Adds a markter to the list of VM-USB operations that
                        will be performed in response to an event trigger.
                        The value of the marker word (<literal>options(-value)</literal>)
                        is the value of the <option>-value</option> configuration
                        option.
                    </para>
                </callout>
            </calloutlist>
            <para>
                In general you will need to look at the reference information
                on the SWIG wrappers for
                <link linkend='vmusb3-cvmusb-swig'>CVMUSB</link>
                <link linkend='vmusb3-cvmusbreadoutlist-swig'>CVMUSBReadoutList</link>
             </para>
        </section>
        <section>
            <title>Using a Tcl driver in a DAQ configuration script</title>
            <para>
                This section assumes you are using a driver that has a
                generator of driver instances.  The object oriented examples
                meet those criteria.
                To use a Tcl driver in a DAQ configuration file you must:
            </para>
            <orderedlist>
                <listitem>
                    <para>
                        Incorporate the driver in the daqconfig file source code.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Create and configure an instance of the driver for
                        the device(s) it manages in your physical configuration
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Use the <command>addtcldriver</command> command to
                        turn each driver instance into a module.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        As with any module, incorporate it into a
                        stack's <option>-modules</option> list.
                    </para>
                </listitem>
            </orderedlist>
            <para>
                Consider the drivers we described in the previous section.
                Suppose the source code for those driver files,
                <filename>tcldriver-itcl.tcl</filename> and
                <filename>tcldriver-snit.tcl</filename> are located in the same
                directory as the DAQ configuration file.  The following
                configuration file fragment creates an instance of each
                and adds them to a stack containing other natively coded
                modules that is triggered on the NIM 1 input.
            </para>
            <example>
                <title>USing a Tcl VM-USB driver.</title>
                <programlisting>
source tcldriver-snit.tcl;                   # load a snit tcl driver.
marker-snit create snitmarker -value 0x5a5a; # Create an instance..
addtcldriver snitmarker;                     # Add it to the list of known modules.


source tcldriver-itcl.tcl;                   # load an incrtcl driver.
marker-itcl itclmarker -value 0xa5a5         # crate/configure an instance.
addtcldriver itclmarker                      # register it.

...
stack config event -modules [list test test2 test <emphasis>snitmarker itclmarker</emphasis>]

                </programlisting>
            </example>
            <para>
                In the exmample above, the Tcl modules are <emphasis>highlighted</emphasis>
                in the <command>stack</command> configuration command.
            </para>
            <formalpara>
                <title>Other approaches to packaging</title>
                <para>
                    If you rdriver is intended for re-use across several setups
                    and even users, the method described above is not maintainable.
                    In that case, it is better to stoere the driver sources in
                    some central location, add <command>package provide</command>
                    commands to each driver files and use
                    <command>pkg_mkIndex</command> command to build a package
                    index file.
                </para>
            </formalpara>
            <para>
                If this is done, and the directory added to the
                Tcl search path, you could then use
                <command>package require</command> to load the driver file.
                Storing driver code centrally allows you to ensure that
                experiments are using up-to-date versions of your software.
            </para>

        </section>
    </section>
            
    <section>
        <title> The slow controls subsystem</title>
        <para>
        </para>
       <para>
            There is nothing to stop you from creating device support that
            does not do anything in its <methodname>addReadoutList</methodname>.
            You could do this to implement static controls devices.  That is
            non data taking devices whose configuration is set up at the start of
            a run and cannot be dynamically modified.
        </para>
        <para>
            There are cases, however when you'd like to have some control
            panel associated with a device, that would provide a virtual knob
            allowing you to dynamically modify settings in the device.
            The slow controls subsystem supports this by offering a
            TCP/IP server which can accept commands to set and query
            devices.  
        </para>
        <para>
            If the run is halted, the slow controls server can directly
            manipulate the VMUSB to perform the desired device changes.
            If, however the VMUSB is in data taking mode, the slow controls
            server pauses the run, makes the setting and then resumes the run.
            You should avoid working with control panels during production runs
            for that reason.
        </para>
        <para>
            The philosophy of the slow controls subsystem is similar to that
            of the readout subsystem.  A controls configuration file defines
            the control modules present in the system and their unchanging
            configuration.  Note that the controls configuration file
            is read only as VMUSBReadout starts, not once per run as
            for the data acquisition configuration file.
        </para>
        <para>
            The <command>Module</command> command is used to create configure
            and query the configuration of slow controls devices known to the server.
            The following fragment from a controls configuration file
            creates and configurea a CAEN V812 CFD.
        </para>
        <informalexample>
            <programlisting>
Module create caenv812 cfd
Module config cfd -base 0x1245000 \
                  -file [file join [file dirname [info script]] cfd1.cofig]
            </programlisting>
        </informalexample>
        <para>
            The slow controls network protocol allows clients to connect
            to a Tcp/IP port and perform requests that are dispatched to
            specific drivers.  The <option>--port</option> option
            specifies the port number on which this Tcip/IP server is listening.
        </para>
        <para>
            Drivers have entry points to get and set values as well as
            to update their understanding of the state of the device.
            In addition a mechanism exists that allows drivers to periodically
            poll devices for status without pausing data taking.  This is done
            by providing a monitor list which is programmatically triggered
            on a periodic basis.
        </para>
        <para>
            Future releases of this documentation will describe how to
            write slow contrrols drivers and integrate them with the
            VM-USB readout framework.
        </para>
        <para>
            Normally device drivers for slow controls modules also have
            control panels associated with them.  For more information
            about the slow controls subsystem and for the protocol control
            panels use to communicate with the control server, see the
            3vmusb reference section.
        </para>

        <section>
            <title>Using Remote procedure call Immediate Lists.</title>
            <para>
                In addition to control panels the VM-USB supports the slow
                controls system executing immediate lists via remote procedure
                calls. This documentation will be fleshed out in a future
                version.
            </para>
            <para>
                This functionality must be enabled
                by including a <command>Module vmusb</command> command
                in your control configuration file.
            </para>
            <para>
                Clients then use a pair of classes/objects
                to perform VM-USB lists:
            </para>
            <variablelist>
                <varlistentry>
                    <term><classname>CVMUSBReadoutList</classname></term>
                    <listitem>
                        <para>
                            Instances of this class represent lists of VME
                            operations you want to perform via the server.
                            See <link linkend='vmusb3-CVMUSBReadoutList'
                                endterm='vmusb3-CVMUSBReadoutList-title' />
                            for reference information.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                   <term><classname>CVMUSBRemote</classname></term>
                   <listitem>
                    <para>
                        Instances of this class represent connections
                        to VMUSBReadout slow controls servers.  Instances
                        provide a mechanism for submitting a
                        <classname>CVMUSBReaoutlist</classname>
                        for remote execution and gathering the results
                        back for client code.
                    </para>
                    <para>
                        See <link linkend='vmusb3-CVMUSBRemote'
                            endterm='vmusb3-CVMUSBRemote-title' />
                        for reference information about this class.
                    </para>
                   </listitem>
                </varlistentry>
            </variablelist>
            <para>
                Programs using these classes must link to the
                <filename>libVMUSBRemote</filename> library in the NSCLDAQ
                <filename>lib</filename> subdirectory.
            </para>
        </section>
	<section>
	  <title>Writing slow control drivers in C++</title>
	  <para>
	    Slow control drivers can be dynamically loaded into the TclServer
	    that runs the slow controls software.  This section provides
	    an overview to the process of writing these drivers and loading them
	    into your VMUSBReadout program.
	  </para>
	  <para>
	    Slow control drivers consist of the following pair of classes:
	  </para>
	  <variablelist>
	    <varlistentry>
	      <term>The driver</term>
	      <listitem>
		<para>
		  Contains the actual code to translate Set, Get, Update
		  and Mon operations into actions on the hardware or internal
		  data or both.
		  Drivers are classes that are derived from
		  <classname>CControlHardware</classname>  They also
		  contain a configurable object called a <classname>CControlModule</classname>
		  which provides support for an option configuration database much like
		  that of readout drivers.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>A driver creator</term>
	      <listitem>
		<para>
		  This object is registered with a module factory and associated with
		  a module type.  It provides a method that creates a specific module
		  driver type.  The factory is used by the <command>Module</command>
		  command to create specific drivers.
		</para>
		<para>
		  The driver creator must be a subclass of <classname>CModuleCreator</classname>
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>An initialization function</term>
	      <listitem>
		<para>
		  The initialization function is called when the driver is loaded
		  either via the Tcl <command>load</command> command or via the
		  <command>package require</command> command if you create a Tcl
		  package index that supports loading your driver in that manner.
		</para>
		<para>
		  The initialization function must have <literal>C</literal> bindings
		  and is expected to register the creator with the module factory
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	  <para>
	  These three bits of code must be compiled and linked together into a
	  shared object.  The resulting shared object must have no dangling external
	  references outside of the VMUSBReadout program or else it cannot be loaded
	  by the Tcl server's interpreter.
	</para>
	<para>
	  What I mean by a dangling reference is best illustrated by an example.
	  Suppose you need the function <function>crypt</function> in your driver
	  (<command>man crypt</command> to know what that does).  That function
	  lives in the <filename>libcrypt</filename> library.  For a library intended 
	  to be linked into other code to make a complete program, it's not necessary
	  for your libarary to link explicitly to <filename>libcrypt</filename> so long
	  as the program itself is linke to <filename>libcrypt</filename>.
	  For a shared library used as a slow control driver, however no expclicitly
	  linking it to <filename>libcrypt</filename> would leave an undefined reference
	  that Tcl would not know how to satisfy, so the <command>load</command> of the
	  library would fail.
	</para>
	<section>
	  <title>Driver requirements</title>
	  <para>
	    A Slow controls device driver is a class that is derived from
	    the 
	    <link linkend='vmusb3_ccontrolhardware' 
		  endterm='vmusb3_ccontrolhardware_title' /> abstract base class.
	    In this section I will briefly go over the mandatory and optional 
	    requirements of a driver class as well as providing an annotated
	    sample (if silly) driver.
	  </para>
	  <para>
	    The <link linkend='vmusb3_ccontrolhardware' 
		  endterm='vmusb3_ccontrolhardware_title' /> class is an abstract
	    base class.  This means it has some virtual methods that are not 
	    implemented and must be implemented by derived classes.
	    In addition the name of the object being created (<command>Module</command>
	    command's name) is maintained by the base class.  
	  </para>
	  <para>
	    These constraints mean that a control driver class must implement the
	    following member functions.
	  </para>
	  <variablelist>
	    <varlistentry>
	      <term>constructor</term>
	      <listitem>
		<para>
		  The class must implement a constructor that takes as a parameter
		  (at least) a <classname>std::string</classname> modulename which
		  it passes to the base class constructor.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><methodname>onAttach</methodname> 
	            (<type>CControlModule&amp;</type> <parameter>configuration</parameter>)
	      </term>
	      <listitem>
		<para>
		  <methodname>onAttach</methodname> is called when the driver's
		  configuration object <parameter>configuration</parameter> is being
		  attached to the object.  The base class provides a protected data
		  item named <varname>m_pConfig</varname> in which a pointer to the
		  <parameter>configuration</parameter> can be stored for future use.
		</para>
		<para>
		  The <methodname>onAttach</methodname> method is also where you must
		  define your configuration options and their constraints.  Soon after this
		  method is invoked, the driver is likely to have to respond to 
		  requests to configure values into these parameters.
		  As with readout drivers, the process of giving values to configuration
		  options transparent to your driver code.  When you need to know the
		  value of an option, you just ask the <parameter>configuration</parameter>
		  and it's magically there.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>
		<methodname>Update</methodname>(<type>CVMUSB&amp;</type> <parameter>vme</parameter>
	      </term>
	      <listitem>
		<para>
		  For some devices it is necessary to maintain an internal state
		  that describes the device.  This is done for devices that are
		  write only such as the V812.  For those devicdes it is useful to be able
		  to refresh the device state from an internal copy of what the state should
		  be.  <methodname>Update</methodname> is provided for that  purpose.
		  This method must be implemented though the implementation can be empty.
		</para>
		<para>
		  The <parameter>vme</parameter> parameter is a reference to a VMUSB controller
		  object that can be used to perform VME operations or to execute a 
		  <classname>CVMUSBReadoutList</classname> of operations built up by this
		  method.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>
		<methodname>Set</methodname>(<type>CVMUSB&amp;</type> <parameter>vme</parameter>, 
		<type>std::string</type> <parameter>parameter</parameter>,
		<type>std::string</type> <parameter>value</parameter>)
	      </term>
	      <listitem>
		<para>
		  Fundamentally, slow control device drivers manage some settable 
		  parameters in a device.  The driver associates a name with each parameter.
		  The <methodname>Set</methodname> operation provides a new value for a parameter.
		  The driver is expected to propagate that value out to the device.
		</para>
		<para>
		  The <parameter>parameter</parameter> argument is the name of the parameter to
		  modify.  Names are assigned by the driver and known to the client via documentation.
		  <parameter>value</parameter> is the new value for the parameter. The driver is
		  responsible for all validity checking and error reporting in the event the parameter
		  value is not valid.
		</para>
		<para>
		  <parameter>vme</parameter> is a reference to a VMUSB controller object that is used
		  by the driver to perform VME operations or list of VME operations encapsulated in
		  a <classname>CVMUSBReaoutList</classname>
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>
		<methodname>Get</methodname>(<type>CVMUSB&amp;</type> <parameter>vme</parameter>,
		<type>std::string</type> <parameter>parameter</parameter>)
	      </term>
	      <listitem>
		<para>
		  This is expected to return the value of a <parameter>parameter</parameter> in 
		  the hardware.  The <parameter>vme</parameter> can be used to perform the
		  needed VME operations or lists of VME operations encapsulated in a
		  <classname>CVMUSBReadouList</classname>
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><methodname>clone</methodname>(<type>const CControllerHardware&amp;</type> <parameter>rhs</parameter>)
	      </term>
	      <listitem>
		<para>
		  There are times when the framework needs to create a copy of a driver instance. When 
		    this happens <methodname>clone</methodname> is invoked.  The
		    <parameter>rhs</parameter> object is the object we are copying into ourselves.  If the object
		    has no additional state it can just cop construct the
		    <classname>CControlMdoule</classname> configuration into <varname>m_pConfig</varname>.
		</para>
	      </listitem>
	    </varlistentry>
	  </variablelist>
	  <para>
	    In addition to the mandatory methods above, you can implement several optional
	    methods if required.
	  </para>
	  <variablelist>
	    <varlistentry>
	      <term><methodname>Initialize</methodname>(<type>CVMUSB&amp;</type> <parameter>vme</parameter>)
	      </term>
	      <listitem>
		<para>
		  If you need to perform any one-time initialization of your
		  hardware you can do that here.  An example of where this is used
		  is with the CAEN V812 driver.   The V812 registers
		  are write only.  Therefore, the driver maintains a
		  configuration file with settings and at initialization
		  time, that configuration file is read and loaded into the
		  device returning it to a known state.
		</para>
		<para>
		  The <parameter>vme</parameter> parameter is a reference to
		  a VMUSB controller object.  It can be used to perform
		  operations on the VME crate or to execute 
		  <classname>CVMUSBReadoutList</classname> objects the
		  method builds.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><methodname>addMonitorList</methodname> (<type>CVMUSBReadoutList&amp;</type> <parameter>vmeList</parameter>)
	      </term>
	      <listitem>
		<para>
		  For some devices, the ability set and get parameters is not the whole story. 
		  This is especially the case because in order to set or get a parameter, active data taking must
		  be stopped and restarted which is time-consuming.  Consider, for example, a VME Bias supply
		  controller.  A control panel would want to monitor the supply for trips periodically and display
		  those trips regardless of whether or not data taking is active.  This  is accomplisshed with
		  a monitor list.
		</para>
		<para>
		  The monitor list is one of the 8 stacks supported by the VM-USB.  It contains a set of operations
		  that are periodically performed by manually triggering the list in the action register.  The
		  data routing software forwards data from this list to the Tcl server for processing.  Since this list
		  can be triggered just like any other acquisition mode list, no time consuming stop/start is needed
		  when data taking is active.  If data taking is inactive the list is periodically issued as an
		  immediate mode list.
		</para>
		<para>
		  <methodname>addMonitorList</methodname> provides an opportunity for a driver to specify a set
		  of VME operations to perform to gather the needed data to monitor the device.
		  This is optional and the default method adds nothing to the list.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>
		<methodname>processMonitorList</methodname>(<type>void*</type> <parameter>pData</parameter>,
		<type>size_t</type> <parameter>remaining</parameter>)
	      </term>
	      <listitem>
		<para>
		  This is called when the data from a monitorlist becomes available.  The drivers
		  <methodname>processMonitorList</methodname> are called in the same order in which their
		  <methodname>addMonitorList</methodname> methods were called.
		  <parameter>pData</parameter> is a pointer to the as yet unprocesssed part of the
		  data read by the monitor list while <parameter>remaining</parameter> is the number
		  of bytes of unprocessed data in that list.
		  The return value from this method should be a pointer to the first unprocessed
		  byte of monitor list data after the data consumed by this driver.
		</para>
		<para>
		  Normally the driver will pull data out of the monitor list and store it internall for
		  the next call to <methodname>getMonitoredData</methodname> below.  It's up to the driver
		  how the data are stored.
		</para>
		<para>
		  The base class implementation just returns <parameter>pData</parameter> which is
		  exactly right for a driver that does not use monitor lists.
		</para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term>
		<methodname>getMonitoredData</methodname>()
	      </term>
	      <listitem>
		<para>
		  This is called when the Mon command is issued for this device.  The driver
		  should package up the most recently received data from the monitor list and return it
		  to the caller as a string in the documented form.  Note: Since many clients are in Tcl
                  it is convenient to return these data as a properly formatted Tcl list.
		</para>
	      </listitem>
	    </varlistentry>		  
	  </variablelist>
	  <para>
	    Let's look at the code for a rather silly user written driver a piece at a time.
	    The driver is not going to interact with any hardware.  What it will do is provide
	    the configuration options <option>-anint</option> which will hold an integer,
	    <option>-astring</option> which holds an arbitraty string, and 
	    <option>-alist</option> which holds a list of integers.
	    The Set and Get operations will modify and retrieve these options.
	    The driver won't support monitor lists.
	  </para>
	  <section>
	    <title>The driver</title>
	    <para>
	      This section provides an annotated view of the driver source code.  For clarity,
	      the header and driver are combined in a single file.  Comments that might ordinarily
	      be in the source code are in the annotations instead.
	    </para>
	    <example>
	      <title>Control driver headers</title>
	      <programlisting>
#include &lt;CControlHardware.h&gt;
#include &lt;CControlModule.h&gt;
#include &lt;CVMUSB.h&gt;
#include &lt;CVMUSBReadoutList.h&gt;
	      </programlisting>
	    </example>
	    <para>
	      This section of the driver sourcde includes the headers required by the driver 
	      itself.  The headers are:
	    </para>
	    <orderedlist>
	      <listitem><para>
		<filename>CControlHardware.h</filename> the base class for the
		driver class
	      </para></listitem>
	      <listitem><para>
		<filename>CControlModule.h</filename>  the specialized version of the 
		configurable object that is used by control drivers is a  <classname>CControlModule</classname>
		this includes the command dispatching that makes configuration transparent
		to your driver code, as well as the harness for dispatching the driver
		calls themselves and marshalling them in a way that makes them available
		to the clients.
	      </para></listitem>
	      <listitem><para>
		<filename>CVMSUB.h</filename> Defines the class that provides access to
		the VMUSB.
	      </para></listitem>
	      <listitem><para>
		<filename>CVMUSBReadoutList.h</filename>  provides a class for constructing
		VME lists of operations that can b executed immediately for better
		performance than single operations with the <classname>CVMUSB</classname>
	      </para></listitem>
	    </orderedlist>
	    <example>
	      <title>Control driver class definition</title>
	      <programlisting>
class CUserDriver : public CControlHardware
{

public:
  CUserDriver(std::string name);
  virtual void onAttach(CControlModule&amp; configuration);
  virtual std::string Update(CVMUSB&amp; vme);
  virtual std::string Set(CVMUSB&amp; vme, 
			  std::string parameter, 
			  std::string value);
  virtual std::string Get(CVMUSB&amp; vme, 
			  std::string parameter);
  virtual void clone(const CControlHardware&amp; rhs);

};
	      </programlisting>
	    </example>
	    <para>
	      The key points are that the user driver inherits from the
	      <classname>CControlHardware</classname> base class. Since
	      <classname>CControlHardware</classname> is an abstract base class,
	      it is necessary to define all abstract methods.  Furthermore, since
	      <classname>CControlHardware</classname> has no default constructor,
	      our driver must define a constructor that is capable of passing the
	      driver instance name (module name) to the base class.
	    </para>
	    <example>
	      <title>Control driver constructor</title>
	      <programlisting>
CUserDriver::CUserDriver(std::string name) :
  CControlHardware(name)
{}
	      </programlisting>
	    </example>
	    <para>
	      The only mandatory function of the constructor is to provide the
	      instance <parameter>name</parameter> to the base class.  The
	      instance name is the name provided to the <command>Module create</command>.
	      Naturally if the driver has internal instance data that requires
	      initialization, the constructor is where this should be done.
	    </para>
	    <example>
	      <title>Control driver <methodname>onAttach</methodname> method</title>
	      <programlisting>
void
CUserDriver::onAttach(CControlModule&amp; configuration)
{
  m_pConfig = &amp;configuration;	       <co id='ctldriver-onattach-saveconfig' />
  m_pConfig-&gt;addIntegerParameter("-anint", 0);
  m_pConfig-&gt;addParameter("-astring", NULL, NULL, ""); <co id='ctldriver-onattach-makeparams' />
  m_pConfig-&gt;addIntListParameter("-alist", 16);

}
	      </programlisting>
	    </example>
	    <para>
	      <methodname>onAttache</methodname> is called when a driver instance
	      is being created and attached to its configuration object. The
	      <parameter>configuration</parameter> is passed as a parameter to the
	      method.  The numbers inthe example text are referenced below in the
	      annotations:
	    </para>
	    <calloutlist>
	      <callout arearefs='ctldriver-onattach-saveconfig'>
		<para>
		  The base class (<classname>CControlHardware</classname>) 
		  provides a protected data member <varname>m_pConfig</varname>
		  that is intended to hold a pointer to the driver instance's
		  configuration object (<classname>CControlModule</classname>).
		  It is usually important to be able to access your configuration
		  later in the life cycle of the driver.
		</para>
	      </callout>
	      <callout arearefs='ctldriver-onattach-makeparams'>
		<para>
		  Drivers normally are parameterized by a set of configuration 
		  paramters.  These are defined/described and constrained in the
		  <methodname>onAttache</methodname> method.  For this toy
		  driver we just define the options
		  <option>-anint</option> which is constrained to be an integer,
		  <option>-astring</option> which is unconstrained and
		  <option>-alist</option> which is constrained to be a list of
		  16 integer parameters.
		</para>
		<para>
		  Normal drivers will defined at least a 
		  <option>-base</option> option which is intended to hold
		  the base address of the device being controlled.
		</para>
	      </callout>
	    </calloutlist>
	    <example>
	      <title>Control driver <methodname>Update</methodname></title>
	      <programlisting>
std::string
CUserDriver::Update(CVMUSB&amp; vme)
{
  return "OK";
}
	      </programlisting>
	    </example>
	    <para>
	      Some devices have write only registers.  Since it is not possible
	      to determine the device state by reading the device registers, it is
	      useful to have an operation that will set the device to a known state.
	      Typcially this state is maintained in a set of <firstterm>shadow registers</firstterm>
	      that are maintained in the driver instance,and possibly read from a 
	      file that is also maintained by that instance or by a control panel for the
	      device.  
	    </para>
	    <para>
	      The <methodname>Update</methodname> method is intended to provide a mechanism
	      for device control panel clients to request the driver set the hardware to a known
	      state. The method should return the string <literal>OK</literal> on success or
	      a streing of the form <literal>ERROR - </literal><replaceable>some descriptive error message</replaceable>
	      normally control panels, on seeing the first return word is <literal>ERROR</literal>
	      will parse the error message out and display it for the user.
	    </para>
	    <example>
	      <title>Control driver <methodname>Set</methodname> method.</title>
	      <programlisting>

std::string
CUserDriver::Set(CVMUSB&amp; vme,    
                 std::string parameter,           <co id='ctldriver-set-params' />
                 std::string value)
{
  try {
    m_pConfig-&gt;configure(parameter, value);   <co id='ctldriver-set-configure' />
    return "OK";
  }
  catch (std::string msg) {	// configure reports errors via std::string exceptions.
    std::string status = "ERROR - ";
    status += msg;
    return status;                              <co id='ctldriver-set-error' />
  }
}
	      </programlisting>
	    </example>

	    <para>
	      The <methodname>Set</methodname> is intended to provide a new
	      value for a device parameter.  When you write a device driver
	      you must give names to each device parameter you want to allow
	      clients to control.  These names are used by the client to identify
	      device parameters both for the <methodname>Set</methodname> and
	      the <methodname>Get</methodname> we will discuss next.
	    </para>
	    <para>
	      In our toy driver, we have no hardware to modify so we are accepting the
	      names of our configuration options as the parameter names.  Normal drivers
	      will need to pull their base address from the configuration
	      and use them, along with the value of the <parameter>parameter</parameter>
	      parameter to know what to do to change the requested
	      parameter to <parameter>value</parameter>.
	    </para>
	    <calloutlist>
	      <callout arearefs='ctldriver-set-params'>
		<para>
		  The parameters passed to the <methodname>Set</methodname> are:
		  <variablelist>
		    <varlistentry>
		      <term><parameter>vme</parameter></term>
		      <listitem><para>
			A <classname>CVMUSB</classname> object reference
			that can be used to either perform direct VME operations
			or to execute <classname>CVMUSBReadoutList</classname>
			objects that have been created and stocked this 
			method.
		      </para></listitem>
		    </varlistentry>
		    <varlistentry>
		      <term><parameter>parameter</parameter></term>
		      <listitem><para>
			The name of the parameter to modify.
		      </para></listitem>
		    </varlistentry>
		    <varlistentry>
		      <term><parameter>value</parameter></term>
		      <listitem><para>
			The stringified version of the new value to 
			set for the parameter.  This parameter is always
			a <classname>std::string</classname> and therefore
			may require conversion by the driver.
		      </para></listitem>
		    </varlistentry>
		  </variablelist>
		</para>
	      </callout>
	      <callout arearefs='ctldriver-set-configure'>
		<para>
		  Since we are using our configuration parameters as device
		    parameters, this line just attempts to set the requested
		    configuration parameter to the reqested value.
		  </para>
		  <para>
		    The <methodname>configure</methodname> throws 
		    <classname>std::string</classname> exceptions
		    on errors.  Hence the <methodname>configure</methodname>
		    operation is done in a <literal>try</literal> block.
		  </para>
		</callout>
		<callout arearefs='ctldriver-set-error'>
		  <para>
		    Error exceptions are caught by this
		    <literal>catch</literal> block where they are turned
		    into error messages.  The return value from
		    the <methodname>Set</methodname> method is either
		    <literal>OK</literal> (No error) or
		    <literal>ERROR -</literal> followeed by an error
		    message string.
		  </para>
		</callout>
	      </calloutlist>
	      <example>
		<title>Control driver <methodname>Get</methodname> method</title>
		<programlisting>

std::string
CUserDriver::Get(CVMUSB&amp; vme, std::string parameter) <co id='ctldriver-get-params' />
{
  try {
    return m_pConfig-&gt;cget(parameter);                <co id='ctldriver-get-cget' />
  }
  catch (std::string msg) {
    std::string retval = "ERROR - ";                    <co id='ctldriver-get-error' />
    retval += msg;
    return msg;
  }
}
		</programlisting>
	      </example>
	      <para>
		The <methodname>Get</methodname> method is used by control panel
		clients to fetch values of device parameters from the driver.
	      </para>
	      <calloutlist>
		<callout arearefs='ctldriver-get-params'>
		  <para>
		    The parameters for the <methodname>Get</methodname> are:
		    <variablelist>
		      <varlistentry>
			<term><parameter>vme</parameter></term>
			<listitem><para>
			  Reference to a <classname>CVMUSB</classname> controller
			  object that can be used to perform VME operations directly
			  or to execute <classname>CVMUSBReadoutList</classname>
			  objects that are created and filled by this method.
			</para></listitem>
		      </varlistentry>
		      <varlistentry>
			<term><parameter>parameter</parameter></term>
			<listitem><para>
			  The name of the parameter to modify.
			</para></listitem>
		      </varlistentry>
		    </variablelist>
		  </para>
		</callout>
		<callout arearefs='ctldriver-get-cget' >
		  <para>
		    In our toy driver our parameter names are configuration option names.
		    In a real driver we would typically need to retrieve the
		    <option>-base</option> value to locate our device in VME space.
		    We would then use the value of <parameter>parameter</parameter>
		    to determine which value to fetch.  That value would be 
		    represented as a string and then returned to the caller.
		  </para>
	      </callout>
	      <callout arearefs='ctldriver-get-error'>
		<para>
		  In the toy driver, <methodname>cget</methodname> can throw an
		  exception.  We turn this into an error return indicated by
		  returning a string of the form
		  <literal>ERROR -</literal>  followed by a descriptive error
		  string.
		</para>
	      </callout>
	      </calloutlist>
	      <example>
		<title>Control driver <methodname>clone</methodname> method</title>
		<programlisting>
void
CUserDriver::clone(const CControlHardware&amp; rhs)
{
  CControlHardware* pRhs = const_cast&lt;CControlHardware*&gt;(&amp;rhs);
  m_pConfig = new CControlModule(*(pRhs->getConfiguration()));
}
		</programlisting>
	      </example>
	      <para>
		All control drivers must supply a <methodname>clone</methodname>
		method.  This method must clone a <parameter>rhs</parameter> object
		into <varname>this</varname>.  The minimal work that must be done
		is to clone the <parameter>rhs</parameter> configuration into our
		<varname>m_pConfig</varname>.
	      </para>
	      <para>
		Any internal data the driver has must also be copied.  Wether this can
		be a shallow or deep copy is up to the needs of the driver.
	      </para>
	  </section>
	  <section>
	    <title>The creator</title>
	    <para>
	      The creator is used by the extensible module factory. It captures
	      knowledge of how to create a driver instance.  The factory matches
	      driver type names with creators and uses the creator to produce
	      the correct constructor.
	    </para>
	    <example>
	      <title>Control driver creator</title>
	      <programlisting>
#include &lt;CModuleCreator.h&gt;                             <co id='cltcreator-headers' />
   
class CUserDriverCreator : public CModuleCreator              <co id='ctlcreator-classdef' />
{
public:
  virtual CControlHardware* operator()(std::string name);     <co id='ctlcreator-functordef' />
};

CControlHardware*
CUserDriverCreator::operator()(std::string name)
{
  return new CUserDriver(name);                               <co id='ctlcreator-new' />
}
	      </programlisting>
	    </example>
	    <calloutlist>
	      <callout arearefs='cltcreator-headers'>
		<para>
		  The creator must have <classname>CModuleCreator</classname> as 
		  a base class.   This line includes the header for that class.
		</para>
	      </callout>
	      <callout arearefs='ctlcreator-classdef'>
		<para>
		  This is the class definition for the crator.  By convention
		  the name of a creator is built from the name of the class
		  it creates with <literal>Creator</literal> suffixed.
		  As previously described this class must inherit from
		  <classname>CModuleCreator</classname>
		</para>
	      </callout>
	      <callout arearefs='ctlcreator-functordef'>
		<para>
		  The creator must define and implement a functor
		  (<methodname>operator()</methodname>).  This method
		  must take the <parameter>name</parameter> of a
		  module as a parameter and return a dynamically
		  allocated <classname>CControlHardware*</classname>
		  whose underlying type is the same as the type we are
		  supposed to be creating.
		</para>
	      </callout>
	      <callout arearefs='ctlcreator-new'>
		<para>
		  The implementation of the functor operator is usually 
		  as simple as what's shown here.  Just
		  <literal>new</literal> into existence the object
		  and return its pointer.
		</para>
	      </callout>
	    </calloutlist>
	  </section>
	  <section>
	    <title>The initialization function</title>
	    <para>
	      The initialization function is called automatically by the
	      Tcl <command>load</command> or <command>package require</command>
	      command used to load the driver into the interpreter.
	      The initialization function must have a specific name that matches
	      the name of the library/package it is built into.  The name must be
	      of the form described in 
	      <ulink url='http://www.tcl.tk/man/tcl8.5/TclCmd/load.htm'>
		http://www.tcl.tk/man/tcl8.5/TclCmd/load.htm
	      </ulink>
	      Unless otherwise specified in the <command>load</command> command,
	      the package name is the part of the name of the library that follows
	      the <literal>lib</literal> part but before the file type.  E.g. for
	      a shared library named <filename>libMyControlDriver.so</filename>,
	      the initialization function should be
	      <literal>Mycontroldriver</literal>
	    </para>
	    <para> 
	      Here is the initialization function for our sample driver:
	    </para>
	    <example>
	      <title>Control driver initialization</title>
	      <programlisting>
#include &lt;CModuleFactory.h&gt;                          <co id='ctldriver-init-headers' />
#include &lt;tcl.h&gt;

extern "C" {                                               <co id='ctldriver-init-cbinding' />
  int Userdriver_Init(Tcl_Interp* pInterp)                 <co id='ctldriver-init-prototype' />
  {
    CModuleFactory* pFact = CModuleFactory::instance();    <co id='ctldriver-init-factget' />
    pFact->addCreator("mydriver", new CUserDriverCreator); <co id='ctldriver-init-creator' />

    return TCL_OK;                                         <co id='ctldriver-init-status' />
  }
  
}
	      </programlisting>
	    </example>
	    <calloutlist>
	      <callout arearefs='ctldriver-init-headers'>
		<para>
		  The headers required for the initialization function are (in addition
		  to any header that defines the module creator):
		  <variablelist>
		    <varlistentry>
			<term><filename>CModuleFactory.h</filename></term>
			<listitem><para>
			  Defines the <classname>CModuleFactory</classname>
			  singleton which is the class in which our creator must
			  be registered.
			</para></listitem>
		      </varlistentry>
		      <varlistentry>
			<term><filename>tcl.h</filename></term>
			<listitem><para>
			  Contains interface definitions for the API to the
			  Tcl interpreter.
			</para></listitem>
		      </varlistentry>
		    </variablelist>
		  </para>
		</callout>
		<callout arearefs='ctldriver-init-cbinding'>
		  <para>
		    The Tcl interpreter needs to be able to compute
		    the function name explicitly.   Since C++ function names
		    are <firstterm>decorated</firstterm> in ways that depend on
		    their signatures, the initialization function must be 
		    declared with C name bindings.  This is done with the
		    <literal>extern "C"</literal> block shown here.
		  </para>
		</callout>
		<callout arearefs='ctldriver-init-prototype'>
		  <para>
		    The initialization functdion takes an interpreter
		    (<type>Tcl_Interp*</type>) as a parameter and returns
		    an <type>int</type> status.  The normal return status
		    is <literal>TCL_OK</literal>.  The failure return status is
		    <literal>TCL_ERROR</literal> and  an error message can be
		    put in the interpreter result (using e.g.
		    <ulink url='http://www.tcl.tk/man/tcl8.5/TclLib/SetResult.htm'>
		      Tcl_SetResult</ulink>).
		  </para>
		</callout>
		<callout arearefs='ctldriver-init-factget'>
		  <para>
		    The main work of the intitialization function is to register
		    the module creator with the module factory.  The
		    <function>CModuleFactory::instance()</function>
		    returns a pointer to the 
		    <ulink url='http://en.wikipedia.org/wiki/Singleton_pattern'>
		      singleton instance</ulink>
		    of the factory.
		  </para>
		</callout>
		<callout arearefs='ctldriver-init-creator'>
		  <para>
		    Registers the new creator object associating it with the
		    module type <literal>mydriver</literal>
		  </para>
		</callout>
		<callout arearefs='ctldriver-init-status'>
		  <para>
		    Returns a normal status value.
		  </para>
		</callout>
	    </calloutlist>

	  </section>
	  <section>
	    <title>Building the driver and using it.</title>
	    <para>
	      Compiled drivers must be built as shared libraries.  You can then
	      either use the Tcl <command>load</command> command to directly
	      load them or build a <filename>pkg_Index.tcl</filename> in a 
	      Tcl library directory and use <command>package require</command>
	      instead.
	    </para>
	    <para>
	      Regardless of the choices you make, if you have bundled your
	      driver into a single file you can build it using:
	    </para>
	    <informalexample>
	      <cmdsynopsis><command>
g++ -shared -o libMyDriver.so MyDriver.cpp
	      </command></cmdsynopsis>
	    </informalexample>
	    <para>
	      Note that you don't need to specify libraries that are
	      included in the readout program, however you do need to
	      resolve any other undefined symbols that are in libraries
	      not part of the readout program.
	    </para>
            <para>
	      To use the driver you need to load it into the interpreter
	      and the use the <command>Module</command> to make an instance
	      and to maniuplate that instance.  For example:
	    </para>
	    <informalexample>
	      <programlisting>
load [file join [file dirname [info script]] libMyDriver.so]
Module create testModule mydriver
Module config testModule -anint 1234
	      </programlisting>
	    </informalexample>
	  </section>
	</section>
	
    </section>
    <section>
      <title>Writing slow control drivers in Tcl</title>
      <para>
	Using the SWIG wrappers for the <classname>CVMUSB</classname> and
	<classname>CVMUSBReadoutList</classname> classes and the
	<literal>tcl</literal> wrapper module type you can write
	slow control modules using pure Tcl. A Tcl driver is a command ensemble
	that defines the following subcommands:
      </para>
      <variablelist>
	<varlistentry>
	  <term><command>Initialize</command></term>
	  <listitem><para>
	    Called by the wrapper's <methodname>Initialize</methodname>
	    to perform initialization.
	  </para></listitem>
	</varlistentry>
	<varlistentry>
	  <term><command>Update</command></term>
	  <listitem><para>
	    Called by the wrapper's <methodname>Update</methodname>
	    method.
	  </para></listitem>
	</varlistentry>
	<varlistentry>
	  <term><command>Set</command></term>
	  <listitem><para>
	    Called by the wrapper's <methodname>Set</methodname> method.
	  </para></listitem>
	</varlistentry>
	<varlistentry>
	  <term><command>Get</command></term>
	  <listitem><para>
	    Called by the wrapper's <methodname>Get</methodname> method.
	  </para></listitem>
	</varlistentry>
	<varlistentry>
	  <term><command>addMonitorList</command></term>
	  <listitem>
	    <para>
	      Called by the wrappers <methodname>addMonitorList</methodname>
	      method.  This method must be supplied though it need not do
	      anything.
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term><command>processMonitorList</command></term>
	  <listitem><para>
	    Called by the wrappers's <methodname>processMonitorList</methodname>.
	    Again while this  method must be supplied, it need not do anything
	    (except return 0 indicating it has not processed antyhing from the monitor
	    list).
	  </para></listitem>
	</varlistentry>
	<varlistentry>
	  <term><command>getMonitoredData</command></term>
	  <listitem>
	    <para>
	      Called from the wrapper's <methodname>getMonitoredData</methodname>.
	      Must be defined but need not do anything useful if the driver
	      does not make use of monitor lists.
	    </para>
	  </listitem>
	</varlistentry>
      </variablelist>
      <para>
	The remainder of this section will pick apart a Tcl driver that performs
	the same basic function as the C++ driver we wrote in the previous section.
	We will also show how to incorporate the driver into a 
	<filename>controlconfig.tcl</filename> file.
      </para>
      <para>
	For this example we will use a driver written using snit. incrTcl or 
	Xotcl or even namespace ensembles can be used to implement drivers, or
	even just a Tcl procedure of only one instance is going to be supported.
      </para>
      <para>
	Let's start by looking at the overall framework of the driver:
      </para>
      <example>
	<title>Control drivers - structure of a Tcl driver</title>
	<programlisting>

package provide Mydriver 1.0
package require cvmusb                            <co id='ctldriver-tclstruct-packages' />
package require cvmusbreadoutlist


snit::type Mydriver {                            <co id='ctldriver-tclstruct-snittype' />
    option -anint -configuremethod _validInt
    option -astring                              <co id='ctldriver-tclstruct-options' />
    option -alist -configuremethod _validIntList

    constructor args {
       ...
       $self configurelist $args                <co id='ctldriver-tclstruct-constructor' />
    }

    method Initialize vme {...}
    method Update     vme {...}
    method Set        {vme parameter value} {...}
    method Get       {vme parameter} {...}     <co id='ctldriver-tclstruct-methods' />
    method addMonitorList vmeList {...}
    method processMonitorList data {...}
    method getMonitoredData {...}

    #  Private method:
    
    method _validInt {optname value} {...}      <co id='ctldriver-tclstruct-configmethods' />
    method _validIntList {optname value} {...}
    

}
	</programlisting>
      </example>
      <calloutlist>
	<callout arearefs='ctldriver-tclstruct-packages'>
	  <para>
	    This section of code defines a package name; <literal>Mydriver</literal>
	    and specifies it to have a version of <literal>1.0</literal>.  This
	    allows the Tcl command 
	    <ulink url='http://www.tcl.tk/man/tcl8.5/TclCmd/pkgMkIndex.htm'>
	    <command>pkg_mkIndex</command></ulink>
	    to create a <filename>pkgIndex.tcl</filename> package index that includes 
	    the <literal>Mydriver</literal> package.
	    The two <command>package require</command> packages include the packages
	    that implement SWIG wrappings of the <classname>CVMUSB</classname>
	    and <classname>CVMUSBReadoutList</classname> classes.
	  </para>
	</callout>
	<callout arearefs='ctldriver-tclstruct-snittype'>
	  <para>
	    Snit classes are declared with the <command>snit::type</command> 
	    command.  That command takes two parameters, the typename
	    (<literal>Mydriver</literal>), and the body of the type definition
	    which begins with the <literal>{</literal>.
	  </para>
	</callout>
	<callout arearefs='ctldriver-tclstruct-options'>
	  <para>
	    The <command>option</command>, defined within a <command>snit::type</command>
	    body declares a configuration option for objects created with this type.
	    These three lines declare the three configuration options we said we would 
	    support.  We want to perform validation on the
	    <option>-anint</option> and the <option>-alist</option>.  The
	    <option>-configuremethod</option> option in the
	    <command>option</command> provides the name of a method that
	    will be called when the option is configured.  This provides for
	    validation.
	  </para>
	</callout>

	<callout arearefs='ctldriver-tclstruct-constructor'>
	  <para>
	    The constructor  method must do all internal initializations,
	    it should also process the configuration options that were passed
	    on the construction command line.  The built-in method
	    <methodname>configurelist</methodname> processes a list of
	    option/value pairs.  Precisely what the <parameter>args</parameter>
	    parameter contains.
	  </para>
	</callout>
	<callout arearefs='ctldriver-tclstruct-methods'>
	  <para>
	    These lines of code are skeletal definitions of the 
	    methods we are required to implement in a Tcl driver. 
	    The <command>method</command> in a <command>snit::type</command>
	    is used to create object methods for a Snit object.  We will
	    look at the bodies of these methods in separate sections.
	  </para>
	</callout>
	<callout arearefs='ctldriver-tclstruct-configmethods'>
	  <para>
	    These lines of code create skeletal definitions of the methods
	    we established as configuration handlers via the 
	    <option>-configuremethod</option>.  Confifgure methods take a pair of parameters.
	    <parameter>optname</parameter> is the name of the parameter being configured
	    while <parameter>value</parameter> is the proposed new value for that parameter.
	    This parameterization allows configuremethods to be shared between several
	    options (for example if we had more than one option we wanted to constrain
	    to be an integer.
	  </para>
	</callout>
      </calloutlist>
      <section>
	<title>Initialize</title>
	<para>
	  The full implementation of the <methodname>Initialize</methodname> is shown
	  below:
	</para>
	<example>
	  <title>Tcl control driver <methodname>Initialize</methodname> method</title>
	  <programlisting>
    method Initialize vme {
    
    }
	  </programlisting>
	</example>
	<para>
	  The <methodname>Initialize</methodname> does nothing for our driver.
	  For a real driver the options might be queried to find the base address
	  of the hardware as well as other static configuration options.  The 
	  <parameter>vme</parameter> argument, which is a Swig wrapped
	  <classname>CVUSB</classname> object would then be used to perform the
	  VME transactions needed to initialize the device.
	</para>
	<para>
	  In the event of an error while executing this method, the wrapper
	  will pull the result of the command as a string, and throw it as a
	  <classname>std::string</classname> exception.  This is the accepted way
	  for drivers to indicate errors in their <methodname>Initialize</methodname>
	  methods
	</para>
      </section>
      <section>
        <title>The update method</title>
        <para>
            The <methodname>Update</methodname> method servesthe same function
            in a Tcl driver as in a C++ driver.  In our case the implementationis
        </para>
        <example>
            <title>Tcl control driver <methodname>Update</methodname> method</title>
            <programlisting>
    method Update vme {
        return "OK"
    }
            </programlisting>
        </example>
        <para>
            The <parameter>vme</parameter> is a SWIG encapsulated
            <classname>CVMUSB</classname> object that, in a real driver,
            would be used to perform VME operations or execute lists created
            via  <classname>CVMUSBReadoutList</classname> objects created and
            filled in by this method.
        </para>
        <para>
            The return string of <literal>OK</literal> indicates a normal
            completion.  Tcl methods have two mechanisms to return errors.
            Returning a string that begins with <literal>ERROR - </literal>
            and concludes with an error message, or simply executing the
            <command>error</command> with an error message argument.
            The wrapper will map error returns into an <literal>ERROR - </literal>
            string return with the value of the string passed t the
            <command>error</command> command appended to the end of the
            error return string.
        </para>
      </section>
      <section>
        <title>The Set method</title>
        <para>
            As with the C++ driver, the <methodname>Set</methodname> method is
            used to process client requests to change a device parameter.
            The Tcl version of this method is:
        </para>
        <example>
            <title>Tcl control driver <methodname>Set</methodname> method</title>
            <programlisting>
    method Set {vme parameter value} {
        $self configure $parameter $value
        return "OK"
    }
            </programlisting>
        </example>
        <para>
            The parameters passed into this are the same as those passed into
            a C++ driver's set, however the <parameter>vme</parameter> parameter
            is a swig wrapped <classname>CVMUSB</classname> object.
        </para>
        <para>
            By using the <methodname>configure</methodname> method rather than
            just directly writing to the <varname>options</varname> array
            we force the call of any <option>-configuremethod</option> code
            that may do validations and throw errors.
        </para>
        <para>
            The return of <literal>OK</literal> indicates successful completion,
            an error will be converted by the wrapper into a return string of the form
            <literal>ERROR - </literal><replaceable>intepreter error result string</replaceable>.
            This allows errors from the <methodname>configurmethod</methodname>,
            including specifying an invalid option name as well as failures
            in validation by the <option>-configuremethod</option> code to be
            naturally mapped back to proper error returns.
        </para>
        <para>
            In a real driver, the <parameter>vme</parameter> parameter will
            be used to perform VME operations.  In addition you can choose
            to explicitly return an error string, or use the
            <command>error</command> command to report failures.
        </para>
      </section>
      <section>
        <title>The Get method</title>
        <para>
            As with the C++ driver this is called to fetch the value of a
            driver parameter.  Our toy driver fetches configuration parameters
            rather than hardware parameters.
        </para>
        <example>
            <title>Tcl control driver <methodname>Get</methodname> method</title>
            <programlisting>
    method Get {vme parameter} {
        if {[array names options $parameter] eq ""} {
            error "Invalid parameter name: $parameter"
        }
        return $options($parameter)
    }
            </programlisting>
        </example>
        <para>
            Our driver ensures the value of <parameter>parameter</parameter> really
            is an option name and then returns the option value from the
            <varname>options</varname> array.
            By doing the check for <command>array names options $parameter</command>
            we can produce a more meaningful error message than would be
            produced if we just let <command>return $options($parameter)</command>
            error.
        </para>
        <para>
            Instead of the <command>error</command> command we could have just
            as easily done a <command>return "ERROR - Invalid parameter name: $parameter"</command>
        </para>
        <para>
            A real driver would use the <parameter>vme</parameter> parameter,
            which is a Swig wrapped <classname>CVMUSB</classname> object
            to fetch the value of the parameter from the hardware.
        </para>
      </section>
      <section>
	<title>The addMonitorList method</title>
	<para>
	  Since we are not using monitor lists, this method is trivial:
	</para>
	<example>
	  <title>Tcl control drer <methodname>addMonitorList</methodname> method</title>
	  <programlisting>
    method addMonitorList vmeList {
    }
	  </programlisting>
	</example>
	<para>
	  The <parameter>vmeList</parameter> is a <classname>CVMEReadoutList</classname>
	  that is wrapped by Swig.  A driver that uses monitor lists would add operations
	  to the list as needed to retrieve the data being monitored from the device.
	</para>
      </section>
      <section>
	<title>The processMonitorList method</title>
	<para>
	  <methodname>processMonitorList</methodname> is called with the data read
	  by the monitor list marshalled into a Tcl list of bytes (string representation).
	  The method is expected to process what it needs from the front of the list
	  and return a count of the number of bytes processed.  Since we are not using
	  monitor lists, our implementation is:
	</para>
	<example>
	  <title>Tcl control driver <methodname>processMonitorList</methodname> method</title>
	  <programlisting>
    method processMonitorList data {
        return 0
    }
	  </programlisting>
	</example>
      </section>
      <section>
	<title>The getMonitoredData method</title>
	<para>
	  If using a monitor list, this method typically returns the data
	  last processed by <methodname>processMonitorList</methodname> with
	  <literal>OK - </literal> prepended to indicate a successful completion.
	  As usual an <command>error</command> or script errors will result in
	  a return of <literal>ERROR - </literal> with the result string appended.
	</para>
	<para>
	  Since we are not using a monitor list, it's appropriate for us
	  to return an error condition:
	</para>
	<example>
	  <title>Tcl control driver <methodname>getMonitoredData</methodname> method</title>
	  <programlisting>
    method getMonitoredData {} {
        error "This driver has no monitored data"
    }
          </programlisting>
	</example>
      </section>
      <section>
	<title>Validating the command options</title>
	<para>
	  The only thing left to do is write the option validation methods
	  <methodname>_validInd</methodname> and <methodname>_validIntList</methodname>.
	</para>
	<note><title>Note</title>
	<para>
	  Snit does not have method visibility control, that is all methods
	  are public.   By convention, methods that are not intended to be
	  called by a client are given names that start with a <literal>_</literal>.
	  Therefore these methods should be considered private.
	</para>
	</note>
	<example>
	  <title>Tcl control driver validation</title>
	  <programlisting>
    method _validInt {optname value} {
        if {[string is integer -strict $value]} {                  <co id='tcldriver-validate-isinteger' />
	    set options($optname) $value                           <co id='tcldriver-validate-setintopt' />
        } else {
            error "$optname must be configured with an integer was given '$value'" <co id='tcldriver-validate-intinvalid' />
        }
    }
    method _validIntList {optname value} {
        if {![info complete $value]} {                            <co id='tldriver-validate-islist' />
            error "$optname must be given an integer list and '$value' isn't one"
        }

	set elements [llength $value]
        if {$elements != 16} {                                    <co id='tcldriver-validate-listcount' />
	    error "$optname must be given an integer list 16 '$value" as $elements"
	}
	
	foreach item $value {                                     <co id='tcldriver-validate-intelements' />
            if {![string is integer -strict $item]} {             
	       error "$optname list elements must be integer but '$item' in '$value' is not"
            }
        }
	set options($optname) $value                              <co id='tcldriver-validate-setlistopt' />
    }
	  </programlisting>
	</example>
	<calloutlist>
	  <callout arearefs='tcldriver-validate-isinteger'>
	    <para>
	      The <command>string is integer -strict</command> command takes its argument
	      and returns true if the argument is an integer and non-blank (a blank integer
	      can be interpreted as a zero).
	    </para>
	  </callout>
	  <callout arearefs='tcldriver-validate-setintopt'>
	    <para>
	      This sets the appropriate element of the <varname>options</varname>
	      array.  This array is used by e.g. <command>cget</command> to
	      return configuration options, unless overridden with a <option>-cgetmethod</option>.
	    </para>
	  </callout>
	  <callout arearefs='tcldriver-validate-intinvalid'>
	    <para>
	      If the option value does not validate as an integer, an error is thrown.  Note 
	      that we have seen that errors are mapped by the wrapper into the appropriate
	      error indication to the driver framework.
	    </para>
	  </callout>
	  <callout arearefs='tldriver-validate-islist'>
	    <para>
	      This trick checks that <varname>value</varname> is a valid list.  This works
	      because complete commands must be valid Tcl lists as well.
	    </para>
	  </callout>
	  <callout arearefs='tcldriver-validate-listcount'>
	    <para>
	      This ensures the list has exactly 16 elements, else an error is thrown.
	    </para>
	  </callout>
	  <callout arearefs='tcldriver-validate-intelements'>
	    <para>
	      Element by element, the list is checked to ensure that all elements are
	      valid integers.
	    </para>
	  </callout>
	  <callout arearefs='tcldriver-validate-setlistopt'>
	    <para>
	      If by now we have not errored out, the value is valid and is set in the
	      <varname>options</varname> array.
	    </para>
	  </callout>
	</calloutlist>
      </section>
      <section>
	<title>Using a Tcl control driver</title>
	<para>
	  To use a Tcl control driver you must:
	</para>
	<orderedlist>
	  <listitem><para>
	    Incorporate the driver into your <filename>controlconfig.tcl</filename>
	    script either using the <command>source</command> or 
	    <command>package require</command> command.
	  </para></listitem>
	  <listitem><para>
	    Create an instance of your driver if needed.  In the case of
	    our toy driver, this means a command like:
	    <command>Mydriver aninstance</command> to create a command
	    ensemble named <literal>aninstance</literal>
	  </para></listitem>
	  <listitem><para>
	    If necessary configure our driver instance.
	  </para></listitem>
	  <listitem><para>
	    Wrap your driver with the <literal>tcl</literal> module type:
	    <informalexample>
	      <programlisting>
Module create  atcldriver tcl
Module config atcldriver -ensemble aninstance
	      </programlisting>
	    </informalexample>
	  </para></listitem>
	</orderedlist>
	
	<para>
	  The key point is that the <option>-ensemble</option> for a 
	  <literal>tcl</literal> module provides the base name of the
	  command ensemble that Tcl driver wraps.
	</para>
      </section>
    </section>
  </section>
    <section>
        <title>Pushing external data into the event stream</title>
        <para>
            The slow controls port can also be used to send data that will
            be periodically inserted in the data stream.  The mechanism
            for this is intended to monitor slowly varying values (for example
            magnet currents).  Here's a brief sketch about how this works:
        </para>
        <itemizedlist>
            <listitem><para>
                In your slow controls configuration file you specify Tcl
                variables whose values will be watched.
                </para></listitem>
            <listitem><para>
                A slow controls client sets those variables to value that
                reflect the things to be monitored in the outside world
                (e.g. <application>controlpush</application> can set
                the arrays <varname>EPICS_DATA</varname>,
                <varname>EPISC_UNITS</varname> and <varname>EPICS_UPDATED</varname>
                to reflect changes in epics process variables).
                </para></listitem>
            <listitem><para>
                When the run is active, every two seconds the current values of
                any variables that were modified since the last update operation
                are pushed to the ring buffer as <literal>MONITORED_VARIABLE</literal>
                string list items.  Note that towards the beginning of the
                run one or more ring items will be generated that have
                all monitored variable values.
                </para>
            </listitem>
        </itemizedlist>
        <section>
            <title>Specifying variables to be monitored.</title>
            <para>
                The key to monitoring variables is that the control server is
                really a Tcl interpreter executing commands that are poked into
                it by its client sockets.  The Tcl server supports a new
                command <command>watch</command> which allows you to specify
                which variables should be monitored.
            </para>
            <para>
                The example below specifies that the arrays
                <varname>EPICS_DATA</varname>, <varname>EPICS_UNITS</varname>,
                <varname>EPICS_UPDATED</varname> and the scalar variable
                <varname>monitored</varname> should be monitored.;
            </para>
            <example>
                <title>Specifying VM-USB monitored variables</title>
                <programlisting>
array set EPICS_DATA    [list]
array set EPICS_UNITS   [list]     <co id='watchexample-createarrays' />
array set EPICS_UPDATED [list]

watch EPICS_DATA
watch EPICS_UNITS                  <co id='watchexample-monitorarrays' />
watch EPICS_UPDATED

watch monitored                   <co id='watchexample-monitorscalar' />
                </programlisting>
            </example>
            <calloutlist>
                <callout arearefs='watchexample-createarrays' >
                    <para>
                        In order to monitor an array, the array must first
                        be created. Note that this is not the case
                        for a scalar variable.
                        </para>
                </callout>
                <callout arearefs='watchexample-monitorarrays'>
                    <para>
                        These commands specify that the three arrays
                        we created with the <command>array set</command>
                        command should be monitored.
                    </para>
                </callout>
                <callout arearefs='watchexample-monitorscalar'>
                    <para>
                       Since <varname>monitored</varname> was not created as
                       an array only the single scalar value
                       will be monitored.
                       </para>
                </callout>
            </calloutlist>
            <para>
                For more information about the <command>watch</command>
                command see <link linkend="vmusb3-watch" endterm='vmusb3-watch-title' />
                in the reference manual pages.
            </para>
        </section>
    </section>
    <section>
        <title>Running VMUSBReadout</title>
        <para>
            <application>VMUSBReadout</application> is installed as:
            <filename>$DAQROOT/bin/VMUSBReadout</filename>.
        </para>
        <para>
            Several command options control the way VMUSBReadout operates:
        </para>
        <variablelist>
            <varlistentry>
                <term><option>-serialno</option></term>
                <listitem>
                    <para>
                        Specifies the serial number of the VMUSB the program
                        will use.  See <option>--enumerate</option> below.
                        If not provided, the first VMUSB located will be used.
                        If you only have one VMUSB connected to your system,
                        this is suitable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--ring</option></term>
                <listitem>
                    <para>
                        Specifies the ring buffer in which event data will
                        be put by the program.  By default this is the
                        same as the username you are logged in on.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--daqconfig</option></term>
                <listitem>
                    <para>
                        Specifies the filename that contains the data acquisition
                        configuration script.  This defaults to
                        <filename>~/config/daqconfig.tcl</filename>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--ctlconfig</option></term>
                <listitem>
                    <para>
                        Specifies the filename that contains the slow controls
                        configuration script.  This defaults to
                        <filename>~/config/controlconfig.tcl</filename>. Note
                        that this file is required even if it is just an empty file.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--port</option></term>
                <listitem>
                    <para>
                        Specifies the port on which the slow controls server
                        listens for connections.  This defaults to
                        <literal>27000</literal>.
                    </para>
                    <para>
                        The value of the <option>--port</option> options
                        must either be an integer port number or the
                        special string <literal>managed</literal>.
                        If <literal>managed</literal> is used, the
                        program interacts with the NSCL port manager server
                        to allocate and advertise a port.  The port is advertised
                        under the name <literal>VMUSBReadout:</literal><replaceable>connection</replaceable>.
                        <replaceable>connection</replaceable> specifies the connection
                        to the VM-USB.  If the VM-USB is attached directly either
                        the Serial number string is used or, if the VM-USB serial number
                        was not selected at program startup, the string
                        <literal>FirstController</literal> is used.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--enumerate</option></term>
                <listitem>
                    <para>
                        Requests that the software list the serial numbers of
                        the VMUSB devices currently attached to the system and
                        exit.  Note that the serial 'numbers' are actually strings
                        of the form <literal>VMnnnn</literal> where <replaceable>nnnn</replaceable>
                        is a number.  One of these strings can be handed to the
                        <option>--serialno </option> to select the VMUSB
                        to use.
                    </para>
                    <para>
                        Sample output:
                    </para>
                    <informalexample>
                        <programlisting>
/usr/opt/daq/10.1/bin/VMUSBReadout --enumerate
VM-USB scriptable readout version V5.0
[0] : VM0134

                        </programlisting>
                        <para>
                            This output says the system is attached to a single
                            VMUSB whose serial number string is
                            <literal>VM0134</literal>
                        </para>
                    </informalexample>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--sourceid</option></term>
                <listitem>
                    <para>
                        If a <option>--timestamplib</option> option is present,
                        events will have a full body header and the integer
                        value of this switch determines the value of the source
                        id.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>--timestamplib</option></term>
                <listitem>
                    <para>
                        The value of this option is a path to a shared object
                        library.  If present, the library must have a C
                        compatible entry point named <function>getTimestamp</function>.
                        If not supplied all events will have abbreviated body
                        headers and no timestamps will be present.
                    </para>
                    <para>
                        The library is dynamically loaded into the readout
                        program and <function>getTimestamp</function> is called
                        for each event.  <function>getTimestamp</function>
                        receives a single null pointer parameter, which points
                        to the event and is supposed to return a
                        <type>uint64_t</type> value that is that event's
                        timestamp.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
    </section>
    <section>
        <title>Using VMUSBReadout with the state/boot managers</title>
        <para>
            For background on the state and boot managers as well as
            the experiment configuration editor, see:
            <link linkend='chap.boot' endterm='chap.boot.title' />,
            <link linkend='chap.statemgr' endterm='chap.statemgr.title' /> and
            <link linkend='chap.expconfig' endterm='chap.expconfig.title' />.
        </para>
        <para>
            To make the VMUSBReadout run under the state/boot managers you must:
        </para>
        <itemizedlist>
            <listitem>
                <para>
                    Write a small script to incorporate the
                    <literal>ReadoutStateHook</literal> package into the
                    VMUSBReadout's main interpreter.
                </para>
            </listitem>
            <listitem>
                <para>
                    Configure the VMUSBReadout to use the
                    <option>--init-script</option> option to specify this
                    script.
                </para>
            </listitem>
        </itemizedlist>
        <para>
            Here's a sample of the script you need to write:
        </para>
        <example>
            <title>Script to incoprorate <literal>ReaodutStateHook</literal> into
            VMUSBReadout</title>
            <programlisting>
set pkgDirs [file join $env(DAQROOT) TclLibs]
lappend auto_path $pkgDirs

package require ReadoutStateHook                   
            </programlisting>
        </example>
        <para>
            Note that the <literal>DAQROOT</literal> environment variable gets
            defined by the boot manager for all of the programs it manages.
            Other environment variables get defined as well that describe to
            the <literal>ReadoutStateHook</literal> how to connect to the
            state manager.
        </para>
        
    </section>
</chapter>

<!-- /chapter -->

<!-- manpage 3vmusb -->
            <!--  adc command reference -->
            
<refentry id="vmusb3-adc">
  <refmeta>
     <refentrytitle>adc</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>adc</refname>
     <refpurpose>Create/configure CAEN V775, V785, V792, V862 modules.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
adc create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
	<command>
caenv965 create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
adc config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
caenv956 config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
adc cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
caenv956 cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>

  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
	This command creates, configures and retrieves the configuration of
        CAEN V775, V785, V792, and V862, V965 digitizer modules.
     </para>
     <para>
         Use the <command>create</command> subcommand to create a new adc
         providing it with a unique <parameter>name</parameter> that will
         be used to identify it in future commands.  The <parameter>base</parameter>
         parameter is the base address of the module as set in the module rotary
         switches.
     </para>
      <para>
         Use the <command>config</command> subcommand to configure
         a module named <parameter>name</parameter>  the <parameter>option</parameter>
         options and legal values are described in the section OPTIONS below.
      </para>
      <para>
         The <command>cget</command> subcommand returns as its value the configuration
         of the module <parameter>name</parameter>.  The configuration is
         returned as a list of two element sublists where each sublist
         contains, in order, an option from OPTIONS below, and its value.
         Note that some values may themselves be lists.
      </para>
      <para>
        When used with the CAEN V965 or other dual range digitizers via the
	caenv956 command, each parameter specified in the <varname>adcChannels</varname>
	array will result in two SpecTcl channels and corresponding raw spectra.
	The first will have
	<literal>.h</literal> appended to the name and will be the high range
	conversion while the second will have <literal>.l</literal> appended to the
	name and will be the low range value.
      </para>
  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	<varlistentry>
	    <term><command>-base</command> <replaceable>value</replaceable></term>
	    <listitem>
		<para>
                  Allows you to reconfigure the base address of a module.
		</para>
	    </listitem>
	 </varlistentry>
         <varlistentry>
            <term><command>-commonstop</command> <replaceable>value</replaceable></term>
            <listitem>
                <para>
                    This is only usable with a V775.  <parameter>value</parameter>
                    is a boolean value which, if true runs the module in common
                    stop mode.  If false (the default), the module is run in common
                    start mode.
                </para>
            </listitem>
        </varlistentry>
         <varlistentry>
            <term><command>-thresholds</command> <replaceable>values</replaceable></term>
            <listitem>
               <para>
                  The value is a list of 32 values that are the module 
                  thresholds.  Unless <option>-smallthresholds</option> has been
                  configured to be <literal>true</literal>, these values
                  are multiplied by 16 before being applied as the channel
                  threshold values.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>-smallthresholds</command> <replaceable>bool</replaceable></term>
            <listitem>
               <para>
                  The value is a boolean (e.g. <emphasis>on</emphasis> or
                  <emphasis>off</emphasis>).
                  A true boolean means that the threshold is applied as is
                  a false boolean means the threshold value is multiplied by 16
                  and then applied.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>-ipl</command> <replaceable>0-7</replaceable></term>
            <listitem>
               <para>
                  The interrupt priority level the module should use to request
                  a VME bus interrupt.  This defaults to 6 and should be set to
                  zero to disable interrupts.  Normally interrupts will be used
                  to trigger an interrupt triggered stack.  The default of 6
                  is historical in nature, in most cases for,
                  the default should be overridden to zero.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>-vector</command> <replaceable>0-255</replaceable></term>
            <listitem>
               <para>
                  The interrupt vector the module should use. This is an integer
                  and defaults to 0x80.  The vector value is ignored if the
                  module interrupts are disabled.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>-highwater</command> <replaceable>0-31</replaceable></term>
            <listitem>
               <para>
                  Defines how many events the module should accumulate before
                  it interrutps.  A value of zero also disables interrupts.
                  The default value is 24 evetns.  This is best suited for
                  singles applications where allowing the module to accumulate
                  a few events before being read is a good thing.
                  This value will be ignored if the <option>-ipl</option> option
                  has been configured to zero as that also disables module interrupts.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>-geo</command> <replaceable>0-31</replaceable></term>
            <listitem>
               <para>
                  Defines the geographical address that will be set in the module.
                  If the module has a PAUX connector, this must be set to be
                  the module's physical location in the crate.  This option must
                  be correctly programmed in order to help SpecTcl form a mapping
                  between data values and parameter names.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>-fastclear</command> <replaceable>value</replaceable></term>
            <listitem>
               <para>
                  Defines the fast clear window for the module.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>-supressrange</command> <replaceable>bool</replaceable></term>
            <listitem>
               <para>
                  If <literal>true</literal> the module will supress overflows
                  and underthreshold conversions.  If not all channels will
                  supply data for an event.  In most cases, this should be set to
                  <literal>false</literal>.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><command>-timescale</command> <replaceable>ns</replaceable></term>
            <listitem>
               <para>
                  Sets the full scale range of the module if it is a V775.
                  If the module is not a V775 TDC, this configuration parameter
                  is silently ignored (the hardware allows the software to
                  determine the module type).  <parameter>ns</parameter> is the
                  range of the TDC in nanoseconds and must be between
                  <literal>140</literal> and <literal>1200</literal>.
               </para>
            </listitem>
         </varlistentry>
	 <varlistentry>
	   <term><command>-iped</command> <replaceable>value</replaceable></term>
	   <listitem>
	      <para>
                 Sets the Iped register.  See section 4.34 of e.g. the
		 CAEN V965 manual.   This register controls the amount of charge
		 initially injected into the conversion circuit and is used to
		 compensate for leakage current that may lower the conversion of
		 a signal during the gate.  The default value is
		 <literal>180</literal>.  Valid values
		 are <literal>0 - 255</literal>, however see the description of
		 the Iped register and pedestal injections in the manual.
	      </para>
            </listitem>
         </varlistentry>
     </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
         <title>Sample ADC commands</title>
         <programlisting>
adc create adc1    0x04000000
adc config adc1    -geo 12 -supressrange off  -ipl 0 -vector 0
         </programlisting>
      </example>
      <para>
         Defines a module with base address 0x04000000 to be in geographical
         address 12.  Range supression and interrupts are disabled.
      </para>
  </refsect1>
  <refsect1>
      <title>NOTES</title>
      <para>
         This command can actually initialize/configure V775 TDCs and
         V792, V862 QDCs in addition to the V785 ADC.
      </para>
  </refsect1>
</refentry>
   <!-- caenchain command - aggregate 785's into CBLT chains -->
            
   <refentry id="vmusb3-caenchain">
     <refmeta>
        <refentrytitle>caenchain</refentrytitle>
        <manvolnum>3vmusb</manvolnum>
     </refmeta>
     <refnamediv>
        <refname>caenchain</refname>
        <refpurpose>Aggregate adc modules into CBLT readout chains.</refpurpose>
     </refnamediv>
     
     <refsynopsisdiv>
       <cmdsynopsis>
   	<command>
caenchain create <replaceable>name</replaceable>
   	</command>
       </cmdsynopsis>
           <cmdsynopsis>
               <command>
caenchain config <replaceable>name option value...</replaceable>
               </command>
         </cmdsynopsis>
             <cmdsynopsis>
                 <command>
caenchain cget <replaceable>name</replaceable>
                 </command>
             </cmdsynopsis>
         
     </refsynopsisdiv>
     <refsect1>
        <title>DESCRIPTION</title>
        <para>
            The CAEN family of 32 channel digitizers (V775, V785, V792, V862)
            can be aggreaged into CBLT readout chains.  A CBLT readout chain can
            then be read at high performance using a single block read operation.
        </para>
        <para>
            A CBLT chain consists of a set of at least two modules in consecutive
            VME bus slots.  From the point of view of defining the crate the
            left most and right most modules are special.  (See OPTIONS below,
            the <option>-module</option> option). 
        </para>
        <para>
            CBLT chains require an additional base address that is used to read
            the modules.  This address is also used as a multicast address to
            do a simultaneous clear of all modules in the chain as the readout
            is initialized (at the beginning of a run). 
        </para>
     </refsect1>
     <refsect1>
        <title>
   	OPTIONS
        </title>
        <variablelist>
   	<varlistentry>
   	    <term><option>-base</option> <replaceable>integer</replaceable></term>
   	    <listitem>
   		<para>
                  Provides the base address to be used to program the CBLT
                  address of the module.  Only the top two hexadecimal digits
                  of an 8 digit hexadecimal address should be non zero. e.g.
                  <literal>0x12000000</literal> is ok, but
                  <literal>0x12340000</literal> is not.
   		</para>
   	    </listitem>
   	</varlistentry>
        <varlistentry>
            <term><option>-modules</option> <replaceable>module-names</replaceable></term>
            <listitem>
            <para>
               Supplies the list of modules that should make up the chain. The
               firs module must be the left most in the chain, the last module the
               right most.  Other than that order is unimportant, however note that
               CBLT readouts always will go from left to right in VME crate. I therefore
               suggest that you supply the modules in left to right order.
               The modules must be a valid TCL list, e.g.:
               <literal>-modules [list adc1 adc2 adc3]</literal> is ok,
               <literal>-modules adc1 adc2 adc3</literal> is not.
            </para>
            </listitem>
         </varlistentry>
        </variablelist>
     </refsect1>

     <refsect1>
        <title>EXAMPLES</title>
        <para>
            The example below takes three ADC modules and aggregates them
            into a chain for readout.
            <example>
               <title>Using the <command>caenchain</command> command.</title>
               <programlisting>
adc create adc1    0x04000000
adc config adc1    -geo 12 -supressrange off  -ipl 0 -vector 0

adc create adc2    0x05000000
adc config adc2    -geo 13 -supressrange off  -ipl 0 -vector 0

adc create adc3    0x06000000
adc config adc3    -geo 14 -supressrange off -ipl 0 -vector 0


caenchain create chain

caenchain config chain -base 0x10000000 -modules [list adc1 adc2 adc3]
               </programlisting>
            </example>
        </para>
     </refsect1>

   </refentry>
   <!-- VM USB control and scaler readout -->
   
         <refentry id="vmusb3_vmusb">
           <refmeta>
              <refentrytitle id='vmusb3_vmusb_title'>vmusb</refentrytitle>
              <manvolnum>3vmusb</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>vmusb</refname>
              <refpurpose>Control VM-USB resources and read internal scalers</refpurpose>
           </refnamediv>
           
           <refsynopsisdiv>
             <cmdsynopsis>
                <command>
vmusb create name ?options?
                </command>
             </cmdsynopsis>
            <cmdsynopsis>
                <command>
vmusb config name ?options?
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
vmusb cget name
                </command>
            </cmdsynopsis>

           </refsynopsisdiv>
           <refsect1>
              <title>DESCRIPTION</title>
              <para>
                The <command>vmusb</command> command can be used in the
                <filename>daqconfig</filename> configuration file to control
                the internal reasources of the VM-USB as well as to enable
                the readout of its pair of scalers.  The VM-USB provides two outputs
                named O1 and O2 as well as a pair of gate and delay generators
                (DGGA and DGGB), and scalers A and B. Four LEDs round out the
                resources controlled by this command.
              </para>
              <para>
                In order to use a vmusb module to configure the controller, you
                must include it in a stack, even if you are not using reading the
                scalers in the VM-USB.  This is because it is the inclusion of
                a module in a stack that causes its initialization methods to
                be invoked, and it is there that teh vmusb module configures
                its resources.
              </para>
              <para>
                More information about the VM-USB and its resources can be found
                in sections 3.4.4 through 3.4.8 and section 1 of the VM-USB manual.
              </para>
              <para>
                The configuration options are described in the OPTIONS section
                below.
              </para>
           </refsect1>
           <refsect1>
              <title>
                 OPTIONS
              </title>
              <variablelist>
                <!-- NIM output configuration  -->
                <varlistentry>
                    <term><option>-nimo1</option></term>
                    <listitem>
                        <para>
                            Determines, along with the options
                            <option>-inverto1</option> and
                            <option>-latcho1</option> the behavior of NIM
                            output O1.  This can be any of the following values:
                            <literal>busy, trigger, busrequest, eventdatatobuvffer,
                            dgga, endevent</literal> or <literal>usbtrigger</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-inverto1</option></term>
                    <listitem>
                        <para>
                            Inverts the sense of the O1 nim output.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-latcho1</option></term>
                    <listitem>
                        <para>
                            Latches the O1 asserted when the condition that asserts
                            it is met.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-nimo2</option></term>
                    <listitem>
                        <para>
                            Along with the options
                            <option>-inverto2</option> and
                            <option>-latcho2</option>, controls when the NIM
                            O2 output is asserted.  This can be any of:
                            <literal>usbtrigger, vmecommand, vmeas,
                            eventdataobuffer, dgga, dggb,</literal> or
                            <literal>endevent</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-inverto2</option></term>
                    <listitem>
                        <para>
                            Inverts the sense of the NIM O2 output.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-latcho2</option></term>
                    <listitem>
                        <para>
                            Latches the state of the O2 NIM output when the
                            condition that would assert it is met.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-topyellow</option></term>
                    <listitem>
                        <para>
                            Together with <option>-inverttopyellow</option>
                            and <option>-latchtopyellow</option> determines
                            when the top Yellow LED of the VM-USB is lit.
                            This can be any of the following values:
                            <literal>ofifonotempty, infifonotempy, scaler
                            infifofull, berr, vmebr,</literal> or
                            <literal>vmebg</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-inverttopyellow</option></term>
                    <listitem>
                        <para>
                            Inverts the sense of the top yellow LED.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-latchtopyellow</option></term>
                    <listitem>
                        <para>
                            Latches the top yellow LED in the on state when the
                            condition is met that would light it.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-red</option></term>
                    <listitem>
                        <para>
                            Together with the <option>-invertred</option> and
                            <option>-latchred</option> options controls the
                            when the red LED on the VM-USB front panel is lit.
                            This can be one of the following value:
                            <literal>trigger, nimi1, nimi2, busy, dtack, berr, vmebr</literal>
                            or <literal>vmebg</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-invertred</option></term>
                    <listitem>
                        <para>
                            Inverts the state of the red LED.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-latchred</option></term>
                    <listitem>
                        <para>
                            Latches the red led on when the condition to light
                            it has been met.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-green</option></term>
                    <listitem>
                        <para>
                            Together with the <option>-invertgreen</option>
                            and <option>-latchgreen</option>, determines when
                            the green LED is lit.  This can be one of the following
                            values:
                            <literal>acquire, stacknotempty, eventready,
                            trigger, dtack, berr, vmebr</literal> or
                            <literal>vmebg</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-invertgreen</option></term>
                    <listitem>
                        <para>
                            Inverts the condition that lights the green LED.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-latchgreen</option></term>
                    <listitem>
                        <para>
                            If true, the green LED is latched in the on state
                            once the condition that would light it is met.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-bottomyellow</option></term>
                    <listitem>
                        <para>
                            Together with <option>-invertbottomyellow</option>
                            and <option>-latchbottomyellow</option> determines
                            when the bottom yellow LED is lit.  The value of this
                            option can be any of the following values:
                            <literal>notslot1, usbtrigger, usbreset, berr, dtack, vmebr</literal>
                            or <literal>vmebg</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-invertbottomyellow</option></term>
                    <listitem>
                        <para>
                            Inverts the condition that lights the bottom yellow
                            LED.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-latchbottomyellow</option></term>
                    <listitem>
                        <para>
                            Latches the bottom yellow LED in the lit state
                            once the condition is met to light it.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-readscalers</option></term>
                    <listitem>
                        <para>
                            If this is true the two scalers A and B will
                            be read by the stack in which the vmusb is
                            module is put.  The A scaler is read first followed
                            by the B scaler.  See <option>-scalera</option>
                            and <option>-scalerb</option> below which define
                            when each scaler increments.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-incremental</option></term>
                    <listitem>
                        <para>
                            This option is ignored unless <option>-readscalers</option>
                            is true.  If <option>-incremental</option> is true,
                            scalers are cleared after they are read.
                            Note that since the VM-USB has no mechanism to
                            atomically read and clear scalers, counts can be lost
                            between the read and clear.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-scalera</option></term>
                    <listitem>
                        <para>
                            Determines the condition that increments scaler A.
                            This can be one of the following values:
                            <literal>dgga, nimi1, nimi2</literal> or <literal>event</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-scalerb</option></term>
                    <listitem>
                        <para>
                            Determines the condition that increments scaler B.
                            This can be one of the following values:
                            <literal>carry,, nimi1, nimi2</literal> or
                            <literal>event</literal>.
                            The <literal>carry</literal> value means that
                            scaler B is incremented when scaler A overflows.
                            This allows both scalers to be combined into a single
                            64 bit scaler that is incremented by the condition
                            defined in the <option>-scalera</option> option.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-dgga</option></term>
                    <listitem>
                        <para>
                            Determines the condition that causes the signal to be
                            generated by the DGGA device. Options are:
                            <literal>off</literal>, <literal>nimi1</literal>,
                            <literal>nimi2</literal>,<literal>trigger</literal>,
                            <literal>endofevent</literal>,<literal>usbtrigger</literal>, 
                            and <literal>pulser</literal>. The default option is <literal>pulser</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-dggb</option></term>
                    <listitem>
                        <para>
                            Determines the condition that causes the signal to be
                            generated by the DGGB device. Options are:
                            <literal>off</literal>, <literal>nimi1</literal>,
                            <literal>nimi2</literal>,<literal>trigger</literal>,
                            <literal>endofevent</literal>,<literal>usbtrigger</literal>, 
                            and <literal>pulser</literal>. The default option is <literal>nimi2</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-widtha</option></term>
                    <listitem>
                        <para>
                            Determines the width of the gate produced by dgga in units of 12.5 ns.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-delaya</option></term>
                    <listitem>
                        <para>
                            Determines the amount of time in units of 12.5 ns to delay the gate
                            output of dgga once it has been triggered.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-widthb</option></term>
                    <listitem>
                        <para>
                            Determines the width of the gate produced by dggb in units of 12.5 ns.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-delayb</option></term>
                    <listitem>
                        <para>
                            Determines the amount of time in units of 12.5 ns to delay the gate
                            output of dggb once it has been triggered.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-mixedbuffers</option></term>
                    <listitem>
                        <para>
                            Sets whether scaler and event data can coexist in the same buffer.
                            The default is false.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-spanbuffers</option></term>
                    <listitem>
                        <para>
                            Sets whether event data can span buffer boundaries. Default is false. 
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-forcescalerdump</option></term>
                    <listitem>
                        <para>
                            If set to true, the VM-USB will immediately output scaler data 
                            once a scaler stack is executed. Default is false.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-busreqlevel</option></term>
                    <listitem>
                        <para>
                            Determines the bus request level that the VMUSB will use for itself
                            when it requests ownership of the bus. The valid values are any in
                            the range [0,7] and the default value is 4.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-optionalheader</option></term>
                    <listitem>
                        <para>
                            Determines whether a second optional header word will follow the first
                            buffer header word. When present, this extra header specifies the number
                            of words in the buffer. The default value is false.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-bufferlength</option></term>
                    <listitem>
                        <para>
                            Determines size of the internal buffer used by the VMUSB in units of 
                            words. The VMUSB fills the buffer before outputting data on a 
                            usb_bulk_read so a smaller buffer size is useful for low data rates. 
                            The optional values are: 13k, 8k, 4k, 2k, 1k, 512, 256, 128, 64, and evtcount.  
                            The evtcount option depends on the value of the -eventsperbuffer option.
                            The default value is 13k.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-eventsperbuffer</option></term>
                    <listitem>
                        <para>
                          If the -bufferlength option is set to evtcount, this determines how many
                          events must occur before transferring data to the FIFO for readout. The values
                          can be any in the range [1,4095]. The default value is 1.
                        </para>
                    </listitem>
                </varlistentry>
                
   
              </variablelist>
           </refsect1>
   
         </refentry>
   
   
   <!-- SIS 330x FADC driver -->
   
         <refentry id="vmusb3-sis330x">
           <refmeta>
              <refentrytitle>sis330x</refentrytitle>
              <manvolnum>3vmusb</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>sis330x</refname>
              <refpurpose>Driver for SIS3300/1 FADC</refpurpose>
           </refnamediv>
           
           <refsynopsisdiv>
            <cmdsynopsis>
                <command>
package require SIS330XDriver
                </command>
            </cmdsynopsis>
             <cmdsynopsis>
                 <command>
sis3300 <replaceable>name ?options?</replaceable>   
                </command>
             </cmdsynopsis>
             <cmdsynopsis>
                <command>
<replaceable>name</replaceable> configure <replaceable>options</replaceable>
                </command>
            </cmdsynopsis>
             <cmdsynopsis>
                <command>
<replaceable>name</replaceable> cget <replaceable>option</replaceable>
                </command>
             </cmdsynopsis>
             <cmdsynopsis>
                <command>
addtcldriver <replaceable>name</replaceable>
                </command>
             </cmdsynopsis>
           </refsynopsisdiv>
           <refsect1>
              <title>DESCRIPTION</title>
              <para>
                Provides support for the SIS 3300/3301 flash adc module.
                This is a Tcl driver, hence the need for a
                <command>package require</command> command to load the driver
                and a <command>addtcldriver</command> command to connect
                a driver instance with the framework.
              </para>
              <para>
                The driver support restricting the readout to a subset of the
                channels. See  the <option>-groupsread</option> option for
                more information in OPTIONS below.
              </para>
              <para>
                The structure of data read from the SIS3300/3301 is shown
                below (all elements are 32 bit integers unless otherwise
                indicated):
              </para>
              <informalexample>
                <programlisting>
+-------------------------------+
|  Group Mask                   | (16 bits)  <co id="sis3300_data_gmask" />
+-------------------------------+
|  Group size                   |            <co id="sis3300_data_gsize" />
+-------------------------------+
| Group data                    |
|          ...                  |            <co id="sis3300_data_group" />
+-------------------------------+
                </programlisting>
              </informalexample>
            <calloutlist>
                <callout arearefs="sis3300_data_gmask">
                    <para>
                        The low order four bits of this 16 bit data word
                        describe which ADC groups are present.  If bit 0
                        is set, group 1 is present, if bit 1 is set group 2
                        and so on.
                    </para>
                    <para>
                        Group data that follow are in order of low numbered
                        group to high numbered group for each group whose bit
                        is set in this group mask.
                    </para>
                </callout>
                <callout arearefs="sis3300_data_gsize" >
                    <para>
                        The group mask is followed by group data for each bit
                        set in the mask.  This field contains the number of
                        longwords of group data that follows.  The size
                        is not self-inclusive.
                    </para>
                </callout>
                <callout arearefs="sis3300_data_group">
                    <para>
                        Group data is the raw ADC trace data from the data
                        buffer.  The format of these longwords
                        is shown in section 4.34 of the SIS manual.
                    </para>
                </callout>
            </calloutlist>
           </refsect1>
           <refsect1>
              <title>
                 OPTIONS
              </title>
              <variablelist>
                <varlistentry>
                    <term><option>-base</option> <replaceable>base-address</replaceable></term>
                    <listitem>
                        <para>Module base address in VME.</para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-clocksource</option> <replaceable>clocksource</replaceable></term>
                    <listitem>
                        <para>
                            Module clock source.  This must be a value chosen
                            from one of the following strings:
                            <literal>100Mhz, 50Mhz, 25Mhz, 12.5Mhz, 6.25Mhz,
                            3.125Mhz FrontPanel P2Connector</literal>.
                            The clock source determines the sampling rate of the
                            ADC (or when data are clocked in in the case of
                            HiRA Mode.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-startdelay</option> <replaceable>boolean</replaceable></term>
                    <listitem>
                        <para>
                            If true the start delay is enabled and.  See
                            <option>-startdelayticks</option> to see how this delay
                            is controlled.  Note that the start delay determines when
                            the first sample is saved relative to the start.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-startdelayticks</option> <replaceable>integer</replaceable></term>
                    <listitem>
                        <para>Number of samples in the start delay.   If
                            <option>-startdelay</option> is <literal>
                            false</literal>, this parameter is not used.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-stopdelay</option> <replaceable>boolean</replaceable></term>
                    <listitem>
                        <para>
                             If true, the stop delay is enabled. See
                             <option>-stopdelayticks</option> to set the actual
                             stop delay.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-stopdelayticks</option></term>
                    <listitem>
                        <para>
                            This is the number of samples in the stop delay.
                            If <option>-stopdelay</option> is <literal>true</literal>,
                            when a stop occurs, data will be taken for this
                            number of samples more.  Note that this value is
                            completely ignored if <option>-stopdelay</option>
                            is <literal>false</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-stoptrigger</option> <replaceable>boolean</replaceable></term>
                    <listitem>
                        <para>
                            If <literal>true</literal> the module stop is the trigger.
                            This pretty much has to be used with
                            <option>-stopdelay</option> and
                            <option>-stopdelayticks</option>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-gatemode</option>  <replaceable>boolean</replaceable></term>
                    <listitem>
                        <para>
                            Module is or is not in gate mode.  In gate mode
                            the module is started from the falling edge of the
                            gate input and stopped by the rising edge of that signal.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-lemostartstop</option> <replaceable>boolean</replaceable></term>
                    <listitem>
                        <para>
                            Start/Stop come from lemo inputs.  This is enabled by
                            default.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-p2startstop</option> <replaceable>boolean</replaceable></term>
                    <listitem>
                        <para>
                                Backplane signals on the p2 connector
                                provide start/stop.  Note that this and
                                <option>lemostartstop</option> are not
                                mutually exlusive.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-hirarandomclock</option> <replaceable>boolean</replaceable></term>
                    <listitem>
                        <para>If true, HiRA random clock mode is enabled.
                            HiRA Random clock is normally used with the
                            Washington University Chip board readouts when
                            the readout is done with an XLM other than the
                            XLM-VV when the analog information is collected
                            by an SIS 3301 board.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-randomclock</option> <replaceable>boolean</replaceable></term>
                    <listitem>
                        <para>If true front panel provides a random clock with
                             a symmetric pulse shape
                             See section2.5.3 of the module documentation.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-samplesize</option> <replaceable>enum value</replaceable></term>
                    <listitem>
                        <para>Size of sample buffers.  This is one of the
                            following text strings:
                            <literal>128K, 16K, 4K, 2K, 1K, 512, 256 128</literal>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-wrap</option> <replaceable>boolean</replaceable></term>
                    <listitem>
                        <para>Buffers are  in wrap mode (normally used if
                            start/stop is longer than the samplesize.  Once
                            sampling runs off the end of the buffer sampling
                            continues writing at the low memory location
                            (wraps).  Please note that at present, the
                            readout method used does not support this.
                            If you have a need to use this mode, please
                            contact the NSCL software development group to
                            arrange further development.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-thresholdslt</option> <replaceable>boolean</replaceable></term>
                    <listitem>
                        <para>If true, channel thresholds represent a  level
                            _below_ which the conversion must fall. This is normally
                            used with negative going pulses since the data are
                            represented as half-scale offset unsigned integers.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-thresholds</option> <replaceable>8 element int list</replaceable></term>
                    <listitem>
                        <para>Threshold values for all 8 channels.  This parameter,
                              if provided is an 8 element integer list of
                              threshold values.  See as well
                              <option>thresholdslt</option> which can modify
                              how this value is interpreted.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><option>-groupsread</option> <replaceable>4 element bool list</replaceable></term>
                    <listitem>
                        <para>List of flags indicating which groups of ADCs will
                            be read. The module is organized into 4 groups of 2 ADCs each).
                            The manual refers to them as groups 1,2,3,4.  The first
                            list element allows or disables the readout of group 1
                            and so on.
                        </para>
                    </listitem>
                </varlistentry>

              </variablelist>
           </refsect1>
   
         </refentry>
   
   <!-- SIS 3820 scaler command  -->
            
      <refentry id="vmusb3-sis3820">
         <refmeta>
           <refentrytitle>sis3820</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
         </refmeta>
         <refnamediv>
           <refname>sis3820</refname>
           <refpurpose>Create and configure SIS 3820 scaler modules</refpurpose>
         </refnamediv>
        
         <refsynopsisdiv>
           <cmdsynopsis>
      	 <command>
sis3820 create <replaceable>name base</replaceable>
      	 </command>
          </cmdsynopsis>
             <cmdsynopsis>
                 <command>
sis3820 config <replaceable>name option value ...</replaceable>
                 </command>
             </cmdsynopsis>
                <cmdsynopsis>
                    <command>
sis3820 cget <replaceable>name</replaceable>
                    </command>
                </cmdsynopsis>
            
         </refsynopsisdiv>
         <refsect1>
           <title>DESCRIPTION</title>
           <para>
               Creates and configures the SIS3820 32 channel scaler for use in
               a stack.   The <command>create</command> subcommand creates a new
               module with a base address of <parameter>base</parameter>, and
               a name <parameter>name</parameter> which will be used to refer
               to this module in later configuration commands.
           </para>
            <para>
               The scaler readout will result in an array of 32 channels
               of scaler data placed in the buffer.  The first longword of this
               data is channel 0, the last, channel 1, unless the scaler in in
               <option>-timestamp</option> mode in which case the data are three
               longwords that consist of channel 0, channel 16 and the high bits
               register that has the top 16 bits of each of those channels as
               a 48 bit scaler.
            </para>
            <para>
               The <command>config</command> sub-command configures the options
               for the scaler <parameter>name</parameter>.  The configuration
               is expressed as a series of one or more
               <parameter>option value</parameter> pairs.  Options may have
               default values and are validity checked to ensure that
               valid values are supplied.  See OPTIONS below for more information
               about the option keywords that are supported and their legal values.
            </para>
            <para>
               The <command>cget</command> sub-command returns the current module
               configuration.  The configuration is returned as a Tcl list of
               <parameter>option value</parameter> pairs.  See
               OPTIONS below for a description of the options ans values
               that are returned.  You should not rely on the list being in any
               specific order.  While the list will have a deterministic order,
               if additional option keywords are added later on, this order may
               change.
            </para>
         </refsect1>
         <refsect1>
           <title>
      	OPTIONS
           </title>
           <variablelist>
      	 <varlistentry>
      	    <term><option>-base</option> <parameter>value</parameter></term>
      	    <listitem>
      		<para>
                  Allows you to override the initial base address of the module,
                  specified when the module was created.
      		</para>
      	    </listitem>
      	 </varlistentry>
         <varlistentry>
            <term><option>--timestamp</option> <parameter>on | off</parameter></term>
            <listitem>
                <para>
                    If this option is true, the scaler is read in timestamp mode as
                    2 48 bit scalers.  If false (the default), 32 bits are read for
                    each channel.
                </para>
            </listitem>
	 </varlistentry>
           </variablelist>
         </refsect1>
         <refsect1>
           <title>EXAMPLES</title>
           <para>
               The example below configures an SIS 3820 scaler to have a base
               address of 0x38000000
           </para>
            <example>
               <title>Configuring an SIS3820 scaler module</title>
               <programlisting>
sis3820 scaler1 0x38000000
               </programlisting>
            </example>
         </refsect1>

      </refentry>
           
      <!-- v830 command - configure CAEN V830 32 channel latching scalers -->
            
      <refentry id="vmusb3-v830">
        <refmeta>
           <refentrytitle>v830</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>v830</refname>
           <refpurpose>Create and configure CAEN V830 32 channel scalers.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
      	<command>
v830 create <replaceable>name base</replaceable>
      	</command>
          </cmdsynopsis>
             <cmdsynopsis>
                 <command>
v830 config <replaceable>name option value...</replaceable>
                 </command>
             </cmdsynopsis>
             <cmdsynopsis>
                 <command>
v830 cget <replaceable>name</replaceable>
                 </command>
             </cmdsynopsis>
         
        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
               This command creates, configures and queries the configuration of
               CAEN V830 scaler modules.  This is a latching scaler module.
               At present, not all functionality has been enabled. Specifically,
               the module code is now tailored to the typical use case of a
               run-time scaler module in the scaler stack.
           </para>

           <para>
               The <command>create</command> subcommand creates a new module.
               The <parameter>base</parameter> address should be the VME base
               address of the module, as configured in the module's
               rotary switches.  The <parameter>name</parameter> parameter is
               a name that you assign to the module, and will be used to
               refer to the module in future <command>config</command> or
               <command>cget</command> commands.
            </para>
            <para>
               The <command>config</command> subcommand configures the module
               <parameter>name</parameter>.  The configuration is supplied as a
               set of <parameter>option value</parameter> pairs.  More than one
               pair can appear on the same line, any number of <command>config</command>
               commands can be used and those that execute later can override
               those that execute earlier.
            </para>
            <para>
               The <command>cget</command> subcommand returns the configuration
               of the module <parameter>name</parameter> as a list of
               <parameter>option value</parameter> pairs.  You should not
               rely on the list being in any specific order.  While the list
               order is determinstic within a version of the program it is possible
               that later versions will return the list in a different order.
            </para>
        </refsect1>
        <refsect1>
           <title>
      	OPTIONS
           </title>
           <variablelist>
      	<varlistentry>
      	    <term><option>-base</option> <replaceable>address</replaceable></term>
      	    <listitem>
      		<para>
                  Allows you to override the base address of the module set at
                  creation time with a new base <parameter>address</parameter>.
      		</para>
      	    </listitem>
      	</varlistentry>
         <varlistentry>
            <term><option>-channels</option> <replaceable>mask</replaceable></term>
            <listitem>
               <para>
                  Provides a mask of enabled channels.  The low order bit represents
                  channel zero the high order bit, channel 31.  Each channel for which
                  a bit is present is enabled to count.  The default value for this
                  mask is <literal>0xffffffff</literal> which enables all channels.
               </para>
            </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-dwelltime</option> <replaceable>value</replaceable></term>
               <listitem>
                  <para>
                     This is used only if the <option>-trigger</option> is set
                     to <literal>periodic</literal> and is the time between
                     triggers in 400ns units.  Each trigger will latch the
                     current counter values into the MEB and, if
                     <option>-autoreset</option> is true, clear them.
                     If the <option>-ipl</option> and <option>-vector</option>
                     are set, this can produce a backplane interrupt which, in turn,
                     can trigger execution of a stack. The default value is zero
                     which disables the periodic trigger.
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-header</option> <replaceable>bool</replaceable></term>
               <listitem>
                  <para>
                     Enables or disables the inclusion of a header on data read from
                     the MEB.  For the format of the header, see figure 3.1 of the
                     CAEN V820/V830 manual.  Note that this header will only be present
                     if the MEB is read out.  A value of <literal>true</literal>
                     enables the header while a value of <literal>false</literal> disables it.
                     The default value is <literal>false</literal> which is appropriate
                     for the case where this module will be used in a scaler stack.
                  </para>
               </listitem>
            </varlistentry>
	    <varlistentry>
	      <term><option>-incremental</option> <replaceable>bool</replaceable></term>
	      <listitem>
		<para>
		  If <literal>true</literal> (the default) scaler ring items are labeled
		  as incremental.  If <literal>false</literal> scaler ring items are labeled
		  as not being incremental.
		</para>
	      </listitem>
	    </varlistentry>
            <varlistentry>
               <term><option>-trigger</option> <replaceable>random | periodic | vme</replaceable></term>
               <listitem>
                  <para>
                     Determines the source the latch trigger.  The values are
                     as follows:
                     <variablelist>
                        <varlistentry>
                           <term><literal>random</literal></term>
                           <listitem>
                              <para>The external trigger input is used to
                                 trigger the latch.
                              </para>
                           </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>periodic</literal></term>
                           <listitem>
                              <para>The module will have a periodic trigger that
                                 is governed by the value of the <option>-dwelltime</option>
                                 option.
                              </para>
                           </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>vme</literal> (default)</term>
                           <listitem>
                              <para>Triggers will be supplied by the stack that'
                                 reads the module out.
                              </para>
                           </listitem>
                        </varlistentry>
                     </variablelist>
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-wide</option>  <replaceable>bool</replaceable></term>
               <listitem>
                  <para>
                     Determines if, when the MEB is read, the scalers will be
                     wide (32 bit counters) or narrow (24 bit counters tagged
                     with the channel number).  See figures 3.2 and 3.3 in
                     the CAEN V820/830 manual for the data forma in both
                     cases.
                  </para>
                  <para>
                     A value of <literal>true</literal> enables wide
                     (32 bit) mode. A value of <literal>false</literal> requests
                     narrow (24 bit) mode.  This only affects data read from the
                     MEB.  The counter data are always wide.
                     The default value is <literal>true</literal>.
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-autoreset</option>  <replaceable>bool</replaceable></term>
               <listitem>
                  <para>
                     Configures the scaler to reset its counters after storing the data in the
                     MEB or not.  If <literal>true</literal> the counters are
                     cleared after latching the data.  If <literal>false</literal> not.
                     The defeault value is <literal>true</literal>.
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-geo</option>  <replaceable>slot</replaceable></term>
               <listitem>
                  <para>
                     Programs the module geographical address.  This value is only
                     relevant if <option>-header</option> is <literal>true</literal>
                     or <option>-wide</option> is <literal>false</literal>.
                     The value can only be programmed for modules that do not have
                     the PAUX connector.  Modules with the PAUX connector read their
                     geographical address from the backplane, and this value,
                     if used in other places, must be set to the physical slot number
                     the scaler is using (not a bad idea in any event).
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-setgeo</option> <replaceable>bool</replaceable></term>
               <listitem>
                  <para>
                     If <literal>true</literal> the configuration code attempts
                     to set the module's GEO value from the <option>-geo</option>
                     parameter.  If not, the <option>-geo</option> value is
                     simply assumed to document the position of the module to other
                     software, and is ignored.  The default value is <literal>false</literal>
                     which is suitable for modules without a PAUX connector and
                     for the normal use case of a module in the scaler stack where
                     the GEO address is not relevant.
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-ipl</option>  <replaceable>priority</replaceable></term>
               <listitem>
                  <para>
                     Provides the interrupt priority level for the module's
                     VME interrupt.  The V830 can interrupt when it has at least
                     <option>-highwatermark</option> events in its MEB.
                     This interrupt can be used to trigger a VM-USB stack.
                  </para>
                  <para>
                     VME bus interrupts are prioritized with the priority value
                     ranging from <literal>1</literal> through <literal>7</literal>.
                     This priority determines the service order of simultaneous interrupts.
                     Larger numbers are higher priorities.   A value of
                     <literal>0</literal> disables module interrupts.  The
                     default value is <literal>0</literal>
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-vector</option>  <replaceable>statusid</replaceable></term>
               <listitem>
                  <para>
                     VME interrupts are identified via a <firstterm>status-id</firstterm>
                     value presented by the interrupting device when the interrupt is
                     acknowledged by the <firstterm>interrupt responder</firstterm>
                     (VM-USB).  In the case of the CAEN V830, this is a value
                     from <literal>0</literal> through <literal>255</literal>.
                  </para>
                  <para>
                     For historical reasons, this status-id value is also called the
                     <firstterm>interrupt vector</firstterm>.  The <option>-vector</option>
                     option sets the value of the interrupt vector presented by the
                     CAEN V830 when it interrupts.  To interrupt, the module must also
                     be configured with a nonzero <option>-ipl</option> and
                     nonzero <option>-highwatermark</option> value.
                  </para>
                  <para>
                     Module interrupts can be used to triggers VM-USB stack
                     execution. 
                  </para>
               </listitem>
            </varlistentry>
            <varlistentry>
               <term><option>-highwatermakr</option> <replaceable>value</replaceable></term>
               <listitem>
                  <para>
                     Configures the value of the V830 <firstterm>Almost Full Level</firstterm>
                     register.  When non zero, if <option>-ipl</option> is also non-zero,
                     and <option>-vector</option> is also non zero, when there is at least
                     <parameter>value</parameter> events in the MEB, the module
                     will initiate a VME bus interrupt.  VME interrupts can be
                     used to trigger VM-USB stacks.  The default value is 1.
                  </para>
               </listitem>
            </varlistentry>
            </variablelist>
        </refsect1>

        <refsect1>
           <title>EXAMPLES</title>
           <para>
               The following example shows how to set up a CAEN V830 scaler
               for inclusion in the scaler stack.  The base address of the
               scaler is <literal>0x80000000</literal>.  The default configuration
               values are suitable for the scaler stack.
           </para>
           <example>
            <title>Configuring a CAEN V830 scaler</title>
               <programlisting>
v830 create scaler 0x80000000
               </programlisting>
           </example>
        </refsect1>

      </refentry>
      <refentry id="vmusb3-v977">
	<refmeta>
	   <refentrytitle>v977</refentrytitle>
	   <manvolnum>3vmusb</manvolnum>
	</refmeta>
	<refnamediv>
	   <refname>v977</refname>
	   <refpurpose>Create and configure CAEN V977 Input registers</refpurpose>
	</refnamediv>
	
	<refsynopsisdiv>
	  <cmdsynopsis>
	  <command>
v977 create <replaceable>name ?option value...?</replaceable>
	  </command>
	  </cmdsynopsis>
	  <cmdsynopsis>
	  <command>
v977 config <replaceable>name option value ?...?</replaceable>	  
	  </command>
	  </cmdsynopsis>
	  <cmdsynopsis>
	  <command>
v977 cget <replaceable>name</replaceable>	  
	  </command>
	  </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	   <title>DESCRIPTION</title>
	   <para>
This command supports the CAEN V977 I/O register.  At this time support is only
provided to read the module's input register.  Other than setup modes that
echo the inputs to the outputs in some way, output is not supported.
	   </para>
	   <para>
The <command>create</command> subcommand creates a new module.  The <parameter>name</parameter>
parameter supplies a unique name by which that module will be known throughout the
rest of the configuration file.  The optional <parameter>option value</parameter>
pairs provide additional configuration options and can be selected from the
set of configuration options described in OPTIONS below.
	   </para>
	   <para>
The <command>config</command> subcommand allows you to further configure an
existing module.  The <parameter>name</parameter> parameter is the name
you assigned to the module in the <parameter>create</parameter> operation.
The <parameter>option value</parameter> pairs configure the module and can
be selecte from the configuration options described in OPTIONS below.
	   </para>
	   <para>
The <command>cget</command> allows you to retrieve the current configuration of
the module.  The <parameter>name</parameter> parameter provides the name of the module
as defined by the <command>create</command> subcommand.  The result is a
well formed Tcl list that consists of option name value pairs.
	   </para>
	</refsect1>
	<refsect1>
	   <title>OPTIONS</title>
	   <para>
          Configuration options provide a mechanism to define where a module
			 is located in the VME space as well as how the moduile should be
			 prepared for data taking.  A module is configured via the
			 <command>config</command> subcommand.  That command identifies
			 the module via the name assigned to it in the <command>create</command>
			 operation and provides configuration information in the form of
			 a set of name value pairs.  
	   </para>
		<para>
          Each name selects what is to be configured and each value provides
          the new value for that item.
          The configuration keywords supported and the meanings of their values
          are described below.
      </para>
      <variablelist>
          <varlistentry>
               <term><option>-base</option> <replaceable>base-address</replaceable></term>
               <listitem>
                  <para>
                     Defines the base address of the module.
                     <parameter>base-address</parameter> must match the base address
                     set in the module's rotary switches.  This address is used
                     to determine how to access the module in VME address space.
                  </para>
               </listitem>
          </varlistentry>
          <varlistentry>
             <term><option>-inputmask</option>  <replaceable>mask</replaceable></term>
             <listitem>
                <para>
                   Provides the value of the module's input mask register.
                   The value of <parameter>mask</parameter> is programmed into
                   the module's input mask register at initialization time.
                   Each bit set in the register prevents the corresponding
                   front panel input from being seen by the module.
               </para>
             </listitem>
          </varlistentry>
          <varlistentry>
             <term><option>-readmode</option>  <replaceable>mode</replaceable></term>
             <listitem>
                <para>
                   Together with the <option>-readandclear</option>, determines
                   which register is actually read by the stack.  Legal values
                   are <literal>singlehit</literal> and <literal>multihit</literal>.
                   If <literal>singlehit</literal> is selected (the default) is
                   provided the module will read either the Single hit read
                   register or the Singlehit read-clear register depending on the
                   value of the <option>-readandclear</option>.  <literal>multihit</literal>
                   is selected, the module's multihit read or multihit read-clear
                   register will be read.
                   </para>
               <para>
                   See the table at the end of this section for a complete
                   listing of the combinations of read modes and read and clear
                   settings and their implications for how the module is read.
                   </para>
              </listitem>
          </varlistentry>
          <varlistentry>
              <term><option>-outputmask</option>  <replaceable>mask</replaceable></term>
              <listitem>
                 <para>
                    Provides a value for the output mask register.
                    This defaults to zero.
                    </para>
                 </listitem>
          </varlistentry>
          <varlistentry>
              <term><option>-interruptmask</option> <replaceable>mask</replaceable></term>
              <listitem>
                 <para>
                    Provides a value that will be programmed into the
                    output mask regiseter.  The module can produce an interrupt
                    if bits that are not masked off in this register are set
                    in the pattern gated into the module.  See also the
                    <option>-ipl</option> and <option>-vetor</option> if
                    you intend to use the module with interrupts.
                    </para>
                 </listitem>
          </varlistentry>
          <varlistentry>
             <term><option>-readandclear</option> <replaceable>true|false</replaceable></term>
             <listitem>
                <para>
                   Determines whether the module will be atomically cleared
                   as it is read.  This option together with the
                   <option>-readmode</option> determines which module register
                   read is added to the readout stack.  For more information,
                   see the table at the end of this section.
                </para>
             </listitem>
          </varlistentry>
          <varlistentry>
             <term><option>-ipl</option> <replaceable>interrupt-level</replaceable></term>
             <listitem>
                <para>
                   Determines the interrupt priority level used by the module
                   when creating interrupt requests on the VME dataway.  If
                   <parameter>interrupt-level</parameter> is <literal>0</literal>
                   (the default), interrupts will not be used.
                </para>
             </listitem>
          </varlistentry>
          <varlistentry>
             <term><option>-vector</option> <replaceable>status-id</replaceable></term>
             <listitem>
                <para>
                   When the module creates a VME dataway interrupt it provides the
                   <parameter>status-id</parameter> as the interrupt vector
                   when requested to by the interrupt handler module (VM-USB normally).
                   If the <parameter>status-id</parameter> is <literal>0</literal>
                   (default), interrupts are not generated on the dataway.
                </para>
             </listitem>
          </varlistentry>
          <varlistentry>
             <term><option>-pattern</option> <replaceable>true|false</replaceable></term>
             <listitem>
                <para>
                   If this is <literal>true</literal>, the pattern bit is set
                   int he control register, and the module operates in pattern
                   mode.  If not, the module operates in I/O register mode.
                </para>
             </listitem>
          </varlistentry>
          
      </variablelist>
      
	</refsect1>
      
      </refentry>
      <refentry id="vmusb3-sis3804">
        <refmeta>
           <refentrytitle>sis3804</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>sis3804</refname>
           <refpurpose>Create and configure SIS 3804 scalers</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
sis3804 create <replaceable>name ?options...?</replaceable>
              </command>
          </cmdsynopsis>
    <cmdsynopsis>
        <command>
sis3804 config <replaceable>name options...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
      <command>
sis3804 cget <replaceable>name option</replaceable>
      </command>
    </cmdsynopsis>
        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
              This command creats and manipulates SIS3804 objects.  The SIS3804
              is an 8 channel latching scaler manufactured by Struck.  The
              SIS3804 objects can configure and add readout instructions for this
              hardware to VM-USB stacks.
           </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
              <varlistentry>
                  <term><option>-base</option> <replaceable>base-address</replaceable></term>
                  <listitem>
                      <para>
                        Sets the base address of the module. This must match the
                        value selected by  the rotary switches on the module.
                        The default for this option is 0, which is typically not
                        what you want.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
               <term><option>-refpulser</option> <replaceable>boolean</replaceable></term>
               <listitem>
                  <para>
                     Enables or disables the reference pulser.  When enabled,
                     the reference pulser disables the input to channel 1 and
                     supplies a 25Mhz pulse frequency to that channel.
                  </para>
                  <para>
                     A value of <literal>true</literal> enables the pulser while
                     <literal>false</literal> (the default) disables the reference
                     pulser.
                  </para>
               </listitem>
              </varlistentry>
              <varlistentry>
                  <term><option>-disables</option> <replaceable>mask</replaceable></term>
                  <listitem>
                     <para>
                        Allows you to disable specific channels from counting.
                        The bottom 8 bits if set disable the corresponding channel
                        of the pulse.  For example if mask &amp; 1 is nonzero,
                        channel 1 (numbered from 1) is disabled, while if
                        mask &amp; 0x10 is nonzero, channel 8 is disasbled.
                     </para>
                     <para>
                        The default value is zero which enables all channels.
                     </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
               <term><option>-autoclear</option> <replaceable>boolean</replaceable></term>
               <listitem>
                  <para>
                     If this option is <literal>true</literal> (the default),
                     scalers are cleared atomically after being latched for readout.
                     The NSCL data acquisition system scaler display program
                     expects the scaler counters to be incremental values  with
                     the sums computed in software (so that overflows can be
                     explicitly managed).  If you have a special application for this
                     scaler, e.g. to provide timestamps in an event, for which you
                     do not want this behavior, you can set this option to <literal>false</literal>
                  </para>
               </listitem>
              </varlistentry>
           </variablelist>
        </refsect1>
        <refsect1>
           <title>EXAMPLES</title>
           <para>
            The example below creatse a scaler at the manufacturer's setting
            for the base address and configures it to have the 25Mhz
            reference pulser in channel 1:
           </para>
           <example>
            <title>Configuring the SIS 3804 scaler</title>
            <programlisting>
sis3804 create scaler1 -base 0x38383800
sis3804 config scaler1 -refpulser true
            </programlisting>
           </example>
        </refsect1>
      
      </refentry>
      <refentry id="vmusb3-hira">
        <refmeta>
           <refentrytitle>hira</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>hira</refname>
           <refpurpose>Pair up to 2 XLMs and FADC for HiRA</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
          <command>
hira create <replaceable>name ?options?</replaceable>
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
hira config <replaceable>name options</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
hira cget <replaceable>name</replaceable>
                </command>
            </cmdsynopsis>


        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            In situations where an XLM-XXV is not available, Wash-U chip boards
            can be read out using an XLM and an SIS3300/SIS3301 FADC module.
            This command allows you to combine these into a single module.
            from the point of view of a stack.
           </para>
           <note>
               <title>Note:</title>
               <para>
                  Normally the XLM modules used are either a hinp or psd
                  module.  As the code for these is maintained by Washington
                  Univ,  Those drivers are not documented here.
               </para>
           </note>
           <para>
            The command produces the following data format:
           </para>
           <informalexample>
            <programlisting>
+------------------------------------+
|   id (16) bits                     |
+------------------------------------+
| tag data from the xlm  1 srama     |
...
| tag data from xlm1 sram b          |
../
+------------------------------------+
| 0xfadc                             |
+------------------------------------+
| Mask of read groups                |
+------------------------------------+
| Data from the FADC module group1   |
+------------------------------------+
| 0xaaa                              |
+------------------------------------+
...
| Data from the FADC module group2   |
...
+y------------------------------------+
            </programlisting>
           </informalexample>
           <para>
            Note that the configuration parameters of the XLM's determine whether
            or not both SRAM banks are read, the configuration of the FADC determines
            which FADC groups are read, and the <option>-xlm</option> option value
            determines whether one or two XLM modules are associated witht this
            HiRA module.
          </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
            <varlistentry>
                <term><option>-id</option> <replaceable>integer</replaceable></term>
                <listitem>
                    <para>
                        Provides the id tag that precedes the data from the
                        two actual modules.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-xlm</option> <replaceable>module-name</replaceable></term>
                <listitem>
                    <para>
                        This parameter is a list of one or two XLM modules assoiated
                        with this HiRA.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-fadc</option> <replaceable>module-name</replaceable></term>
                <listitem>
                    <para>
                        This parameter is the name of the sis330x module that
                        gets the analog data
                    </para>
                </listitem>
            </varlistentry>
           </variablelist>
           <note>
            <title>Note:</title>
            <para>
                The software does not check that the XLM is an XLM or that the
                fadc is an SIS 330x module.
            </para>
           </note>
        </refsect1>

      </refentry>

      <refentry id="vmusb3-hytec">
        <refmeta>
           <refentrytitle>hytec</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>hytec</refname>
           <refpurpose>Support the Hytec NADC 2530 adc module.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
hytec create <replaceable>name ?options?</replaceable>
              </command>
          </cmdsynopsis>
<cmdsynopsis>
    <command>
hytec <replaceable>config name ?options?</replaceable>
    </command>
</cmdsynopsis>
<cmdsynopsis>
    <command>
hytec cget <replaceable>name</replaceable>
    </command>
</cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
              This command provides support for the Hytec NADC2530.  The NADC2530
              is an 8 channel multi-event peak sensing adc.  While the module
              is capable of autonomously creating histograms, this software does
              not support that capability as it's much easier to treat that
              module differently if used in that way.
           </para>
	   <para>
	    Beginning with the VM-USB readout program verssion 3.2-001, the
	    software tags the ADC data with a user defined virtual slot number,
	    and the module provides a 48 bit timetamp with each event if
	    its firmware revision is 2530V305 or later.
	   </para>	
           <para>
               As for all VM-USB module support commands, <command>hytec</command>
               is a command ensemble with the subcommands
               <variablelist>
                  <varlistentry>
                     <term><command>create</command></term>
                     <listitem>
                        <para>Which creates an object for an NADC2530 adc
                           which can be referred to by the name <parameter>name</parameter>.
                           Additional options can provide device configuration.
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><command>config</command></term>
                     <listitem>
                        <para>
                           Which configures the existing device object
                           <parameter>name</parameter>
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><command>cget</command></term>
                     <listitem>
                        <para>
                           Which returns the module <parameter>name</parameter>'s
                           configuration as an item list of name value pairs.
                        </para>
                     </listitem>
                  </varlistentry>
               </variablelist>
                                                                
           </para>
            <para>
               Configuration options are described in the OPTIONS section below.
            </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
              <varlistentry>
                  <term><option>-csr</option> <replaceable>address</replaceable></term>
                  <listitem>
                      <para>
                           This option must appear somewhere in the module configuration.
                           It establishes the base address of the module's
                           register space.  The NADC 2530 has two address spaces,
                           register space, used to configure and control the module,
                           and memory space where events get stored.
                      </para>
                      <para>
                        The <parameter>address</parameter> is an A24 address.
                        this means it must be in the range
                        <literal>0x000000</literal> through <literal>0xffffff</literal>.
                        Each module must have a unique base address, and the address
                        configured in the software must match the address configured
                        in the module's address jumpers.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
               <term><option>-memory</option> <replaceable>address</replaceable></term>
               <listitem>
                  <para>
                     This option must appear somewhere in the module configuration.
                     It establishes the base address of the module's event buffer
                     memory. Each module's event memory must carve out a unique
                     slice of A32 address space (values between
                     <literal>0x00000000</literal> and <literal>0xffffffff</literal>).
                  </para>
                  <para>
                     The buffer memory address space is software programmable.
                     See the NADC2530 manual for the size of this address space
                     as any overlap can cause corrupted data to be read from the
                     modules.
                  </para>
               </listitem>
              </varlistentry>
               <varlistentry>
                  <term><option>-ipl</option> <replaceable>irqlevel</replaceable></term>
                  <listitem>
                     <para>
                        If you are using the module's interrupt to trigger
                        a stack execution, <parameter>irqlevel</parameter> must
                        be a nonzero value between <literal>1</literal> and
                        <literal>7</literal>, and will be the interrupt priority
                        level on which the module will generate an iterrupt request.
                     </para>
                     <para>
                        The value of this parameter defaults to <literal>0</literal>
                        which disables module interrupts.  See also the
                        <option>-vector</option> option below.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-vector</option> <replaceable>statusid</replaceable></term>
                  <listitem>
                     <para>
                        If the module is being used to trigger a stack,
                        <parameter>statusid</parameter> should be the value the
                        module will use to reply to the interrupt acknowledge cycle's
                        request for a status/id from the module.
                     </para>
                     <para>
                        The NADC2530 has a status/id 16 bits wide
                        (between <literal>1</literal> and <literal>65535</literal>
                        where zero disables the interrupt).  The VM-USB, however
                        only triggers on the bottom 8 bits of the status id field.
                        therefore you should use values between
                        <literal>1</literal> and <literal>255</literal> unless
                        you are directing the interrupt at other modules in the VME
                        crate.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-lld</option> <replaceable>millivolts</replaceable></term>
                  <listitem>
                     <para>
                        Provides the low level threshold value in <parameter>millivolts</parameter>.
                        Due to the resolution of the threshold DAQ, the actual threshold
                        value programmed may be slightly different than the one requested.
                        See the manual for the relationship between
                        <parameter>millivolts</parameter> and threshold DAC values.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-hld</option> <replaceable>volts</replaceable></term>
                  <listitem>
                     <para>
                        Provides the high level discriminator value in floating
                        point <parameter>volts</parameter>.  Due to the
                        Due to the resolution of the threshold DAQ, the actual threshold
                        value programmed may be slightly different than the one requested.
                        See the manual for the relationship between
                        <parameter>volts</parameter> and threshold DAC values.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-events</option> <parameter>count</parameter></term>
                  <listitem>
                     <para>
                        Indicates that <parameter>count</parameter> events must
                        be in the event buffer before an interrupt will be
                        signalled on the VME backplane.  This item also configures
                        how many events are required for the module to indicate
                        that it has data.  Therefore, if not being used with interrupts,
                        this value should be programmed to its default value of
                        <literal>1</literal>
                     </para>
                  </listitem>
               </varlistentry>
	       <varlistentry>
		  <term><option>-id</option> <parameter>value</parameter></term>
		  <listitem>
		     <para>
			Provides a 16 bit id (virtual slot number) that will be
			used to tag the data.  The NADC2530 is not capable
			of providing a hardware virtual slot number as of firmware
			2530V305, therefore the <parameter>value</parameter> is
			inserted as a marker word prior to the data from the ADC.
		     </para>
		     </listitem>
		  </varlistentry>
	       <varlistentry>
		  <term><option>-zerosuppress</option> <parameter>on|off</parameter></term>
		  <listitem>
		     <para>
			If the value of this parameter is a true boolean, the
			channels that are outside the high and low level
			discriminators are not present in the data from the
			device.  If the value is a boolean true, all 8 channels
			are present in the data.
		     </para>
		  </listitem>
	       </varlistentry>
           </variablelist>
        </refsect1>
        <refsect1>
           <title>EXAMPLES</title>
           <para>
               The example below configures an NADC 2530 with a register base
               address of <literal>0x400000</literal>, and a buffer address
               of <literal>0x10000000</literal>.  It leaves the thresholds
               wide open and does not enable module interrupts.  A marker
	       word 0xadc1 is inserted prior to the data, and, if the
	       discriminator levels are later set, data outside of them
	       will be supressed from the data stream.:
           </para>
           <example>
            <title>Sample Hytec 2530 configuration</title>
            <programlisting>
hytec create adc
hytec config adc  -csr 0x400000 -memory 0x10000000 
hytec config adc -lld 0.0 -hld 8.191 -events 1 -id 0xadc1 -zerosuppress on
            </programlisting>
           </example>
        </refsect1>
	<refsect1>
	    <title>DATA FORMAT</title>
	    <para>
	       Readout prepends the data from the ADC with three additional
	       data words.  This section describes what to expect in the
	       event file for this module.
	    </para>
	    <para>
	       The first word of data from this module will be the value of
	       the <option>-id</option> optin.  This defaults to zero if
	       not supplied.  This is followed by a mask word, and then a
	       count word.  These two words allow you to determine the number
	       of longwords of ADC data that follow.
	       </para>
	    <para>
	       Suppose the mask word is <literal>mask</literal> and the
	       count word is <literal>count</literal>.
	       <literal>mask &amp; count</literal> computes the number of longwords
	       of ADC data that follow in the data packet from this module.
	       </para>
	    <para>
	       Following these three words, the data from the ADC as shown in
	       section 4.3.1 of the manual is inserted in the event. Note that:
	    </para>
	    <orderedlist>
	       <listitem>
		  <para>
		     The ADC may convert serveral times for a single channel
		     if multiple signal peaks are detected within the gate
		     time.  SpecTcl will only pay attention to the largest of these
		     conversions for a specific channel.
		     </para>
	       </listitem>
	       <listitem>
		  <para>
		     When the system starts up, or if the busy lock out logic
		     is not perfect, and allows gates to go to the ADC when
		     the system is busy, you may see additional events or event
		     fragments.  SpecTcl will only pay attention to the data from
		     the first event (it will stop processing channels after the first)
		     trailer word or after the longword count described above is
		     exhausted.
		  </para>
		  </listitem>
	       <listitem>
		  <para>
		     When the system initially starts, there may be a large number
		     of gates prior to the VM-USB completing intialization...
		     depending on when it actually asserts busy.  Once more SpecTcl
		     will only histogram the first of these events from the ADC.
		     As subsequent data from the ADC should be synchronized to the
		     IN1 trigger, this should at most affect the first event.
		  </para>
	       </listitem>
	       <listitem>
		  <para>
		     When setting up the SpecTcl parameters for this module,
		     remember that the module provides 9 parameters. The first
		     of these is a 48 bit timestamp.  The remaining 8 are the
		     adc parameters.  SpecTcl is not able to guess how you want to
		     set up the timestamp spectrum.  In general this is not a problem
		     as usuall you will be using the timestamp to generate rate
		     stripchart spectra rather than looking at the timestamp
		     itself.
		     </para>
	       </listitem>
	       <listitem>
		  <para>
		     When looking at SpecTcl timestamp based spectra you may see
		     significant gaps in the time online. This happens because of
		     the way data are sampled to SpecTcl from the online system.
		     SpecTcl may miss complete buffers of data online if it is not
		     able to keep up with the data rate.  If you process the
		     event file for that run offline, these gaps disappear.
		     </para>
	       </listitem>
	    </orderedlist>
	</refsect1>
      </refentry>
      <refentry id="vmusb3-tcldriversupport">
        <refmeta>
           <refentrytitle>tcl driver support</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>tcl driver support</refname>
           <refpurpose>tcl driver support functions.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
package require VMUSBDriverSupport
            </command>
          </cmdsynopsis>
        <cmdsynopsis>
            <command>
::VMUSBDriverSupport::convertVmUSB <replaceable>name</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
::VMUSBDriverSupport::convertVmUSBReadoutList <replaceable>name</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
::VMUSBDriverSupport::validInt <replaceable>value ?low ?high??</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::VMUSBDriverSupport::validReal <replaceable>value ?low ?high??</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::VMUSBDriverSupport::valideEnum <replaceable>value set</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::VMUSBDriverSupport::validBool <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::VMUSBDriverSupport::validList <replaceable>value ?fewest ?most ?checker ?args????</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::VMUSBDriverSupport::validIntList <replaceable>value ?fewest ?most ?low ?high????</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::VMUSBDriverSupport::validBoolList <replaceable>value ?fewest ?most???</replaceable>
                </command>
            </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This package provides utiltities that are of use/interest to
            Tcl device driver modules for the VM-USB readout framework.
            The attempt is to centralize/factor common code out of driver
            modules that is commonly used.  
           </para>
        </refsect1>
        <refsect1>
           <title>
              COMMANDS
           </title>
           <variablelist>
            <varlistentry>
                <term><command>::VMUSBDriverSupport::convertVmUSB <replaceable>name</replaceable>
                </command></term>
                <listitem>
                    <para>
                        Converts a swig CVMUSB object identifier into a usable
                        CVMUSB object.  Once converted the driver can invoke
                        methods on that object.  <parameter>name</parameter>
                        is the object passed in to the driver.  The return
                        value will be the  name of the new object.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>::VMUSBDriverSupport::convertVmUSBReadoutList <replaceable>name</replaceable></command></term>
                <listitem>
                    <para>
                        Converts a CVMUSBReadoutList swig object identifier into
                        an object.  Once converted, the object methods can
                        be directl invoked.
                        <parameter>name</parameter> is the name passed in to the
                        method by the framework.  the return value is the
                        name of the object.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>::VMUSBDriverSupport::validInt <replaceable>value ?low ?high??</replaceable></command></term>
                <listitem>
                    <para>
                        Provides type checking and optional range checking for
                        integer data. This is most often called to validate
                        an integer driver option.
                    </para>
                    <para>
                        Throws an error if <parameter>value</parameter> is not
                        a valid integer.  Additionally, if <parameter>low</parameter>
                        is not empty, an error is thrown if
                        <literal>$value &lt; $low</literal>.  Similarly if
                        <parameter>high</parameter> is not empty an error
                        is thrown if <literal>$value &gt; $high</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>::VMUSBDriverSupport::validReal <replaceable>value ?low ?high??</replaceable></command></term>
                <listitem>
                    <para>
                        Provides type and optional range checking for
                        real parameters.
                    </para>
                    <para>
                        If <parameter>value</parameter> is not valid real number
                        this proc throws an error.  Furthermore if <parameter>low</parameter>
                        is not blank, an error is thrown if <literal>$value &lt; $low</literal>.
                        Similarly if <parameter>high</parameter> is not blank,
                        an error is thrown if <literal>$value &gt; $high</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>::VMUSBDriverSupport::valideEnum <replaceable>value set</replaceable></command></term>
                <listitem>
                    <para>
                        Throw an error if <parameter>value</parameter> is not
                        one of the strings  in the Tcl list <parameter>set</parameter>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>::VMUSBDriverSupport::validBool <replaceable>value</replaceable></command></term>
                <listitem>
                    <para>
                        Throws an error if <parameter>value</parameter> is not
                        recognizable as a boolean by Tcl.
                        <ulink url='http://www.tcl.tk/man/tcl8.5/TclLib/GetInt.htm'>
                            http://www.tcl.tk/man/tcl8.5/TclLib/GetInt.htm</ulink>
                        describes the set of <parameter>value</parameter>s that are
                        recognized as valid booleans.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>::VMUSBDriverSupport::validList <replaceable>value ?fewest ?most ?checker ?args????</replaceable>
                </command></term>
                <listitem>
                    <para>
                        Throws an error if <parameter>value</parameter> is not
                        a valid Tcl list.  Futhermore if <parameter>fewest</parameter>
                        is not blank, an error is thrown if
                        <literal>[llength $value] &lt; $fewest</literal>.
                        Similarly, if <parameter>most</parameter> is not blank,
                        an error is thrown if
                        <literal>[llength $value] &gt; $most</literal>.
                    </para>
                    <para>
                        <parameter>checker</parameter> is a script which if
                        not blank is called for each element of
                        <parameter>value</parameter>. <parameter>checker</parameter> is
                        called as follows: <literal>$checker $element {*}$args</literal>
                        where <parameter>element</parameter> is an element of the
                        list.  The intent of this is to provide support for
                        type/range checking each element of the list.
                    </para>
                    <para>
                        One sample use of this proc is:
                        <literal>::::VMUSBDriverSupport::validList $value 32 32 ::::VMUSBDriverSupport::validInt 0 4095</literal>
                        which ensures that <parameter>value</parameter> is a valid
                        list that contains exactly 32 integer elements in the range
                        <literal>[0..4095]</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>::VMUSBDriverSupport::validIntList <replaceable>value ?fewest ?most ?low ?high????</replaceable>
                </command></term>
                <listitem>
                    <para>
                        This is a convenience procedure that uses <function>validList</function>
                        and <function>validInt</function> to determine if
                        <parameter>value</parameter> is a valid list of
                        integer values with optional range constraints.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><command>::VMUSBDriverSupport::validBoolList <replaceable>value ?fewest ?most???</replaceable>
                </command></term>
                <listitem>
                    <para>
                        This is a convenience procedure that uses <function>validList</function>
                        and <function>validBool</function> to determine if
                        <parameter>value</parameter> is a valid list of
                        boolean values.
                    </para>
                </listitem>
            </varlistentry>
           </variablelist>
        </refsect1>

      </refentry>

      <refentry id="vmusb3-madc">
        <refmeta>
           <refentrytitle>madc</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>madc</refname>
           <refpurpose>Acquire events from Mesytec MADC32 ADC.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
madc create <replaceable>name ?options?</replaceable>              
              </command>
          </cmdsynopsis>
         <cmdsynopsis>
             <command>
madc config <replaceable>name ?options?</replaceable>
             </command>
         </cmdsynopsis>
         <cmdsynopsis>
             <command>
madc cget <replaceable>name</replaceable>         
             </command>
         </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
         
           <title>DESCRIPTION</title>
           <para>
              The <command>madc</command> command provides scripted support
               for the Mesytec 32 channel peak sensing adc module.  For scaler
               support for this module's dead time counters, see the
               <link linkend="vmusb3-madcscaler">madcscaler</link> command.
           </para>
           <para>
               As with all VM-USB module support commands, <command>madc</command>
               is a command ensemble with subcommands that
               <command>create</command> and
               <command>config</command>ure modules as well as
               <command>cget</command> which introspects a module configuration.
           </para>
           <para>
               <command>create</command> creates an object with the specified
               <parameter>name</parameter>. Additional options are treated like
               configuration options.  <command>config</command> configures
               an existing module, and <command>cget</command> returns a list of
               configuration name/value pairs that describe the configuration of
               the module.
           </para>
            <para>
               It is important to note that the module configuration does not
               actually get loaded until the run is initialized.  The order in
               which configuration parameter are supplied is therefore unimportant.
               Think of the configuration options as being accumulated and then
               applied as the run starts.  Only modules that are in
               <command>stack</command> are configured.
            </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
              <varlistentry>
                  <term><option>-base</option> <replaceable>address</replaceable></term>
                  <listitem>
                      <para>
                        <parameter>address</parameter> must be the module base
                        address as configured in its rotary switches.
                        This base address is used to access the module's register
                        and event memory.
                      </para>
                     <para>
                        Each module must be programmed and hardware configured
                        with a different base address. The address used will be
                        an A32 VME address.
                     </para>
                  </listitem>
              </varlistentry>
               <varlistentry>
                  <term><option>-id</option> <replaceable>vsn</replaceable></term>
                  <listitem>
                     <para>
                        <parameter>vsn</parameter> will be used as the module's
                        identifier or <firstterm>virtual slot number</firstterm>.
                        The <parameter>vsn</parameter> will be encoded into the
                        event data that is returned by the module.  This, in turn
                        is normally used by event decoders to determine which parameters
                        the channels of the module should be unpacked into.
                     </para>
                     <para>
                        Each module should be given a unique <parameter>vsn</parameter>.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-ipl</option> <replaceable>irqlevel</replaceable></term>
                  <listitem>
                     <para>
                        If the module will be used to trigger an interrupt driven
                        stack, the <parameter>irqlevel</parameter> parameter must
                        be programmed to a valid non zero interrupt priority level
                        (<literal>1</literal> through <literal>7</literal>).
                        This must match the interrupt priority level used to trigger
                        the stack.
                     </para>
                     <para>
                        The default value of <literal>0</literal> disables module
                        interrupts.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-vector</option> <replaceable>statusId</replaceable></term>
                  <listitem>
                     <para>
                        If the module will be used to trigger an interrupt driven
                        stack, the <parameter>statusId</parameter> must be programmed
                        to a non zero 8 bit status id, or <firstterm>vector</firstterm>
                        (between <literal>1</literal> and <literal>255</literal>
                     </para>
                     <para>
                        The value used must match the value of the
                        <option>-vector</option> configuration parameter used to
                        trigger the stack.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-timestamp</option>  <replaceable>onoff</replaceable></term>
                  <listitem>
                     <para>
                        This option controls whether or not the
                        module tags each event with a trigger number or with a
                        timestamp (see also the
                        <option>-timingsource</option> and
                        <option>-timingdivisor</option> options).
                     </para>
                     <para>
                        The <replaceable>onoff</replaceable> is a boolean value.
                        If true, the module tags events with a timestamp.  If
                        false, with a trigger number.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-gatemode</option>  <replaceable>mode</replaceable></term>
                  <listitem>
                     <para>
                        The MADC32 has a pair of gate inputs.  The inputs may
                        be used either as <literal>separate</literal> gates,
                        where each gate controlls 16 of the 32 channels, or
                        as <literal>common</literal> where either input will
                        gate all 32 channels.
                     </para>
                     <para>
                        The value <parameter>mode</parameter> should be either
                        <literal>separate</literal> or <literal>common</literal>.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-gategenerator</option> <replaceable>onoff</replaceable></term>
                  <listitem>
                     <para>
                        The module can either use the gates as provided or can
                        insert a gate and delay generator between the gate inputs
                        and the actual gates seen by the ADCs.  Since in most cases,
                        gate must be stretched and timed to match the ADC inputs,
                        this feature can reduce the external electronics needed to
                        properly gate the adc.
                     </para>
                     <para>
                        The <parameter>onoff</parameter> is a boolean that if
                        true enables this gate generator, if false, disables it.
                        See also the <option>-holddelays</option> and
                        <option>-holdwidths</option> configuration parameters
                        that control the gate and delay parameters for each of these
                        resources.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-holddelays</option> <replaceable>delayList</replaceable></term>
                  <listitem>
                     <para>
                        If the gate generators are enabled (see
                        <option>-gategenerator</option> above), the
                        <parameter>delayList</parameter> is a Tcl list consisting of
                        the two delay parameters, one for each of the gate and
                        delay generators. See the MADC32 manual for a description of
                        the meaning of these values, which are just the values
                        programmed into the module registers.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-holdwidths</option> <replaceable>widthList</replaceable></term>
                  <listitem>
                     <para>
                        If the gate generators are enabled (see
                        <option>-gategenerator</option> above), the
                        <parameter>widthList</parameter> is a Tcl l ilst
                        consisting of the two gate and delay generator width
                        parameters.  See the MADC32 manual for a description
                        of the meaning of these values, which are just the
                        values programmed into the module registers.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-inputrange</option> <replaceable>rangeSelector</replaceable></term>
                  <listitem>
                     <para>
                        Programs the input range for the module.
                        The <parameter>rangeSelector</parameter> must
                        <literal>4v</literal>, <literal>8v</literal>,
                        or <literal>10v</literal>.  Where the selector
                        represents the input range in volts.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-ecltermination</option> <replaceable>onoff</replaceable></term>
                  <listitem>
                     <para>
                        This parameter when true enables the ECL input termination.
                        If disabled, the termination is off.  If you are bussing
                        the ECL inputs, only the final module in the bus should
                        have terminatinon enabled, all other modules, should
                        have termination turned off.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-ecltiming</option> <replaceable>onoff</replaceable></term>
                  <listitem>
                     <para>
                        This parameter, when true enables tge gate1 ECL input to
                        to be a clock source for the timestamp if true.  If false,
                        The ECL G1 input is an ECL gate1.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-nimtiming</option> <replaceable>onoff</replaceable></term>
                  <listitem>
                     <para>
                        If true, enables the NIM Gate1 input to be a clock source
                        for the timestamp.  If not, the NIM Gate1 input is an adc gate.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-timingsource</option> <replaceable>sourceName</replaceable></term>
                  <listitem>
                     <para>
                        Specifies the source of the clock for timestamps.
                        If <literal>external</literal>, whichever of the NIM or
                        ECL GATE1 inputs are enabled is the clock source.
                        If <literal>vme</literal> the VME 16Mhz backplane
                        clock is the clockk.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-timingdivisor</option> <replaceable>log2</replaceable></term>
                  <listitem>
                     <para>
                        Specifies a scale-down value for the timestamp clock.
                        At the time I'm typing this, this value is log base
                        2 of the scale down, that is
                        the final scale down is 1 &lt;&lt; <parameter>log2</parameter>.
                        By the time we get installed, I am supposed to have
                        some firwmare that will allow this to be a 16 bit
                        direct scaledown (e.g. the scaledown would be between 1 and
                        65535).
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-thresholds</option> <replaceable>valueList</replaceable></term>
                  <listitem>
                     <para>
                        Supplies the per channel thresholds for the adc.
                        Channels which convert below their threshold are suppressed
                        from the data stream reducing both data volume and
                        dead-time.  The <parameter>valueList</parameter> is a
                        32 element Tcl  list of the integer thresholds.
                     </para>
                     <para>
                        Note that at the time I'm typing this, channel thresholds
                        have not yet been implemented in the firmware.
                        The firmware I bring with me at installation time
                        will hopefully implement this feature.
                     </para>
                  </listitem>
               </varlistentry>
               <varlistentry>
                  <term><option>-nimbusy</option> <replaceable>busyselect</replaceable></term>
                  <listitem>
                     <para>
                        This option selects which signal is presented at the
                        NIM busy output lemo connector.  By default, this will
                        be the module busy.  The <parameter>busyselect</parameter> can
                        be any of the following strings:
                     </para>
                     <variablelist>
                        <varlistentry>
                           <term><literal>busy</literal></term>
                           <listitem>
                              <para>The module busy is output.  This is the
                                 default.
                              </para>
                           </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>gate0</literal></term>
                           <listitem>
                              <para>
                                 The Gate0 signal is output. If the internal gate
                                 and delay generator is enabled for Gate0,
                                 the output will be the output of the gate and
                                 delay generator.  This provides a mechanism
                                 to check the gate timing on a scope if you are
                                 using the internal gate and delay generators.
                              </para>
                           </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>gate1</literal></term>
                           <listitem>
                              <para>
                                 The Gate1 signal is output.  If the internal gate
                                 and delay generator is enabled for Gate1,
                                 the output will be the output of the gate and
                                 delay generator.  This provides a mechanism
                                 to check the gate timing on a scope if you are
                                 using the internal gate and delay generators.
                              </para>
                              <para>
                                 It is not clear to me what happens if you are using
                                 module common gates.
                              </para>
                           </listitem>
                        </varlistentry>
                        <varlistentry>
                           <term><literal>cbus</literal></term>
                           <listitem>
                              <para>
                                 The CBUS output is reflected here.
                              </para>
                           </listitem>
                        </varlistentry>
                     </variablelist>
                  </listitem>
               </varlistentry>
	       <varlistentry>
		      <term><option>-multievent</option> <replaceable>boolean</replaceable></term>
		      <listitem>
		         <para>
		            Allows the module to be used in multi-event mode.
			    This is normally done in conjunction with the
			    <command>madcchain</command> configuration command.
			    It also usually requires a custom SpecTcl version
			    to handle the data from this device.
		         </para>
			 <para>
			    the default value for this parameter is
			    <literal>false</literal> which runs the module in
			    single event mode.
		         </para>
		      </listitem>
               </varlistentry>
	       <varlistentry>
	          <term><option>-irqthreshold</option> <replaceable>integer</replaceable></term>
		  <listitem>
		     <para>
		        Sets the interrupt threshold.  When a number of
			complete events have put at least this number of
			longwords in the fifo, if interupts are enabled,
			the module will interrupt.
		      </para>
                    </listitem>
               </varlistentry>
               <varlistentry>
	          <term><option>-resolution</option> <replaceable>2k|4k|4khires|8k|8khires</replaceable></term>
		  <listitem>
		     <para>
		        Sets the resolution of the module.  This has an impact on
			the conversion time. 
		     </para>
                  </listitem>
	       </varlistentry>
            </variablelist>
        </refsect1>

        <refsect1>
           <title>EXAMPLES</title>
           <example>
            <title>Sample use of madc command</title>
            <programlisting>
set madcTimeDivisor 14

madc create adc -base 0x40000000 -id 5 -ipl 0             <co id="madccreate" />
madc config adc -gatemode common -gategenerator disabled
madc config adc -inputrange 8v
madc config adc -timestamp on -timingsource vme -timingdivisor $madcTimeDivisor  <co id="madcsubst" />

for {set i 0} {$i &lt; 32} {incr i} {
    lappend thresholds 0                                 <co id="madcmakethresh" />
}
madc config adc -thresholds $thresholds                  <co id="madcthresholds" />

            </programlisting>
           </example>
            <calloutlist>
               <callout arearefs="madccreate">
                  <para>
                     This command creates an object to manage an MADC 32
                     whose base address is <literal>0x40000000</literal>.
                     The module will be referred to by the symbolic name:
                     <literal>adc</literal>
                  </para>
               </callout>
               <callout arearefs="madcsubst">
                  <para>
                     This line illustrates substitution of a Tcl variable for
                     a parameter value.  Tcl variable substition is textual,
                     so you can also use varibles to hold option names, though
                     that may be  a bit odd.
                  </para>
               </callout>
               <callout arearefs="madcmakethresh">
                  <para>
                     This highlights the fact that the configuration file is
                     really a configuration program.  The loop creates a
                     varaiable named <varname>thresholds</varname> that
                     contains a list of 32 zeroes.  This list will be used
                     to program the <literal>adc</literal> thresholds.
                     Normally these values will neither be zero nor uniform
                     from channel to channel.  It may be best to read them from
                     some external file.
                  </para>
               </callout>
               <callout arearefs="madcthresholds" >
                  <para>
                     This command uses the <varname>thresholds</varname> variable
                     and programs the channel thresholds of the ADC.
                  </para>
               </callout>
            </calloutlist>
        </refsect1>
      
      </refentry>
      <refentry id="vmusb3-madcchain">
         <refmeta>
	    <refentrytitle>madcchain</refentrytitle>
	    <manvolnum>3vmusb</manvolnum>
         </refmeta>
	 <refnamediv>
	    <refname>madcchain</refname>
	    <refpurpose>Support CBLT chains of MADC32 modules.</refpurpose>
         </refnamediv>
	 <refsynopsisdiv>
	    <cmdsynopsis>
	       <command>
madcchain create <replaceable>name</replaceable>
               </command>
           </cmdsynopsis>
	   <cmdsynopsis>
	       <command>
madcchain config <replaceable>name ?options</replaceable>
               </command>
	   </cmdsynopsis>
	   <cmdsynopsis>
	      <command>
madcchain cget <replaceable>name</replaceable>
	      </command>
           </cmdsynopsis>
         </refsynopsisdiv>
	 <refsect1>
	    <title>DESCRIPTION</title>
	    <para>
	       This module creates and configures chains of MADC32 modules.
	       If these modules are, in turn, run in multi-event mode,
	       a specialized SpecTcl will be needed to unpack the data.
	       It is possible, however to use single event mode with
	       CBLT readout and use 'normal' SpecTcl unpacking.
	    </para>
	    <para>
	       The <command>create</command> creates a new MADC32 chain.
	       <replaceable>name</replaceable> will be used to refer to this chain
	       during configuration.  At any time the
	       <command>cget</command> returns the configuration of the chain
	       as a list of parameter-name parameter-value pairs.
	    </para>
	    <para>
	       The <command>config</command> configures an MADC32 chain.
	       A set of option name option value argument pairs should follow
	       the chain name on the commandline.  OPTIONS below descsribes the
	       options and their legal values.
	    </para>
         </refsect1>
	 <refsect1>
	    <title>OPTIONS</title>
	    <para>
	       This section describes the configuration options supported by
	       the <command>cmadcchain</command> command.
	    </para>
	    <variablelist>
	       <varlistentry>
	          <term><option>-cbltaddress</option>  <replaceable>base-address</replaceable></term>
		  <listitem>
		     <para>
		        Defines the base address to which the CBLT reads will be
			directed.  When the modules in the chain are initialized,
			this address will be programmed as the CBLT base address.
			Note that only the top 8 bits of this value are used.
		     </para>
		  </listitem>
	       </varlistentry>
	       <varlistentry>
	          <term><option>-mcastaddress</option> <replaceable>base-address</replaceable></term>
		  <listitem>
		     <para>
		        Defines the base address for the chain's multicast address.
			The multicast address is used to perform synchronous initialization
			and time-stamp clears.  This address will be programmed as the
			MCAST base address for all modules in the chain.
			Only the top 8 bits of the <replaceable>base-address</replaceable>
			have any meaning.
		     </para>
		  </listitem>
               </varlistentry>
	       <varlistentry>
	          <term><option>-maxwordspermodule</option> <replaceable>longword-coun</replaceable></term>
		  <listitem>
		     <para>
		        Defines the maximuim words that can be read from each module.
			This should be a number between
			<literal>1</literal> and <literal>1024</literal>.
			This value should usually be larger than the
			<option>-irqthreshold</option> option programmed into the
			MADC32 modules in the chain.  For each block read, the
			module will return no more data than the complete event that
			causes the number of longwords read from the module to exceed
			this value.
		     </para>
		  </listitem>
	       </varlistentry>
	       <varlistentry>
	          <term><option>-modules</option>  <replaceable>module-name-list</replaceable></term>
		  <listitem>
		     <para>
		        Defines the list of MADC32 modules that make up the chain.
			The value for this option should be a well formulated
			Tcl list containing names of <command>madc</command> modules.
			There is a restriction on the order of these names.  The
			first name in the list must be the leftmost module in the
			crate and the last name must be the right most module in the
			chain. 
		     </para>
		     <para>
		        For practical purposes, to limit confusion, I generally
			enumderate the modules from left (low slot number) to
			right (higher slot number). 
		     </para>
		  </listitem>
	       </varlistentry>
	    </variablelist>
	 </refsect1>
      </refentry>
      <refentry id="vmusb3-madcscaler">
        <refmeta>
           <refentrytitle>madcscaler</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>madcscaler</refname>
           <refpurpose>Support dead-time counters in MADC32 as scalers.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
madcscaler create <replaceable>name ?options?</replaceable>              
              </command>
          </cmdsynopsis>
         <cmdsynopsis>
             <command>
madcscaler config <replaceable>name ?options?</replaceable>
             </command>
         </cmdsynopsis>
         <cmdsynopsis>
             <command>
madcscaler cget <replaceable>name</replaceable>         
             </command>
         </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
              The Mesytec MADC 32 module provides two counters. These counters
              count time and ADC busy time (time between the adc gate and
              readout completion).  Reading these two values as periodic scalers
              in a scaler stack, allows for the computation of dead-time ratios
              without the use of an additional external scaler module..
           </para>
           <para>
               The <command>madcscaler</command> command supports configuring
               MADC32 modules for use as dead-time scalers.
           </para>
           <para>
            The <command>madcscaler</command> command provides the usual
            ensemble of subcommands;
            <command>create</command> to create a named module object,
            <command>config</command> to configure a previously existing object
            by name, and
            <command>cget</command> to obtain the configuration of an existing
            named object.
           </para>
           <para>
             OPTIONS below describes the configuration options.
           </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
              <varlistentry>
                  <term><option>-base</option> <replaceable>baseAddress</replaceable></term>
                  <listitem>
                      <para>
                        Provides the base address of the module as configured
                        in its rotary switches.
                      </para>
                  </listitem>
              </varlistentry>
           </variablelist>
        </refsect1>

      </refentry>

      <refentry id="vmusb3-mase">
	<refmeta>
	   <refentrytitle>mase</refentrytitle>
	   <manvolnum>3vmusb</manvolnum>
	</refmeta>
	<refnamediv>
	   <refname>mase</refname>
	   <refpurpose>Support for XLM with MASE firmware.</refpurpose>
	</refnamediv>
	
	<refsynopsisdiv>
	  <cmdsynopsis>
	      <command>
mase create <replaceable>name ?options?</replaceable>
              </command>
	  </cmdsynopsis>
          <cmdsynopsis>
	     <command>
mase config <replaceable>name ?options?</replaceable>
	     </command>
	  </cmdsynopsis>
	  <cmdsynopsis>
	     <command>
mase cget <replaceable>name</replaceable>
	     </command>
          </cmdsynopsis>
	</refsynopsisdiv>
	<refsect1>
	   <title>DESCRIPTION</title>
	   <para>
	      The <command>mase</command> command allows you to create and configure
	      modules that are XLM-VV FGPA modules with firmware for the
	      Indiana MASE data acqusitiopn subsystem.  Please note that this
	      modules is a block mode device, in the sense that each
	      VM-USB trigger may result in multiple events being present in the
	      XLM memory by the time the VM-USB reads the data.  When used with
	      other modules, you must arrange for event building at some point
	      in the system to ensure that data from the MASE module are coherently
	      assembled with data from other devices.
	   </para>
	   <para>
              The module object is created via the <command>create</command>
	      subcommand.  The <parameter>name</parameter> on this defines
	      a unique name which will be used to refer to this module in
	      future commands directed at it.  The optional options are
	      name value pairs used to configure the module.  See
	      OPTIONS below for a list of the supported options.
	   </para>
	   <para>
	      The <command>config</command> subcommand can be used to set or modify
	      configuration parameters after the module is created.  The
	      <parameter>name</parameter> is the name of the module as defined
	      by the <command>create</command> subcommand.   The options are
	      once more name value pairs that are described in the OPTIONS section
	      below.
	   </para>
	   <para>
	      The <command>cget</command> subcommand is can be used to ask
	      a module about its current configuration.  The module configuration is
	      returned as a Tcl list of name value pairs where the name is the
	      name of a configuration option described in the OPTIONS section
	      and the value is the value of that configuration parameter.
	   </para>
	</refsect1>
	<refsect1>
	   <title>
	      OPTIONS
	   </title>
	   <variablelist>
              <varlistentry>
	         <term><option>-base</option>  <replaceable>base-address</replaceable></term>
		 <listitem>
		    <para>
		       Supplies the base address of the XLM module.  The XLM base
		       address is determined by the slot it occupies in a VME
		       backplane with V430 extensions (V430 supplies additional
		       voltages and the slot location on a middle 'JAUX' connector).
		       The base address must be an unsigned integer.  There is no
		       default value for this configuration option.  The value
		       supplied must match the actual board's base address.
                   </para>
		   <para>
		       The XLM-VV must be used in a V430 backplane as it has no other
		       mechanism for the board to set the base address.
		       For information about the JAUX connector see e.g.
		       <ulink url='http://cdsweb.cern.ch/record/1201456/files/Blanchetti_001.pdf'>
		       http://cdsweb.cern.ch/record/1201456/files/Blanchetti_001.pdf</ulink>
		       Specifically page 10 and page 25 and beyond.
		   </para>
		</listitem>
	      </varlistentry>
	      <varlistentry>
	         <term><option>-firmware</option>  <replaceable>firmware-path</replaceable></term>
		 <listitem>
		    <para>
		       <replaceable>firmware-path</replaceable> provides the path
		       to the XLM firmware file.  In the MASE module, the firmware
		       is loaded prior to the start of a run.  The file path
		       can be relative or absolute, however environment variables
		       and tilde expansions are not performed by the module driver.
		       The Tcl script however may use the <command>file normalilze</command>
		       and the <varname>envname</varname> to perform these substitutions
		       prior to providing the final filename to this option.
		    </para>
		 </listitem>
	      </varlistentry>
	   </variablelist>
	</refsect1>

      </refentry>


<refentry id="vmusb3-tdcv1x90">
  <refmeta>
     <refentrytitle>tdc1x90</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>tdc1x90</refname>
     <refpurpose>Provide support for the CAEN V1x90 TDC family.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
tdc1x90 create name ?options...?
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
    <command>
tdc1x90 config name ?options?
    </command>
</cmdsynopsis>
<cmdsynopsis>
    <command>
tdc1x90 cget name
    </command>
</cmdsynopsis>

  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
	Creates, configures and introspects CAEN V1x90 TDCs.  These modules
        are only supported in trigger matching mode.  Note that the trigger
        time is only good to the FPGA clock, to get precise trigger relative
        timing you will need to also digitize the trigger itself.  SpecTcl
        supports doing a digital subtraction of the trigger channel from
        all other channels to get precise trigger relative timing.
     </para>
     <para>
         The <command>create</command> subcommand creates a new TDC named
         <parameter>name</parameter> the <parameter>options...</parameter> optional
         parameter are configuration option value pairs as described in
         OPTIONS below.
         The <command>config</command> subcommand locates the TDC named
         <parameter>name</parameter> and further configures it via the
         options described in OPTIONS below.
     </para>
      <para>
         The <command>cget</command> subcommand returns as a value the module
         configuration.  The configurationis returned as a list.  Each element
         of the list is a two element sublist consisting of the configuration
         option name and its current value.
      </para>
  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	<varlistentry>
	    <term><option>-base</option> <replaceable>base-address</replaceable></term>
	    <listitem>
		<para>
                  provides the module base address as set by the rotary switches
                  on the board.
		</para>
	    </listitem>
	</varlistentry>
        <varlistentry>
         <term><option>-vsn</option> <replaceable>geo</replaceable></term>
         <listitem>
            <para>
               Provides the virtual slot number. This value will appear in the
               data from the module in the GEO field.  The <parameter>geo</parameter>
               value must be between 0 and 31 inclusive.
            </para>
         </listitem>
       </varlistentry>
       <varlistentry>
        <term><option>-ipl <replaceable>n</replaceable></option></term>
        <listitem>
            <para>
                Sets the interrupt priority level when using the device interrupts.
                If this is 0 interrupts are disabled.  Legal value are between
                0 and 7 inclusive.  See the <option>-vector</option> switch
                as well.  This defaults to 0.
            </para>
        </listitem>
       </varlistentry>
        <varlistentry>
            <term><option>-vector</option> <replaceable>nnn</replaceable></term>
            <listitem>
                <para>
                    Sets the interrrupt status id value for the module if
                    used in interrupt mode.  If this is 0, interrupts are disabled.
                    See <option>-ipl</option> as well.  This defaults to 0.
                    The values must be integers in the range 0 - 255 inclusive.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-termination</option> <replaceable>none|switch|on</replaceable></term>
            <listitem>
                <para>
                    Sets the module termination.  The value can be any of the
                    following:
                    <variablelist>
                    <varlistentry>
                       <term><literal>none</literal></term>
                       <listitem>
                       <para>
                          No termination will be supplied by the module.
                       </para>
                       </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>switch</literal></term>
                       <listitem>
                       <para>
                          Termination will be controlled by switches in the module
                       </para>
                       </listitem>
                    </varlistentry>
                    <varlistentry>
                       <term><literal>on</literal></term>
                       <listitem>
                          <para>
                          Termination is enabled.
                          </para>
                       </listitem>
                    </varlistentry>
                    </variablelist>
                    The default is <literal>on</literal>
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-tagtime</option> <replaceable>on|off</replaceable></term>
            <listitem>
                <para>
                    Controls wehther or not the trigger time will be inlcuded
                    in the data.  Note that the trigger time is only accurate
                    to within one tick of the 80Mhz FPGA clock.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-highwatermark</option> <replaceable>n</replaceable></term>
            <listitem>
            <para>
                Determines the numbger of events that must be buffered by the TDC
                to generate an interrupt.  The vale must be an integer in the range
                0..65535 inclusive.  The default value 1, means an interrupt is
                generated whenever there is at least one event in the TDC and
                the TDC interrupts are enabled.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-ecloutput</option> <replaceable>ready|full|almostfull|error</replaceable></term>
            <listitem>
            <para>
                Determines which signal is presented at the programmable ECL
                output pins.  See the CAEN V1190/1290 manuals for information about
                the possible values.  The default is <literal>ready</literal>
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-window</option> <replaceable>n</replaceable></term>
            <listitem>
            <para>
              The width of the trigger matching window in 25ns units.
              This is sets the effective range of the TDC when simulating
              a common stop or common start TDC. See also <option>-offset</option>,
              <option>-extramargin</option> and <option>-rejectmargin</option>
              and see the section of the TDC manual that describes trigger matching
              mode.  The default value is 40 which corresponds to a 1usec
              matching window.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-offset</option> <replaceable>n</replaceable></term>
            <listitem>
            <para>
                Determines when the trigger matching window starts relative
                to the gate.  A positive offset starts the match window after the
                gate while a negative offset starts the match window prior to the
                gate.  The values are integers and are in 25ns units.  See
                section 2.4.1 for additional constraints.  Note that the actual
                window start time will jitter by +/-25ns, and therefore you should
                use a reference channel to get good gate relative timing.
                Values must be in the range -2048 to 40 inclusive...
                Defaults to -40 or 1usec prior to the gate.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-extramargin</option> <replaceable>n</replaceable></term>
            <listitem>
            <para>
                The extra search margin for hits.  This is the addtional
                time during after the matching window during which the module
                will search for hits that
                are within the window before declaring the event.  
                This is needed because hits are searched for in the
                module's L1 buffer. Contention may prevent matching hits
                from being written to the L1 buffer for some time after
                they have actually occured.  See 2.4.1 in the manual.
                The units of this value are also 25ns.
                Defaults to  8 which is 200ns.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-rejectmargin</option> <replaceable>n</replaceable></term>
            <listitem>
            <para>
                 The reject margin.  This is also in 25ns units.  While
                 the module is in continuous storage, it maintains a reject
                counter that flushes hits from the buffer when the
                trigger window is not active.  The module will only
                retain hits for the width of the trigger 
                window + offset + reject marjin before throwing them away
                if there is no trigger.  This ensures the TDC buffer does
                not overflow and that the search for matching hits on the
                trigger is rapid.  
                Defaults to 4 which is 100ns.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-triggerrelative</option> <replaceable>enabled|disabled</replaceable></term>
            <listitem>
            <para>
                 If enabled, the trigger time is subtracted from all the
                hits.  Note again that the trigger time is 
                only precise to 25ns. Precise timing relative to the trigger
                can only be done by subtracting a digitized trigger time
                from the hits.
                Defaults to  <literal>enabled</literal>
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-edgedetect</option> <replaceable>pair | leading | trailing | both</replaceable></term>
            <listitem>
            <para>
                Sets the module edge detect mode.   Figure 2.2 provides
                trailing, both}  documentation about what this means;
                'pair' provides the width of a pulse in a 
                channel, 'leading' provides a hit time at the leading
                edge of a pulse, 'trailing' provides a hit time at the
                trailing edge of an input pulse, and 'both' provides
                the time of both the leading and trailing edges of a pulse
                Defaults to  <literal>leading</literal>.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-edgeresolution</option> <replaceable>800ps | 200ps | 100sp | 25ps </replaceable></term>
            <listitem>
            <para>
                 Selects the resolution for the leading/trailing resolution.
                 It is an error to use 25ps if the module is not a V1290
                Defaults to  <literal>100ps</literal>
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-leresolution</option> <replaceable>100ps | 200ps | 400ps
            | 800ps | 1.6ns | 3.12ns | 6.25ns | 12.5ns </replaceable></term>
            <listitem>
            <para>
                 In leading, trailing and both mode, sets the resolution
                 with which the leading edge is detected.  
                 Defaults to: <literal>100ps</literal>.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-widthresolution</option> <replaceable>
            100ps | 200ps | 400ops | 800ps | 1.6ns | 3.2ns | 6.25ns | 12.5ns | 400ns | 800ns </replaceable> </term>
            <listitem>
            <para>
                 Sets the resolution with which a pulse width is
                 measured in pair mode. 
                 defaults to <literal>100ps</literal>
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-deadtime</option> <replaceable>
            5ns | 10ns | 30ns | Sets 
                  100ns</replaceable></term>
            <listitem>
            <para>
                the double hit resolution. Defaults to <literal>5ns</literal>
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-encapsulatechip</option> <replaceable>true | false </replaceable></term>
            <listitem>
            <para>
                If true, the data from a chip is encapsulated as shown
                in figures 6.2/6.4 by a TDC Chip header/trailer.
                default <literal>enabled</literal>
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-maxhits</option> <replaceable>
            0 | 1 |  2 |  4 |  8 |
                 16 | 32 | 64 | 128 | infinite</replaceable></term>  
            <listitem>
            <para>
                     Specifies the maximum number of hits for each TDC chip
                     in an event.  Note that a TDC chip has 32 channels.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-errormark</option> <replaceable>true | false </replaceable></term>
            <listitem>
            <para>
                 If true, when an error is detected, an error mark item
                is placed in the output buffer. Figure 6.5 describes the
                format of this item.
                Defaults to  <literal>true</literal>
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-errorbypass</option> <replaceable>on | off</replaceable></term>
            <listitem>
            <para>
                If enabled, a TDC that reports an error will not be
                read out for that event.
                Default: <literal>on</literal>
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-globaloffset</option> <replaceable>{n m}</replaceable></term>
            <listitem>
            <para>
                Provides the global offset/vernier offset.
                Default: <literal>{0 0}</literal>
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-channeladjusts</option></term>
            <listitem>
            <para>
                 Arbitary number of elements that can adjust
                the value of individual channels by adding a positive
                offset to them.  The value of this is a list of two element
                lists where each element consist of a channel number and
                its offset. e.g. {{10 6} {32 5}}  sets the channel
                offsets for channel 10 to 6 and for channel 32 to 5.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-refchannel</option> <replaceable>n</replaceable></term>
            <listitem>
            <para>
                Sets the reference channel.  The value of this channel
                is subtracted from all other channels to produce
                high precision times.  Defaults to <literal>0</literal>.
                This option is only used by SpecTcl and does not influence
                the way the TDC is initialized or read.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-depth</option> <replaceable>n</replaceable></term>
            <listitem>
            <para>
                Sets the number of hits to retain for each channel
                for the purposes of histogramming.
                Defaults to <literal>16</literal>. This option is only
                processed by SpecTcl.  It setting does not influence the setup
                or readout of the TDC.  Note however that setting this value
                larger than the value of <option>-maxhits</option> is probably
                not very useful.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><option>-channelcount</option> <replaceable>n</replaceable></term>
            <listitem>
            <para>
                Sets the number of channels the model of the TDC being used has.
                This is only used to setup SpecTcl's histogramming.
                The value should be one  of 16, 32, 64, or 128, however
                this is not checked by the processing code for this option.
            </para>
            </listitem>
        </varlistentry>
     </variablelist>
  </refsect1>
  <refsect1>
     <title>METHODS</title>
     <variablelist>
	<varlistentry>
	    <term><command>create <replaceable>name base</replaceable></command></term>
	    <listitem>
		<para>
                    Creates a new instance of a CAEN multihit TDC from the
                    V1x90 family of digitizers.
                    <parameter>name</parameter> is used to refer to this module
                    from now on.
                    The 
                    <parameter>base</parameter> sets the base address of the
                    module.
		</para>
	    </listitem>
	</varlistentry>
        <varlistentry>
            <term><command>config <replaceable>name options</replaceable></command></term>
            <listitem>
            <para>
                Configures an existing TDC <parameter>name</parameter>
                <parameter>options</parameter> are option name value pairs described
                above.
            </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term><command>cget <replaceable>name</replaceable></command></term>
            <listitem>
            <para>
                Returns the module <parameter>name</parameter>'s configuration
                as a list of name value pairs.
            </para>
            </listitem>
        </varlistentry>
     </variablelist>
  </refsect1>
  <refsect1>
     <title>EXAMPLES</title>
     <para>
     </para>
  </refsect1>

</refentry>
        <refentry id="vmusb3-v1729a">
          <refmeta>
             <refentrytitle>v1729a</refentrytitle>
             <manvolnum>3vmusb</manvolnum>
          </refmeta>
          <refnamediv>
             <refname>v1729a</refname>
             <refpurpose>CAENV1729a waveform digitizer.</refpurpose>
          </refnamediv>
          
          <refsynopsisdiv>
            <cmdsynopsis>
                <command>
v1729a create <replaceable>name base</replaceable>
            </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
v1729a config <replaceable>name options</replaceable>
            </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
v1729a cget <replaceable>name</replaceable>
            </command>
            </cmdsynopsis>
      
          </refsynopsisdiv>
          <refsect1>
             <title>DESCRIPTION</title>
             <para>
                This command ensemble provides access to the CAEN V1729A
                waveform digitizer.  The three subcommands allow creation
                configuration and introspection.  See METHODS below for more
                information about these subcommands and their formats.
             </para>
             <para>
                The options described in OPTIONS below allow data taking
                and analysis to be configured according the needs of the
                application.
             </para>
          </refsect1>
          <refsect1>
             <title>
                OPTIONS
             </title>
             <variablelist>
                <varlistentry>
                <term><option>-base</option> <replaceable>base</replaceable></term>
                <listitem>
                <para>
                    Provides the module base address.  The <parameter>base</parameter>
                    must match the base address set in the rotary switches
                    of the module.
                </para>
                </listitem>
             </varlistentry>
             <varlistentry>
                <term><option>-threshold</option> <replaceable>n</replaceable></term>
                <listitem>
                <para>
                     Threshold for internal trigger.  The default value is
                     <literal>4095</literal>
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-pretrigger</option> <replaceable>n</replaceable></term>
                <listitem>
                <para>
                    Pretrigger time in samples.  Defaults to
                    <literal>10240</literal>
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-posttrigger</option> <replaceable>n</replaceable></term>
                <listitem>
                <para>
                    Post trigger time in samples.
                    Defaults to <literal>64</literal>
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-triggersource</option>
                <replaceable>external | internal | both</replaceable></term>
                <listitem>
                <para>
                    Specifies trigger source: his can also be 'internal', or 'both'.
                    Defaults to <literal>external</literal>
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-triggeredge</option> <replaceable>rising | falling</replaceable></term>
                <listitem>
                <para>
                    Specifies which edge of the trigger is used.
                    Default is <literal>rising</literal>
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-triggermask</option> <replaceable>on | off</replaceable></term>
                <listitem>
                <para>
                     Specifies whether the trigger is masked via the EXT_EN_TRIGGER
                    if this is 'on' EXT_EN_TRIGGER is required to enable triggers
                    to fire.  Defaults to <literal>off</literal>.
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-triggerchannels</option> <replaceable>n</replaceable></term>
                <listitem>
                <para>
                    Only used if internal triggers are allowed.  Set one bit for each
                    channel from which triggers are allowed.
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-poststoplatency</option> <replaceable> n</replaceable></term>
                <listitem>
                <para>
                    Sets the post trigger latency register in samples.
                    Defaults to <literal>4</literal>
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-postlatencypretrig</option> <replaceable>n</replaceable></term>
                <listitem>
                <para>
                    Sets the value of the post latency pretrigger register.
                    Defaults to <literal>1</literal>
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-samplingfreq</option>
                <replaceable>2ghz | 1gzh | 500mhz</replaceable></term>
                <listitem>
                <para>
                     Sampling frequency.  Default value is
                     <literal>2ghz</literal>
                </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-delay</option> <replaceable>n</replaceable></term>
                <listitem>
                <para>
                     uSec to delay prior to executing the readout.
                    this can be set to zero if the modle interrupt is 
                    used to trigger the data acquisition else it should be set
                    to on the order of 700usec depending on triggering parameters.
                    650usec from end of the signal are required to transfer data.
                    the remaining time depends on the time of the computer trigger
                    relative to the time of the signal end.
                    When setting this recall that the module requires 650usec
                    to digitize and transfer data from the analog memory to
                    the readout memory.
                </para>
                </listitem>
            </varlistentry>

            </variablelist>
            </refsect1>
            <refsect1>
                <title>METHODS</title>
                <para>
                    Subcommands recognized by this module are:
                </para>
                <variablelist>
                    <varlistentry>
                        <term>create <replaceable>name base</replaceable></term>
                        <listitem>
                        <para>
                            Creates a new module that can be referred to by
                            <parameter>name</parameter>.  <parameter>base</parameter>
                            is the module base address. This can be overidden
                            by the <option>-base</option> configuration
                            parameter.
                        </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>config <replaceable>name options</replaceable></term>
                        <listitem>
                        <para>
                            Configures the module <parameter>name</parameter>.
                            The <parameter>optinos</parameter> are configuration
                            option value pairs described inthe OPTIONS
                            section above.
                        </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>cget <replaceable>name</replaceable></term>
                        <listitem>
                        <para>
                            Retrieves the module configuration as a list
                            of name value pairs.
                        </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
          </refsect1>
  
        </refentry>

      <refentry id="vmusb3-stack">
        <refmeta>
           <refentrytitle>stack</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>stack</refname>
           <refpurpose>Compose and configure VM-USB readout stacks.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
      	<command>
stack create <replaceable>name</replaceable>
      	</command>
          </cmdsynopsis>
             <cmdsynopsis>
                 <command>
stack config <replaceable>name option value...</replaceable>
                 </command>
             </cmdsynopsis>
             <cmdsynopsis>
                 <command>
stack cget <replaceable>name</replaceable>
                 </command>
             </cmdsynopsis>
         
        </refsynopsisdiv>        

        <refsect1>
    
           <title>DESCRIPTION</title>
           <para>
               The VM-USB supports eight readout <firstterm>stacks</firstterm>.
               A stack can be thought of as a set of VME operations the
               VM-USB should perform in response to some trigger condition.
               Reads performed by a stack are placed in an event buffer. Writes
               occure but result in no data.  At appropriate times, the VM-USB
               transmits buffers of read events to the host computer over its USB
               interface. Stacks provide avoid the high latency of the USB bus
               by pushing the readout intelligence for events into the VM-USB, and
               out of the host.
           </para>
           <para>
               The VM-USB supports 8 stacks, and  three kinds of triggers for stacks.
               While all stacks can be
               interrupt triggered, we simplify the VM-USB usage by only allowing
               stacks 2-7 to accept interrupt triggers, defining stack 0 to be
               only triggerable on the <literal>NIM1</literal> input, and stack
               1 to only be triggered with some time periodicity.
           </para>
            <para>
               The <command>stack</command> command allows you to compose stacks
               and specify their trigger conditions.  When data taking is
               enabled, all defined stacks are loaded into the VM-USB and
               their triggers set up.  Stacks are composed by specifying the
               set of modules they should read via the <option>-modules</option>
               configuration option.  All modules in a stack are initialized
               at stack load time and read when the stack is triggered, in the
               order in which they were specified.
            </para>
            <para>
               The <command>create</command> subcommand creates a stack named
               <parameter>name </parameter>.  <parameter>name</parameter>
               will be used by you in future <command>config</command> and
               <command>cget</command> subcommands to refer to this stack.
            </para>
            <para>
               The <command>config</command> subcommand allows you to configure
               the stack contents and trigger conditions of the stack.
               <parameter>name</parameter> determines which stack will be configured.
               The configuration is specified via a set of <replaceable>option value</replaceable>
               pairs.  These are described in OPTIONS below.
            </para>
            <para>
               The <command>cget</command> command returns the configuration of
               the stack as a well formed Tcl list of <replaceable>option value</replaceable>
               pairs.
            </para>
        </refsect1>
        <refsect1>
           <title>
      	OPTIONS
           </title>
           <variablelist>
      	<varlistentry>
      	    <term><option>-trigger</option> <replaceable>nim1 | scaler | interrupt</replaceable></term>
      	    <listitem>
      		<para>
                  Defines the strigger source for the stack.  When the designated
                  trigger is present, the stack will execute.
                  <literal>nim1</literal> triggers the stack on a nim logic true pulse
                  to the IN1 input of the VM-USB.  This forces the stack to be 
                  VM-USB stack number zero as that is the only stack that can be
                  triggered by the IN1.
      		</para>
                <para>
                  <literal>scaler</literal>
                  triggers the stack on the periodic scaler.  This forces the stack
                  to be stack number 1 as that is the only peridically triggerable stack.
                  We restrict periodic triggers to time based periodicity rather than
                  event division periodicity.  The <option>-period</option> option
                  defined below must be configured as well to define the periodicity
                  of the scaler stack.
                </para>
                <para>
                  <literal>interrupt</literal>
                  indicates the stack will be interrupt triggered. This can be
                  used for stacks 2 through 7 as defined by the <option>-stack</option>
                  configuration parameter.   The actual VME interrupt that will trigger
                  the stack is defined by both its interrupt priority level
                  <option>-ipl</option> and the status id the interrupt source
                  places on the backplane in response to the interrupt acknowledge
                  cycle, and specified with the <option>-vector</option> configuration
                  parameter.
                </para>
      	    </listitem>
      	</varlistentry>
         <varlistentry>
            <term><option>-period</option> <replaceable>seconds</replaceable></term>
            <listitem>
               <para>
                  Defines the number of seconds (integer) between scaler stack triggers.
                  This is ignored for all stacks that are not <literal>scaler</literal>
                  <option>-trigger</option>-ed.  The VM-USB manual defines the range of legal
                  values for this option.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><option>-stack</option> <replaceable>stacknum</replaceable></term>
            <listitem>
               <para>
                  Defines the stack number for <literal>interrupt</literal>
                  <option>-trigger</option>-ed stacks.  This is an integer value
                  in the range 2-7 inclusive. This will also select the
                  interrupt register used to define the trigger for the stack.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><option>-vector</option> <replaceable>status-id</replaceable></term>
            <listitem>
               <para>
                  For <literal>interrupt</literal> <option>-trigger</option>-ed
                  stacks, this defines the status Id that must be presented by
                  the interrupt source in response to an interrupt acknowledge
                  to trigger the list.  This taken together with the value of the
                  <option>-ipl</option> configuration option defines the trigger
                  condition for these stacks. The <parameter>status-id</parameter>
                  must be a value between 0 and 255.
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><option>-ipl</option> <replaceable>priority</replaceable></term>
            <listitem>
               <para>
                  Defines the interrupt priority level that of the interrupt
                  that will trigger the stack.  An iterrupter places a 3 bit
                  interrupt priority level (IPL) on the VME bus when it requests
                  an interrupt.  The IPL must be nonzero and is intended to reflect
                  the priority of the interrupt (7 highest, 1 lowest), although, in fact,
                  the VME standard allows interrupt responders to treat this value
                  in any way they want.
               </para>
               <para>
                  The VM-USB uses the specified <parameter>priority</parameter> as
                  part of the trigger condition for an <literal>interrupt</literal>
                  <option>-trigger</option>-ed stack.  When an acknowledged interrupt
                  matches both the <option>-ipl</option>, and the <option>-vector</option>
                  configuration parameters of a stack the stack is triggered.
                                                </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><option>-delay</option> <replaceable>microseconds</replaceable></term>
            <listitem>
               <para>
                  The VM-USB allows you to define a delay between the stack trigger condition
                  and the actual start of stack execution.  This is normally intended to be used
                  with stacks that are triggered on <literal>nim1</literal>, as there may be
                  a significant time between the generation of an external trigger and the
                  conversion of the digitizers associated with the trigger.  As I read the
                  VM-USB manual, however this delay applies to <emphasis>all</emphasis> stacks.
               </para>
               <para>
                  The <parameter>microseconds</parameter> is the number of microseconds to delay
                  (0-255) between triggers and stack executions.  Because of my understanding of the
                  <emphasis>intent</emphasis> of this delay, the <option>-delay</option> option
                  is ignored for all stacks that are not <literal>nim1</literal>
                  <option>-trigger</option>-ed.
               </para>
               <para>
                  In the very unlikely event that you need to apply a trigger delay
                  to interrupt triggered stacks (most hardware interrupts when data
                  are ready not on a trigger), and you are not using <literal>nim1</literal>
                  triggered stacks, simply build a non-empty <literal>nim1</literal> triggered
                  stack, set it's
                  <option>-delay</option> option to the required delay and never trigger
                  that stack (don't cable anything to the IN1 input).
               </para>
            </listitem>
         </varlistentry>
         <varlistentry>
            <term><option>-modules</option>  <replaceable>module-list</replaceable></term>
            <listitem>
               <para>
                  Defines the set of modules that will be read out. This can be
                  a valid Tcl list of any set of modules that have been defined
                  so far.  The modules are specified in the order in which readout
                  commands for them will be added to the stack.  If you have
                  built a <command>caenchain</command> add that to the stack rather
                  than adding the individual modules.
               </para>
               <para>
                  Lists of modules must be valid Tcl lists thus:
                  <programlisting>
stack config astack -modules adc1 adc2 adc3  ;      # Incorrect
stack config astack -modules [list adc1 adc2 adc3]; # Correct.
                  </programlisting>
               </para>
            </listitem>
         </varlistentry>
           </variablelist>
        </refsect1>
        <refsect1>
           <title>EXAMPLES</title>
           <para>
               The example below is a rather complete demonstration of how to
               define a set of modules, adc's and scalers, aggregate the
               three adc's into a caenchain, and read that chain as a stack
               triggered on NIM1, and read a pair of scalers triggered every two seconds.
           </para>
           <example>
            <title>Building Stacks</title>
            <programlisting>
adc create adc1    0x04000000
adc config adc1    -geo 12 -supressrange off  -ipl 0 -vector 0

adc create adc2    0x05000000
adc config adc2    -geo 13 -supressrange off  -ipl 0 -vector 0

adc create adc3    0x06000000
adc config adc3    -geo 14 -supressrange off -ipl 0 -vector 0


caenchain create chain

caenchain config chain -base 0x10000000 -modules [list adc1 adc2 adc3]


sis3820 create scaler1 0x35000000
v830    create scaler2 0x80000000
sis3804 create scaler3 -base 0x38383800



stack create events
stack config events -trigger nim1   -modules chain -delay 12

set scalers [list scaler1 scaler2 scaler3]


stack create scalers


stack config scalers -trigger scaler -modules $scalers -period 2

            </programlisting>
           </example>
        </refsect1>

      </refentry>
      
	 <refentry id="vmusb3-CVMUSB">
       <refmeta>
          <refentrytitle id='vmusb3-CVMUSB-title'>CVMUSB</refentrytitle>
          <manvolnum>3vmusb</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CVMUSB</refname>
          <refpurpose>Interface with VM-USB controller.</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>
        #include &lt;CVMUSB.h&gt;

        class <ooclass><classname>CVMUSB</classname></ooclass> {
        
        <methodsynopsis>
          <modifier>static </modifier>
          <type>std::vector&lt;struct usb_device*&gt;</type>
          <methodname>enumerate</methodname>
          <void />
        </methodsynopsis>
        <methodsynopsis>
            <modifier>static</modifier> <type>std::string</type>
            <methodname>serialNo</methodname>
            <methodparam>
                <type>usb_device*</type> <parameter>dev</parameter>
            </methodparam>
        </methodsynopsis>
        <constructorsynopsis>
           <methodname>CVMUSB</methodname>
           <methodparam>
                <type>struct usb_device*</type> <parameter>vmUsbDevice</parameter>
           </methodparam>
        </constructorsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeActionRegister</methodname>
            <methodparam>
                <type>uint16_t</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>readFirmwareID</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeGlobalMode</methodname>
            <methodparam>
                <type>uint16_t</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint16_t</type> <methodname>readGlobalMode</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeDAQSettings</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type>
            <methodname>readDAQSettings</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeLEDSource</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>readLEDSource</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeDeviceSource</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>readDeviceSource</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeDGG_A</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>readDGG_A</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeDGG_B</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>readDGG_B</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeDGG_Extended</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>readDGG_Extended</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>readScalerA</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>readScalerB</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeVector</methodname>
            <methodparam>
                <type>int</type> <parameter>which</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>readVector</methodname>
            <methodparam>
                <type>int</type> <parameter>which</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeIrqMask</methodname>
            <methodparam>
                <type>uint8_t</type> <parameter>mask</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint8_t</type> <methodname>readIrqMask</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>writeBulkXferSetup</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>uint32_t</type> <methodname>readBulkXferSetup</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeWrite32</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>aModifier</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>data</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeRead32</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_tM</type> <parameter>aModifier</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t*</type> <parameter>data</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeWrite16</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>aModifier</parameter>
            </methodparam>
            <methodparam>
                <type>uint16_t</type> <parameter>data</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeRead16</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>aModifier</parameter>
            </methodparam>
            <methodparam>
                <type>uint16_t*M</type> <parameter>data</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeWrite8</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>aModifier</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>data</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeRead8</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>aModifier</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t*</type> <parameter>data</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeBlockRead</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>baseAddress</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>aModifier</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>data</parameter>
            </methodparam>
            <methodparam>
                <type>size_t</type> <parameter>transferCount</parameter>
            </methodparam>
            <methodparam>
                <type>size_t*</type> <parameter>countTransferred</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeFifoRead</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>int8_t</type> <parameter>aModifier</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>data</parameter>
            </methodparam>
            <methodparam>
                <type>size_t</type> <parameter>transferCount</parameter>
            </methodparam>
            <methodparam>
                <type>size_t*</type> <parameter>countTransferred</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeReadBlockCount8</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>mask</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeReadBlockCount16</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>mask</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeReadBlockCount32</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>addressM</parameter>
            </methodparam>
            <methodparam>
                <type>uint32_t</type> <parameter>mask</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeVariableBlockRead</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>data</parameter>
            </methodparam>
            <methodparam>
                <type>size_t</type> <parameter>maxCount</parameter>
            </methodparam>
            <methodparam>
                <type>size_t*</type> <parameter>countTransferred</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>vmeVariableFifoRead</methodname>
            <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
            </methodparam>
            <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>data</parameter>
            </methodparam>
            <methodparam>
                <type>size_t</type> <parameter>maxCount</parameter>
            </methodparam>
            <methodparam>
                <type>size_t*</type> <parameter>countTransferred</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>executeList</methodname>
            <methodparam>
                <type>CVMUSBReadoutList&amp;</type> <parameter>list</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>pReadBuffer</parameter>
            </methodparam>
            <methodparam>
                <type>size_t</type> <parameter>readBufferSize</parameter>
            </methodparam>
            <methodparam>
                <type>size_t*</type> <parameter>bytesRead</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>loadList</methodname>
            <methodparam>
                <type>uint8_t</type> <parameter>listNumber</parameter>
            </methodparam>
            <methodparam>
                <type>CVMUSBReadoutList&amp;</type> <parameter>list</parameter>
            </methodparam>
            <methodparam>
                <type>off_t</type> <parameter>listOffset</parameter>
                <initializer> 0</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>usbRead</methodname>
            <methodparam>
                <type>void*</type> <parameter>data</parameter>
            </methodparam>
            <methodparam>
                <type>size_t</type> <parameter>bufferSize</parameter>
            </methodparam>
            <methodparam>
                <type>size_t*</type> <parameter>transferCount</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>timeout</parameter>
                <initializer>2000</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>setDefaultTimeout</methodname>
            <methodparam>
                <type>int</type> <parameter>ms</parameter>
            </methodparam>
        </methodsynopsis>
        
        class <ooclass><classname>CVMUSB::RegisterOffsets</classname></ooclass>  {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>FIDRegister</varname> <initializer>0</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>GMODERegister</varname> <initializer>4</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>DAQSetRegister</varname><initializer>8</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>LEDSrcRegister</varname><initializer>0xc</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>DEVSrcRegister</varname><initializer>0x10</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>DGGARegister</varname><initializer>0x14</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>DGGBRegister</varname><initializer>0x18</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>ScalerA</varname><initializer>0x1c</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>ScalerB</varname><initializer>0x20</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>ExtractMask</varname><initializer>0x24</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>ISV12</varname><initializer>0x28</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>ISV34</varname><initializer>0x2c</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>ISV56</varname><initializer>0x30</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>ISV78</varname><initializer>0x34</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>DGGExtended</varname><initializer>0x38</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>USBSetup</varname><initializer>0x3c</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>USBVHIGH1</varname><initializer>0x40</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>unsigned int</type>
            <varname>USBVHIGH2</varname><initializer>0x44</initializer>
        </fieldsynopsis>

        };
        class <ooclass><classname>CVMUSB::ActionRegister</classname></ooclass> {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>startDAQ</varname><initializer>1</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>usbTrigger</varname><initializer>2</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>clear</varname><initializer>4</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>sysReset</varname><initializer>8</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>scalerDump</varname><initializer>0x10</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>triggerL0</varname><initializer>0x100</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>triggerL1</varname><initializer>0x200</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>triggerL2</varname><initializer>0x400</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>triggerL3</varname><initializer>0x800</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>triggerL4</varname><initializer>0x1000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>triggerL5</varname><initializer>0x2000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>triggerL6</varname><initializer>0x4000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint16_t</type>
            <varname>triggerL7</varname><initializer>0x8000</initializer>
        </fieldsynopsis>
    };
    class <ooclass><classname>CVMUSB::FirmwareRegister</classname></ooclass> {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>minorRevMask</varname><initializer>0x000000ff</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>minorRevShift</varname><initializer>0</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>majorRevMask</varname><initializer>0x0000ff00M</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>majorRevShift</varname><initializer>8</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>betaVersionMask</varname><initializer>0x00ff0000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>betaVersionShift</varname><initializer>16</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>yearMask</varname><initializer>0x0f000000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>yearShift</varname><initializer>24</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>monthMask</varname><initializer>0xf0000000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>monthshift</varname><initializer>27</initializer>
        </fieldsynopsis>
    };
    class <ooclass><classname>CVMUSB::GlobalModeRegister</classname></ooclass> {
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLenMask</varname><initializer>0xf</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLenShift</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLen13K</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLen8K</varname><initializer>1</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLen4K</varname><initializer>2</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLen2K</varname><initializer>3</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLen1K</varname><initializer>4</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLen512</varname><initializer>5</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLen256</varname><initializer>6</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLen128</varname><initializer>7</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLen64</varname><initializer>8</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>bufferLenSingle</varname><initializer>9</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>spanBuffers</varname><initializer>0x10</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>mixedBuffers</varname><initializer>0x20</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>doubleSeparator</varname><initializer>0x40</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>align32</varname><initializer>0x80</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>doubleHeader</varname><initializer>0x100</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>flushScalers</varname><initializer>0x200</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>busReqLevelMask</varname><initializer>0x7000</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint16_t</type>
        <varname>busReqLevelShift</varname><initializer>12</initializer>
    </fieldsynopsis>
    };
    class <ooclass><classname>CVMUSB::DAQSettingsRegister</classname></ooclass> {
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>readoutTriggerDelayMask</varname><initializer>0xff</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>readoutTriggerDelayShift</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerReadoutPeriodMask</varname><initializer>0xff00</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>>uint32_t</type>
        <varname>scalerReadoutPeriodShift</varname><initializer>8</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerReadoutFrequenyMask</varname><initializer>0xffff0000</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerReadoutFrequencyShift</varname><initializer>16</initializer>
    </fieldsynopsis>
    };
    class <ooclass><classname>CVMUSB::LedSourceRegister</classname></ooclass> {
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>topYellowOutFifoNotEmpty</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>topYellowInFifoNotEmpty</varname><initializer>1</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>topYellowScalerEvent</varname><initializer>2</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>topYellowInFifoFull</varname><initializer>3</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>topYellowDTACK</varname><initializer>4</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>topYellowBERR</varname><initializer>5</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>topYellowBusRequest</varname><initializer>6</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>topYellowBusGranted</varname><initializer>7</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>topYellowInvert</varname><initializer>0x8</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>topYellowLatch</varname><initializer>0x10</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>redEventTrigger</varname><initializer>(0 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>redNimInput1</varname><initializer>(1 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>redNimInput2</varname><initializer>(2 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>redBusyM</varname><initializer>(3 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>redDTACK</varname><initializer>(4 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>redBERR</varname><initializer>(5 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>redBusRequest</varname><initializer>(6 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>redBusGranted</varname><initializer>(7 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>redInvert</varname><initializer>(8 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>redLatch</varname><initializer>(0x10 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>greenAcquire</varname><initializer>(0 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>greenStackNotEmpty</varname><initializer>(1 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>greenEventReady</varname><initializer>(2 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>greenEventTrigger</varname><initializer>(3 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>greenDTACK</varname><initializer>(4 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>greenBERR</varname><initializer>(5 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>greenBusRequest</varname><initializer>(6 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>greenBusGranted</varname><initializer>(7 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>greenInvert</varname><initializer>(8 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>greenLatch</varname><initializer>(0x10 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>bottomYellowNotArbiter</varname><initializer>(0 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>bottomYellowUsbTrigger</varname><initializer>(1 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>bottomYellowUSBReset</varname><initializer>(2 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>bottomYellowBERR1</varname><initializer>(3 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>bottomYellowDTACK</varname> <initializer>(4 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>bottomYellowBERR</varname><initializer>(5 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>bottomYellowBusRequest</varname><initializer>(6 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>bottomYellowBusGranted</varname><initializer>(7 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>bottomYellowInvert</varname><initializer>(8 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>bottomYellowLatch</varname><initializer>(0x10 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    };
    class <ooclass><classname>CVMUSB::DeviceSourceRegister</classname></ooclass> {
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1Busym</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1Trigger</varname><initializer>1</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1BusRequest</varname><initializer>2</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1EventToBuffer</varname><initializer>3</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1DGGA</varname><initializer>4</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1DGGB</varname><initializer>5</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1EndOfEvent</varname><initializer>6</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1UsbTrigger</varname><initializer>7</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1Invert</varname><initializer>8M</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1Latch</varname><initializer>0x10</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2UsbTrigger1</varname><initializer>(0 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2VMEExecuting</varname><initializer>(1 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2VMEAS</varname><initializer>(2 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2DataToUsbFIFO</varname><initializer>(3 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2DGGA</varname><initializer>(4 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2DGGB</varname><initializer>(5 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2EndOfEvent</varname><initializer>(6 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2UsbTrigger</varname><initializer>(7 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2Invert</varname><initializer>(8 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2Latch</varname><initializer>(0x10 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    
    <!-- Scaler A -->
    
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerADGGA</varname><initializer>(0   &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerANIMI1</varname><initializer>(1   &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerANIMI2</varname><initializer>(2   &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerAEvent</varname><initializer>(3   &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerAEnable</varname><initializer>(8   &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerAReset</varname><initializer>(0x10 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBCarryA</varname><initializer>(0   &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBNIMI1</varname><initializer>(1   &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBNIMI2</varname><initializer>(2   &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBEvent</varname><initializer>(3   &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBEnable</varname><initializer>(8   &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBReset</varname><initializer>(0x10 &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggADisabled</varname><initializer>(0   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggANIMI1</varname><initializer>(1   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggANIMI2</varname><initializer>(2   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggAEventTrigger</varname><initializer>(3   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggAEndOfEvent</varname><initializer>(4   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggAUsbTrigger</varname><initializer>(5   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggAPulser</varname><initializer>(6   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBDisabled</varname><initializer>(0   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBNIMI1</varname><initializer>(1   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBNIMI2</varname><initializer>(2   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBEventTrigger</varname><initializer>(3   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBEndOfEvent</varname><initializer>(4   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBUsbTrigger</varname><initializer>(5   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBPulser</varname><initializer>(6   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>freezeScalers</varname><initializer>0x80000000</initializer>
    </fieldsynopsis>
    };
    class <ooclass><classname>CVMUSB::DGGAndPulserRegister</classname></ooclass> {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>dggFineDelayMask</varname><initializer>0xffff</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>dggFineDelayShift</varname><initializer>0</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>dggGateWidthMask</varname><initializer>0xffff0000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>dggGateWidthShift</varname><initializer>16</initializer>
        </fieldsynopsis>
    
    };
    class <ooclass><classname>CVMUSB::DGGCoarseRegister</classname></ooclass> {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>ACoarseMask</varname><initializer>0xffff</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>ACoarseShift</varname><initializer>0</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BCoarseMask</varname><initializer>0xffff0000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BCoarseShift</varname><initializer>16</initializer>
        </fieldsynopsis>
    
    }; 
    class <ooclass><classname>CVMUSB::ISVRegister</classname></ooclass> {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AVectorMask</varname><initializer>= 0xff</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AVectorShift</varname><initializer>0</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AIPLMask</varname><initializer>0x700</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AIPLShift</varname><initializer>8</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AStackIDMask</varname><initializer>0x7000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AStackIDShift</varname><initializer>12</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BVectorMask</varname><initializer>0xff0000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BVectorShift</varname><initializer>16</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BIPLMask</varname><initializer>0x7000000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BIPLShift</varname><initializer>24</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BStackIDMask</varname><initializer>0x70000000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BStackIDShift</varname><initializer>28</initializer>
        </fieldsynopsis>
    };
    class <ooclass><classname>CVMUSB::TransferSetupRegister</classname></ooclass> {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>multiBufferCountMask</varname><initializer>0xff</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>multiBufferCountShift</varname><initializer>0</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>timeoutMask</varname><initializer>0xf00</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>timeoutShift</varname><initializer>8</initializer>
        </fieldsynopsis>
    };
    



};
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            <classname>CVMUSB</classname> encapsulates a VM-USB controller.
            Its methods are divided in to several categories:
          </para>
          <itemizedlist>
            <listitem>
                <para>Static methods for enumeration and selection</para>
            </listitem>
            <listitem>
                <para>Methods to access the VM-USB register set</para>
            </listitem>
            <listitem>
                <para>Methods to perform simple VME operations via the controller</para>
            </listitem>
            <listitem>
                <para>A method to execute immediate lists and get the data read
                by those stacks</para>
            </listitem>
            <listitem>
                <para>Methods to download lists and manage the module in
                data taking mode.
                </para>
            </listitem>
          </itemizedlist>
          <para>
            See METHODS below for descriptions of each of the methods.
          </para>
          <para>
            Register bits and field definitions are provided as nested classes
            see CONSTANTS below for a description of each of these classes.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <para>
            This section provides a description of each of the methods. Where
            appropriate reference is made to sections of the VM-USB manual.
          </para>
          <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                      <modifier>static </modifier>
                      <type>std::vector&lt;struct usb_device*&gt;</type>
                      <methodname>enumerate</methodname>
                      <void />
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This function returns a vector of <type>usb_device*</type>
                        pointers, one for each VM-USB powered up and attached
                        to the system.  <type>usb_device</type> is an opaque
                        type used by libusb to refer to a specific device
                        attached to the host via USB.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>static</modifier> <type>std::string</type>
                        <methodname>serialNo</methodname>
                        <methodparam>
                            <type>usb_device*</type> <parameter>dev</parameter>
                        </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Given a <type>usb_device</type> pointer, typically]
                        gotten from <methodname>CVMUSB::enumerate</methodname>,
                        returns the serial number string of the device that
                        corresponds to it.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                       <methodname>CVMUSB</methodname>
                       <methodparam>
                            <type>struct usb_device*</type> <parameter>vmUsbDevice</parameter>
                       </methodparam>
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a <classname>CVMUSB</classname> object given
                        a <type>usb_device</type> pointer typically gotten from
                        <methodname>CVMUSB::enumerate</methodname>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeActionRegister</methodname>
                        <methodparam>
                            <type>uint16_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Writes <parameter>value</parameter> to the VM-USB
                        action register.  The action register is a write only
                        register that is used to control the overall behavior
                        of the VM-USB.  It allows you to enter or leave
                        data taking mode, reset the VME bus and trigger the
                        various downloaded VME lists.
                    </para>
                    <para>
                        The action register is described in section 3.1 of the
                        VM-UBS manual.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>uint32_t</type> <methodname>readFirmwareID</methodname>
                        <void />
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Reads the firmware Id register.  The firmware Id is a
                        bit encoded readonly register that provides the date,
                        status (beta test or production), the major and minor
                        versions of the firmware.  The firmware Id register
                        is described by section 3.4.1 of the VM-USB manual.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeGlobalMode</methodname>
                        <methodparam>
                            <type>uint16_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                <listitem>
                    <para>
                        Writes <parameter>value</parameter> to the VM-USB
                        global mode regiseter.  The global mode register determiens
                        the bus request level, header options and the size of the
                        output buffer, as well as a few other buffer options.
                        It is described in setion 3.4.2 of the VM-USB manual.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>uint16_t</type> <methodname>readGlobalMode</methodname>
                        <void />
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the value of the global mode register.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeDAQSettings</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                   <para>
                        Writes the data acquisition settings register with
                        <parameter>value</parameter>.  This register, described
                        in section 3.4.3 of the VM-USB manual, determines how
                        scaler buffers are read and the delay between a readout
                        trigger from <literal>IN1</literal> and the actual
                        start of VME list execution.  This is provided to
                        allow users to provide a common digitizer and VM-USB
                        trigger.  The delay, in that case allows digitizers to
                        complete their conversions prior to being read by the
                        readout list.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>uint32_t</type>
                        <methodname>readDAQSettings</methodname>
                        <void />
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the value of the data acquisition settings
                        register.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeLEDSource</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Write <parameter>value</parameter> to the VM-USB
                        LED source register.  The VM-USB has a set of four LEDs.
                        This register determines the conditions under which each
                        of those LEDs is lit.  The LED source register is described
                        in section 3.4.4 of the VM-USB manual.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>uint32_t</type> <methodname>readLEDSource</methodname>
                        <void />
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the current value of the LED source register.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeDeviceSource</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Writes <parameter>value</parameter> to the VM-USB device
                        source register.  The VM-USB provides a pair of scalers
                        and gate and delay generators, as well as two front panel
                        NIM outputs.  This register defines the signal sources
                        for each of these devices (when scalers increment, what
                        starts a gate and delay generator and when the outputs
                        are asserted).
                    </para>
                    <para>
                        The Device Sources register is described in section
                        3.4.5 of the VM-USB manual.
                    </para>
                 </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>uint32_t</type> <methodname>readDeviceSource</methodname>
                        <void />
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the value of the Device source register.        
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeDGG_A</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Writes <parameter>value</parameter> to the Delay and
                        Gate Generator A control register. This register
                        contains the length of the output gateas well as the
                        low order bits of the delay.  The Delay and Gate register
                        setup is described in section 3.4.6 of the VM-USB
                        manual.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>uint32_t</type> <methodname>readDGG_A</methodname>
                        <void />
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the value of the DGG A control register.        
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeDGG_B</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to the Delay and
                            Gate Generator B control register. This register
                            contains the length of the output gateas well as the
                            low order bits of the delay.  The Delay and Gate register
                            setup is described in section 3.4.6 of the VM-USB
                            manual.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>uint32_t</type> <methodname>readDGG_B</methodname>
                        <void />
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the value of the DGG B control register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeDGG_Extended</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes the DGG extended delay offset.  This register
                            contains the top 16 bits of the delay for both
                            A and B DGG's. It is describedin section 3.4.6
                            of the VM-USB manual.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>uint32_t</type> <methodname>readDGG_Extended</methodname>
                        <void />
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the DGG extended delay register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>uint32_t</type> <methodname>readScalerA</methodname>
                        <void />
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The VM-USB contains two scalers (counters) that
                            can be incremented as a result of several
                            conditions.  These scalers are named A and B and
                            are described in section 3.4.7 of the VM-USB manual.
                        </para>
                        <para>
                            This method returns the value of scaler A.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>uint32_t</type> <methodname>readScalerB</methodname>
                        <void />
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            See <methodname>readScalerA</methodname> this method
                            returns the value of scaler B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeVector</methodname>
                        <methodparam>
                            <type>int</type> <parameter>which</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The VM-USB allows stacks to be triggered as a result
                            of VME interrupts.  4 interrupt registers are provided
                            as described in section 3.4.8.  Each register
                            describes the IPL and Status ID of two interrupts
                            and associates each of those with a stack.
                            This method allows you to program the value of one
                            of those registers.
                        </para>
                        <para>
                            The <parameter>which</parameter>   parameter selects
                            which of the interrupt registers to write, numbered
                            from 1 through 4.  The <parameter>value</parameter>
                            parameter is written to the selected register.
                        </para>
                        <para>
                            An error message is thrown as an <type>std::string</type>
                            if <parameter>which</parameter> is illegal.
                        </para>
                        <para>
                            As essentially all VME interrupters in existence
                            use an 8 bit status ID for which the top
                            bits must be set, according to the VME standard,
                            These methods also write both Status/ID expansion
                            registers to <literal>0xffffffff</literal>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>uint32_t</type> <methodname>readVector</methodname>
                        <methodparam>
                            <type>int</type> <parameter>which</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the value of
                            one of the interrupt registers described
                            above.  <parameter>which</parameter> indicates
                            which one to read.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeIrqMask</methodname>
                        <methodparam>
                            <type>uint8_t</type> <parameter>mask</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes the IRQ mask register described in section
                            3.5 of the VM-USB manual.  The register is
                            set to <parameter>mask</parameter>. Each bit in the
                            mask represents a VME IPL.  <literal>0x01</literal>
                            represents IPL1, <literal>0x40</literal> represents
                            IPL 7.  If a bit is set to 1, interrupts at that IPL
                            will be ignored by the VM-USB.
                        </para>
                        <para>
                            This register only needs to be programmed when
                            the VM-USB is used with other interrupt handling
                            modules (e.g. CPU modules).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>uint8_t</type> <methodname>readIrqMask</methodname>
                        <void />
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the value last written to the
                            IRQ mask register.  The actual register is write-only.
                            The <classname>CVMUSB</classname> class therefore
                            remembers the most recently written value. This
                            <firstterm>shadow register value</firstterm> is what
                            is returned by this method.  Note as well that
                            the IRQ mask register is set to <literal>0xff</literal>
                            by the constructor so that it has a known intial
                            value.  This initial value <emphasis>disables</emphasis>
                            all
                            interrupt handling by the VM-USB.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>writeBulkXferSetup</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to the Bulk
                            Transfer setup register.  This register is described
                            in section 3.4.10 of the VM-USB manual.  It controls
                            several parameters that can optimize the bandwidth of
                            the USB.  Specifically you can set the number of buffers
                            that will be sent from the VM-USB to the host without
                            generating a USB Packet end frame and the timeout
                            after which the packet end frame will be sent
                            regardless of how many bufers were sent.
                        </para>
                        <para>
                            If the paragraph above is not meaningful to you,
                            and you read 3.4.10 and its still not meaningful, you
                            should probably not touch this register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>uint32_t</type> <methodname>readBulkXferSetup</methodname>
                        <void />
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the value of the Bulk Transfer Setup register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeWrite32</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>aModifier</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t</type> <parameter>data</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes a 32 bit longword, <parameter>data</parameter>
                            to a vme <parameter>address</parameter> using
                            the VME Address modifier <parameter>aModifier</parameter>.
                        </para>
                        <para>
                            The function returns <literal>0</literal> on
                            success, <literal>-1</literal> if the USB write
                            failed, <literal>-2</literal> if the USB read of the
                            acknowledgement failed, and <literal>-3</literal>
                            if the acknowledgement packet indicated the
                            transfer failed due to a bus error.
                        </para>
                        <para>
                            For USB write and read failures, the resason for
                            the failure is available in <varname>errno</varname>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeRead32</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_tM</type> <parameter>aModifier</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t*</type> <parameter>data</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a 32 bit longword read from
                            <parameter>address</parameter> using the VME bus
                            address modifier <parameter>aModifier</parameter>.
                            If successful, the data are stored in <parameter>data</parameter>.
                        </para>
                        <para>
                            The return value reflects a high level status of the
                            operation.
                            The function returns <literal>0</literal> on
                            success, <literal>-1</literal> if the USB write
                            failed, <literal>-2</literal> if the USB read of the
                            acknowledgement failed.
                        </para>
                        <para>
                            For USB write and read failures, the resason for
                            the failure is available in <varname>errno</varname>
                        </para>                            
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeWrite16</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>aModifier</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint16_t</type> <parameter>data</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Identical to <methodname>vmeWrite32</methodname>
                            however the data transfered is only a 16 bit
                            word wide.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeRead16</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>aModifier</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint16_t*M</type> <parameter>data</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Identical to <methodname>vmeRead32</methodname>
                            however the data read are only a 16 bit word wide.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeWrite8</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>aModifier</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>data</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>vmeWrite32</methodname> however
                            the data written are an 8 bit byte in width.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeRead8</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>aModifier</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t*</type> <parameter>data</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>vmeRead32</methodname> however
                            the data read are an 8 bit byte in width.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeBlockRead</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>baseAddress</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>aModifier</parameter>
                        </methodparam>
                        <methodparam>
                            <type>void*</type> <parameter>data</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t</type> <parameter>transferCount</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t*</type> <parameter>countTransferred</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a block read from the VME bus.  VME block
                            reads the requestor to only send an initial VME
                            base address followed by a new address every time
                            the address crosses a 256 byte boundary.  Subsequent
                            addresses are assumed  to represent a contiguous
                            block of storage.  Not all devices support block
                            transfers.  Block transfers also require specific
                            block transfer address modifiers.  When used properly,
                            block transfers allow higher throughput by
                            reducing the number of address cycles.
                        </para>
                        <para>
                            The base address of the block transfer is
                            <parameter>baseAddress</parameter>.  The address
                            modifier used is <parameter>aModifier</parameter>
                            the caller is responsible for ensuring that
                            <parameter>aModifier</parameter> is a valid
                            block transfer address modifier. <parameter>data</parameter>
                            is a buffer that will receive the data read.
                            <parameter>transferCount</parameter> is the number
                            of longwords (32 bit items) to transfer.  All transfers
                            will be 32 bit wide transfers.  <parameter>countTransferred</parameter>
                            will be the actual number of longwords transferred.
                        </para>
                        <para>
                            For some devices it is possible to transfer fewer
                            items thatn the number of items requested.  An example
                            of this is the use of CAEN V785's in chained block
                            mode.  In that case, the read will transfer data
                            until the ADC's have no more data left at which time
                            the modules will return a bus error on the next transfer
                            and the VM-USB will insert a <literal>0xffffffff</literal>
                            marker in the data stream when the bus error occured.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeFifoRead</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>int8_t</type> <parameter>aModifier</parameter>
                        </methodparam>
                        <methodparam>
                            <type>void*</type> <parameter>data</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t</type> <parameter>transferCount</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t*</type> <parameter>countTransferred</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This function is the same as <methodname>vmeBlockRead</methodname>
                            except that all address cycles use the same <parameter>address</parameter>
                            value.  This makes the function suitable to read FIFO
                            registers in modules that support block reads.
                        </para>
                   </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeReadBlockCount8</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t</type> <parameter>mask</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>amod</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The VM-USB supports variable sized block reads.
                            These operate by first performing a
                            read of the block count from some register and providing
                            a mask that indicates what part of that data
                            contains the transfer count.
                            The block count read must at some point be
                            folowed by a call to
                            <methodname>vmeVariableBlockRead</methodname>
                            to actually perform the block read.
                        </para>
                        <para>
                            This method does an 8 bit transfer to read the
                            block count for the next
                            <methodname>vmeVariableBlockRead</methodname>
                            call. <parameter>address</parameter> is the
                            byte address of the location that contains the
                            count field.  The addressed module must support
                            byte addressing at this location.  <parameter>mask</parameter>
                            is the mask that defines the bit field containing
                            the count.
                            <parameter>amod</parameter> is the address modifier
                            for the transfer of the transfer count.
                        </para>
                        
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeReadBlockCount16</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t</type> <parameter>mask</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>amod</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>vmeReadBlockCount8</methodname>
                            but the block count transfer is 16 bits wide.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeReadBlockCount32</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>addressM</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t</type> <parameter>mask</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>amod</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>vmeReadouBlockCount8</methodname>
                            except the block count is read with a 32 bit transfer.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeVariableBlockRead</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>amod</parameter>
                        </methodparam>
                        <methodparam>
                            <type>void*</type> <parameter>data</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t</type> <parameter>maxCount</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t*</type> <parameter>countTransferred</parameter>
                        </methodparam>
                    </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Do a variable length block transfer.  This
                                transfer must have been
                                set up by doing a call to one of the
                                <methodname>vmeReadBlockCountxx</methodname> functions.
                                furthermore, no other block transfer can have
                                taken place since that
                                operation.  It is <emphasis>strongly</emphasis>
                                recommended that unless prohibited by the
                                hardware, a vmeReadBlockCountxx be
                                <emphasis>immediately</emphasis> followed by a
                                variable block read or variable fifo read.
                            </para>
                            <para>
                                <parameter>address</parameter> is the starting
                                address of the block read.  <parameter>amod</parameter>
                                is the VME address modifier.  <parameter>data</parameter>
                                is a buffer into which data will be stored and
                                <parameter>maxCount</parameter> the size of that buffer
                                in 32bit longwords.  <parameter>countTransferred</parameter>
                                will be filled in with the total number of longwords
                                actually transferred.
                            </para>
                            <para>
                                The total transfer count is the minimum of the
                                variable block read gotten by the
                                <methodname>vmeReadBlockCountxx</methodname>
                                method, the value of the <parameter>maxCount</parameter>
                                parameter to this call and the number of transfers
                                actually performed prior to and including the
                                transfer that caused a bus error if any.
                            </para>
                            <para>
                                As usual, in the event the transfer terminated
                                with a bus error, that operation inserts a
                                <literal>0xffffffff</literal> in the buffer.
                            </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>vmeVariableFifoRead</methodname>
                        <methodparam>
                            <type>uint32_t</type> <parameter>address</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint8_t</type> <parameter>amod</parameter>
                        </methodparam>
                        <methodparam>
                            <type>void*</type> <parameter>data</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t</type> <parameter>maxCount</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t*</type> <parameter>countTransferred</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>vmeVariableBlockRead</methodname>
                            but all addresses cycles
                            provide <parameter>address</parameter> rather than
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>executeList</methodname>
                        <methodparam>
                            <type>CVMUSBReadoutList&amp;</type> <parameter>list</parameter>
                        </methodparam>
                        <methodparam>
                            <type>void*</type> <parameter>pReadBuffer</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t</type> <parameter>readBufferSize</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t*</type> <parameter>bytesRead</parameter>
                        </methodparam>
                    </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This function executes a list of operations.
                                The <parameter>list</parameter> parameter
                                is an instance of a
                                <classname>CVMUSBReadoutList</classname>
                                class.  See the documentation for that
                                class for a description of how to build up
                                lists of VM-USB operations.
                            </para>
                            <para>
                                <parameter>pReadBuffer</parameter> points to
                                a buffer into which the results of all
                                VME read operations will be put.
                                The buffer must be <parameter>readBufferSize</parameter>
                                8 bit bytes long.  <parameter>bytesRead</parameter>
                                will be written with the number of bytes actually
                                transferred to <parameter>pReadBuffer</parameter>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>loadList</methodname>
                        <methodparam>
                            <type>uint8_t</type> <parameter>listNumber</parameter>
                        </methodparam>
                        <methodparam>
                            <type>CVMUSBReadoutList&amp;</type> <parameter>list</parameter>
                        </methodparam>
                        <methodparam>
                            <type>off_t</type> <parameter>listOffset</parameter>
                            <initializer> 0</initializer>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Loads a list for triggered execution in data taking
                            mode.  <parameter>listNumber</parameter> is the
                            number of the list to load (stack Number).  Tis
                            is a value in the range <literal>[0..7]</literal>.
                            <parameter>list</parameter> is a list of operations
                            built up by instantiating a <classname>CVMUSBReadoutList</classname>
                        </para>
                        <para>
                            <parameter>listOffset</parameter> is the starting
                            offset in  VM-USB memory at which the list
                            should be loaded.  When computing where to load
                            multiple stacks you need to know that each
                            stack requires:
                            <informalexample>
                                <programlisting>
list.size() * sizeof(uint32_t)/sizeof(uint16_t) + 4
                                </programlisting>
                            </informalexample>
                            locations.
                        </para>
                    </listitem>
                </varlistentry>
                    <varlistentry>
                        <term>
                    <methodsynopsis>
                        <type>int</type> <methodname>usbRead</methodname>
                        <methodparam>
                            <type>void*</type> <parameter>data</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t</type> <parameter>bufferSize</parameter>
                        </methodparam>
                        <methodparam>
                            <type>size_t*</type> <parameter>transferCount</parameter>
                        </methodparam>
                        <methodparam>
                            <type>int</type> <parameter>timeout</parameter>
                            <initializer>2000</initializer>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a bulk read on the VM-USB.
                            <parameter>data</parameter> provides a buffer
                            into which the data will be read.
                            <parameter>bufferSize</parameter> is the number
                            of bytes of space pointed to by <parameter>data</parameter>
                            <parameter>transferCount</parameter>
                            will be written with the
                            number of transfers that actually were performed.
                        </para>
                        <para>
                            The return value is <literal>0</literal> on success
                            or <literal>-1</literal> on failure.  On failure,
                            zero will be stored in the <parameter>transferCount</parameter>
                            and <varname>errno</varname> will have the reason
                            for the failure.
                        </para>
                        <para>
                            If no data are available by <parameter>timeout</parameter>
                            milliseconds, the read will fail with an
                            <varname>errno</varname> value of
                            <literal>ETIMEDOUT</literal>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>void</type> <methodname>setDefaultTimeout</methodname>
                        <methodparam>
                            <type>int</type> <parameter>ms</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Sets the timeout used for transactions that
                            don't provide a timeout value.  <parameter>ms</parameter>
                            is the number of milliseconds these methods will
                            wait for a response from the VM-USB.
                        </para>
                        <para>
                            Almost all actions with the VM-USB require the
                            host to send a USB packet to the VM-USB and receive
                            a packet in return.  This function sets the timeout
                            that will be used for the <methodname>usbRead</methodname>
                            call to get the return packets.
                        </para>
                    </listitem>
                </varlistentry>        
          </variablelist>
       </refsect1>
        <refsect1>
           <title>CONSTANTS</title>
           <para>
                This class defines a large number of nested classes.  Each nested
                class defines symbolic constants for a register.  The
                SYNOPSIS section shows these definitions.  
           </para>
           <para>
            For example, the <classname>CVMUSB::ActionRegister</classname>
            provides bit definitions fro the Action register.
           </para>
        </refsect1>
     </refentry>
         
	 <refentry id="vmusb3-CVMUSBReadoutList">
       <refmeta>
          <refentrytitle id='vmusb3-CVMUSBReadoutList-title'>CVMUSBReadoutList</refentrytitle>
          <manvolnum>3vmusb</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CVMUSBReadoutList</refname>
          <refpurpose>Construct VM-USB stacks</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
            <synopsis>
#include &lt;CVMUSBReadoutList.h&gt;

class <ooclass><classname>CVMUSBReadoutList</classname></ooclass>
    <constructorsynopsis>
       <methodname>CVMUSBReadoutList</methodname>
       <void />
       
    </constructorsynopsis>
    <constructorsynopsis>
       <methodname>CVMUSBReadoutList</methodname>
       <methodparam>
            <type>std::vector&lt;uint32_t&gt;&amp;</type> <parameter>list</parameter>
       </methodparam>
       
    </constructorsynopsis>
    <constructorsynopsis>
       <methodname>CVMUSBReadoutList</methodname>
       <methodparam>
            <modifier>const</modifier> <type>CVMUSBReadoutList&amp;</type>
            <parameter>rhs</parameter>
       </methodparam>
       
    </constructorsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>clear</methodname>
      <void />
      <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>size_t</type>
      <methodname>size</methodname>
      <void />
      <modifier>const</modifier>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>std::vector&lt;uint32_t&gt;</type>
      <methodname>get</methodname>
      <void />
      <modifier>const</modifier>
    </methodsynopsis>                    
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addRegisterRead</methodname>
      <methodparam>
        <type>unsigned int</type> <parameter>address</parameter>
      </methodparam>
      <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addRegisterWrite</methodname>
      <methodparam>
        <type>unsigned int</type> <parameter>address</parameter>
      </methodparam>
      <methodparam>
        <type>uint32_t</type> <parameter>data</parameter>
      </methodparam>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addWrite32</methodname>
      <methodparam>
        <type>uint32_t</type> <parameter>address</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type> <parameter>amod</parameter>
      </methodparam>
      <methodparam>
        <type>uint32_t</type> <parameter>datum</parameter>    
      </methodparam>
      <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addWrite16</methodname>
      <methodparam>
        <type>uint32_t</type> <parameter>address</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type> <parameter>amod</parameter>
      </methodparam>
      <methodparam>
        <type>uint16_t</type> <parameter>datum</parameter>
      </methodparam>
      <modifier></modifier>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addWrite8</methodname>
      <methodparam>
        <type>uint32_t</type> <parameter>address</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type> <parameter>amod</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type> <parameter>datum</parameter>   
      </methodparam>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addRead32</methodname>
      <methodparam>
        <type>uint32_t</type> <parameter>address</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type> <parameter>amod</parameter>
      </methodparam>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addRead16</methodname>
      <methodparam>
        <type>uint32_t</type> <parameter>address</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type> <parameter>amod</parameter>
      </methodparam>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addRead8</methodname>
      <methodparam>
        <type>uint32_t</type> <parameter>address</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type> <parameter>amod</parameter>
      </methodparam>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addBlockRead32</methodname>
      <methodparam>
        <type>uint32_t</type> <parameter>baseAddress</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type><parameter>amod</parameter>
      </methodparam>
      <methodparam>
        <type>size_t</type><parameter>transfers</parameter>
      </methodparam>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addFifoRead32</methodname>
      <methodparam>
        <type>uint32_t</type><parameter>baseAddress</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type><parameter>amod</parameter>
      </methodparam>
      <methodparam>
        <type>size_t</type><parameter>transfers</parameter>
      </methodparam>    
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addFifoRead16</methodname>
      <methodparam>
        <type>uint32_t</type><parameter>baseAddress</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type><parameter>amod</parameter>
      </methodparam>
      <methodparam>
        <type>size_t</type><parameter>transfers</parameter>
      </methodparam>    
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addBlockWrite32</methodname>
      <methodparam>
        <type>uint32_t</type><parameter>baseAddress</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type><parameter>amod</parameter>
      </methodparam>
      <methodparam>
        <type>void*</type><parameter>data</parameter>
      </methodparam>
      <methodparam>
        <type>size_t</type><parameter>transfers</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addBlockCountRead8</methodname>
      <methodparam>
        <type>uint32_t</type><parameter>address</parameter>
      </methodparam>
      <methodparam>
        <type>uint32_t</type><parameter>mask</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type><parameter>amod</parameter>
      </methodparam>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addBlockCountRead16</methodname>
      <methodparam>
        <type>uint32_t</type><parameter>address</parameter>
      </methodparam>
      <methodparam>
        <type>uint32_t</type><parameter>mask</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type><parameter>amod</parameter>
      </methodparam>
    </methodsynopsis>
    <methodsynopsis>
      <modifier></modifier>
      <type>void</type>
      <methodname>addBlockCountRead32</methodname>
      <methodparam>
        <type>uint32_t</type><parameter>address</parameter>
      </methodparam>
      <methodparam>
        <type>uint32_t</type><parameter>mask</parameter>
      </methodparam>
      <methodparam>
        <type>uint8_t</type><parameter>amod</parameter>
      </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>void</type>
        <methodname>addMaskedCountBlockRead32</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>amod</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>void</type>
        <methodname>addMaskedCountFifoRead32</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>amod</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>    
        <modifier></modifier>
        <type>void</type>
        <methodname>addDelay</methodname>
        <methodparam>
            <type>uint8_t</type><parameter>clocks</parameter>
        </methodparam>
    </methodsynopsis>  
    <methodsynopsis>
        <modifier></modifier>
        <type>void</type>
        <methodname>addMarker</methodname>
        <methodparam>
            <type>uint16_t</type><parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier>
        <type>uint8_t</type> <varname>a32UserData</varname>
        <initializer>0x09</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint8_t</type>
        <varname>a32UserProgram</varname><initializer>0xa</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier>
        <type>uint8_t</type><varname>a32UserBlock</varname>
        <initializer>0x0b</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint8_t</type>
        <varname>a32PrivData</varname><initializer>0x0d</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier>
        <type>uint8_t</type><varname>a32PrivProgram</varname><initializer>0x0e</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint8_t</type>
        <varname>a32PrivBlock</varname><initializer>0x0f</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint8_t</type>
        <varname>a16User</varname><initializer>0x29</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint8_t</type>
        <varname>a16Priv</varname><initializer>0x2d</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint8_t</type>
        <varname>a24UserData</varname><initializer>0x39</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint8_t</type>
        <varname>a24UserProgram</varname><initializer>0x3a</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint8_t</type>
        <varname>a24UserBlock</varname><initializer>0x3b</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint8_t</type>
        <varname>a24PrivData</varname><initializer>0x3d</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint8_t</type>
        <varname>a24PrivProgram</varname><initializer>0x3e</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint8_t</type>
        <varname>a24PrivBlock</varname><initializer>0x3f</initializer>
    </fieldsynopsis>

</synopsis>

       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            This object is used to build up lists (stacks) of VME commands.
            The normal procedure is to create an instance of a
            <classname>CVMUSBReadoutList</classname> and invoke its member
            functions to build up the list of operations desired.  The resulting
            list is then passed either to
            <classname>CVMUSB</classname>::<methodname>executeList</methodname>,
            which executes the operations in the list immediately and returns
            any data read.  Alternatively, if the list is being created for
            use as a data acquisition mode stack, it is passed to
            <classname>CVMUSB</classname>::<methodname>loadList</methodname>
            to load it into the VM-USB stack memory.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <para>
            This section desribes the methods provide by the
            <classname>CVMUSBReadoutList</classname> class and objects.  Several
            parameters are common throughout and will only be explained here.
          </para>
          <para>
            <type>uint8_t</type> <parameter>amod</parameter> is always a VME Bus
            address modifier.  See CONSTANTS below for a list of the address
            modifiers.
          </para>
          <para>
            <type>uint32_t</type><parameter>address</parameter> is the VME
            address that is the source or target of an operation.  
          </para>
          <para>
            <type>uint32_t</type><parameter>baseAddress</parameter> is the
            starting address of a block transfer operation.
          </para>
          <variablelist>
        <varlistentry>
            <term>
    <constructorsynopsis>
       <methodname>CVMUSBReadoutList</methodname>
       <void />
    </constructorsynopsis>
            </term>
            <listitem>
                <para>
                    This is the constructor you will normally use.  It produces
                    an empty VM-USB stack which can be built up using
                    the remaining methods described in this section.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
    <constructorsynopsis>
       <methodname>CVMUSBReadoutList</methodname>
       <methodparam>
            <type>std::vector&lt;uint32_t&gt;&amp;</type> <parameter>list</parameter>
       </methodparam>
    </constructorsynopsis>
            </term>
            <listitem>
                <para>
                    This constructor builds a VM-USB list that is intially
                    stocked with the stack contained in <parameter>list</parameter>.
                    This list can be built either by hand or could have been
                    gotten by a call to <methodname>get</methodname> on a
                    previously existinglist.
                    </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
    <constructorsynopsis>
       <methodname>CVMUSBReadoutList</methodname>
       <methodparam>
            <modifier>const</modifier> <type>CVMUSBReadoutList&amp;</type>
            <parameter>rhs</parameter>
       </methodparam>
       
    </constructorsynopsis>
            </term>
            <listitem>
                <para>
                    Copy constructor.   The existence of this constructor
                    also allows lists to be passed by value to other functions.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
                <methodsynopsis>
                  <modifier></modifier>
                  <type>void</type>
                  <methodname>clear</methodname>
                  <void />
                  <modifier></modifier>
                </methodsynopsis>
                </term>
            <listitem>
                <para>
                    Clears the stack.  This allows a <classname>CVMUSBReadoutList</classname>
                    to be re-used once it has been either loaded or executed.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>size_t</type>
              <methodname>size</methodname>
              <void />
              <modifier>const</modifier>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns the number of stack lines. The VM-USB manual
                    defines a stack line as a 32 bit datum.  Most instructions
                    require at least two lines.  Some are even longer.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>std::vector&lt;uint32_t&gt;</type>
              <methodname>get</methodname>
              <void />
              <modifier>const</modifier>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Returns the undelying std::list that is used to store
                    the stack as it is being built.  The return value from
                    this method is also usable in a constructor.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addRegisterRead</methodname>
              <methodparam>
                <type>unsigned int</type> <parameter>address</parameter>
              </methodparam>
              <modifier></modifier>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds an instruction to read a VM-USB internal register.
                    In this case <parameter>address</parameter> is a VM-USB
                    register rather than a VME address. The register addresses
                    are listed in the table in section 3.4 of the VM-USB
                    manual.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addRegisterWrite</methodname>
              <methodparam>
                <type>unsigned int</type> <parameter>address</parameter>
              </methodparam>
              <methodparam>
                <type>uint32_t</type> <parameter>data</parameter>
              </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds an instruction to do a write to a VM-USB internal
                    register.  <parameter>data</parameter> is the data to be
                    written.  As with <methodname>addRegisterRead</methodname>,
                    <parameter>address</parameter> is a register file address
                    from the table in section 3.4 of the VM-USB manual.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addWrite32</methodname>
              <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
              </methodparam>
              <methodparam>
                <type>uint32_t</type> <parameter>datum</parameter>    
              </methodparam>
              <modifier></modifier>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a command to write a 32 bit <parameter>datum</parameter>
                    to the VME bus.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addWrite16</methodname>
              <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
              </methodparam>
              <methodparam>
                <type>uint16_t</type> <parameter>datum</parameter>
              </methodparam>
              <modifier></modifier>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a command to write a 16 bit <parameter>datum</parameter>
                    to the VME bus.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addWrite8</methodname>
              <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type> <parameter>datum</parameter>   
              </methodparam>
            </methodsynopsis>
              </term>
              <listitem>
                <para>
                    Adds an instruction to perform an 8 bit write
                    of <parameter>datum</parameter> to the VME-Bus.
                </para>
              </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addRead32</methodname>
              <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
              </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds an instruction to do a 32 bit read from the VME
                    bus to the stack.  The data read are either placed in the
                    buffer handed to
                    <classname>CVMUSB</classname>::<methodname>executeList</methodname>
                    or, if the stack is triggered in data taking mode, to the
                    event read for the trigger.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addRead16</methodname>
              <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
              </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds an instruction to perform a 16 bit read from
                    the VME bus to the stack.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addRead8</methodname>
              <methodparam>
                <type>uint32_t</type> <parameter>address</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type> <parameter>amod</parameter>
              </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds an instruction to perform an 8 bit read from the VME
                    bus to the stack.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addBlockRead32</methodname>
              <methodparam>
                <type>uint32_t</type> <parameter>baseAddress</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type><parameter>amod</parameter>
              </methodparam>
              <methodparam>
                <type>size_t</type><parameter>transfers</parameter>
              </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a block read of 32 bit wide quantities to the stack.
                    <parameter>transfers</parameter> is the maximum number of
                    transfers that will be performed.   The transfer will also
                    terminate if VME bus reports a bus error.  In that case,
                    a 32 bit <literal>0xffffffff</literal> will be put in the
                    buffer to mark termination.
                </para>
                <para>
                    If the <parameter>amod</parameter> is a VME block transfer
                    address modifier, the block transfer will only provde an
                    address cycle at the beginning of the transfer and whenever
                    the address crosses a 256 byte boundary as provided for
                    in the VME bus specification for block transfers.  This can
                    significantly improve performance.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addFifoRead32</methodname>
              <methodparam>
                <type>uint32_t</type><parameter>baseAddress</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type><parameter>amod</parameter>
              </methodparam>
              <methodparam>
                <type>size_t</type><parameter>transfers</parameter>
              </methodparam>    
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addBlockRead32</methodname>, however
                    all address cycles will assert
                    <parameter>baseAddress</parameter>.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addFifoRead16</methodname>
              <methodparam>
                <type>uint32_t</type><parameter>baseAddress</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type><parameter>amod</parameter>
              </methodparam>
              <methodparam>
                <type>size_t</type><parameter>transfers</parameter>
              </methodparam>    
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addFifoRead32</methodname>, however
                    the transfers will be 16 bits wide.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addBlockWrite32</methodname>
              <methodparam>
                <type>uint32_t</type><parameter>baseAddress</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type><parameter>amod</parameter>
              </methodparam>
              <methodparam>
                <type>void*</type><parameter>data</parameter>
              </methodparam>
              <methodparam>
                <type>size_t</type><parameter>transfers</parameter>
                </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a block write to the list.  <parameter>data</parameter>
                    is a buffer containing <parameter>transfers</parameter>
                    worth of 32 bit data to transfer.  If a block transfer
                    <parameter>amod</parameter> is used, the controller will
                    only perform address cycles atthe start of the transfer
                    and as the address crosses 256-byte boundaries as provided
                    for in the VME bus block transfer specification. There must
                    be at least 2 transfers for this to succeed. 
                  </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addBlockCountRead8</methodname>
              <methodparam>
                <type>uint32_t</type><parameter>address</parameter>
              </methodparam>
              <methodparam>
                <type>uint32_t</type><parameter>mask</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type><parameter>amod</parameter>
              </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    The VM-USB provides a set of instructions that
                    allow you to perform variable length block transfers.
                    This is done in two steps.   The first step readss the
                    length of the transfer from somewhere on the VME bus
                    (usually this is a module register).  The second step is
                    to actually perform the variable block transfer.
                </para>
                <para>
                    This method adds a stack instruction to perform
                    an 8 bit data transfer from the VME
                    bus and place the result in the output buffer or event.
                    The set of bits in that data defined by <parameter>mask</parameter>
                    are used to set the transfer count for the next variable length
                    block transfer.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addBlockCountRead16</methodname>
              <methodparam>
                <type>uint32_t</type><parameter>address</parameter>
              </methodparam>
              <methodparam>
                <type>uint32_t</type><parameter>mask</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type><parameter>amod</parameter>
              </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addBlockCountRead8</methodname> however
                    the datum transferred from the VME bus is 16 bits wide rather
                    than 8.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
              <modifier></modifier>
              <type>void</type>
              <methodname>addBlockCountRead32</methodname>
              <methodparam>
                <type>uint32_t</type><parameter>address</parameter>
              </methodparam>
              <methodparam>
                <type>uint32_t</type><parameter>mask</parameter>
              </methodparam>
              <methodparam>
                <type>uint8_t</type><parameter>amod</parameter>
              </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addBlockCountRead16</methodname>, however
                    the datum transferred from the VME bus is 32 bits wide
                    rather than 16.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
                <modifier></modifier>
                <type>void</type>
                <methodname>addMaskedCountBlockRead32</methodname>
                <methodparam>
                    <type>uint32_t</type><parameter>baseAddress</parameter>
                </methodparam>
                <methodparam>
                    <type>uint8_t</type><parameter>amod</parameter>
                </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    This method adds an instruction to use the transfer count
                    register loaded by one of the <methodname>addBlockCountRead</methodname>xx
                    methods as the transfer count for a block read that is 32 bits wide.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
                <modifier></modifier>
                <type>void</type>
                <methodname>addMaskedCountFifoRead32</methodname>
                <methodparam>
                    <type>uint32_t</type><parameter>address</parameter>
                </methodparam>
                <methodparam>
                    <type>uint8_t</type><parameter>amod</parameter>
                </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addMaskedCountBlockRead32</methodname>
                    however all address cycles provide <parameter>address</parameter>
                    on the bus.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>    
                <modifier></modifier>
                <type>void</type>
                <methodname>addDelay</methodname>
                <methodparam>
                    <type>uint8_t</type><parameter>clocks</parameter>
                </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a delay of <parameter>clocks</parameter> FPGA cycles
                    to the stack.  Each cyle is 12.5ns long.
                </para>
            </listitem>
        </varlistentry>
        <varlistentry>
            <term>
            <methodsynopsis>
                <modifier></modifier>
                <type>void</type>
                <methodname>addMarker</methodname>
                <methodparam>
                    <type>uint16_t</type><parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            </term>
            <listitem>
                <para>
                    Adds an instruction to put the literal <parameter>value</parameter>
                    into the output buffer.
                </para>
            </listitem>
            </varlistentry>
          </variablelist>
       </refsect1>
        <refsect1>
           <title>CONSTANTS</title>
           <para>
            The class defines a set of constants that are symbolic definitions of
            the VME address modifiers.  Remember that since these constants
            are defined within <classname>CVUSBReadoutList</classname> the
            classname must be used to scope uses of those definitions.
            For example <programlisting>CVMUSBReadoutList::a32UserData</programlisting>.
           </para>
           <variablelist>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier>
                    <type>uint8_t</type> <varname>a32UserData</varname>
                    <initializer>0x09</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        In the VME bus standard this is referred to
                        as <firstterm>Extended Non-privileged Data Access</firstterm>
                        Extended means addresses use the full 32 bits of width.
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier><type>uint8_t</type>
                    <varname>a32UserProgram</varname><initializer>0xa</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        In the VME bus standard thisis referred to as
                        <firstterm>Extended Non-privileged program access</firstterm>
                        Extended means addresses use the full 32 bits of width.
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier>
                    <type>uint8_t</type><varname>a32UserBlock</varname>
                    <initializer>0x0b</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        In the VME bus standard this is referred to as
                        <firstterm>Extended Non-privileged Block Transfer</firstterm>
                        Block transfer address modifiers only require address
                        cycles on the first cycle, to establish the base address
                        and whenver the address would cross a 256 byte boundary.
                        Using block transfers where possible provides a measurable
                        performance improvement.
                    </para>
                    <para>
                        Extended means addresses use the full 32 bits of width.
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier> <type>uint8_t</type>
                    <varname>a32PrivData</varname><initializer>0x0d</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The VME bus standard refers to this as
                        <firstterm>Extended Supervisory Data</firstterm>.
                        Supervisory data accesses are considered to be from
                        a privileged state.
                        Extended means addresses use the full 32 bits of width.
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier>
                    <type>uint8_t</type><varname>a32PrivProgram</varname><initializer>0x0e</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The VME bus standard refers to this as
                        <firstterm>Extended Supervisory Program access</firstterm>
                        Extended means addresses use the full 32 bits of width.
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier> <type>uint8_t</type>
                    <varname>a32PrivBlock</varname><initializer>0x0f</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The VME bus standard refers to this as
                        <firstterm>Extended Supervisory Block Transfer</firstterm>.
                        Transfers using block transfer modifiers are assumed to
                        go over a contiguous address block.  The bus master only
                        needs to perform an address cycle at the beginning of the
                        transfer and again as the address crosses 256 byte
                        boundaries.
                    </para>
                    <para>
                        Extended means addresses use the full 32 bits of width.
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier><type>uint8_t</type>
                    <varname>a16User</varname><initializer>0x29</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        In the VME standard this is referred to as
                        <firstterm>Short Non-privileged</firstterm>.
                        Short addresses are those that only use 16 bits of
                        address. The address space is assumed to be used for
                        devices.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier><type>uint8_t</type>
                    <varname>a16Priv</varname><initializer>0x2d</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        In the VME standard this is referred to as
                        <firstterm>Short Supervisory</firstterm>.
                      Short addresses are those that only use 16 bits of
                        address. The address space is assumed to be used for
                        devices.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>  
                <fieldsynopsis>
                    <modifier>static const</modifier><type>uint8_t</type>
                    <varname>a24UserData</varname><initializer>0x39</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        In the VME standard, this is referred to as
                        <firstterm>Standard Non-privileged Data</firstterm>.
                        Standard address modifiers pay attention to 24 bits of'
                        address.
                    </para>
                    <para>
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>      
                <fieldsynopsis>
                    <modifier>static const</modifier><type>uint8_t</type>
                    <varname>a24UserProgram</varname><initializer>0x3a</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The VME standard refers to this a
                        <firstterm>Standard Non-Privileged Program</firstterm>
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier><type>uint8_t</type>
                    <varname>a24UserBlock</varname><initializer>0x3b</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The VME standad refers to this as
                        <firstterm>Standard Non-privileged Block</firstterm>.
                        Block transfer address modifiers allow the master to
                        improve performance by only requiring an address cycle
                        at the start of the first transfer and as the block
                        transfer crosses 256 byte address boundaries.
                    </para>
                    <para>
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier><type>uint8_t</type>
                    <varname>a24PrivData</varname><initializer>0x3d</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The VME standard refers to ths as
                        <firstterm>Standard Supervisory Data</firstterm>
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier><type>uint8_t</type>
                    <varname>a24PrivProgram</varname><initializer>0x3e</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The VME standard refers to this as
                        <firstterm>Standard Supervisory Program</firstterm>
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <fieldsynopsis>
                    <modifier>static const</modifier><type>uint8_t</type>
                    <varname>a24PrivBlock</varname><initializer>0x3f</initializer>
                </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The VME standard refers to this as
                        <firstterm>Standard Supervisory Block</firstterm>.
                        Block transfer address modifiers allow the master to
                        improve performance by only requiring an address cycle
                        at the start of the first transfer and as the block
                        transfer crosses 256 byte address boundaries.
                    </para>
                    <para>
                        VME bus provides for privileged and non-privileged access
                        modes as well as program and data access modes.
                    </para>
                    <para>
                        Check the documentation of your target to see which
                        address modifiers are accetpable.
                    </para>
                </listitem>
            </varlistentry>
           </variablelist>
        </refsect1>
     </refentry>
	 <refentry id="vmusb3-CVMUSBRemote">
       <refmeta>
          <refentrytitle id='vmusb3-CVMUSBRemote-title'>CVMUSBRemote</refentrytitle>
          <manvolnum>3vmusb</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CVMUSBRemote</refname>
          <refpurpose>Execute lists remotely on VMUSBReadout</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>
#include &lt;CVMUSBRemote.h&gt;

class <ooclass><classname>CVMUSBRemote</classname></ooclass> {
    <constructorsynopsis>
        <methodname>CVMUSBRemote</methodname>
        <methodparam>
            <type>std::string</type> <parameter>deviceName</parameter>
            <initializer>"vmusb"</initializer>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>host</parameter>
            <initializer>"localhost"</initializer>
        </methodparam>
        <methodparam>
            <type>unsigned int</type> <parameter>port</parameter>
            <initializer>27000</initializer>
        </methodparam>
    </constructorsynopsis>
    <destructorsynopsis>
        <modifier>virtual</modifier><methodname>~CVMUSBRemote</methodname><void />
    </destructorsynopsis>
    <methodsynopsis>
        <type>uint32_t</type> <methodname>readFirmwareID</methodname><void />
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname>writeGlobalMode</methodname>
        <methodparam>
            <type>uint16_t</type><parameter>value)</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>uint16_t</type><methodname>readGlobalMode</methodname><void />
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname>writeDAQSettings</methodname>
        <methodparam>
            <type>uint32_t</type> <parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>uint32_t</type> <methodname>readDAQSettings</methodname><void />
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname>writeLEDSource</methodname>
        <methodparam>
            <type>uint32_t</type> <parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>uint32_t</type> <methodname>readLEDSource</methodname>
        <void />
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname>writeDeviceSource</methodname>
        <methodparam>
            <type>uint32_t</type> <parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>uint32_t</type> <methodname>readDeviceSource</methodname><void />
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname>writeDGG_A</methodname>
        <methodparam>
            <type>uint32_t</type> <parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>uint32_t</type><methodname>readDGG_A</methodname>
        <void />
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname>writeDGG_B</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>uint32_t</type> <methodname>readDGG_B</methodname>
        <void />
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname>writeDGG_Extended</methodname>
        <methodparam>
            <type>uint32_t</type> <parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>uint32_t</type> <methodname>readDGG_Extended</methodname>
        <void />
    </methodsynopsis>
    <methodsynopsis>
        <type>uint32_t</type><methodname>readScalerA</methodname>
        <void />
    </methodsynopsis>
    <methodsynopsis>
        <type>uint32_t</type><methodname>readScalerB</methodname>
        <void />
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname>writeVector</methodname>
        <methodparam>
            <type>int</type> <parameter>which</parameter>
            </methodparam>
        <methodparam>
            <type>uint32_t</type> <parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>uint32_t</type><methodname>readVector</methodname>
        <methodparam>
            <type>int</type> <parameter>which</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname>writeBulkXferSetup</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>uint32_t</type><methodname>readBulkXferSetup</methodname>
        <void />
    </methodsynopsis>
    <methodsynopsis>
        <type>int</type> <methodname>vmeWrite32</methodname>
        <methodparam>
            <type>uint32_t</type> <parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>aModifier</parameter>
        </methodparam>
        <methodparam>
            <type>uint32_t</type><parameter>data</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>int</type><methodname>vmeRead32</methodname>
        <methodparam>
            <type>uint32_t</type> <parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>aModifier</parameter>
        </methodparam>
        <methodparam>
            <type>uint32_t*</type> <parameter>data</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>int</type><methodname>vmeWrite16</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>aModifier</parameter>
        </methodparam>
        <methodparam>
            <type>uint16_t</type><parameter>data</parameter>
        </methodparam>
        </methodsynopsis>
    <methodsynopsis>
        <type>int</type><methodname>vmeRead16</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type> <parameter>aModifier</parameter>
        </methodparam>
        <methodparam>
            <type>uint16_t*</type><parameter>data</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>int</type> <methodname>vmeWrite8</methodname>
        <methodparam>
            <type>uint32_t</type> <parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>aModifier</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>data</parameter>
        </methodparam>
        </methodsynopsis>
    <methodsynopsis>
        <type>int</type> <methodname>vmeRead8</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
            </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>aModifier</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t*</type> <parameter>data</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>int</type><methodname>vmeBlockRead</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>baseAddress</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>aModifier</parameter>
            </methodparam>
        <methodparam>
            <type>void*</type><parameter>data</parameter>
        </methodparam>
        <methodparam>
            <type>size_t</type><parameter>transferCount</parameter>
        </methodparam>
        <methodparam>
            <type>size_t*</type><parameter>countTransferred</parameter>
        </methodparam>
        </methodsynopsis>
    <methodsynopsis>
        <type>int</type><methodname>vmeFifoRead</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type> <parameter>aModifier</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type><parameter>data</parameter>
        </methodparam>
        <methodparam>
            <type>size_t</type><parameter>transferCount</parameter>
        </methodparam>
        <methodparam>
            <type>size_t*</type><parameter>countTransferred</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>int</type><methodname>vmeReadBlockCount8</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint32_t</type> <parameter>mask</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>amod</parameter>
        </methodparam>
        </methodsynopsis>
    <methodsynopsis>
        <type>int</type><methodname>vmeReadBlockCount16</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint32_t</type><parameter>mask</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>amod</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>int</type> <methodname>vmeReadBlockCount32</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint32_t</type><parameter>mask</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>amod</parameter>
        </methodparam>
        </methodsynopsis>
    <methodsynopsis>
        <type>int</type><methodname>vmeVariableBlockRead</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>amod</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type><parameter>data</parameter>
        </methodparam>
        <methodparam>
            <type>size_t</type><parameter>maxCount</parameter>
        </methodparam>
        <methodparam>
            <type>size_t*</type><parameter>countTransferred</parameter>
            </methodparam>
        </methodsynopsis>
    <methodsynopsis>
        <type>int</type><methodname>vmeVariableFifoRead</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>amod</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type><parameter>data</parameter>
        </methodparam>
        <methodparam>
            <type>size_t</type><parameter>maxCount</parameter>
            </methodparam>
        <methodparam>
            <type>size_t*</type><parameter>countTransferred</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>int</type><methodname>executeList</methodname>
        <methodparam>
            <type>CVMUSBReadoutList&amp;</type><parameter>list</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type><parameter>pReadBuffer</parameter>
        </methodparam>
        <methodparam>
            <type>size_t</type><parameter>readBufferSize</parameter>
        </methodparam>
        <methodparam>
            <type>size_t*</type><parameter>bytesRead</parameter>
        </methodparam>
    </methodsynopsis>


    // Register bit definintions.

public:
    class <ooclass><classname>RegisterOffsets</classname></ooclass> {
    public:
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>FIDRegister</varname><initializer>0</initializer>
            </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>GMODERegister</varname><initializer>4</initializer>
            </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>DAQSetRegister</varname><initializer>8</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>LEDSrcRegister</varname><initializer>0xc</initializer>
            </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>DEVSrcRegister</varname><initializer>0x10</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>DGGARegister</varname><initializer>0x14</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>DGGBRegister</varname><initializer>0x18</initializer>
            </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>ScalerA</varname><initializer>0x1c</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>ScalerB</varname><initializer>0x20</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>ExtractMask</varname><initializer>0x24</initializer>
            </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>ISV12</varname><initializer>0x28</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>ISV34</varname><initializer>0x2c</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>ISV56</varname><initializer>0x30</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>ISV78</varname><initializer>0x34</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>DGGExtended</varname><initializer>0x38</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>USBSetup</varname><initializer>0x3c</initializer>
            </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>USBVHIGH1</varname><initializer>0x40</initializer>
            </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>USBVHIGH2</varname><initializer>0x44</initializer>
        </fieldsynopsis>
    };

    class <ooclass><classname>ActionRegister</classname></ooclass>
    public:
        <fieldsynopsis>        
            <modifier>static const</modifier><type>uint16_t</type>
            <varname>startDAQ</varname><initializer>1</initializer>
            </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>uint16_t</type>
            <varname>usbTrigger</varname><initializer>2</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>uint16_t</type>
            <varname>clear</varname><initializer>4</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>uint16_t</type>
            <varname>sysReset</varname><initializer>8</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>uint16_t</type>
            <varname>scalerDump</varname><initializer>0x10</initializer>
        </fieldsynopsis>
    };
   class <ooclass><classname>FirmwareRegister</classname></ooclass> {
    public:
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>minorRevMask</varname><initializer>0x000000ff</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>minorRevShift</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>majorRevMask</varname><initializer>0x0000ff00</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>majorRevShift</varname><initializer>8</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>betaVersionMask</varname><initializer>0x00ff0000</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>betaVersionShift</varname><initializer>16</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>yearMask</varname><initializer>0x0f000000</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>yearShift</varname><initializer>24</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>monthMask</varname><initializer>0xf0000000</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>monthshift</varname><initializer>27</initializer>
    </fieldsynopsis>
    };

    class <ooclass><classname>GlobalModeRegister</classname></ooclass> {
    public:
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLenMask</varname><initializer>0xf</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLenShift</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLen13K</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLen8K</varname><initializer>1</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLen4K</varname><initializer>2</initializer>
        </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLen2K</varname><initializer>3</initializer>
        </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLen1K</varname><initializer>4</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLen512</varname><initializer>5</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLen256</varname><initializer>6</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLen128</varname><initializer>7</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLen64</varname><initializer>8</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLenSingle</varname><initializer>9</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>mixedBuffers</varname><initializer>0x20</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>doubleSeparater</varname><initializer>0x40</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>align32</varname><initializer>0x80</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>doubleHeader</varname><initializer>0x100</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>flushScalers</varname><initializer>0x200</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>busReqLevelMask</varname><initializer>0x7000</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>busReqLevelShift</varname><initializer>12</initializer>
    </fieldsynopsis>
    };
    class <ooclass><classname>DAQSettingsRegister</classname></ooclass> {
    public:
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>readoutTriggerDelayMask</varname><initializer>0xff</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>readoutTriggerDelayShift</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>scalerReadoutPeriodMask</varname><initializer>0xff00</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>scalerReadoutPeriodShift</varname><initializer>8</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>scalerReadoutFrequenyMask</varname><initializer>0xffff0000</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>scalerReadoutFrequencyShift</varname><initializer>16</initializer>
    </fieldsynopsis>
    };
    class <ooclass><classname>LedSourceRegister</classname></ooclass> {
    public:
        // Top yellow led:
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>topYellowOutFifoNotEmpty</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>topYellowInFifoNotEmpty</varname><initializer>1</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>topYellowScalerEvent</varname><initializer>2</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>topYellowInFifoFull</varname><initializer>3</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>topYellowDTACK</varname><initializer>4</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>topYellowBERR</varname><initializer>5</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>topYellowBusRequest</varname><initializer>6</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>topYellowBusGranted</varname><initializer>7</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>topYellowInvert</varname><initializer>0x8</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>topYellowLatch</varname><initializer>0x10</initializer>
    </fieldsynopsis>

        // Red LED:
        
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>redEventTrigger</varname><initializer>(0 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>redNimInput1</varname><initializer>(1 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>redNimInput2</varname><initializer>(2 &lt;&lt; 8)</initializer>
        </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>redBusy</varname><initializer>(3 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>redDTACK</varname><initializer>(4 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>redBERR</varname><initializer>(5 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>redBusRequest</varname><initializer>(6 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>redBusGranted</varname><initializer>(7 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>redInvert</varname><initializer>(8 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>redLatch</varname><initializer>(0x10 &lt;&lt; 8)</initializer>
    </fieldsynopsis>

        // Green led:

    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>greenAcquire</varname><initializer>(0 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>greenStackNotEmpty</varname><initializer>(1 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>greenEventReady</varname><initializer>(2 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>greenEventTrigger</varname><initializer>(3 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>greenDTACK</varname><initializer>(4 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>greenBERR</varname><initializer>(5 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>greenBusRequest</varname><initializer>(6 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>greenBusGranted</varname><initializer>(7 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>greenInvert</varname><initializer>(8 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>greenLatch</varname><initializer>(0x10 &lt;&lt; 16)</initializer>
    </fieldsynopsis>

        // Bottom yellow LED

    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>bottomYellowNotArbiter</varname><initializer>(0 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>bottomYellowUsbTrigger</varname><initializer>(1 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>bottomYellowUSBReset</varname><initializer>(2 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>bottomYellowBERR1</varname><initializer>(3 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>bottomYellowDTACK</varname><initializer>(4 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>bottomYellowBERR</varname><initializer>(5 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>bottomYellowBusRequest</varname><initializer>(6 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>bottomYellowBusGranted</varname><initializer>(7 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>bottomYellowInvert</varname><initializer>(8 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>bottomYellowLatch</varname><initializer>(0x10 &lt;&lt; 24)</initializer>
    </fieldsynopsis>

    };
    class <ooclass><classname>CVMUSB::DeviceSourceRegister</classname></ooclass> {
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1Busym</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1Trigger</varname><initializer>1</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1BusRequest</varname><initializer>2</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1EventToBuffer</varname><initializer>3</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1DGGA</varname><initializer>4</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1DGGB</varname><initializer>5</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1EndOfEvent</varname><initializer>6</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1UsbTrigger</varname><initializer>7</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1Invert</varname><initializer>8M</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1Latch</varname><initializer>0x10</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2UsbTrigger1</varname><initializer>(0 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2VMEExecuting</varname><initializer>(1 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2VMEAS</varname><initializer>(2 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2DataToUsbFIFO</varname><initializer>(3 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2DGGA</varname><initializer>(4 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2DGGB</varname><initializer>(5 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2EndOfEvent</varname><initializer>(6 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2UsbTrigger</varname><initializer>(7 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2Invert</varname><initializer>(8 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2Latch</varname><initializer>(0x10 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerADisabled</varname><initializer>(0   &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerANIMI1</varname><initializer>(1   &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerANIMI2</varname><initializer>(2   &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerAEvent</varname><initializer>(2   &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerAEnable</varname><initializer>(8   &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerAReset</varname><initializer>(0x10 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBDisabled</varname><initializer>(0   &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBNIMI1</varname><initializer>(1   &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBNIMI2</varname><initializer>(2   &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBEvent</varname><initializer>(2   &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBEnable</varname><initializer>(8   &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBReset</varname><initializer>(0x10 &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggADisabled</varname><initializer>(0   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggANIMI1</varname><initializer>(1   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggANIMI2</varname><initializer>(2   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggAEventTrigger</varname><initializer>(3   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggAEndOfEvent</varname><initializer>(4   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggAUsbTrigger</varname><initializer>(5   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggAPulser</varname><initializer>(6   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBDisabled</varname><initializer>(0   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBNIMI1</varname><initializer>(1   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBNIMI2</varname><initializer>(2   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBEventTrigger</varname><initializer>(3   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBEndOfEvent</varname><initializer>(4   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBUsbTrigger</varname><initializer>(5   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBPulser</varname><initializer>(6   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    };
    class <ooclass><classname>CVMUSB::DGGAndPulserRegister</classname></ooclass> {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>dggFineDelayMask</varname><initializer>0xffff</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>dggFineDelayShift</varname><initializer>0</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>dggGateWidthMask</varname><initializer>0xffff0000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>dggGateWidthShift</varname><initializer>16</initializer>
        </fieldsynopsis>
    
    };
    class <ooclass><classname>CVMUSB::DGGCoarseRegister</classname></ooclass> {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>ACoarseMask</varname><initializer>0xffff</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>ACoarseShift</varname><initializer>0</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BCoarseMask</varname><initializer>0xffff0000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BCoarseShift</varname><initializer>16</initializer>
        </fieldsynopsis>
    
    }; 
    class <ooclass><classname>CVMUSB::ISVRegister</classname></ooclass> {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AVectorMask</varname><initializer>= 0xff</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AVectorShift</varname><initializer>0</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AIPLMask</varname><initializer>0x700</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AIPLShift</varname><initializer>8</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AStackIDMask</varname><initializer>0x7000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AStackIDShift</varname><initializer>12</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BVectorMask</varname><initializer>0xff0000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BVectorShift</varname><initializer>16</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BIPLMask</varname><initializer>0x7000000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BIPLShift</varname><initializer>24</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BStackIDMask</varname><initializer>0x70000000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BStackIDShift</varname><initializer>28</initializer>
        </fieldsynopsis>
    };
    class <ooclass><classname>CVMUSB::TransferSetupRegister</classname></ooclass> {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>multiBufferCountMask</varname><initializer>0xff</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>multiBufferCountShift</varname><initializer>0</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>timeoutMask</varname><initializer>0xf00</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>timeoutShift</varname><initializer>8</initializer>
        </fieldsynopsis>
    };

}; 
 
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            Provides remote access to the VM-USB via the VMUSBReadout's
            slow controls server.  This class is a proxy and transparently
            performs network operations with the slow control server to
            execute each method.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <para>
            With the exception of the constructor, please refer to
            <link linkend='vmusb3-CVMUSB' endterm='vmusb3-CVMUSB-title' />
            for per method documentation.
            The constructor forms a connection with the VMUSBReadout's
            control server or throws an exception if that is not possible.
          </para>
          <para>
            The parameter constrcutors are:
          </para>
          <variablelist>
            <varlistentry>
                <term>
                    <fieldsynopsis>
                        <type>std::string</type> <varname>deviceName</varname>
                        <initializer>"vmusb"</initializer>
                    </fieldsynopsis>
                    </term>
                <listitem>
                    <para>
                        The n ame of the device driver to direct requests to.
                        This is the name of the driver instance
                        created by the <command>Module</command> command
                        in the control configuration file.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <fieldsynopsis>
                        <type>std::string</type> <varname>host</varname>
                        <initializer>"localhost"</initializer>
                    </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The host in which the readout software is running.
                    </para>
                    </listitem>
                </varlistentry>
            <varlistentry>
                <term>
                    <fieldsynopsis>
                        <type>unsigned int</type> <varname>port</varname>
                        <initializer>27000</initializer>
                    </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The port on which the control server is running.
                    </para>
                </listitem>
            </varlistentry>
          </variablelist>
       </refsect1>
     </refentry>     
         
        <refentry id="vmusb3-CConfigurableObject">
          <refmeta>
             <refentrytitle>CConfigurableObject</refentrytitle>
             <manvolnum>3vmusb</manvolnum>
          </refmeta>
          <refnamediv>
             <refname>CConfigurableObject</refname>
             <refpurpose>Configuration database</refpurpose>
          </refnamediv>
          <refsynopsisdiv>
           <synopsis>
#include &lt;CConfigurableObject.h&gt;
class <ooclass><classname>CConfigurableObject</classname></ooclass>
{
    <constructorsynopsis>
      <methodname>CConfigurableObject</methodname>
      <methodparam>
          <type>std::string</type> <parameter>name</parameter>
      </methodparam>
    </constructorsynopsis>
    <constructorsynopsis>
        <methodname>CConfigurableObject</methodname>
        <methodparam>
            <modifier>const</modifier> <type>CConfigurableObject&amp;</type>
            <parameter>rhs</parameter>
        </methodparam>
    </constructorsynopsis>
    <methodsynopsis>
        <type>std::string</type><methodname>getName</methodname>
        <void /><modifier>const</modifier>
    </methodsynopsis>
    <methodsynopsis>
        <type>std::string</type> <methodname>cget</methodname>
        <methodparam>
            <type>std::string</type><parameter>name</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>ConfigurationArray</type> <methodname>cget</methodname>
        <void />
    </methodsynopsis>
    <methodsynopsis>
        <type>int</type> <methodname>getIntegerParameter</methodname>
        <methodparam>
            <type>std::string</type><parameter>name</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>unsigned int</type> <methodname>getUnsignedParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>bool</type> <methodname>getBoolParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>double</type> <methodname>getFloatParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>std::vector&lt;int&gt;</type> <methodname>getIntegerList</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type> <methodname>addParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>typeChecker</type> <parameter>checker</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>defaultValue</parameter>
            <initializer>std::string(""))</initializer>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type> <methodname>clearConfiguration</methodname>
        <void />
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type> <methodname>configure</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type> <methodname>addIntegerParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>int</type> <parameter>defaultVal</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type>
        <methodname>addIntegerParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>int</type> <parameter>low</parameter>
        </methodparam>
        <methodparam>
            <type>int </type> <parameter>high</parameter>
        </methodparam>
        <methodparam>
            <type>int</type>    <parameter>defaultVal</parameter>
            <initializer>0</initializer>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname> addBooleanParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>bool</type> <parameter>defaultVal</parameter>
            <initializer>true</initializer>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname> addEnumParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>const char**</type> <parameter>pValues</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>defaultValue</parameter>
            <initializer>std::string(""))</initializer>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type> <methodname>addBoolListParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>size</parameter>
        </methodparam>
        <methodparam>
            <type>bool</type> <parameter>defaultVal</parameter>
            <initializer>true</initializer>
        </methodparam>
    </methodsynopsis>  
    <methodsynopsis>
        <type>void</type> <methodname>addBoolListParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>minLength</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>maxLength</parameter>
        </methodparam>
        <methodparam>
            <type>bool</type> <parameter>defaultVal</parameter>
            <initializer>true</initializer>
        </methodparam>
        <methodparam>
            <type>int</type> <parameter>defaultSize</parameter>
            <initializer>-1</initializer>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type> <methodname>addIntListParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>size</parameter>
        </methodparam>
        <methodparam>
            <type>int</type> <parameter>defaultVal</parameter>
            <initializer>0</initializer>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type> <methodname>addIntListParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>minlength</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>maxLength</parameter>
        </methodparam>
        <methodparam>
            <type>int</type> <parameter>defaultVal</parameter>
            <initializer>0</initializer>
        </methodparam>
        <methodparam>
            <type>int</type> <parameter>defaultSize</parameter>
            <initializer>-1</initializer>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>void</type>
        <methodname>addIntListParam</methodname>
        <methodparam><type>std::string</type> <parameter>name</parameter></methodparam>
        <methodparam><type>int</type> <parameter>minvalue</parameter></methodparam>
        <methodparam><type>int</type> <parameter>maxvalue</parameter></methodparam>
        <methodparam><type>unsigned</type> <parameter>minlength</parameter></methodparam>
        <methodparam><type>unsigned</type> <parameter>maxlength</parameter></methodparam>
         <methodparam>
            <type>int</type> <parameter>defaultVal</parameter>
        </methodparam>
        <methodparam>
            <type>int</type> <parameter>defaultSize</parameter>
        </methodparam>       
        
        <exceptionname></exceptionname>
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <type>void</type> <methodname>addStringListParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>size</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type><parameter>defaultVal</parameter>
            <initializer>""</initializer>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type> <methodname>addStringListParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>minLength</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>maxLength</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>defaultVal</parameter>
            <initializer>""</initializer>
        </methodparam>
        <methodparam>
            <type>int</type> <parameter>defaultLength</parameter>
            <initializer>-1</initializer>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier><type>bool</type> <methodname>isInteger</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type><methodname> isBool</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type><methodname> isEnum</methodname>
        <methodparam>
            <type>std::string</type><parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type><parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type><methodname> isFloat</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier><type>bool</type>
        <methodname>isList</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type><parameter> value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isBoolList</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isIntList</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isStringList</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>isEnumParameter</type>
        <methodname>makeEnumSet</methodname>
        <methodparam>
            <modifier>const</modifier> <type>char**</type> <parameter>values</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>>strToBool</methodname>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    
    typedef <type>std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt; ConfigurationArray</type>;
    
    struct  limit {
    <fieldsynopsis>
        <type>bool</type> <varname>s_checkMe</varname>
    </fieldsynopsis>
    <fieldsynopsis>
        <type>long</type> <varname>s_value</varname>
    </fieldsynopsis>
    <constructorsynopsis>
        <methodname>limit</methodname><void />
    </constructorsynopsis>
    <constructorsynopsis><methodname>limit</methodname>
        <methodparam>
            <type>long</type> <parameter>value</parameter>
        </methodparam>
    </constructorsynopsis>

  typedef <type>std::pair&lt;limit, limit&gt;   LimitsM</type>
  typedef <type>std::set&lt;std::string&gt; isEnumParameter</type>
  
  typedef struct _ListSizeConstraint {
    <fieldsynopsis>
        <type>limit</type> <varname>s_atLeast</varname>
    </fieldsynopsis>
    <fieldsynopsis>
        <type>limit</type> <varname>s_atMost</varname>
    </fieldsynopsis>    
  } ListSizeConstraint;

  struct isListParameter {
  <fieldsynopsis>
    <type>ListSizeConstraint</type> <varname>s_allowedSize</varname>
  </fieldsynopsis>
  <fieldsynopsis>
    <type>TypeCheckInfo</type> <varname>s_checker</varname>
  </fieldsynopsis>
  <constructorsynopsis>
    <methodname>isListParameter</methodname>
    <methodparam>
        <type>limit</type> <parameter>atLeast</parameter>
    </methodparam>
    <methodparam>
        <type>limit</type> <parameter>atMost</parameter>
    </methodparam>
    <methodparam>
        <type>TypeCheckInfo</type> <parameter>checker</parameter>
    </methodparam>
  </constructorsynopsis>
  <constructorsynopsis>
    <methodname>isListParameter</methodname>
    <methodparam>
        <type>ListSizeConstraint</type> <parameter>limits</parameter>
    </methodparam>
    <methodparam>
        <type>TypeCheckInfo</type> <parameter>checker</parameter>
    </methodparam>
  </constructorsynopsis>
  <constructorsynopsis>
    <methodname>isListParameter</methodname>
    <void />
  </constructorsynopsis>
  
  };
    
  struct  flimit {
  <fieldsynopsis>
    <type>bool</type> <varname>s_checkMe</varname>
  </fieldsynopsis>
  <fieldsynopsis>
    <type>float</type> <varname>s_value</varname>
  </fieldsynopsis>
  <constructorsynopsis>
    <methodname>flimit</methodname><void />
  </constructorsynopsis>
  <constructorsynopsis>
    <methodname>flimit</methodname>
    <methodparam>
        <type>float</type> <parameter>value</parameter>
    </methodparam>
  </constructorsynopsis>
  };
  
  typedef <type>?std::pair&lt;flimit, flimit&gt;</type> <varname>FloatingLimits</varname>;
  typedef <type>std::vector&lt;isEnumParameter*&gt;</type> <varname>EnumCheckers</varname>;

}

           </synopsis>
          </refsynopsisdiv>
          <refsect1>
             <title>DESCRIPTION</title>
             <para>
                Each VM-USB device driver object contains an instance of
                a <classname>CConfigurableObject</classname>.  The driver
                defines its configuration parameters within that object and
                the object is transparently hooked into the driver command's
                config and cget methods so that the driver code does not have
                to worry about handling those commands.
             </para>
             <para>
                <classname>CConfigurableObject</classname> provides mechanisms
                for not only defining and retrieving configuration parameters, but
                for enforcing constraints on those parameters.  Constraint checking
                can include not only checking the type of a parameter but
                checking for completely arbitrary constraints on the values
                of the confgiguration parameter.
             </para>
             <para>
                Constraint checking is accomplished by associating a validity
                checking function with each parameter.  A set of pre-defined
                validity checking functions, implemented as static class methods
                mean that for most cases you don't need to define your own
                constraint checkers.
             </para>
             <para>
                Another side enforcing strong parameter typing and constraints is
                a set of parameter getters that transparently convert the
                string representation of a parameter to a form that is meaningful
                to the driver.
            </para>
            <para>
                As a simple example, consider a threshold value that must be
                an integer in the range of <literal>[0..4095]</literal>.
                This can be easily defined as a configuration parameter that
                uses the predefined <methodname>isInteger</methodname>
                constraint checker passed an appropriate limit checking
                structure.  When retrieving the paramter, since the <command>config</command>
                subcommand has already perfromed type and range checking, the
                driver can simply use <methodname>getIntegerParameter</methodname>
                to retrieve the parameter value without worrying about
                having any illegal values for the parameter.
            </para>
          </refsect1>
          <refsect1>
             <title>
            METHODS
             </title>
             <para>
                This section describes the bulk of the methods provided by
                <classname>CConfigurableObject</classname>.  The sections
                UTILITY METHODS and BUILT IN TYPE CHECKERS provide information
                about utility methods provided to objects and the built in
                constraint checking methods respetively.
             </para>
             <variablelist>
                <varlistentry>
                    <term><constructorsynopsis>
                    <methodname>CConfigurableObject</methodname>
                    <methodparam>
                        <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                  </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Basic constructor for a configurable object.
                            Each configuratino has a <parameter>name</parameter>
                            under which it is registered with the device configuration
                            database.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>std::string</type><methodname>getName</methodname>
                            <void /><modifier>const</modifier>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the name of the configuable object.
                                
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>std::string</type> <methodname>cget</methodname>
                            <methodparam>
                                <type>std::string</type><parameter>name</parameter>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                All configuration values are stored as strings.
                                This method returns the configuration value of
                                the configuration parameter named <parameter>name</parameter>.
                            </para>
                            <para>
                                Note  that other methods exist that convert the
                                string ot a more natural type given for
                                parameters with specific semantics.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>ConfigurationArray</type> <methodname>cget</methodname>
                            <void />
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns a <classname>ConfigurationArray</classname>
                                that contains the entire device configuration.
                                For information about the shape of a
                                <classname>CConfigurationArray</classname>  see
                                the TYPES section below.
                            </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>getIntegerParameter</methodname>
                            <methodparam>
                                <type>std::string</type><parameter>name</parameter>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the value of the configuration parameter
                                <parameter>name</parameter> converted to a
                                signed integer.  Care should be taken when
                                using this with a parameter that is not validated
                                vai <methodname>isIntegerParameter</methodname>.
                                If the underlying string is not a valid integer,
                                this method will throw a <type>std::string</type>
                                exception.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>unsigned int</type> <methodname>getUnsignedParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Same as <methodname>getIntegerParameter</methodname>
                                however the conversion is to an unsigned integer.
                                If your driver requires a
                                <option>-base</option> option, you should use
                                this method to retrieve that rather than
                                <methodname>getIntegerParameter</methodname>
                                to avoid overflow.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>bool</type> <methodname>getBoolParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the value of <parameter>name</parameter>
                                converted to a boolean.  Boolean parameters
                                should use <methodname>isBool</methodname>
                                as their constraint checkers.
                            </para>
                            <para>
                                In order to make boolean parameters more natural.
                                The following set of strings is acceepted as
                                <literal>true</literal>
                                <literal>{"true", "yes", "1", "on", "enabled"}</literal>
                                and <literal>false</literal> strings are in the
                                set:
                                <literal>{"false", "no", "0", "off", "disabled"}</literal>.
                            </para>
                            <para>
                                If the string value is not in one of those
                                two sets, a <type>std::string</type>
                                exception is thrown.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>double</type> <methodname>getFloatParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the parameter <parameter>name</parameter>
                                converted to a floating point value.  <parameter>name</parameter>
                                should be associated with the
                                <methodname>isFloat</methodname> constraint checker.
                                If, however it is not, an <type>std::string</type>
                                exception is thrown if the value does not have
                                a floating point representation.
                            </para>
                         </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>std::vector&lt;int&gt;</type> <methodname>getIntegerList</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This member function parses the value of
                                parameter <parameter>name</parameter> as a Tcl
                                list of integers and returns those integers
                                as a <type>std::vector&lt;int&gt;</type>.
                                This is most often used when a configuration
                                parameter is used to represent per channel
                                values for a digitizer.
                            </para>
                            <para>
                                Normally you will use this to process values
                                of parameters that use the <methodname>isList</methodname>
                                constraint checker with <methodname>isInteger</methodname>
                                specifies as a per element constraint chedker.
                            </para>
                            <para>
                                As with all parameter value getting methods, if
                                the value does not parse correctly (is not a
                                Tcl list or a list element is not an integer),
                                a <type>std::string</type> exception is thrown.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>addParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>typeChecker</type> <parameter>checker</parameter>
                            </methodparam>
                            <methodparam>
                                <type>void*</type> <parameter>arg</parameter>
                            </methodparam>
                            <methodparam>
                                <type>std::string</type> <parameter>defaultValue</parameter>
                                <initializer>std::string(""))</initializer>
                            </methodparam>
                        </methodsynopsis>
                        <methodsynopsis>
                            <type>void</type> <methodname>clearConfiguration</methodname>
                            <void />
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Adds a new parameter to the configurable object.
                                This parameter will be reported in
                                <command>cget</command> subcommands and
                                can be modified in <command>config</command>
                                subcomands.
                            </para>
                            <para>
                                The <parameter>name</parameter> parameter is
                                the name fo the new parameter. By convention,
                                the first character of a configuration option
                                is a hyphen (<literal>-</literal>), although
                                the configurable object makes no such restriction.
                            </para>
                            <para>
                                <parameter>defaultValue</parameter> specifies
                                the initial value given to this variable.
                                Careful thought about initial/default values
                                allows users to minimize the number of
                                configuration options they actually need to set.
                            </para>
                            <para>
                                <parameter>checker</parameter> and
                                <parameter>arg</parameter> specify the constraint
                                checking that is performed on a parameter when
                                the configuration script attempts to modify it.
                                <parameter>checker</parameter> is a function that
                                is expected to check the proposed new value for
                                validity.  <parameter>arg</parameter> is a
                                parameter that is passed, without interpretation,
                                to the checker.  See TYPE CHECKERS below for
                                more information about constraint checking.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>configure</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>std::string</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Provides a new proposed <parameter>value</parameter>
                                to the configuration parameter <parameter>name</parameter>.
                                This method does not bypass constraint checks.
                                If the constraint check on the parameter fails,
                                a <type>std::string</type> error message exception
                                is thrown.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>addIntegerParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>defaultVal</parameter>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This is a convenience method that adds a new
                                parameter,
                                <parameter>name</parameter>,
                                to the configuration database.
                                The <methodname>isInteger</methodname>
                                constraint checker is associated with
                                the parameter, however no range limits are
                                specified.
                            </para>
                            <para>
                                The <parameter>defaultVal</parameter> is
                                used as the initial value of the parameter>
                            </para>
                        </listitem>    
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type>
                            <methodname>addIntegerParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>low</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int </type> <parameter>high</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type>    <parameter>defaultVal</parameter>
                                <initializer>0</initializer>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Same as the previous method, however
                                <parameter>low</parameter> and <parameter>high</parameter>
                                constrain the range of the integer value.
                                If you require an asymmetric range you have two choices.
                                Use <methodname>addParameter</methodname> and
                                fill in the parameter struct for <methodname>isInteger</methodname>
                                appropriately, or use one of
                                <literal>INT_MAX, INT_MIN, UINT_MAX</literal>
                                for the appropriate limit.  These values
                                are defined in <literal>&lt;limits.h&gt;</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type><methodname> addBooleanParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>bool</type> <parameter>defaultVal</parameter>
                                <initializer>true</initializer>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Adds a parameter <parameter>name</parameter>
                                whose value checked via
                                <methodname>isBool</methodname> to ensure
                                it is always a boolean value.
                                <parameter>defaultVal</parameter> is the
                                initial value given to the parameter.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type><methodname> addEnumParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>const char**</type> <parameter>pValues</parameter>
                            </methodparam>
                            <methodparam>
                                <type>std::string</type> <parameter>defaultValue</parameter>
                                <initializer>std::string(""))</initializer>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Adds a parameter <parameter>name</parameter>
                                whose type checker ensures that valid values
                                are constrained to be in the list of
                                strings in <parameter>pValues</parameter>.
                                The initial value of the parameter is
                                <parameter>defautltValue</parameter>
                            </para>
                            <para>
                                <parameter>pValues</parameter> is a null
                                terminated array of pointers to the legal strings.
                                These can be declared as shown below:
                            </para>
                            <informalexample>
                                <programlisting>
static const char* validEnums[] = {
"one", "two", "three", NULL
};
                                </programlisting>
                            </informalexample>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>addBoolListParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>unsigned</type> <parameter>size</parameter>
                            </methodparam>
                            <methodparam>
                                <type>bool</type> <parameter>defaultVal</parameter>
                                <initializer>true</initializer>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Adds a parameter <parameter>name</parameter> to
                                the configuration whose legal values are
                                lists of boolean parameters.  The list
                                is a fixed <parameter>size</parameter>.
                                The <parameter>defaultVal</parameter>
                                is the value that each element of the list is
                                initialized to.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>addBoolListParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>unsigned</type> <parameter>minLength</parameter>
                            </methodparam>
                            <methodparam>
                                <type>unsigned</type> <parameter>maxLength</parameter>
                            </methodparam>
                            <methodparam>
                                <type>bool</type> <parameter>defaultVal</parameter>
                                <initializer>true</initializer>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>defaultSize</parameter>
                                <initializer>-1</initializer>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Same as the previous method, however
                                the length of the list can vary between a
                                minimum length (<parameter>minLength</parameter>)
                                and a maximum length (<parameter>maxLength</parameter>).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>addIntListParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>unsigned</type> <parameter>size</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>defaultVal</parameter>
                                <initializer>0</initializer>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Adds a parameter <parameter>name</parameter>
                                that is checked to ensure it consists of a
                                list of integer values.  The size of the list
                                is fixed at <parameter>size</parameter>.
                                The initial value of all elements of the list
                                is set to <parameter>defaultValue</parameter>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>addIntListParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>unsigned</type> <parameter>minlength</parameter>
                            </methodparam>
                            <methodparam>
                                <type>unsigned</type> <parameter>maxLength</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>defaultVal</parameter>
                                <initializer>0</initializer>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>defaultSize</parameter>
                                <initializer>-1</initializer>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Same as the previous function however
                                the length of the list can vary between
                                <parameter>minlength</parameter> and
                                <parameter>maxLength</parameter> and the
                                list has an initial value of <parameter>defaultSize</parameter>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                                <methodsynopsis>
                                    <modifier></modifier>
                                    <type>void</type>
                                    <methodname>addIntListParam</methodname>
                                    <methodparam><type>std::string</type> <parameter>name</parameter></methodparam>
                                    <methodparam><type>int</type> <parameter>minvalue</parameter></methodparam>
                                    <methodparam><type>int</type> <parameter>maxvalue</parameter></methodparam>
                                    <methodparam><type>unsigned</type> <parameter>minlength</parameter></methodparam>
                                    <methodparam><type>unsigned</type> <parameter>maxlength</parameter></methodparam>
                                     <methodparam>
                                        <type>int</type> <parameter>defaultVal</parameter>
                                    </methodparam>
                                    <methodparam>
                                        <type>int</type> <parameter>defaultSize</parameter>
                                    </methodparam>       
                                    
                                    <exceptionname></exceptionname>
                                    <modifier></modifier>
                                </methodsynopsis>  
                        </term>
                        <listitem>
                            <para>
                                Same as the other <methodname>addIntListParam</methodname>
                                methods however <parameter>minvalue</parameter>
                                and <parameter>maxvalue</parameter>
                                place constraints on the value that can be given to each
                                element of the list.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>addStringListParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>unsigned</type> <parameter>size</parameter>
                            </methodparam>
                            <methodparam>
                                <type>std::string</type><parameter>defaultVal</parameter>
                                <initializer>""</initializer>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Adds a parameter <parameter>name</parameter> that
                                is a list of <parameter>size</parameter>   strings. Initially
                                each element of the list will have the value
                                <parameter>defautlVal</parameter>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>addStringListParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>unsigned</type> <parameter>minLength</parameter>
                            </methodparam>
                            <methodparam>
                                <type>unsigned</type> <parameter>maxLength</parameter>
                            </methodparam>
                            <methodparam>
                                <type>std::string</type> <parameter>defaultVal</parameter>
                                <initializer>""</initializer>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>defaultLength</parameter>
                                <initializer>-1</initializer>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Same as the previous method however the
                                length of the list can provide to a
                                <command>config</command> subcommand can be
                                between <parameter>minLength</parameter>
                                and <parameter>maxLength</parameter>. The initial
                                length will be <parameter>defaultLength</parameter>  .
                            </para>
                        </listitem>
                    </varlistentry>
             </variablelist>
        </refsect1>
        <refsect1>
          <title>
              UTILITY METHODS
          </title>
          <para>
              This section provides some simple
              utility methods.
          </para>
          <variablelist>
              <varlistentry>
                  <term>
                  <methodsynopsis>
                      <modifier>static</modifier> <type>isEnumParameter</type>
                      <methodname>makeEnumSet</methodname>
                      <methodparam>
                          <modifier>const</modifier>
                          <type>char**</type>
                          <parameter>values</parameter>
                      </methodparam>
                  </methodsynopsis>
                  </term>
                  <listitem>
                      <para>
                          Produces a data structure used
                          by the enumerated parameter checker
                          <methodname>isEnum</methodname>
                          decribing the legal options.
                          <parameter>values</parameter>
                          is an array of pointers to
                          acceptable strings.  The last pointer
                          must be a NULL value.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term>
                      <methodsynopsis>
                          <modifier>static</modifier>
                          <type>bool</type>
                          <methodname>>strToBool</methodname>
                          <methodparam>
                              <type>std::string</type>
                              <parameter>value</parameter>
                          </methodparam>
                      </methodsynopsis>
                      </term>
                      <listitem>
                          <para>
                              Converts a string to its
                              boolean representation or
                              throws a <type>std::string</type>
                              exception if the string does
                              not map to a bool.
                          </para>
                      </listitem>
                  </varlistentry>
          </variablelist>
  
          </refsect1>
          <refsect1>
            <title>
                TYPE CHECKERS
            </title>
            <para>
                A type checker is a function that can be passed to
                <methodname>addParameter</methodname> to check constraints on
                the value of a parameter. See below in BUILT IN TYPE CHECKERS
                for information about the constraint checkers that are
                available for drop in use.
            </para>
            <para>
                A type checker <function>myTypeChecker</function>
                function has the following signature:
            </para>
            <informalexample>
                <programlisting>
bool myTypeChecker(std::string name, std::string value, void* arg)
                </programlisting>
            </informalexample>
            <para>
                <parameter>name</parameter> is the name of the configuration
                parameter that is being checked.
            </para>
            <para>
                <parameter>value</parameter> is the proposed new string value
                for the parameter.
            </para>
            <para>
                <parameter>arg</parameter> is the
                <parameter>arg</parameter> parameter in the
                <methodname>addParameter</methodname> method.  While not always
                the case, this parameter usually is a pointer to some struct
                or object that further refines the constraint checking required.
                For example, for the <methodname>isInteger</methodname> pre-packaged
                checker, this parameter is a pointer to a struct that defines
                whichi limits should be checked and what those limit values
                are, where appropriate.
            </para>
            <para>
                Type checkers are supposed to return <literal>true</literal>
                if the constraints they are checking match,
                <literal>false</literal> otherwise.
            </para>
        </refsect1>
          <refsect1>
            <title>
                BUILT IN TYPE CHECKERS.
            </title>
            <para>
                A built in set of type checkers allows you to define the vast
                majority of parameters without any need to write your own
                type checking function.
            </para>
            <para>
                In the descriptions below, <parameter>arg</parameter>
                always refers to the <parameter>arg</parameter> parameter
                of the <methodname>addParameter</methodname> method. It will
                be referred to as the <firstterm>additional data</firstterm>
                parameter and described in the documentation for each
                checker.
            </para>
            <para>
                Note that all type checkers descdibed allow you to pass a
                <literal>NULL</literal> for the <parameter>args</parameter>
                parameter which means that the value of the
                parameter does not undergo any of the processing that is
                implied by the data normally pointed to by <parameter>arg</parameter>.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                <methodsynopsis>
                    <modifier>static</modifier><type>bool</type> <methodname>isInteger</methodname>
                    <methodparam>
                        <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <type>std::string</type> <parameter>value</parameter>
                    </methodparam>
                    <methodparam>
                        <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Checks that the proposed new value is a valid integer.
                        Optionally, depending on the <parameter>arg</parameter>
                        struct this function can also ensure that the
                        converted integer value of the new value meets
                        range constraints.
                    </para>
                    <para>
                        <parameter>arg</parameter> actually points to a
                        <type>Limits</type> which provides optional flags
                        and values to determine if a lower and/or an upper limit
                        should be checked and the limit values as well.
                        <type>Limits</type> is described fully in TYPES
                        below.
                    </para>
                </listitem>
            </varlistentry>
                <varlistentry>
                    <term>
                <methodsynopsis>
                    <modifier>static</modifier> <type>bool</type><methodname> isBool</methodname>
                    <methodparam>
                        <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <type>std::string</type> <parameter>value</parameter>
                    </methodparam>
                    <methodparam>
                        <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Type checker that determines if the proposed new value
                        has a valid conversion to a  <type>boolean</type>.
                        The <parameter>args</parameter> parameter is not used by
                        this checker.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <methodsynopsis>
                    <modifier>static</modifier> <type>bool</type><methodname> isEnum</methodname>
                    <methodparam>
                        <type>std::string</type><parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <type>std::string</type><parameter>value</parameter>
                    </methodparam>
                    <methodparam>
                        <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Ensures that the proposed new <parameter>value</parameter>
                        is an element of a set of allowed strings.  <parameter>args</parameter>
                        is actually a pointer to a <type>std::set&lt;std::string&gt;</type>
                        where the elements of that set are the allowed values of the
                        parameter.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <methodsynopsis>
                    <modifier>static</modifier> <type>bool</type><methodname> isFloat</methodname>
                    <methodparam>
                        <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <type>std::string</type> <parameter>value</parameter>
                    </methodparam>
                    <methodparam>
                        <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Requires that the proposed new parameter
                        <parameter>value</parameter> is a valid floating point
                        and optionally that it satisfies lower and/or upper
                        limit constraints.  The <parameter>arg</parameter>
                        parameter actually points to a
                        <type>FloatingLimits</type> struct.
                        See TYPES below for a description of that struct.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <methodsynopsis>
                    <modifier>static</modifier><type>bool</type>
                    <methodname>isList</methodname>
                    <methodparam>
                        <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <type>std::string</type><parameter> value</parameter>
                    </methodparam>
                    <methodparam>
                        <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This type checker requires that the proposed new
                        <parameter>value</parameter> is a valid Tcl list.
                        The <parameter>arg</parameter> parameter points to a
                        <type>isListParameter</type>.  This is described in
                        TYPES below.  The struct allows you to constrain the list
                        size as well as to provide an additional type checker
                        that is applied to each element of the list.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <methodsynopsis>
                    <modifier>static</modifier> <type>bool</type> <methodname>isBoolList</methodname>
                    <methodparam>
                        <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <type>std::string</type> <parameter>value</parameter>
                    </methodparam>
                    <methodparam>
                        <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is a simplified version of the previous function
                        that ensures that each element of the list
                        <parameter>value</parameter>is a
                        valid boolean.  The <parameter>arg</parameter>
                        parameter points to a <type>ListSizeConstraint</type>
                        which, as described in TYPES below, allows you to
                        place constraints on the length of the list.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <methodsynopsis>
                    <modifier>static</modifier> <type>bool</type> <methodname>isIntList</methodname>
                    <methodparam>
                        <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <type>std::string</type> <parameter>value</parameter>
                    </methodparam>
                    <methodparam>
                        <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        A specialized version of <methodname>isList</methodname>
                        that checks that all elements of a list parameter
                        are unbounded integers.  <parameter>arg</parameter>
                        is actually a pointer to a <type>ListSizeConstraint</type>
                        that allows you to place constraints of the size of the
                        list.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <methodsynopsis>
                    <modifier>static</modifier> <type>bool</type> <methodname>isStringList</methodname>
                    <methodparam>
                        <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <type>std::string</type> <parameter>value</parameter>
                    </methodparam>
                    <methodparam>
                        <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Checks only that a parameter is a valid Tcl List
                        constrained by the sizes specified by the
                        <type>ListSizeConstraint</type> pointed to by
                        <parameter>arg</parameter>
                    </para>
                </listitem>
            </varlistentry>
            </variablelist>
          </refsect1>
           <refsect1>
              <title>TYPES</title>
             <para>
                This section describes the data types that are exported
                 by the <classname>CConfigurableObject</classname>.
                 To a large extent, these are parameters to
                 constraint/type checkers described in the previous
                 secition.
             </para>
             <variablelist>
                <varlistentry>
                    <term>typedef <type>std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt;
                          ConfigurationArray</type>;
                    </term>
                    <listitem>
                        <para>
                          This type is returned from <methodname>getConfiguration</methodname>
                          It consists of an <type>std::vector</type>.  Each element
                          of the vector is a <type>std::pair</type>.   The
                          first element of the pair is a configuration parameter
                          name.  The second element of that pair is the
                          parameter value.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term> struct<type>limit</type></term>
                    <listitem>
                        <para>
                            Provides a struct that describes a single optional
                            limit. <varname>s_checkMe</varname> is a boolean
                            which is <literal>true</literal> if the
                            limit should be checked and
                            <varname>s_value</varname> is the limit value.
                        </para>
                        <para>
                            The Constructor <methodname>limit</methodname>
                            comes in two flavors.  Without a parameter it
                            initializes the struct so that <varname>s_checkme</varname>
                            is false.  With an integer parameter it initializes
                            <varname>s_checkme</varname> to <literal>true</literal>
                            and sets the limit value to the parameter value.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>typedef <type>std::pair&lt;limit, limit&gt;   Limits</type></term>
                    <listitem>
                        <para>
                            Defines a set of integer limits.  The first item in
                            the pair is the lower limit, the second item,
                            the upper limit.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>typedef <type>std::set&lt;std::string&gt; isEnumParameter</type></term>
                    <listitem>
                        <para>
                            A set of strings that constrain the legal values
                            of an enumerated parameter.
                            The <methodname>makeEnumSet</methodname> is a
                            conveniencde method that builds one of these
                            from a null terminated array of const char*
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>struct ListSizeConstraint</term>
                    <listitem>
                        <para>
                            Defines a constraint on the size of a list
                            parameter.  <varname>s_atLeast</varname>
                            is the smallest length the list can have,
                            <varname>s_atMost</varname> the longest length.
                            These values are inclusive so if you specify
                            <varname>s_atLeast</varname> = <varname>s_atMost</varname>,
                            the list will have a fixed length.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>struct <type>isListParameter</type></term>
                    <listitem>
                        <para>
                            Defines a fully constrained list.  The list size
                            is constrained by the <varname>s_allowedSize</varname>
                            field which is a <type>ListSizeConstraint</type>.
                            The contents of the list are constrainded by the
                            <varname>s_checker</varname> field which is
                            a <type>TypeCheckinfo</type> data item.
                        </para>
                        <para>
                            The <varname>s_checker</varname> is an
                            <type>std::pair</type> whose first elemnent
                            is a pointer to a typeChecker function and
                            whose second element is the user parameter
                            that is normally passed in to allow the type checker
                            to further constrain values.
                        </para>
                        <para>
                            Several constructors are supplied to help build
                            this structure:
                            <informalexample>
                                <programlisting>
  <constructorsynopsis>
    <methodname>isListParameter</methodname>
    <methodparam>
        <type>limit</type> <parameter>atLeast</parameter>
    </methodparam>
    <methodparam>
        <type>limit</type> <parameter>atMost</parameter>
    </methodparam>
    <methodparam>
        <type>TypeCheckInfo</type> <parameter>checker</parameter>
    </methodparam>
  </constructorsynopsis>
                                </programlisting>
                            </informalexample>
                            Allows you to specify the size limits and
                            <type>TypeCheckInfo</type> pair used to
                            initialize all of the fields.
                        </para>
                        <para>
                            <informalexample>
                                <programlisting>
  <constructorsynopsis>
    <methodname>isListParameter</methodname>
    <methodparam>
        <type>ListSizeConstraint</type> <parameter>limits</parameter>
    </methodparam>
    <methodparam>
        <type>TypeCheckInfo</type> <parameter>checker</parameter>
    </methodparam>
  </constructorsynopsis>
                                </programlisting>
                            </informalexample>
                            Provides a constructor you an use if  you already
                            have built up a <type>ListSizeConstraint</type>
                            that descsribes the constraints on the list size.
                        </para>
                        <para>
                            A default constructor is also provided that doe
                            <emphasis>no</emphasis> initialization of the
                            struct.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>struct <type>flimit</type></term>
                    <listitem>
                        <para>
                            This is analagous to the
                            <type>limit</type> described above, however
                            the <varname>s_value</varname> field is
                            a <type>float</type> rather than an
                            <type>int</type>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>typedef <type>?std::pair&lt;flimit, flimit&gt;</type> <varname>FloatingLimits</varname>;
                    </term>
                    <listitem>
                        <para>
                            Defines a pair of floating point limits that constrain
                            the value of a float parameter.
                        </para>
                    </listitem>
                </varlistentry>
             </variablelist>

           </refsect1>
           
        </refentry>
      <refentry id='vmusb3_ccontrolhardware'>
         <refmeta>
	   <refentrytitle id='vmusb3_ccontrolhardware_title'>CControlHardware</refentrytitle>
	   <manvolnum>3vmusb</manvolnum>
	 </refmeta>
	 <refnamediv>
	   <refname>CControlHardware</refname>
	   <refpurpose>Base class for slow controls drivers</refpurpose>
	 </refnamediv>
	 <refsynopsisdiv>
	   <synopsis>
	     #include &lt;CControlHardware.h&gt;
	     class <ooclass><classname>CControlHardware</classname></ooclass> {
             protected:
                 CControlModule* m_pConfig;
             public:
	         <constructorsynopsis>
		   <methodname>CControlModule</methodname>
		   <methodparam>
		     <type>std::string</type><parameter>name</parameter>
		   </methodparam>
		 </constructorsynopsis>
		 <methodsynopsis>
		   <type>CControlModule*</type> <methodname>getConifguration</methodname>
		   <void />
		 </methodsynopsis>
		 <methodsynopsis>
		   <modifier>virtual</modifier>
		   <type>void</type> <methodname>onAttach</methodname>
		   <methodparam>
		     <type>CControlModule&amp;</type> <parameter>configuration</parameter>
		   </methodparam>
		   <modifier> = 0</modifier>
		 </methodsynopsis>
		 <methodsynopsis>
		   <modifier>virtual</modifier>
		   <type>void</type> <methodname>Initialize</methodname>
		   <methodparam>
		     <type>CVMUSB&amp;</type> <parameter>vme</parameter>
		   </methodparam>
		   <modifier> = 0</modifier>
		 </methodsynopsis>
		 <methodsynopsis>
		   <modifier>virtual</modifier>
		   <type>std::string</type><methodname>Update</methodname>
		   <methodparam>
		     <type>CVMUSB&amp;</type> <parameter>vme</parameter>
		   </methodparam>
		 </methodsynopsis>
		 <methodsynopsis>
		   <modifier>virtual</modifier>
		   <type>std::string</type> <methodname>Set</methodname>
		   <methodparam>
		     <type>CVMUSB&amp;</type><parameter> vme</parameter>
		   </methodparam>
		   <methodparam>
		     <type>std::string</type> <parameter>parameter</parameter>
		   </methodparam>
		   <methodparam>
		     <type>std::string</type><parameter> value</parameter>
		   </methodparam>
		   <modifier>= 0</modifier>
		 </methodsynopsis>
		 <methodsynopsis>
		   <modifier>virtual</modifier>
                   <type>std::string</type><methodname>Get</methodname>
		   <methodparam>
		     <type>CVMUSB&amp;</type><parameter> vme</parameter>
		   </methodparam>
		   <methodparam>
		     <type>std::string</type> <parameter>parameter</parameter>
		   </methodparam>
		   <modifier> = 0</modifier>
		 </methodsynopsis>
		 <methodsynopsis>
		   <modifier>virtual</modifier>
		   <type>void</type> <methodname> clone</methodname>
		   <methodparam>
		     <modifier>const</modifier>
		     <type> CControlHardware&amp;</type> <parameter> rhs</parameter>
		   </methodparam>
		   <modifier>= 0</modifier>
		 </methodsynopsis>
		 <methodsynopsis>
		   <modifier>virtual</modifier>
		   <type>void</type> <methodname> addMonitorList</methodname>
		   <methodparam>
		     <type>CVMUSBReadoutList&amp;</type> <parameter> vmeList</parameter>
		   </methodparam>
		 </methodsynopsis>
		 <methodsynopsis>
		   <modifier>virtual</modifier>
		   <type>void*</type> <methodname>processMonitorList</methodname>
		   <methodparam>
		     <type>void*</type><parameter> pData</parameter>
		   </methodparam>
		   <methodparam>
		     <type>size_t</type><parameter> remaining</parameter>
		   </methodparam>
		 </methodsynopsis>
		 <methodsynopsis>
		   <modifier> virtual</modifier>
		   <type>std::string</type>
		   <methodname>getMonitoredData</methodname>
		   <void />
		 </methodsynopsis>
		 
	     };
           </synopsis>
         </refsynopsisdiv>
	 <refsect1>
	   <title>DESCRIPTION</title> 
	   <para>
	     <classname>CControlHardware</classname> is an abstract base class for
	     slow control drivers.  To build a driver one must build a concrete
	     derived class, a <classname>CModuleCreator</classname> and register 
	     them with the <classname>CModuleFactory</classname> which associates
	     a module type string with a creator.
	   </para>
	   <para>
	     The base class and its <classname>CControLModule</classname> take care
	     of configuration management, command dispatching and parameter marshalling
	     for the methods of this class.  This framework therefore frees people
	     writing controls support software from most tasks not directly related to
	     controlling their devices.
	   </para>
	   <para>
	     The driver framework supports get and set operations and these transparently 
	     interrupt data taking if active.  Thus a series of sets or gets performed
	     while data taking is active can take a substantial time as each get or set
	     will pause data taking, flush in-flight buffers, perform the operatin and then
	     resume data taking.
	   </para>
	   <para>
	     In addition to get and set operations, the driver supports using a periodically
	     triggered list to monitor device state.  This monitoring does
	     <emphasis>not</emphasis> impact data taking other than the time required to
	     execute the list.   This mechanism is normally used to support the recognition
	     of exceptional states in the hardware (e.g. trips in detector bias supplies).
	   </para>
	   <para>
	     Implementation of the set/get interface is mandatory (those methods are pure
	     virtual)  Implementation of the monitor list operations is optional, as there
	     are do-nothing default behaviors defined in this base class.
	   </para>
	 </refsect1>
        <refsect1>
            <title>METHODS</title>
            <variablelist>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                          <methodname>CControlModule</methodname>
                          <methodparam>
                            <type>std::string</type><parameter>name</parameter>
                          </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The base class constructor makes a correspondence between
                            the name of the module and the actual device.  Therefore
                            when you construct an object you should invoke this
                            base class constructor passing <parameter>name</parameter>
                            the name passed into your own constructor>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                          <type>CControlModule*</type> <methodname>getConifguration</methodname>
                          <void />
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Obtains the configuration object from the module.
                            Your own methods can refer directly to the
                            <varname>m_pConfig</varname> member variable.
                            See MEMBER DATA below for more information.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                          <modifier>virtual</modifier>
                          <type>void</type> <methodname>onAttach</methodname>
                          <methodparam>
                            <type>CControlModule&amp;</type> <parameter>configuration</parameter>
                          </methodparam>
                          <modifier> = 0</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This method must be implemented by concrete classes.
                            It is invoked as a new module instance is being
                            put together internally and hooked into the
                            slow controls server.  <parameter>configuration</parameter>
                            is the coniguration object.  Its address should be
                            stored in <varname>m_pConfig</varname> (see
                            MEMBER DATA) below.
                        </para>
                        <para>
                            This method should also be used to define any
                            configuration options you need.  Normally drivers will
                            define at least an option to allow the hardware to be
                            located.  For modules with base addressing this is
                            normally an option named <option>-base</option>
       H                 </para>
                    </listitem>
                </varlistentry>
		<varlistentry>
		  <term>
                        <methodsynopsis>
                          <modifier>virtual</modifier>
                          <type>void</type> <methodname>Initialize</methodname>
                          <methodparam>
                            <type>CVMUSB&amp;</type> <parameter>vme</parameter>
                          </methodparam>
                          <modifier> = 0</modifier>
                        </methodsynopsis>
		  </term>
		<listitem>
		  <para>
		    Optional method that can be implemented by concrete sub-classes.
		    The method is intended to do one-time initialization of the hardware
		    being controlled by this driver.  <parameter>vme</parameter>
		    is a reference to a VMUSB controller object.  This object can
		    perform VME operations on behalf of the method or execute
		    <classname>CVMUSBReadoutLists</classname> this method builds.
		  </para>
		  <para>
		    If this method is not implemented the base class method does nothing.
		  </para>
		</listitem>
	      </varlistentry>
	      <varlistentry>
		<term>
                        <methodsynopsis>
                          <modifier>virtual</modifier>
                          <type>std::string</type><methodname>Update</methodname>
                          <methodparam>
                            <type>CVMUSB&amp;</type> <parameter>vme</parameter>
                          </methodparam>
			  <modifier>= 0</modifier>
                        </methodsynopsis>
		</term>
		<listitem>
		  <para>
		    This method must be implemented by concrete sub-classes.
		    It is intended for use by drivers that work with devices that have 
		    write only state.  The method is called by clients that want to
		    push shadow data out to the write only state of the device.  Typically,
		    a device of this sort would have an initialization file that
		    describes the desired initial state of the device.  The <methodname>Update</methodname>
		    often is a means to push that state out to the device when the GUI starts and
		    reads in the same initializationfile.
		  </para>
		</listitem>
	      </varlistentry>
              <varlistentry>
                <term>
                        <methodsynopsis>
                          <modifier>virtual</modifier>
                          <type>std::string</type> <methodname>Set</methodname>
                          <methodparam>
                            <type>CVMUSB&amp;</type><parameter> vme</parameter>
                          </methodparam>
                          <methodparam>
                            <type>std::string</type> <parameter>parameter</parameter>
                          </methodparam>
                          <methodparam>
                            <type>std::string</type><parameter> value</parameter>
                          </methodparam>
                          <modifier>= 0</modifier>
                        </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method must be implemented by concrete sub-classes.
                        The framework will call this in response to a request
                        by a client to make a setting for this instance of the driver.
                        The <parameter>vme</parameter> object is a
                        <classname>CVMUSB</classname> object that can be used to
                        perform individual VME operations or execute immediate
                        <classname>CVMUSBReadoutList</classname> objects
                        created and filled by this method.
                    </para>
                    <para>
                        <parameter>parameter</parameter> is a string that specifies
                        the name of the parameter the client wants to set.
                        The parameter names that are supported by a driver are
                        up to the driver and hardware specific.  If the
                        client requests a parameter that is not supoprted an
                        error should be returned.
                    </para>
                    <para>
                        The <parameter>value</parameter> parameter is the
                        new value requested by the client.  If this value is
                        not legal for the parameter (e.g. a string that is not
                        an integer for an integer parameter), an error should
                        be returned.
                    </para>
                    <para>
                        The return value of this method is a
                        <classname>std::string</classname>.  On successful
                        completion this should be the value <literal>OK</literal>.
                        On failure, this should be a string that begins with
                        the word <literal>ERROR</literal> and, after some whitespace
                        provides a human readable message describing the error.
                    </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                        <methodsynopsis>
                          <modifier>virtual</modifier>
                          <type>std::string</type> <methodname>Get</methodname>		   
                          <methodparam>
                            <type>CVMUSB&amp;</type><parameter> vme</parameter>
                          </methodparam>
                          <methodparam>
                            <type>std::string</type> <parameter>parameter</parameter>
                          </methodparam>
                          <modifier> = 0</modifier>
                        </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method must be implemented by a concrete class.
                        It is invoked by the framework when a client requests the
                        value of a parameter from this instance of the driver.
                    </para>
                    <para>
                        <parameter>vme</parameter> is a <classname>CVMUSB</classname>
                        object that can be used to perform simple VME operations
                        or execute <classname>CVMUSBReadoutList</classname> objects
                        created by this method. 
                    </para>
                    <para>
                        <parameter>parameter</parameter> is the name of a parameter
                        supported by the driver.  The parameter names that are supported by a driver are
                        up to the driver and hardware specific.  If the
                        client requests a parameter that is not supoprted an
                        error should be returned.
                    </para>
                    <para>
                        The return value of this method is a
                        <classname>std::string</classname>.  On successful
                        completion this should be the value <literal>OK</literal>.
                        On failure, this should be a string that begins with
                        the word <literal>ERROR</literal> and, after some whitespace
                        provides a human readable message describing the error.
                    </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                          <methodsynopsis>
                            <modifier>virtual</modifier>
                            <type>void</type> <methodname> clone</methodname>
                            <methodparam>
                              <modifier>const</modifier>
                              <type> CControlHardware&amp;</type> <parameter> rhs</parameter>
                            </methodparam>
                            <modifier>= 0</modifier>
                          </methodsynopsis>
                </term>
                <listitem>
                  <para>
                      This must be implemented by concrete subclasses.  It is a
                      virtual copy constructor in the sense that the state of the
                      <parameter>rhs</parameter> object must be copied to the state
                      of <varname>this</varname>
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                        <methodsynopsis>
                          <modifier>virtual</modifier>
                          <type>void</type> <methodname> addMonitorList</methodname>
                          <methodparam>
                            <type>CVMUSBReadoutList&amp;</type> <parameter> vmeList</parameter>
                          </methodparam>
                        </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method need only be implemented by drivers for
                        devies that require continuous monitoring.
                        <parameter>vmeList</parameter> is a reference for
                        a <classname>CVMUSBReadoutList</classname> to which this
                        call must add appropriate operations to obtain the
                        data fromt he device that needs to be monitored.
                        See also <methodname>processMonitorList</methodname> and
                        <methodname>getMonitoredData</methodname>
                    </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                        <methodsynopsis>
                          <modifier>virtual</modifier>
                          <type>void*</type> <methodname>processMonitorList</methodname>
                          <methodparam>
                            <type>void*</type><parameter> pData</parameter>
                          </methodparam>
                          <methodparam>
                            <type>size_t</type><parameter> remaining</parameter>
                          </methodparam>
                        </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called for each execution of the monitor list built up
                        via <methodname>addMonitorList</methodname>.
                        <parameter>pData</parameter> points to the data
                        for this device from that list and
                        <parameter>remaining</parameter> is the number of bytes
                        of data remaining in that buffer.
                    </para>
                    <para>
                        The method must return a pointer to the first byte in
                        the buffer pointed to by <parameter>pData</parameter>
                        beyond the data returned by this driver's monitor list.
                    </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                        <methodsynopsis>
                          <modifier> virtual</modifier>
                          <type>std::string</type>
                          <methodname>getMonitoredData</methodname>
                          <void />
                        </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called to return the most recently received data from
                        the driver's monitor list.  The data are encoded
                        as a string that must begin with the word
                        <literal>OK</literal>.  normally the remainder of the
                        string is whitespace separated followed by a well formed
                        Tcl list containing the data from the monitor list.
                    </para>
                    <para>
                        If the device does not use monitor lists the return
                        value should be <literal>ERROR</literal>
                    </para>
                </listitem>
              </varlistentry>
            </variablelist>
        </refsect1>
	<refsect1>
            <title>MEMBER DATA</title>
            <para>
            </para>
        </refsect1>
       </refentry>

      <refentry id="vmusb3-cvmusb-swig">
        <refmeta>
           <refentrytitle>cvmusb</refentrytitle>
           <manvolnum>3tcl</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>cvmusb</refname>
           <refpurpose>SWIG Tcl wrapping of <classname>CVMUSB</classname></refpurpose>
        </refnamediv>
    
        <refsynopsisdiv>
            <cmdsynopsis>
                <command>
package require cvmusb
                </command>
            </cmdsynopsis>
            <formalpara>
                <title>Device enumeration and identification</title>
                <para></para>
            </formalpara>   
          <cmdsynopsis>
            <command>
::cvmusb::CVMUSB_enumerate
            </command>
          </cmdsynopsis>
          <cmdsynopsis>
            <command>
::cvmusb::usb_device_vector_get <replaceable>enumeration i</replaceable>
            </command>
          </cmdsynopsis>
        <cmdsynopsis>
        <command>
::cvmusb::usb_device_vector_size <replaceable>enumeration</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
        <command>
::cvmusb::CVMUSB_serialNo  <replaceable>usbdevice</replaceable>
            </command>
        </cmdsynopsis>
        
        <formalpara>
            <title>Construction</title>
            <para></para>
        </formalpara>
        <cmdsynopsis>
        <command>
::cvmusb::CVMUSBusb <replaceable>name usbdevice</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
        <command>
::cvmusb::CVMUSBusb <replaceable>name</replaceable> -this <replaceable>usb-object-ptr</replaceable>
            </command>
        </cmdsynopsis>
        <formalpara>
            <title>VM-USB register operations</title>
            <para></para>
        </formalpara>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readBulkXferSetup
            </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
<replaceable>object</replaceable> readDAQSettings
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readDGG_A
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readDGG_B
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readDGG_Extended
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readDeviceSource
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readFirmwareID
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readGlobalMode
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readIrqMask
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readLEDSource
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readScalerA
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readScalerB
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readVector
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeActionRegister <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeBulkXferSetup <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeDAQSettings <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeDGG_A <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeDGG_B <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeDGG_Extended <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeDeviceSource <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeGlobalMode <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeIrqMask <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeLEDSource <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeVector <replaceable>which value</replaceable>
            </command>
        </cmdsynopsis>
        <formalpara>
            <title>VME operations</title>
            <para></para>
        </formalpara>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeBlockRead <replaceable>base amod xfers</replaceable>
            </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
<replaceable>object</replaceable> vmeFifoRead <replaceable>base amod xfers</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeRead16 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeRead32 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeRead8 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeReadBlockCount16 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeReadBlockCount32 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeReadBlockCount8 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeVariableBlockRead  <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeVariableFifoRead  <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeWrite16 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeWrite32 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeWrite8 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
        <formalpara>
            <title>List operations</title><para></para>
        </formalpara>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> executeList <replaceable>list maxbytes</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> loadList    <replaceable>number list offset</replaceable>
            </command>
        </cmdsynopsis>
        <formalpara>
            <title>Miscellaneous operations.</title><para></para>
        </formalpara>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> setDefaultTimeout <replaceable>ms</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
::cvmusb::getuint16 <replaceable>uint16</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
::cvmusb::string_to_char <replaceable>std_string</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
::cvmusb::uint32_vector_get <replaceable>std_uint32_vector i</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
::cvmusb::uint32_vector_size <replaceable>std_uint32_vector</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
::cvmusb::uint8_vector_get <replaceable>std_uint8_vector i</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
::cvmusb::uint8_vector_size <replaceable>std_uint8_vector</replaceable>
            </command>
        </cmdsynopsis>
        
        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
                This package provides a tcl interface to the
                <classname>CVMUSB</classname> class described in
                <link linkend='vmusb3-CVMUSB' >CVMUSB(3)</link>.
                See COMMANDS below for more information.
           </para>
        </refsect1>
        <refsect1>
           <title>
              COMMANDS
           </title>
            <formalpara>
                <title>Device enumeration and identification</title>
                <para>
                    The commands in this section are used to determine the
                    set of VM-USB controllers attached to the host and
                    identify them by serial number.
                </para>
            </formalpara>

           <variablelist>
            <varlistentry>
                <term>
          <cmdsynopsis>
            <command>
::cvmusb::CVMUSB_enumerate
            </command>
          </cmdsynopsis>
          </term>
                <listitem>
                    <para>
                        Enumerates the set of VM-USB devices that are
                        attached to and powered up on the host.  The result
                        of this command is <type>usb_device_vector</type>.
                        You can think of this as a sort of an array with integer
                        indices whose elements represent a single VM-USB device.
                        See below for commands that can manipulate this vector.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
          <cmdsynopsis>
            <command>
::cvmusb::usb_device_vector_get <replaceable>enumeration i</replaceable>
        </command>
          </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Given the result of the <command>::cvmusb::CVMUSB_enumerate</command>
                command <parameter>enumeration</parameter>   and an integer
                index <parameter>i</parameter>, returns a single element
                of the enumerated device set.  The return value is of type
                <type>usb_device</type> and can be passed to the constructor,
                to create a controller object that talks to this device or to
                <command>cvmusb::CVMUSB_serialNo</command> to get the device's
                serial number string.
                </para>
                </listitem>
                </varlistentry>
          <varlistentry>
            <term>
        <cmdsynopsis>
        <command>
::cvmusb::usb_device_vector_size <replaceable>enumeration</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Given a <parameter>enumeration</parameter> gotten from
                <command>::cvmusb::CVMUSB_enumerate</command>,
                returns the number of elements in that array.  The array is
                indexed from 0.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
        <command>
::cvmusb::CVMUSB_serialNo  <replaceable>usbdevice</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Given a <parameter>usbdevice</parameter> returned from
                <command>::cvmusb::usb_device_vector_get</command>
                Returns the serial number string.  Note that this is not
                immediately usable but must be converted to a Tcl string
                via a call to
                <command>::cvmusb::string_to_char</command>
                described below.
                </para>
                </listitem>
            </varlistentry>
           </variablelist>
        <formalpara>
            <title>Construction</title>
            <para>
                This set of commands is used to construct CVMUSB objects.
                The return value of these constructors is a command. The
                command can be either explicitly named by the
                <parameter>name</parameter> parameter in each of these
                constructors or you can use the name <literal>%AUTO</literal>
                to allow constructors to generate a unique object command
                name.
            </para>
        </formalpara>
        <variablelist>
        <varlistentry>
            <term>
        <cmdsynopsis>
        <command>
::cvmusb::CVMUSBusb <replaceable>name usbdevice</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Creates a new CVMUSBusb object given a <parameter>usbdevice</parameter>
                gotten from
                <command>::cvmusb::usb_device_vector_get</command>.
                This results in a new command <parameter>name</parameter> unless
                <parameter>name</parameter> is the special value
                <literal>%AUTO</literal>, in which case a unique name will be
                assigned the object. To construct a CVMUSB-type object to control
                a locally connected usb, this CVMUSBusb constructor must be used rather than 
                a CVMUSB because the C++ CVMUSB base class is abstract and cannot be instantiated.
                SWIG therefore does not produce a cvmusb::CVMUSB constructor. With that said, 
                the object produced by this command will inherit the functionality of the
                cvmusb::CVMUSB type.
                </para>
            <para>
                Naturally if you use <literal>%AUTO</literal> as the name
                 you must capture the actual name in a Tcl variable e.g.:
            </para>
            <informalexample>
                <programlisting>
set controller [::cvmusb::CVMUSBusb %AUTO $device]
$controller <replaceable>some method</replaceable>
                </programlisting>
            </informalexample>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
    <cmdsynopsis>
        <command>
::cvmusb::CVMUSB <replaceable>name</replaceable> -this <replaceable>usb-object-ptr</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Constructs a VMUSB object given a <replaceable>usb-object-ptr</replaceable>
                    object pointer.  This is normally used to wrap a pointer to a C++
                    underlying object passsed into a method from compiled code
                    (e.g in the Tcl driver <methodname>Initialize</methodname> method).
                    </para>
                    </listitem>
                    </varlistentry>
        </variablelist>
        <formalpara>
            <title>VM-USB register operations</title>
            <para>
                These methods all require a constructed VM-USB object
                <parameter>object</parameter> and write internal registers
                of the VM-USB.  It is beyond the scope of this document to fully
                describe these registers.  For each method, therefore, a high level
                description will be given along with the VM-USB reference manual
                section that does fully describe the register.
            </para>
        </formalpara>
        <variablelist>
        
        <varlistentry>
            <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readBulkXferSetup
            </command>
    </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Returns the current value of the USB Bulk transfer register.
                This register is described in section 3.4.10.  It can be used
                to tune performance of the USB interface by setting the number
                of buffers that can be streamed without a packet end signal.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
    <cmdsynopsis>
        <command>
<replaceable>object</replaceable> readDAQSettings
            </command>
        </cmdsynopsis>
    </term>
    <listitem>
        <para>
            Returns the current value of the Data acquisition settings register.
            This register is described in section 3.4.3 of the VM-USB manual.
            It contains bit fields that control the way in which the scaler stack
            is trigggered and the delay between a trigger and stack start.
            Note that within the VM-USB readout framework, this register is
            programmed by the framework at the start of each run.  You will
            only need to program this register if you are building pure Tcl
            applications with the VM-USB.
            </para>
            </listitem>
            </varlistentry>
            <varlistentry>
                <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readDGG_A
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Reads the contents of the VM-USB A gate and delay generator.
                The VM-USB has two internal Gate and delay generators named
                A and B.  Section 3.4.6 describes the registers that control
                these resources. The
                bit fields in this register control the gate width and delay of
                the A gate and delay generator.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readDGG_B
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as <command>readDGGG_A </command> but the register
                for the B gate and delay register is read.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readDGG_Extended
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Returns the value of the extended gate and delay generator
                register.  This supplies high order bits for the delay values
                for both the A and B DGG's.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readDeviceSource
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Reads the device source register.  This register, described in
                section 3.4.5 defines the sources for the the NIM outputs, the
                internal scalers and the starts for the gate generators.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readFirmwareID
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Returns the current firmware revision level of the controller.
                The bit fields of this register are defined in section 3.4.1 of
                the VM-USB manual.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readGlobalMode
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Reads the module's global mode register
                (see VM-USB manual secgtion 3.4.2).  This register sets the
                VME bus request level, as well as several data acquisition
                options.
                </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readIrqMask
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
 
                            This reads a shadow regiseter that remembers
                            the last value written to the VM-USB's
                            interrupt request mask register (see
                            section 3.5 of the VM-USB manual).  This is
                            a write only register.  Therefore, when you
                            create a <classname>CVMUSB</classname> object,
                            the value of the register is set to all ones which
                            disables all interrupts.  Remember to set interrupt
                            enable bits if you use interrupt triggered stacks.
                
                </para>
                </listitem>
                </varlistentry>
             <varlistentry>
                <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readLEDSource
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Reads the LED source selectors register.  This is described in
                section 3.4.4 of the VM-USB manual.  The registser allows you to
                determine the cirumstances which light each of the four LED's on
                the VM-USB front panel.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readScalerA
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                The VM-USB has a pair of 32 bit scalers, Scaler A and B.
                These are descsribed in section 3.4.7 of the VM-USB manual.
                This method returns the value of scaler A's counter.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readScalerB
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                The VM-USB has a pair of 32 bit scalers, Scaler A and B.
                These are descsribed in section 3.4.7 of the VM-USB manual.
                This method returns the value of scaler B's counter.
                   </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readVector <replaceable>which</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Reads the value of the interrupt vector register designated
                by <parameter>which</parameter>
                The vector registers are described in section 3.4.8 of the VM-USB
                Manual.  The VM-USB supports triggering stacks as a result of
                an interrupt on the VME bus.  To do this, an interrupt service vector
                register must be programmed with the IPL, the vector and stack id.
                The interrupt sevice vectors are in pairs numbered <literal>1-4</literal>.
                This function returns one of those pairs.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeActionRegister <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Writes the <parameter>value</parameter> to the action register.
                This register is responsible for starting data acquisition
                mode and can be used to trigger lists.  It is a write only register
                that is described in section 3.1 of the VM-USB manual.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeBulkXferSetup <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Writes <parameter>value</parameter> to the bulk transfer setup
                register described in section 3.4.10 of the VM-USB manual.
                This register allows sophisiticated users to optimize the
                bandwidth of the USB during event data transfer.
                </para>
                </listitem>
                </varlistentry>
       
            <varlistentry>
                <term>
                <cmdsynopsis>
                   <command>
               <replaceable>object</replaceable> writeDAQSettings <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
 
            </term>
            <listitem>
                <para>
                    Writes <parameter>value</parameter> to the data
                    acquisition settings register described in sectino
                    3.4.3 of the VM-USB manual.  TYhat register allows
                    you to determine how the scaler stack is triggered as well
                    as the delay betrweena stack trigger and the start of
                    stack execution.
                    </para>
                    </listitem>
                    </varlistentry>
            <varlistentry>
                <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeDGG_A <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Writes <parameter>value</parameter> to the A delay and gate
                generator.  The gate and delay generator registers are
                described in section 3.4.6 of the VM-USB manual.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeDGG_B <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as above but writes to the B delay and gate generator
                register.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeDGG_Extended <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Writes the gate and delay extended delay register. This is
                provides the ability to run very long delays.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeDeviceSource <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Writes <parameter>value</parameter> to the users device
                sources selection register described in section 3.4.5 of the
                VM-USB manual.  This determines what is gated to the
                NIM 0/1 outputs, the Scaler inputs and the gate and delay
                generator inputs.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeGlobalMode <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Writes <parameter>value</parameter> to the global mode
                register described in section 3.4.2 of the VM-USB manual.  This
                sets a variety of data acquisition parameters as well as
                the VM-USB bus request level.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeIrqMask <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Writes the interrupt request mask register.  This register is
                desacribed in section 3.5 and describes the set of interrupt
                priority levels the VM-USB responds to.  See also
                <methodname>writeVector</methodname>.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeLEDSource <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Writes
                <parameter>value</parameter>
                the LED source register described in section 3.4.4 of the
                VM-USB manual.  This register determines the conditions under
                which the four programmable LEDS on the front panel of the
                VM-USB light.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeVector <replaceable>which value</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Writes one of the four vector registers (numbered
                <literal>[1-4]</literal>) described in section 3.4.8.  These
                allow stacks to be triggered by specific VME interrupts.
                Note that at present there is no support to write the
                interrupt extension bits registers as virtually all VME
                interrupters use 8-bit vectors.
                </para>
                </listitem>
                </varlistentry>
        </variablelist>
        <formalpara>
            <title>VME operations</title>
            <para>
                This section describes the methods that perform VME
                actions.  Single shot read operations return the value
                read, howver block reads return an std::vector which
                requires further calls to obtain the actual number
                of items read and to fish out individual items.
            </para>
        </formalpara>
            <para>
                VME operations target an address within an address space.
                The address space is seleted by what in VME parlance is
                called an <firstterm>address modifier</firstterm>.
                A table of address modifiers is available on the Wikipedia
                article describing the VME bus:
                <ulink url='http://en.wikipedia.org/wiki/VMEbus'>
                    http://en.wikipedia.org/wiki/VMEbus</ulink>.
            </para>
            <para>
                The documentation that describes each module describes the
                set of address modifiers it supports.  Modules occupy an
                address space whose base is generally configured by switches,
                jumpers or rotary switches.  The module documentation will describe
                both the size and contents of its address space as well as
                how the base address is determined.
            </para>
        <variablelist>
        <varlistentry>
        <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeBlockRead <replaceable>base amod xfers</replaceable>
            </command>
    </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Performs a block read from the the VME bus. The source is
                determined by the <parameter>base</parameter> address and
                the address  modifier (<parameter>amod</parameter>).
                At most <parameter>xfers</parameter> transfers will be performed.
                The block transfer may terminate prematurely if a bus error
                occurs during the transfer.
                </para>
            <para>
                The result of the block read is returned as an item that is
                encapsulates a <type>std::vector&lt;uint32_t&gt;</type>.
                See <methodname>::cvmusb::CVMUSB_uint32_vector_size</methodname>
                which will return the actual number of transfers performed.
                <methodname>::cvmusb::CVMUSB_uint32_vector_get</methodname>
                allows you to extract individual values from the data
                returned.
            </para>
            <para>
                Suitable address modifiers force the VME bus to run in
                <firstterm>block transfer mode</firstterm>. In that mode,
                Addresses cycles are only performed infrequently with the
                source device keeping track of the offset from the last address
                cycle.  If the module providing the data supports block transfer
                address modifiers, substantial peformance gains can be had
                by using it.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
    <cmdsynopsis>
        <command>
<replaceable>object</replaceable> vmeFifoRead <replaceable>base amod xfers</replaceable>
            </command>
        </cmdsynopsis>
    </term>
    <listitem>
        <para>
            This method is the same as <methodname>vmeBlockRead</methodname>
            however all address cycles assert the <parameter>base</parameter>
            address. This makes the operation suitable for address blocks
            that actually implement FIFO memories.
        </para>
        <para>
            Consider, for example the
            data buffer address block of a large group of CAEN 32 bit
            digitizers run in multi-event mode read out via a chained block
            transfer.  If a block read is used to read this module, it is possible
            for the address to increment off the end of the window that is
            recognized as the data buffer.  Using a FIFO read ensures this
            cannot happen.
            </para>
            </listitem>
            </varlistentry>
            <varlistentry>
                <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeRead16 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Performs a single 16 bit transfer from <parameter>address</parameter>
                in the address space selected by <parameter>amod</parameter>
                The result of the command is word that was read.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeRead32 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as <methodname>vmeRead16</methodname> however a 32
                bit read is performed.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeRead8 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as <methodname>vmeRead16</methodname> however a 16 bit
                read is performed.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeReadBlockCount16 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                The VM-USB provides the ability to do a variable sized block read.
                When using this facility you first perform a VME read operation
                to obtain the number of transfers in the block read.
                You then perform the block read itself
                </para>
            <para>
                The block read count is a field in the data transferred from
                the VME <parameter>address</parameter>/<parameter>amod</parameter>
                specified by a <parameter>mask</parameter>.  This method performs
                an 16 bit read from the VME bus and uses the
                <parameter>mask</parameter> provided to determine which bits
                constitute the transfer size.  The resulting block transfer
                size is saved for the variable block transfer operation which
                should immediately follow.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeReadBlockCount32 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as <methodname>vmeReadBlockCount16</methodname> however
                the read is 32 bits wide.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeReadBlockCount8 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as <methodname>vmeReadBlockCount16</methodname> however
                the data transfer is 8 bits wide.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeVariableBlockRead  <replaceable>address mask maxcount</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Performs a variable block read whose transfer count was
                determined by one of the previous three methods.
                The transfer base address is specified by
                <parameter>address</parameter>/<parameter>amod</parameter>.
                <parameter>maxcount</parameter> is used to allocate aninternal
                buffer fro the transfer and can further limit the number of
                transfers.  The return value from this method is the same as
                a return value from <methodname>vmeBlockRead</methodname>
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeVariableFifoRead  <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as <methodname>vmeVariableBlockRead</methodname> however
                all address cycles provide <parameter>address</parameter> as
                the address making this suitable as a block read froma  FIFO.
                The return value is the same as from
                <methodname>vmeBlockRead</methodname>.
                </para>
                </listitem>
                </varlistentry>
             <varlistentry>
                <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeWrite16 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Performs a single shot 16 bit write of <parameter>data</parameter>
                to the VME target specified by
                <parameter>address</parameter>/<parameter>amod</parameter>.
                The least significant bits of <parameter>data</parameter>
                are written.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeWrite32 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as <parameter>vmeWrite16</parameter> however 32bits of
                <parameter>data</parameter> are written.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeWrite8 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as vmeWrite16, however only the least significant 8 bits
                of <parameter>data</parameter> are written.
                </para>
                </listitem>
                </varlistentry>
        </variablelist>
        <formalpara>
            <title>List operations</title>
            <para>
                The VM-USB allows you to build and execute lists of VME
                operations.  These are built up using
                cvmusbreadoutlist.  Lists can also be downloaded for
                execution in data acquisition mode when triggered.
            </para>
        </formalpara>
        <variablelist>
        <varlistentry>
            <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> executeList <replaceable>list maxbytes</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Executes a list of instructions.  <parameter>list</parameter>
                is a <classname>cvmusbreadoutlist</classname> object or pointer.
                <parameter>mabytes</parameter> is the maximum number of
                bytes of data that miight be returned from this list as a result
                of the reado operations it contains.   This is used to size
                an internal buffer into which that data are accepted.
                </para>
            <para>
                The return value from this command is a
                <type>std::vector&lt;uint8_t&gt;</type>.
                See <methodname>cvmusb::CVMUSB_uint8_vector_size</methodname>
                and <methodname>cvmusb::CVMUSB_uint8_vector_get</methodname>
                for information about how to get data ouf of this object.
            </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> loadList    <replaceable>number list offset</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Loads a list into the VM-USB for execution in response to a trigger
                in data taking mode.
                <parameter>list</parameter> is a <classname>cvmusbreadoutlist</classname>
                object.  <parameter>number</parameter> is the stack number and
                must be in the range <literal>[0..7]</literal>.
                <parameter>offset</parameter> is the memory offset at which
                the list should be loaded.  See
                <classname>CVMUSB</classname>::<methodname>loadList</methodname>
                for information about how to compute this.
                </para>
                </listitem>
                </varlistentry>
        </variablelist>
        <formalpara>
            <title>Miscellaneous operations.</title>
            <para>
                This section describes methods that don't fit into a convenient
                category.  Many of these are static methods that provide
                impedance matching between the data types in use in the
                <classname>CVMUSB</classname> underlying class ansd Tcl data types.
            </para>
        </formalpara>
        <variablelist>
        <varlistentry>
            <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> setDefaultTimeout <replaceable>ms</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Sets the default timeout of VM-USB operations as
                <parameter>ms</parameter> milliseconds.  This timeout is
                used to define how long most of the methods in this
                section will wait for a response from the VM-USB before
                giving up. It is ONLY valid to call with a cvmusb::CVMUSBusb
                object.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
::cvmusb::getuint16 <replaceable>uint16</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Given a <type>uint16_t</type>
                Returns an integer that has the same value  This is needed
                because SWIG thinks that <type>uint16_t</type> is some
                fancy object type and will not allow it to be shimmered
                to an int.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
::cvmusb::string_to_char <replaceable>std_string</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Given an <type>std::string</type>, returns a string that
                Tcl can deal with.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
::cvmusb::uint32_vector_get <replaceable>std_uint32_vector i</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Given a <type>std::vector&lt;uint32_t&gt;</type>
                (<parameter>std_uint32_vector</parameter>) returns
                element <parameter>i</parameter>.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
::cvmusb::uint32_vector_size <replaceable>std_uint32_vector</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Given <parameter>std_uint32_vector</parameter> a
                <type>std::vector&lt;uint32_t&gt;</type> returns
                the number of elements it contains.  Elements
                are indexed from zero.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
::cvmusb::uint8_vector_get <replaceable>std_uint8_vector i</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as
                <methodname>::cvmusb::uint32_vector_get</methodname> but
                <parameter>std_uint8_vector</parameter> is a
                <type>std::vector&lt;uint8_t&gt;</type>.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
::cvmusb::uint8_vector_size <replaceable>std_uint8_vector</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as <methodname>::cvmusb::uint32_vector_size</methodname>
                but <parameter>std_uint8_vector</parameter>
                is a <type>std::vector&lt;uint8_t&gt;</type>
                </para>
                </listitem>
                </varlistentry>
        

           </variablelist>
        </refsect1>

      </refentry>
            <refentry id="vmusb3-cvmusbreadoutlist-swig">
              <refmeta>
                 <refentrytitle>cvmusbreadoutlist</refentrytitle>
                 <manvolnum>3tcl</manvolnum>
              </refmeta>
              <refnamediv>
                 <refname>cvmusbreadoutlist</refname>
                 <refpurpose>SWIG wrappers for <classname>CVMUSBReadoutList</classname>
                 </refpurpose>
              </refnamediv>
              
              <refsynopsisdiv>

                <formalpara>
                    <title>Construction</title>
                    <para></para>
                </formalpara>
                     <synopsis>
                <cmdsynopsis>
                    <command>
::cvmusbreadoutlist::CVMUSBReadoutList <replaceable>name</replaceable>
            </command>
            </cmdsynopsis>
                <cmdsynopsis>
                    <command>
::cvmusbreadoutlist::CVMUSBReadoutList <replaceable>name</replaceable> -this <replaceable>ptr</replaceable>
            </command>
            </cmdsynopsis>
                     </synopsis>
            <formalpara>
                <title>Simple VME/register operations</title>
                <para></para>
            </formalpara>
            <synopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRead16 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRead32 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRead8 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRegisterRead <replaceable>address</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRegisterWrite <replaceable>address data</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addWrite16 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addWrite32 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addWrite8 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
            </synopsis>
            <formalpara>
                <title>Block transfer operations</title>
                <para></para>
            </formalpara>
            <synopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addBlockRead32 <replaceable>base amod transfers</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addFifoRead16 <replaceable>address amod transfers</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addFifoRead32 <replaceable>address amod transfers</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addMaskedCountBlockRead32 <replaceable>base amod</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addMaskedCountFifoRead32 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addBlockCountRead16 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addBlockCountRead32 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addBlockCountRead8 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
            </synopsis>
        <formalpara>
            <title>Miscellaneous methods</title>
            <para></para>
        </formalpara>
        <synopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> addMarker <replaceable>value</replaceable>
            </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
<replaceable>object</replaceable> addDelay <replaceable>cycles</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> clear
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> get
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> size
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
::cvmusbreadoutlist::CVMUSBReadoutList_uint32_vector_get <replaceable>v i</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
::cvmusbreadoutlist::CVMUSBReadoutList_uint32_vector_size <replaceable>v</replaceable>
            </command>
        </cmdsynopsis>
        </synopsis>
        <formalpara>
            <title>Variables</title>
            <para></para>
            </formalpara>
    <synopsis>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a16Priv</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a16User</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24PrivBlock</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24PrivData</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24PrivProgram</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24UserBlock</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24UserData</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24UserProgram</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32PrivBlock</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32PrivData</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32PrivProgram</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32UserBlock</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32UserData</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32UserProgram</varname>

     </synopsis>
              </refsynopsisdiv>
              <refsect1>
                 <title>DESCRIPTION</title>
                 <para>
                    This package encapsulates a <classname>CVMUSBReadoutList</classname>
                    class/object.  The class allows you to create instances
                    of VME operation lists.  Once created, you can add
                    operations to that list that can either be executed
                    immediately or stored fro execution in data taking mode
                    in response to an appropriate trigger.
                 </para>
                 <para>
                    For more information about this class and its methods,
                    see METHODS below.  The class also defines a set of
                    variables that contain the VME address modifier values.
                    See VARIABLES for information about those.
                 </para>
              </refsect1>
              <refsect1>
                 <title>
                    METHODS
                 </title>
                <formalpara>
                    <title>Construction</title>
                    <para>
                        Two construction mechanisms are provided.  The first
                        creates an empty list.  The second creates an object
                        that wraps itself around a pointer to an existing list.
                    </para>
                </formalpara>
                <para>
                    Constructed objects appear like a command ensemble who's
                    base command name is the <parameter>name</parameter> parameter
                    to the constructor command.  If the special name
                    <literal>%AUTO</literal> is specified, the constructor will
                    assign a unique name.  In all cases the base name of the
                    command ensemble (or object name) is returned by the constructor.
                </para>
                <variablelist>
                <varlistentry>
                    <term>
                <cmdsynopsis>
                    <command>
::cvmusbreadoutlist::CVMUSBReadoutList <replaceable>name</replaceable>
            </command>
            </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs an empty list object named <parameter>name</parameter>
                        (see the discussion above however).  The name of the object
                        is returned by this command.
                        </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                <cmdsynopsis>
                    <command>
::cvmusbreadoutlist::CVMUSBReadoutList <replaceable>name</replaceable> -this <replaceable>ptr</replaceable>
            </command>
            </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs an object around an existing pointer to a
                        list object.  The name of the object is
                        <parameter>name</parameter> and <parameter>ptr</parameter>
                        is a SWIG type safe pointer.  Type-safe pointers are
                        just the address of a C++ object as a string that has
                        been decorated with information about the type of the
                        object.
                        </para>
                    <para>
                        A type-safe pointer to a readout list is passed to a Tcl
                        driver's <methodname>addReadoutList</methodname>
                        sub-command.
                    </para>
                        </listitem>
                        </varlistentry>
                </variablelist>
            <formalpara>
                <title>Simple VME/register operations</title>
                <para>
                    This group of methods add single shot VME operations
                    and register transfers to a list.  A VME operation is
                    specified by both an address and an address modifier.
                    The address modifier selects a specific address space.
                    See
                    <ulink url="http://en.wikipedia.org/wiki/VMEbus">
                        http://en.wikipedia.org/wiki/VMEbus</ulink>
                    for a table of address modifiers and their meaning.
                </para>
            </formalpara>
            <para>
                    <classname>cvmusbreadoutlist</classname> also defines
                    some variables that contain these address modifiers.
                    See VARIABLES below for a description of those
                    variables.
            </para>
            <variablelist>
            <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRead16 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a 16 bit read from the address and address modifier
                    specified by <parameter>address</parameter> and
                    <parameter>amod</parameter> respectively.  The data
                    are put in either the output buffer if the read is performed
                    by <methodname>cvmsub::executeList</methodname> or in the
                    event buffer if the list is triggered in data acquisition
                    mode.
                    </para>
                    </listitem>
                    </varlistentry>
            <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRead32 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addRead16</methodname> however the
                    data transfer width is 32 bits.  The list performs
                    the operation in little endian order.   That is the
                    low order part of the longword is placed in the
                    output/event buffer prior to the upper order bits.
                    </para>
                    </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRead8 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addRead16</methodname> however only
                    the data emitted consists of 8 bits of data in the low order
                    8 bits of a 16 bit word.
                    </para>
                    </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRegisterRead <replaceable>address</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a read of an internal register to the stack.
                    The <parameter>address</parameter> parameter specifies
                    which register to read.  This is a number that should be
                    taken from the table in section 3.4 of the VM-USB
                    manual.
                    </para>
                    </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRegisterWrite <replaceable>address data</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a register write to the list.  <parameter>address</parameter>
                    specifies the register address (taken from the table in
                    section 3.4 of the VM-USB manual), <parameter>data</parameter>
                    is the value to write.
                    </para>
                    </listitem>
                    </varlistentry>
             <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addWrite16 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Writes the 16 bit <parameter>data</parameter> to the VME
                    location specified by <parameter>address</parameter>
                    and <parameter>amod</parameter>.  If there are bits set
                    above the least significant 16 bits of <parameter>data</parameter>,
                    they are ignored.
                    </para>
                    </listitem>
                    </varlistentry>
            <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addWrite32 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Same as for <methodname>addWrite16</methodname> however 32 bits of
                    <parameter>data</parameter> are written.
                    </para>
                    </listitem>
                    </varlistentry>
            <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addWrite8 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addWrite16</methodname> however only the
                    least significant 8 bits are written.
                    </para>
                    </listitem>
                    </varlistentry>
            </variablelist>
            <formalpara>
                <title>Block transfer operations</title>
                <para>
                    The VM-USB is capable of several types of block transfer
                    operations.  If the address modifier is a block transfer
                    address modifier, the VM-USB will take advantage of that
                    mode of transfer.
                </para>
            </formalpara>
                <para>
                    VME block transfer operations allow a significant
                    improvment in performance by reducing the number of address
                    cycles asserted on the bus by the master.  Specifically,
                    in steady state operation, an address is only cycled on the
                    bus as the transfer address crosses a 256 byte address
                    boundary.  In between these boundaries, slave boards that
                    support block transfers are assumed to maintain counters
                    that keep track of the transfer offset within the 256 byte
                    page.
                </para>
                <para>
                    In addition to block transfer operations as described above,
                    the VM-USB also supports FIFO block transfers.   A FIFO
                    block transfer is just a block transfer that always asserts
                    the base address when an address cycle is required.
                </para>
                <para>
                    Finaly the VM-USB also supports block transfers whose
                    size depends on a bit field in a value read from the VME
                    bus.
                </para>
            <variablelist>
            <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addBlockRead32 <replaceable>base amod transfers</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a block read that is 32 bits wide tyo the stack.
                    The first transfer address is <parameter>base</parameter>,
                    transfers are all done with <parameter>amod</parameter> as
                    the address modifier.  <parameter>transfers</parameter>
                    operations are performed (transers*sizeof(uint32_t) bytes), unless
                    a transfer causes a bus error.
                    </para>
                <para>
                    If a transfer triggered a bus error, a <literal>0xffffffff</literal>
                    is placed in the output/event buffer and the transfer terminates.
                    Note that if the last transfer was a bus error and the data
                    in a successful transfer might have been a <literal>0xffffffff</literal>,
                    there is some ambiguity about how the transfer actually terminated.
                    If you expect that the tranfer might be terminated by a bus
                    error "normally", ber sure to specify a transfer count very
                    much in exceess of what you might reasonably expect to get.
                </para>
                    </listitem>
                    </varlistentry>
             <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addFifoRead16 <replaceable>base amod transfers</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a 16 bit FIFO read to the list.  All transfers are
                    performed from <parameter>base</parameter> with the
                    <parameter>amod</parameter> address modifier.
                    At most <parameter>transfers</parameter> transfers are performed.
                    In the even to of a bus error, a marker value;
                    <literal>0xffff</literal> will be inserted in the
                    read/event buffer, and the transfer will terminate.
                    </para>
                    </listitem>
                    </varlistentry>
            <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addFifoRead32 <replaceable>base amod transfers</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addFifoRead16</methodname> however
                    each read transfers 32 bits of data.
                    </para>
                    </listitem>
                    </varlistentry>
            <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addBlockCountRead16 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a 16 bit read that extracts the transfer count for the
                    next variable block read.   A 16 bit read is performed from
                    the location specified by <parameter>address</parameter> and
                    address modifier <parameter>amod</parameter>.  The
                    bits that are set in <parameter>mask</parameter> determine the final
                    actual value of the transfer count (bits set in
                    <parameter>mask</parameter> matter unset bits don't).
                    </para>
                    </listitem>
                    </varlistentry>
            <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addBlockCountRead32 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addBlockCount16</methodname> however
                    the tranfer is 32 bits wide.
                    </para>
                    </listitem>
                    </varlistentry>
        <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addBlockCountRead8 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addblockCountRead16</methodname> but the
                    transfer is 8 bits.
                    </para>
                    </listitem>
            </varlistentry>

             <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addMaskedCountBlockRead32 <replaceable>base amod</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a variable block read operation to the VME operation
                    list.  The last block count read by one of the
                    <methodname>addBlockCountReadxxx</methodname> methods'
                    above is used as the transfer count.    The base address
                    of the transfer is <parameter>base</parameter>
                    and all transfers are done with the <parameter>amod</parameter>
                    address modifier.
                    </para>
                <para>
                    The normal rules for bus error termination of block transfers
                    apply.
                </para>
                    </listitem>
                    </varlistentry>
            <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addMaskedCountFifoRead32 <replaceable>base amod</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addMaskedCountBlockRead32</methodname>,
                    however any needed address cycles always place
                    <parameter>base</parameter> on the address bus.  This
                    makes this method usable to get data from a FIFO register.
                    </para>
                    </listitem>
                    </varlistentry>
        </variablelist>
        <formalpara>
            <title>Miscellaneous methods</title>
            <para>
                The methods in this section don't fit into any other category.
                Where the method is not a subcommand of a <parameter>object</parameter>
                it is a static method of the class.
            </para>
        </formalpara>
        <variablelist>
        <varlistentry>
            <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> addMarker <replaceable>value</replaceable>
            </command>
    </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Adds a command to put a literal marker for
                <parameter>value</parameter> in to the buffer/event.
                </para>
                </listitem>
                </varlistentry>
    <varlistentry>
        <term>
    <cmdsynopsis>
        <command>
<replaceable>object</replaceable> addDelay <replaceable>cycles</replaceable>
            </command>
        </cmdsynopsis>
    </term>
    <listitem>
        <para>
            Adds a delay to the list.  When this instruction is executed,
            stack execution stalls for <parameter>cycles</parameter> cycles where
            one cycle is 200ns.    The maximum wait time is 255 cycles, however
            you can insert more than one wait operation to get longer waits.
            </para>
            </listitem>
            </varlistentry>
        <varlistentry>
            <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> clear
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Clears the list
                </para>
                </listitem>
                </varlistentry>
         <varlistentry>
            <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> get
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Returns a vector to a uint32 where each vector element is one
                32 bit stack line.  See below for static methods to get
                information about/from this vector.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> size
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Returns the number of 32 bit stack lines in the object.
                </para>
                </listitem>
                </varlistentry>
         <varlistentry>
            <term>
        <cmdsynopsis>
            <command>
::cvmusbreadoutlist::CVMUSBReadoutList_uint32_vector_get <replaceable>v i</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Given a vector <parameter>v</parameter> retrived from
                the <methodname>get</methodname> method tells you  how many
                elements it contains.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
::cvmusbreadoutlist::CVMUSBReadoutList_uint32_vector_size <replaceable>v</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Given a vector <parameter>v</parameter> gotten from
                <methodname>get</methodname> returns the nmber of 32 bit entities
                 in the vrctor.
                </para>
                </listitem>
                </varlistentry>
        </variablelist>
              </refsect1>
              <refsect1>
                <title>VARIABLES</title>
                <para>
                    The <classname>cvmusbreadoutlist</classname> class provides
                    several variables that define the various address modifiers
                    symbolcally:
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a16Priv</varname></term>
                        <listitem>
                            <para>
                                Defines the address modifier for 16 bit address
                                widths privilege access.  16 bit address space
                                is often refered to as shortio as  well.
                            </para>
                        </listitem>
                        </varlistentry>
                    <varlistentry>
                        <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a16User</varname></term>
                        <listitem>
                            <para>
                                Same as above, however accesses are in user
                                mode rather than privileged transfer mode.
                                </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24PrivBlock</varname></term>
                            <listitem>
                                <para>
                                    Defines the address modifier for A24
                                    privileged block transfers.  Block transfers
                                    are a mechanism the VME bus defines for
                                    reducing the number of address cycles required
                                    to transfer a contiguous block of data.
                                    </para>
                                <para>
                                    A24 bit addressing mode is also called
                                    standard addressing.
                                </para>
                            </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24PrivData</varname></term>
                                <listitem>
                                    <para>
                                        Defines the address modifier for 24
                                        bit wide addressing of privileged data.
                                        A24 address modes are also called
                                        standard addressing.
                                        </para>
                                </listitem>
                                </varlistentry>
                                <varlistentry>
                                    <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24PrivProgram</varname></term>
                                    <listitem>
                                        <para>
                                            Same as above, however the
                                            addressing is to privileged progfam space.
                                            </para>
                                    </listitem>
                                    </varlistentry>
                                    <varlistentry>
                                        <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24UserBlock</varname></term>
                                        <listitem>
                                            <para>
                                                Defines the address modifier for
                                                24 bit wide address block transfers.
                                                </para>
                                        </listitem>
                                        </varlistentry>
                    <varlistentry>
                        <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24UserData</varname></term>
                        <listitem>
                            <para>
                                Defines the address modifier for 24 bit wide
                                user data transfers.
                                </para>
                        </listitem>
                        </varlistentry>
                    <varlistentry>
                        <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24UserProgram</varname></term>
                        <listitem>
                            <para>
                                Defines the address modifier for 24 bit wide
                                user program space.
                                </para>
                        </listitem>
                        </varlistentry>
                <varlistentry>
                    <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32PrivBlock</varname></term>
                    <listitem>
                        <para>
                            Defines the address modifier for 32 bit privileged
                            block transfers.
                            </para>
                    </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32PrivData</varname></term>
                        <listitem>
                            <para>
                                Defines the address modifier for 32 bit wide
                                privileged data transfers.  32 bit addressing is
                                sometimes called <firstterm>extended addressing</firstterm>.
                                </para>
                        </listitem>
                        </varlistentry>
                   <varlistentry>
                    <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32PrivProgram</varname></term>
                    <listitem>
                        <para>
                            Defines the address modifier for 32 bit privileged
                            program accesses.
                            </para>
                    </listitem>
                    </varlistentry>
                <varlistentry>
                    <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32UserBlock</varname></term>
                    <listitem>
                        <para>
                            Defines the address modifier for 32 bit user
                            block transfers.
                            </para>
                    </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32UserData</varname></term>
                        <listitem>
                            <para>
                                Defines the address modifier for 32 bit user
                                data transfers.
                                </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32UserProgram</varname></term>
                            <listitem>
                                <para>
                                    Defines the address modifier for 32 bit user
                                    program access.
                                    </para>
                            </listitem>
                            </varlistentry>
                </variablelist>
              </refsect1>               
      
            </refentry>
      <refentry id="vmusb3-Module">
        <refmeta>
           <refentrytitle>Module</refentrytitle>
           <manvolnum>3tcl</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>Module</refname>
           <refpurpose>control config command: create/configure modules.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <synopsis>
          <cmdsynopsis>
          <command>
Module create <replaceable>type name</replaceable>
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
Module config <replaceable>name ?option value? ...</replaceable> 
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
Module cget <replaceable>name</replaceable>
                </command>
            </cmdsynopsis>
          </synopsis>
        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This command is processed by the Tcl slow controls server when it
            processes the control configuration file.  It is used to create,
            configure and query the configuration of slow controls
            modules.
           </para>
           <para>
                The <command>create</command> subcommand creates a new module
                assigned the <parameter>name</parameter> by which it can be
                referred to by remote control panels, and the remainder of
                the cofiguration file.  The module will be of type
                <parameter>type</parameter>.  See MODULE TYPES below for
                information about the module types supported.
           </para>
           <para>
            The <command>config</command> subcommand configures the
            module <parameter>name</parameter>, setting the configuration
            options provided on the command line to the specified values.
            See MODULE TYPES below for information about the configuration
            options accepted by each module.
           </para>
           <para>
            The <command>cget</command> subcommand returns the configuration of
            the <parameter>name</parameter>ed module.  The configuration is
            returned as a list of pairs where each pair consists of the
            configuration parameter name and value.
           </para>  
        </refsect1>
        <refsect1>
           <title>
              MODULE TYPES
           </title>
            <para>
                This section describes the module types that are supported
                currently and the device specific configuration options and
                settable/readable parameters
                each supports.  Device support includes both the
                driver and a control panel for the device.
            </para>
            <refsect2>
                <title>jtecgdg</title>
                <para>
                    This module is actually a general purpose logic module.
                    The only support for it at this time is as a multi-channel
                    gate and delay generator.
                </para>
                <refsect3>
                    <title>Options</title>
                    <para>
                        The only option supported by the <literal>jtecgdg</literal>
                        is the <option>-base</option> option which sets the
                        VME base address for the module (must match the
                        rotary switch settings).
                    </para>
                </refsect3>
                <refsect3>
                    <title>Parameters</title>
                    <variablelist>
                        <varlistentry>
                            <term>delay<emphasis>n</emphasis></term>
                            <listitem>
                                <para>
                                    The delay register value for register n.
                                    There are 8 registers numbered
                                    <literal>[0..7]</literal>
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>width<emphasis>n</emphasis></term>
                            <listitem>
                                <para>
                                    The width of channel <parameter>n</parameter>
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </refsect3>
            </refsect2>
            <refsect2>
                <title>caenv812/caen895</title>
                <para>
                    The CAEN V812 is a VME 16 channel constant fraction
                    disriminator while the V895 is a software compatible
                    leading edge discriminator.
                </para>
                <refsect3>
                    <title>Options</title>
                    <variablelist>
                        <varlistentry>
                            <term><option>-base</option></term>
                            <listitem>
                                <para>
                                    The value of this parameter is the base
                                    address of the module as set by the
                                    on-board rotary switches.
                                    </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><option>-file</option></term>
                            <listitem>
                                <para>
                                    The value of this parameter is the path to a
                                    configuration file whose contents are used to
                                    initialize the state of the device. Note
                                    that these modules are write-only so writing
                                    their initial state is the only way to put them
                                    into a known state.
                                </para>
                                <para>
                                    The contents of this file are described in
                                    <link linkend='manpage.caenv812config'>
                                        CAENV812Config(5)</link>
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </refsect3>
                <refsect3>
                    <title>Parameters</title>
                    <variablelist>
                        <varlistentry>
                            <term><parameter>threshold</parameter>n</term>
                            <listitem>
                                <para>
                                    The threshold register value for
                                    channel <parameter>n</parameter>
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><parameter>width</parameter>i</term>
                            <listitem>
                                <para>
                                    The width register value for bank
                                    <parameter>i</parameter>.  The module
                                    is divided into two banks of 8 modules.
                                    the banks are numbered 0 and 1.
                                </para>
                            </listitem>
                        </varlistentry>
                        
                    </variablelist>
                </refsect3>
            </refsect2>
            <refsect2>
                <title>vmusb</title>
                <para>
                    This slow control module supports remote execution of
                    arbitrary VM-USB lists.  Full documentation of this facility
                    will be produced in a later version of this document.
                    The idea is, however that the module, which has no
                    configuration options, has exactly one parameter,
                    <literal>list</literal>
                </para>
                <para>
                    <literal>list</literal> is a set only parameter.  It's
                    value is a Tcl list.  The first element of thel ist specifies
                    the maximum input buffer size required by the list.
                    The second value of the list is a Tcl list containing
                    the VM-USB stack.  The Set operation executes the stack
                    and returns the text <literal>Ok - </literal> followed by a
                    Tcl list  whose elements are the bytes of data put in the
                    read buffer by the stack.
                </para>
            </refsect2>
            <refsect2>
                <title>v6553</title>
                <para>
                    This is a CAEN bias supply controller.  It makes use of the
                    slow controls monitor facility to maintain an up-to-date
                    module state without interrupting data acquisition.
                </para>
                <refsect3>
                    <title>Options</title>
                    <para>
                        The module supports only the <option>-base</option>
                        option which describes to the software the base address
                        of the bias supply as encoded in the module rotary
                        switches.
                    </para>
                </refsect3>
                <refsect3>
                    <title>Parameters</title>
                    <para>
                        The following parameters can be Set:
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term><literal>>v</literal><emphasis>i</emphasis></term>
                            <listitem>
                                <para>
                                    Sets the requested voltage on channel
                                    <parameter>i</parameter> in floating point
                                    volts.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>i</literal><emphasis>i</emphasis></term>
                            <listitem>
                                <para>
                                    Sets the current limit on channel <parameter>i</parameter>
                                    in floating point micro-amps.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>on</literal><emphasis>i</emphasis></term>
                            <listitem>
                                <para>
                                    Turns channel on or off.  The value of this
                                    parameter is a legal boolean value.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>ttrip</literal><emphasis>i</emphasis></term>
                            <listitem>
                                <para>
                                    Sets the number of seconds (floating point)
                                    for which channel <parameter>i</parameter>
                                    is allowed to be out of specification before
                                    it trips  off.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>svmax</literal><emphasis>i</emphasis></term>
                            <listitem>
                                <para>
                                    Sets the maximum voltage allowed for
                                    channel <parameter>i</parameter> in floating
                                    point volts.  If a voltage setting is made
                                    that is larger than this, the actual requested
                                    voltage will be limited to this value.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>rdown</literal><emphasis>i</emphasis></term>
                            <listitem>
                                <para>
                                    Sets the ramp down rate of channel
                                    <parameter>i</parameter> in
                                    floating point volts per second.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>rup</literal><emphasis>i</emphasis></term>
                            <listitem>
                                <para>
                                    Sets the ramp up rate of channel
                                    <parameter>i</parameter> in floating point
                                    volts per second.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>pdownmode</literal><emphasis>i</emphasis></term>
                            <listitem>
                                <para>
                                    Sets the power down mode of channel
                                    <parameter>i</parameter>.  The value of this
                                    parameter can be either <literal>kill</literal>
                                    which abruptly drops the voltage to zero,
                                    or <literal>ramp</literal> which ramps the
                                    channels down at the ramp down rate.
                                </para>
                            </listitem>
                        </varlistentry>
                        
                    </variablelist>
                    <para>
                        Note that if you want to monitor key components
                        of this device periodically you should use the
                        <command>Mon</command> command as that will retrieve
                        data without temporarily halting data taking.
                    </para>
                    <para>
                        The following parameters can be retrieved via Get:
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term><literal>globalmaxv</literal></term>
                            <listitem>
                                <para>
                                    Returns the global maximum voltage
                                    for the module.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>globalmaxI</literal></term>
                            <listitem>
                                <para>
                                    Returns the global maximum current for the
                                    module.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>v</literal></term>
                            <listitem>
                                <para>
                                    Returns a list of the requested voltages from all
                                    channels.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>i</literal></term>
                            <listitem>
                                <para>
                                    Returns  a list consisting of the requested
                                    maximum currents
                                    from all channels.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>on</literal></term>
                            <listitem>
                                <para>
                                    Returns a list that contains the requested
                                    channel states (on or off for each
                                    channel).
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>vact</literal></term>
                            <listitem>
                                <para>
                                    Returns a list contaning the actual voltage
                                    reading from each channel.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>iact</literal></term>
                            <listitem>
                                <para>
                                    Returns a list containing the actual
                                    current readings from each channel.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>status</literal></term>
                            <listitem>
                                <para>
                                    Returns a list of status values for each
                                    channel.  See sections 3.2.2.6 for a bit
                                    b bit description of the valuesthat
                                    can be set in each list element.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>ttrip</literal></term>
                            <listitem>
                                <para>
                                    Returns the trip times for each channel.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>svmax</literal></term>
                            <listitem>
                                <para>
                                    Returns the software maximum voltage for
                                    each channel.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>rdown</literal></term>
                            <listitem>
                                <para>
                                    Returns a list of ramp down rates for each
                                    channel.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>rup</literal></term>
                            <listitem>
                                <para>
                                    Returns a list of the ramp up rates for each
                                    channel.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>pdownmode</literal></term>
                            <listitem>
                                <para>
                                    Returns a list of the power down modes
                                    for each channel.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>polarities</literal> </term>
                            <listitem>
                                <para>
                                    Returns a list of the channel polarity values.
                                    Each channel polarity is represented by a
                                    <literal>+</literal> or a
                                    <literal>-</literal>
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>temp</literal></term>
                            <listitem>
                                <para>
                                    Returns a list of the temperaturs  for each
                                    channel.
                                </para>
                            </listitem>
                        </varlistentry>
                        
                    </variablelist>
                </refsect3>
                <refsect3>
                    <title>Monitored variables</title>
                    <para>
                        Bias supplies must normally be monitored periodically
                        so that operators can be informed of trip and alarm
                        conditions.  The VM-USB framework provides for each
                        slow control device to contribut to a list that is
                        triggered periodically via the action register.
                        This allows this monitoring to be done without
                        pausing data taking.
                    </para>
                    <para>
                        The V5633 driver uses this capability and the
                        <command>mon</command> command should be used to
                        retrieve the most recent values of the monitored
                        variables.
                    </para>
                    <para>
                        The <command>mon</command> protocol command
                        will return the the string
                        <literal>OK </literal> followed by a Tcl list of lists.
                        The first list will be the channel status values.
                        The second list will be the channel actual voltages.
                        The third list will be the actual channel currents.
                        The fourth and last list will be the channel temperatures.
                    </para>
                </refsect3>
            </refsect2>
            <refsect2>
                <title>mdgg16</title>
                <para>
                  This slow-controls module provides support for the Wiener 
                  MDGG-16 device as used as a fourfold 16-channel configurable
                  OR. It sets up the device to output NIM logic signals
                  according to four separately defined OR definitions.                 
                </para>
                <refsect3>
                  <title>Options</title>
                  <variablelist>
                    
                    <varlistentry>
                      <term><option>-base</option></term>
                      <listitem>
                        <para>
                          The value of the base address of the Wiener MDGG-16
                          must be provided via this option.  
                        </para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><option>-mode</option></term>
                      <listitem>
                        <para>
                          This is an enumerated option that only accepts two
                          parameter values: explicit, file. The "explicit" value
                          will use the values of the -or_a, -or_b, -or_c, and
                          -or_d parameters to set up the ORs. The "file" value
                          will read an input file defined by the -configfile
                          parameter to load the definitions. Default =
                          explicit.
                        </para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><option>-or_a</option></term>
                      <listitem>
                        <para>
                          This is a 16-bit integer that represents the 16-bit
                          mask identifying which input channels will
                          contribute to the NIM 0 output (OR A). A bit that is
                          set indicates that its corresponding channel will
                          contribute to the OR A output. Bit 0 corresponds to
                          the first input channel and bit 15 corresponds to the
                          last input channel.  Default value is 65535 (i.e. all
                          16 channels contribute to output).
                        </para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><option>-or_b</option></term>
                      <listitem>
                        <para>
                          This is the same as the -or_a parameter except that it
                          corresponds to the OR B definition controlling the NIM
                          1 output.
                        </para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><option>-or_c</option></term>
                      <listitem>
                        <para>
                          This is the same as the -or_a parameter except that it
                          corresponds to the OR C definition controlling the NIM
                          2 output.
                        </para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><option>-or_d</option></term>
                      <listitem>
                        <para>
                          This is the same as the -or_a parameter except that it
                          corresponds to the OR D definition controlling the NIM
                          3 output.
                        </para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><option>-configfile</option></term>
                      <listitem>
                        <para>
                          The value of this parameter should be a valid path to
                          a configuration file. The configuration file should be
                          in the same form as the one generated by the
                          MDGG16Control program. In general, it should have the
                          following form:
                        </para>

                        <programlisting>
                         or_a  value_a  
                         or_b  value_b  
                         or_c  value_c  
                         or_d  value_d  
                        </programlisting>

                        <para> 
                          where value_a, value_b, value_c, and value_d are the
                          16-bit integers defining the bit masks for OR A, OR B,
                          OR C, and OR D, respectively.
                        </para>
                      </listitem>
                    </varlistentry>
                  </variablelist>
                </refsect3>
            </refsect2> 
        </refsect1>

      </refentry>
      <refentry id="vmusb3-watch">
        <refmeta>
           <refentrytitle id='vmusb3-watch-title'>watch</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>watch</refname>
           <refpurpose>Watch variables (slow controls)</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
          <command>
watch <replaceable>name</replaceable>   
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Informs the slow controls server that a variable or array
            named <parameter>name</parameter> should be monitored.  The
            watched variable are monitored for changes (which are initiated
            by clients performing <command>set</command> commands). Periodically
            the current values of changed variables are dumped to the event
            stream as string items of type <literal>MONITORED_VARIABLES</literal>.
           </para>
           <para>
            If <parameter>name</parameter> is an array, all elements
            of that array are monitored.
           </para>
        </refsect1>
      </refentry>

<refentry id="vmusb3-delay">
  <refmeta>
     <refentrytitle>delay</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>

  <refnamediv>
     <refname>delay</refname>
     <refpurpose>Insert a stack delay.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
    	<command>
delay create <replaceable>name base</replaceable>
	    </command>
    </cmdsynopsis>
    
    <cmdsynopsis>
      <command>
delay config <replaceable>name option value ...</replaceable>
      </command>
    </cmdsynopsis>
  
    <cmdsynopsis>
        <command>
delay cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
 
  </refsynopsisdiv>

  <refsect1>
     <title>DESCRIPTION</title>
     <para>
      This command creates a wait point in a stack. 	
     </para>
  </refsect1>

  <refsect1>
     <title>OPTIONS</title>
  
     <variablelist>
	    <varlistentry>
	       <term><command>-value</command> <replaceable>value</replaceable></term>
	       <listitem>
		       <para>Defines the duration of delay in units of 200 ns.</para>
	       </listitem>
	     </varlistentry>
     </variablelist>
 
  </refsect1>

  <refsect1>
      <title>EXAMPLES</title>
      <example>
        <title>A simple delay example</title>
         <programlisting>
delay create delay0 -value 4 
         </programlisting>
      </example>
      <para>
        Defines an 800 ns delay.
      </para>
  </refsect1>

</refentry>

<refentry id="vmusb3-CBDCamacBranch">
  <refmeta>
     <refentrytitle>CBDCamacBranch</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>

  <refnamediv>
     <refname>CBDCamacBranch</refname>
     <refpurpose>run a CAMAC branch through a CES CBD8210 bridge</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
    	<command>
CBDCamacBranch create <replaceable>name base</replaceable>
	    </command>
    </cmdsynopsis>
    
    <cmdsynopsis>
      <command>
CBDCamacBranch config <replaceable>name option value ...</replaceable>
      </command>
    </cmdsynopsis>
  
    <cmdsynopsis>
      <command>
CBDCamacBranch cget <replaceable>name</replaceable>
      </command>
    </cmdsynopsis>
 
   </refsynopsisdiv>
  
  <refsect1>
    <title>DESCRIPTION</title>
    
    <para>
When the user intends to read out CAMAC devices through the VM-USB this driver can be used if the branch driver is a CES CBD8210. This class maintains a camac branch driver object that must encapsulate the necessary functionality for controlling the CAMAC devices on its branch. The camac branch driver essentially provides the means for translating standard bcnaf commands to VME commands that are executable by the VM-USB in a command stack. It must also properly implements the CCamacBranchDriver interface. 
    </para>
    
    <para>
A CAMAC branch is just a bunch of CAMAC crates strung together with a common branch number. For this reason, the CBDCamacBranch must be told which branch number it is operating on and also the camac crates that exist on the branch. Be sure that the camac crates registered to the branch are consistent with the driver being used by the CBDCamacBranch. In other words, modules prefixed by CBD, like CBDCamacCrates, must be registered to the CBDCamacBranch if the driver has been defined as a CES CBD8210.
    </para>
    
    <para>
    At initialization the following operations occur:
    <orderedlist>
      <listitem>
        <para> Setup the appropriate camac branch driver </para>
      </listitem>
      
      <listitem>
        <para> The branch driver will initiate the branch </para>
      </listitem>
     
      <listitem>
        <para> Call initialize for each crate registered to the branch </para>
      </listitem>
  
    </orderedlist>
    </para>

    <para>
    At the end of the run, the specific end of run operations are called for each crate registered to the branch.
    </para>

    <para>
    During execution of an event stack, the operations defined in each crate are executed in the order that the crate list was passed.
    </para>
  
  </refsect1>

  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	    <varlistentry>
	      <term><command>-branch</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
        Specifies the branch index. Default is 0.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-crates</command> <replaceable>list</replaceable></term>
	      <listitem>
		    <para>
        Specify a proper tcl list of crate modules to be operated on the branch. These crates must be compatible with the driver in use. Care should also be taken to ensure that the crate indices are all different. Default is an empty list. 
		    </para>
	       </listitem>
	    </varlistentry>
   </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
        <title>Sample setup of two camac crates on branch 0</title>
         <programlisting>
# define some camac crates
CBDCamacCrate create crate1 -crate 1
CBDCamacCrate create crate2 -crate 2

CBDCamacBranch create branch0 -branch 0
CBDCamacBranch config branch0 -crates [list crate1 crate2]
         </programlisting>
      </example>
      <para>
       Defines two camac crates compatible with the CBD8210 branch driver and adds those to the camac branch, whose branch index is 0.
      </para>
  </refsect1>
</refentry>

<refentry id="vmusb3-CBDCamacCrate">
  <refmeta>
     <refentrytitle>CBDCamacCrate</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>CBDCamacCrate</refname>
     <refpurpose>group CBD8210 compatible modules into a crate</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
CBDCamacCrate create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
CBDCamacCrate config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
CBDCamacCrate cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>

  <refsect1>
     <title>DESCRIPTION</title>
     <para>
The CBDCamacCrate command defines a container type driver that holds a registry of modules. It is designed to work on a CAMAC branch rooted in a VME crate by a CES CBD8210 device. If this is not the case, use of this driver will fail. In addition, the modules that are registered to this crate must also be capable of working with a CBD8210 device. This module cannot operate on its own and must be registered to a valid CBDCamacBranch. 
  </para>

  <para>
At the start of every run, the initialization procedures will be called for all of the registered modules in the order the modules were listed.
  </para>

  <para>
At the end of every run, the end of run procedures will be called for all of the registered module in the order the modules were listed.
  </para>

  <para>
During stack execution initiated by an event trigger, the event-wise procedures of each of the registered modules will be executed in the order that they were listed.
  </para>

  </refsect1>

  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	    <varlistentry>
	      <term><command>-crate</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
        Specifies the crate index. Default is 0.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-modules</command> <replaceable>list</replaceable></term>
	      <listitem>
		    <para>
        Specify a proper tcl list of modules to be registered with this crate. these must all be compatible with the CBD8210 branch driver. The order in which modules are listed will be the order in which each module is serviced. A single module can be registered to multiple CBDCamacCrates. Default is an empty list. 
		    </para>
	       </listitem>
	    </varlistentry>
  </variablelist>

  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
        <title>Sample setup of a single LeCroy 2551</title>
         <programlisting>
CBDLeCroy2551 create sclr -slot 10

# Create a crate to stick it in
CBDCamacCrate create crate0 -crate 1
CBDCamacCrate config crate0 -modules [list sclr]

# Create a branch to register the crate in
CBDCamacBranch create branch0 -branch 0
CBDCamacBranch config branch0 -crates [list crate0]
         </programlisting>
      </example>
      <para>
       Defines a camac crate with a single LeCroy2551 to operate on with a CBD8210 branch driver. This crate is labeled with index 1 on the branch and the branch is labeled with index 0.
      </para>
  </refsect1>
</refentry>

<refentry id="vmusb3-CBDLeCroy4300B">
  <refmeta>
     <refentrytitle>CBDLeCroy4300B</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>CBDLeCroy4300B</refname>
     <refpurpose>control a LeCroy 4300B FERA on a CAMAC branch</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
CBDLeCroy4300B create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
CBDLeCroy4300B config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
CBDLeCroy4300B cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
  <para>
The CBDLeCroy4300B cannot be registered as a stack module by itself. Instead it must be registered first to a CBDCamacCrate. That CBDCamacCrate must then be registered to a CBDCamacBranch module. See the example below to understand how this works. 
  </para>
  <para>
There are a number of options that are provided to ultimately control the command register of the device. The command register is what establishes how the FERA will read out its data. Two options must be specified to operate the device, -pedestals and slot. If either of these are not specified, the initialization of the module will fail. 
  </para>

  <para>
  During initialization the following operations occur:
    <orderedlist>
     <listitem> 
        <para> Clear the module </para>
     </listitem>
     <listitem>
      <para> Write all pedestals passed to the -pedestal option </para>
     </listitem>
     <listitem>
      <para> Compute the command register from user define options and write it to the module </para>
     </listitem>
  </orderedlist>
  </para>

  <para>
  At the end of the run, no actions are taken. 
  </para>

  <para>
  During stack execution initiated by an event trigger, this driver will operate based on the following logic:
  <programlisting>

  if "-camacclear" is true
      Clear the module

  </programlisting>
  
  </para>
  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	    <varlistentry>
	      <term><command>-slot</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
        Specifies the slot of the CAMAC crate the target module is occupying. DEFAULT is 1.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-pedestals</command> <replaceable>list</replaceable></term>
	      <listitem>
		    <para>
          A proper tcl list of 16 integer parameters defining the pedestals for each of the 16 channels. The first element of the list will configure the first channel of the FERA, the second element will configure the second channel, and so on. REQUIRED
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-vsn</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
The virtual station number to associate with the target device. This will be included in the header if data compression is enabled. 
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-eclpedsub</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
        	Specify whether to use pedestal subtraction in ECL port readout (aka. EPS). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-eclcompression</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specify whether to enable a data compression cycle before ECL port readout (aka. ECE). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-eclenable</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
        	Specify whether to enable ECL port readout (aka. EEN). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-camacpedsub</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specify whether to use pedestal subtraction in CAMAC readout (aka. CPS). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-camaccompression</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specify whether to enable a data compression cycle before CAMAC readout (aka. CCE). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-camacseqrdo</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specify whether to configure the device for sequential readout in CAMAC (aka. CSR). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-camaclam</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specify whether the allow the device to emit a LAM when data is available to be read (aka. CLE). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-overflowsuppress</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specify whether to suppress output of overflows as well as zeros (aka. OAFS). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
   </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
         <title>Sample setup of a few FERAs</title>
         <programlisting>
CBDLeCroy4300B create fera -slot 10 
CBDLeCroy4300B config fera -pedestals \
          [list 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]
CBDLeCroy4300B config fera -eclenable on
CBDLeCroy4300B config fera -eclpedsub on
CBDLeCroy4300B config fera -eclcompression on
CBDLeCroy4300B config fera -camacclear off

# Create a crate to stick it in
CBDCamacCrate create crate0 -crate 1
CBDCamacCrate config crate0 -modules [list fera]

# Create a branch to register the crate in
CBDCamacBranch create branch0 -branch 0
CBDCamacBranch config branch0 -crates [list crate0]
         </programlisting>
      </example>
      <para>
        Sets up a LeCroy4300B module with all pedestals 1 to be read out by the ECL ports. The FERA resides in slot 10.
      </para>
  </refsect1>
</refentry>

<refentry id="vmusb3-CBDLeCroy4434">
  <refmeta>
     <refentrytitle>CBDLeCroy4434</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>CBDLeCroy4434</refname>
     <refpurpose>control a LeCroy 4434 Scaler on a CAMAC branch</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
CBDLeCroy4434 create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
CBDLeCroy4434 config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
CBDLeCroy4434 cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
    <para>
The CBDLeCroy4434 is intended to control a LeCroy 4434 scaler situated on a camac branch rooted in a VME crate by a CES CBD8210 branch driver. If you intend to utilize the driver in a camac crate controlled by a CCUSB, see the LeCroy4434 command. It provides the exact same functionality but understands the CCUSB to be its controller.
  </para>

  <para>
The CBDLeCroy4434 cannot be registered as a stack module by itself. Instead it must be registered first to a CBDCamacCrate. That CBDCamacCrate must then be registered to a CBDCamacBranch module. See the example below to understand how this works.
  </para>

  <para>
  During initialization, all scalers are cleared and the auxiliary bus is disabled. 
  </para>

  <para>
  At the end of the run, no actions are taken. 
  </para>

  <para>
  During stack execution initiated by an event trigger, this driver will operate based on the following logic:
  <programlisting>

  Read all channels
  if "-incremental" is true
      Clear the module
  </programlisting>

  Just as a note, the latch and the clear are not atomic.
  </para>
  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	    <varlistentry>
	      <term><command>-slot</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
        Specifies the slot of the CAMAC crate the target module is occupying. Default is 1.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-incremental</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specifies whether to clear the scalers on each event after latching them. Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
   </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
         <title>Sample setup of a single scaler</title>
         <programlisting>
CBDLeCroy4434 create sclr -slot 10

# Create a crate to stick it in
CBDCamacCrate create crate0 -crate 1
CBDCamacCrate config crate0 -modules [list sclr]

# Create a branch to register the crate in
CBDCamacBranch create branch0 -branch 0
CBDCamacBranch config branch0 -crates [list crate0]
         </programlisting>
      </example>
      <para>
        Sets up a LeCroy 4434 scaler module in slot 10.
      </para>
  </refsect1>
</refentry>
  
<refentry id="vmusb3-CBDLeCroy2551">
  <refmeta>
     <refentrytitle>CBDLeCroy2551</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>CBDLeCroy2551</refname>
     <refpurpose>control a LeCroy 2551 Scaler on a CAMAC branch</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
CBDLeCroy2551 create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
CBDLeCroy2551 config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
CBDLeCroy2551 cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
    <para>
The CBDLeCroy2551 is intended to control a LeCroy 2551 scaler situated on a camac branch rooted in a VME crate by a CES CBD8210 branch driver. If you intend to utilize the driver in a camac crate controlled by a CCUSB, see the LeCroy2551 command. It provides the exact same functionality but understands the CCUSB to be its controller.
  </para>

    <para>
The CBDLeCroy2551 cannot be registered as a stack module by itself. Instead it must be registered first to a CBDCamacCrate. That CBDCamacCrate must then be registered to a CBDCamacBranch module. See the example below to understand how this works.
    </para>

  <para>
  During initialization, all scalers are cleared. 
  </para>

  <para>
  At the end of the run, no actions are taken. 
  </para>

  <para>
  During stack execution initiated by an event trigger, all 12 scaler channels are read individually. There is no clear at the end of an event.
  </para>

  <para>
  It is important for the user to understand that format of the data is outputted by the VMUSB when this scaler is used. Each channel readout consists of two separate 16-bit reads that accomplish the reading of the upper bits followed by the lower 16-bits of the actual scaler value. This is done because the CBD8210 is a D16 device rather than a D32 device. There is no getting around it. What this means is that the actual scaler values need to be filtered or processed before they look like meaningful numbers.
  </para>

  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	    <varlistentry>
	      <term><command>-slot</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
        Specifies the slot of the CAMAC crate the target module is occupying. Default is 1.
		    </para>
	       </listitem>
	    </varlistentry>
   </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
         <title>Simple setup of a single scaler</title>
         <programlisting>
CBDLeCroy2551 create sclr -slot 10

# Create a crate to stick it in
CBDCamacCrate create crate0 -crate 1
CBDCamacCrate config crate0 -modules [list sclr]

# Create a branch to register the crate in
CBDCamacBranch create branch0 -branch 0
CBDCamacBranch config branch0 -crates [list crate0]
         </programlisting>
      </example>
      <para>
        Sets up a LeCroy 2551 scaler module in slot 10.
      </para>
  </refsect1>
</refentry>

<refentry id="vmusb3-CBDULMTrigger">
  <refmeta>
     <refentrytitle>CBDULMTrigger</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>CBDULMTrigger</refname>
     <refpurpose>control a LeCroy 2637 ULM running trigger firmware on a CAMAC branch</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
CBDULMTrigger create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
CBDULMTrigger config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
CBDULMTrigger cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
    <para>
The CBDULMTrigger is intended to control a LeCroy 2367 ULM situated on a camac branch rooted in a VME crate by a CES CBD8210 branch driver. If you intend to utilize the driver in a camac crate controlled by a CCUSB, see the ULMTrigger command. It provides the exact same functionality but understands the CCUSB to be its controller.
  </para>

    <para>
The CBDULMTrigger cannot be registered as a stack module by itself. Instead it must be registered first to a CBDCamacCrate. That CBDCamacCrate must then be registered to a CBDCamacBranch module.
    </para>

  <para>
Two options need to be specified to function properly. The first is firmware which defines the location of the firmware file to load. The second is the slot number in the camac crate it lives in.
  </para>


  <para>
  On initialization the module will always be cleared and the GO bit set to 1.
  </para>

  <para>
  At the end of the run, the GO bit is set to 0.
  </para>

  <para>
  During stack execution initiated by an event trigger, the following logic is carried out:

  <programlisting>
if "-registerRead" is true
    Read the register

if "-eventwiseClear" is true
    Clear the register
  </programlisting>
  
  By default, both -registerRead and -eventwiseClear are set to false.
  </para>

  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	    <varlistentry>
	      <term><command>-slot</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
        Specifies the slot of the CAMAC crate the target module is occupying. Default is 1.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-firmware</command> <replaceable>path</replaceable></term>
	      <listitem>
		    <para>
        The path to the firmware file usbtrig.bit. Default is "".
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-readRegister</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
        Specifies whether to add a hit register read into the event stack. Defaults to true.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-eventwiseClear</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
        Specifies whether to send a clear command via the CAMAC dataway at the end of the event. Defaults to true.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-forceFirmwareLoad</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
        By default, the ULM will only load the firmware if it fails to validate the configuration. This occurs always after a bad firmware load or after a crate has been power cycled. Firmware loads take a bit of time so it is worthwhile to skip reloading the firmware on every run. However, sometimes it may be considered useful. This option causes the firmware to be loaded at the start of EVERY run. Defaults to false.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-configuration</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Specifies the number that will be used to validate a successful firmware configuration. This number is compared to the value returned by the function A=15 F=0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-pcDelay</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-pcWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-scDelay</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-scWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-ccWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-ssDelay</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-bypasses</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-pdFactor</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-sdFactor</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-triggerBox</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-inspect1</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-inspect2</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-inspect3</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-inspect4</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-adcWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-qdcWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-tdcWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-coincWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
   </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
         <title>Setup of a single ULM trigger module</title>
         <programlisting>
# Define values for each parameter in TRIGGER array
CBDULMTrigger create sclr -slot 23
CBDULMTrigger config ulm firmware /user/s800/server/fpga/usbtrig.bit
CBDULMTrigger config ulm -pcDelay $TRIGGER(PCDelay) \
                  -pcWidth $TRIGGER(PCWidth) \
                  -scDelay $TRIGGER(SCDelay) \
                  -scWidth $TRIGGER(SCWidth) \
                  -psDelay $TRIGGER(PSDelay) \
                  -ccWidth $TRIGGER(CCWidth) \
                  -ssDelay $TRIGGER(SSDelay) \
                  -bypasses $TRIGGER(Bypasses) \
                  -pdFactor $TRIGGER(PDFactor) \
                  -sdFactor $TRIGGER(SDFactor) \
                  -triggerBox $TRIGGER(TriggerBox) \
                  -inspect1 $TRIGGER(Inspect1) \
                  -inspect2 $TRIGGER(Inspect2) \
                  -inspect3 $TRIGGER(Inspect3) \
                  -inspect4 $TRIGGER(Inspect4) \
                  -adcWidth $TRIGGER(ADCWidth) \
                  -qdcWidth $TRIGGER(QDCWidth) \
                  -tdcWidth $TRIGGER(TDCWidth) \
                  -coincWidth $TRIGGER(CoincidenceWidth) \
                  -configuration $TRIGGER(configuration) 
CBDULMTrigger config trig -forceFirmwareLoad off
CBDULMTrigger config trig -readRegister on
CBDULMTrigger config trig -eventwiseClear off


# Create a crate to stick it in
CBDCamacCrate create crate0 -crate 1
CBDCamacCrate config crate0 -modules [list trig]

# Create a branch to register the crate in
CBDCamacBranch create branch0 -branch 0
CBDCamacBranch config branch0 -crates [list crate0]
         </programlisting>
      </example>
      <para>
        Sets up a ULM module in slot 23 of crate 1 on branch 0.
      </para>
  </refsect1>
</refentry>

  
<refentry id="vmusb3-XLMTimestamp">
  <refmeta>
     <refentrytitle>XLMTimestamp</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>XLMTimestamp</refname>
     <refpurpose>control an XLM running 64-bit latching scaler firmware</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
XLMTimestamp create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
XLMTimestamp config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
XLMTimestamp cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>

     <para>
      The XLMTimestamp module is a driver to control an JTech XLM running a 64-bit latching scaler firmware. It is intended to be used specifically with the stamp64.bit firmware written by Daniel Bazin at the NSCL.
    </para>

  <para>
  During initialization, the firmware is loaded and all scalers are cleared. 
  </para>

  <para>
  At the end of the run, no actions are taken. 
  </para>

  <para>
  During stack execution initiated by an event trigger, the 64-bits of scaler are read out in two 32-bit chunks. The lower 32-bits are read first and the upper 32-bits are read second. 
  </para>

  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>

	    <varlistentry>
	      <term><command>-base</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
          Specifies the base address of the module. See the manual on how to address the XLM. When the module is using geographic addressing, the slot number is pushed up 27 bits (i.e. slot 10 produces a base address of 0x50000000).
		    </para>
	       </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><command>-firmware</command> <replaceable>path</replaceable></term>
	      <listitem>
		    <para>
          The path to the stamp64.bit firmware file.
		    </para>
	       </listitem>
	    </varlistentry>

   </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
         <title>Simple setup of a single timestamp module</title>
         <programlisting>
          xlmtstamp create tstamp -base 0x50000000
          xlmtstamp config tstamp -firmware /user/s800/server/fpga/stamp64.bit
         </programlisting>
      </example>
      <para>
        Sets up an XLM in slot 10 to run the stamp64.bit firmware.
      </para>
  </refsect1>
</refentry>
      <refentry id="vmusb3-marker">
        <refentryinfo>
          <author>
                  <personname>
                          <firstname>Ron</firstname>
                          <surname>Fox</surname>
                  </personname>
          </author>
          <productname>NSCLDAQ</productname>
          <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='vmusb3-marker-title'>marker</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>marker</refname>
           <refpurpose>Insert a constant into the VMUSB data stream</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
marker create <replaceable>name</replaceable>
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
marker config <replaceable>name -value uint16</replaceable>                    
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
marker cget <replaceable>name</replaceable>
                </command>
            </cmdsynopsis>
            
            
        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            When added to a stack, a marker inserts a constant 16 bit unsigned
            value in the outupt data produced by the VM-USB in response to that
            stack's trigger.
           </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
            <varlistentry>
                <term><option>-value</option> <replaceable>uint16</replaceable></term>
                <listitem>
                    <para>
                        The <replaceable>uint16</replaceable> unsigned 16 it
                        bit integer will be inserted into the output stream.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>

      </refentry>

<refentry id="vmusb3-XLMFERA">
  <refmeta>
     <refentrytitle>XLMFERA</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>XLMFERA</refname>
     <refpurpose>control an XLM72V running firmware to readout FERA via ECL ports</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
XLMFERA create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
XLMFERA config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
XLMFERA cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>

     <para>
      The XLMFERA module is a driver to control a JTech XLM72V running firmware to handle readout of FERA modules via ECL ports. The XLM actually interfaces with a LeCroy 4301 FERA driver to accomplish this. The firmware associated with this is the xferajan.bit firmware that was written primarily by an unknown author but was assisted by Jan Toke (JTech). 
    </para>

    <para>
     This is just a derived class of the CXLM base class. 
    </para>

  <para>
  During initialization, the firmware is loaded. The user must provide the path to the firmware file by means of the -firmware option. If no firmware file is specified or the path provided is invalid, an exception will be thrown. The firmware will always be validated on initialization by a validation test. This validation test reads the signature of the firmware from the device and compares it to the value passed by the -configuration option. If these numbers are not identical or the -forceFirmwareLoad flag is set to true, the firmware will be loaded. The user will be alerted to the success of the validation via messages printed to the console. Immediately following the firmware load, the validation test is repeated and the user will be alerted of the results. An exception will be thrown if the validation test fails at this point.
  </para>

  <para>
  At the end of the run, no actions are taken. 
  </para>

  <para>
  During stack execution, a block transfer is executed. First, the lowest 16-bits of memory in the sramA is read via a 32-bit read. The value of these 16-bits will be used to specify the number of 32-bit transfers to execute in a subsequent block transfer. The block transfer will begin at 5th byte of sramA (i.e. the second 32-bits).
  </para>

  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>

	    <varlistentry>
	      <term><command>-base</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
          Specifies the base address of the module. See the manual on how to address the XLM. When the module is using geographic addressing, the slot number is pushed up 27 bits (i.e. slot 10 produces a base address of 0x50000000).
		    </para>
	       </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><command>-firmware</command> <replaceable>path</replaceable></term>
	      <listitem>
		    <para>
          The path to the xferajan.bit firmware file.
		    </para>
	       </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><command>-configurationID</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
          The value to use in the validation test. Default is 0x54000041. 
		    </para>
	       </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><command>-forceFirmwareLoad</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Force reload of the firmware every run regardless of whether the XLM passes the validation test.
		    </para>
	       </listitem>
	    </varlistentry>

   </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
         <title>Simple setup of a single timestamp module</title>
         <programlisting>
          XLMFERA create myxlm -base 0x50000000
          XLMFERA config myxlm -firmware /user/s800/server/fpga/xferajan.bit
         </programlisting>
      </example>
      <para>
        Sets up an XLM in slot 10 to run the xferajan.bit firmware.
      </para>
  </refsect1>
</refentry>

<refentry id="vmusb3-AXLM72ScalerControl">
  <refmeta>
     <refentrytitle>AXLM72ScalerControl</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>AXLM72ScalerControl</refname>
     <refpurpose>slow-controls driver for controlling an XLM72 running 32-ch scaler firmware</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
AXLM72ScalerControl <replaceable>name option value ...</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
<replaceable>name</replaceable> Set <replaceable>usb parameter value</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
<replaceable>name</replaceable> Get <replaceable>usb parameter</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
<replaceable>name</replaceable> Update <replaceable>usb</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
<replaceable>name</replaceable> addMonitorList <replaceable>list</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
<replaceable>name</replaceable> processMonitorList <replaceable>data</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>

  <title>DESCRIPTION</title>

     <para>
    The AXLM72ScalerControl driver is a pure-TCL driver that is used to communicate with the XLM72 when running the ech32x24.bit firmware. It implements the CControlHardware interface as is equivalent in TCL. When loaded into the slow-controls server, any remote process can send it commands that it will translate into actual communication with a specific XLM72 device. It communicates through the low-level driver for the ech32x24.bit firmware called AXLM72Scaler. The XLM72ScalerGUI requires that an instance of this class is registered as a TCL module (see Module command), in the slow-controls server.
    </para>

  </refsect1>
  
  <refsect1>
  <title>OPTIONS</title>
    <variablelist>

	    <varlistentry>
	      <term><command>-slot</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
          Specifies the slot in which the target XLM72 module resides.
		    </para>
	       </listitem>
	    </varlistentry>
    </variablelist>

  </refsect1>

  <refsect1>
  <title>METHODS</title>
  <variablelist>

    <varlistentry>
      <term><replaceable>name</replaceable> <command>Set</command> <replaceable>vmusb parameter value</replaceable></term>
      <listitem>
        <para>
          The Set command causes a write to the XLM72. There are 34 supported parameters: enable, reset, trigger0, trigger1, trigger2, ..., and trigger31. The number appended to the trigger parameter identifies the channel number. The values provided for reset and the any trigger must be either 0 or 1, and the value of the reset command is ignored. The returned value is the status value of the return value for the write operation (0 => success, otherwise => failure).
        </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><replaceable>name</replaceable> <command>Get</command> <replaceable>vmusb parameter</replaceable></term>
      <listitem>
        <para>
          The Get command causes a read from the XLM72. There are 5 parameters that can be provided to this method: enable, alltriggers, firmware, runstate, and allscalers. These all return the value read from the device. The enable parameter returns a 0 or 1 indicating whether the scalers are enabled. The alltriggers parameter returns a 32-bit integer with the status of each channel's trigger status encoded in its bits. Channel 0's status is encoded in bit 0 and channel 31's status is encoded in bit 31, with all others likewise. The firmware parameter returns the firmware signature. The runstate parameter causes a return of the run state as one of the following strings: idle, starting, stopping, active, paused. Finally the allscalers parameters causes the scaler values to be latched and read out of the device. These are returned as a list of 32 integers beginning with channel 0.
        </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><replaceable>name</replaceable> <command>Update</command> <replaceable>vmusb</replaceable></term>
      <listitem>
        <para>
          The Update method is defined but does nothing.
        </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><replaceable>name</replaceable> <command>addMonitorList</command> <replaceable>list</replaceable></term>
      <listitem>
        <para>
          The addMonitorList method is defined but does nothing.
        </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><replaceable>name</replaceable> <command>processMonitorList</command> <replaceable>data</replaceable></term>
      <listitem>
        <para>
          The processMonitorList method is defined but does nothing more than return 0.
        </para>
      </listitem>
    </varlistentry>
  </variablelist> 

  </refsect1>

  <refsect1>
      <title>EXAMPLES</title>
      <example>
         <title>Simple setup of the AXLM72ScalerControl</title>
         <programlisting>
          package require scalerxlm72

          # Instantiation an object
          AXLM72ScalerControl mysclr -slot 5 

          # create the module for the slow-controls configure it to call the methods of the mysclr object
          Module create tcl sclrmod
          Module config sclrmod -ensemble mysclr
         </programlisting>
      </example>
      <para>
        Sets up an instance of the AXLM72ScalerControl to run on the slow-controls server. If the XLM72ScalerGUI is to be run with this module, it would have to be given the name of the module as "sclrmod".
      </para>
  </refsect1>
</refentry>

<refentry id="vmusb3-XLM72ScalerGUI">
  <refmeta>
     <refentrytitle>XLM72ScalerGUI</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>XLM72ScalerGUI</refname>
     <refpurpose>Diagnostics GUI for controlling an XLM72 running 32 ch scaler firmware</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
  <cmdsynopsis>
    <command>
      XLM72ScalerGUI <replaceable>name option value ...</replaceable>
    </command>
  </cmdsynopsis>
  </refsynopsisdiv>

  <refsect1>

  <title>DESCRIPTION</title>
  <para>
The XLM72ScalerGUI is a graphical user interface (GUI) that provides interactive control over an XLM72 running the ech32x24.bit firmware in a crate being readout by VMUSBReadout program. This firmware was written and is supported by Daniel Bazin and the software driver that supports the readout is provided by NSCLDAQ as the AXLM72Scaler tcl driver. The XLM72ScalerGUI is a UI that displays the scaler values of the XLM72 when not in DAQ mode and gives the user some basic control over the XLM72 while the VMUSB is not in acquisition mode. It is primarily a diagnostics tools that can be used to enable or disable the scaler channels from counting, to clear the scaler counters, and also to repeatedly update the values at a selectable frequency.
  </para>

  </refsect1>

  <refsect1>
    <title>PARAMETERS</title>

    <variablelist>

	    <varlistentry>
	      <term><command>--module</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
          The name of the module registered to the VMUSBReadout slow-controls server that will handle the requests of the GUI.
		    </para>
	       </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><command>--host</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
          The host running the VMUSBReadout slow-controls server.
		    </para>
	       </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><command>--port</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
          The port on which the VMUSBReadout slow-controls server is listening for connections.
		    </para>
	       </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><command>--ring</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
          The name of the ring being filled by the VMUSBReadout program
		    </para>
	       </listitem>
	    </varlistentry>
    </variablelist>

  </refsect1>


  <refsect1>
    <title>Configuration</title>

    <para>
      The XLM72ScalerGUI is designed as a client-server architecture and thus using it requires setting up two different pieces: the client and the server. The setup of the server will be explained first. To avoid confusion, the server that will be communicated with is the VMUSBReadout slow-controls server and thus setting it up requires loading a driver with the needed functionality into it. The specific driver to be used is contained in the AXLM72ScalerControl class. It is just a standard slow-controls driver written purely in TCL that implements the Set, Get, and Update methods. Once an instance has been created of the AXLM72ScalerControl class, it needs to be registered as a TCL module using the ?Module? command. The name of the ensemble is just the name of the instance created. As with all slow-controls set up, this must be done in the ctlconfig.tcl file. The name of the AXLM72ScalerControl instance is not important so long as it does not conflict with any other tcl commands (e.g. setting the name to ?set? would lead to unexpected failures). Here is a sample of how to set it up in the ctlconfig.tcl file.
    </para>

    <example>
    <title>Example ctlconfig.tcl entry</title>
    <programlisting>
package require scalerxlm72			          ;# load the plugin

AXLM72ScalerControl XLM72SclrCtl -slot 5  ;# Create an instance of for an XLM72 in slot 5

Module create tcl xlm72sclrctl		        ;# Create a new pure tcl module named xlm72sclrctl
Module config xlm72sclrctl -ensemble XLM72SclrCtl ;# set the name of the ensemble to be the same as the name of the instance
    </programlisting>
    </example>

    <para>
The second portion of the XLM72ScalerGUI is the setup of the client. The client is much simpler and amounts to running the XLM72ScalerGUI program with the appropriate arguments. This program requires a few pieces of information to successfully communicate with the server. Those are the name of the host running the VMUSBReadout slow-controls server, the port on which that server is listening for connections, the name of the ringbuffer being filled by the VMUSBReadout program, and the name of the slow-controls module that is receiving requests from the GUI. In the above example, the name of that module would be "xlm72sclrctl".  
    </para>

    <para>
    That is it. If you want know why the ringbuffer name is needed read on about run state awareness.
    </para>

  </refsect1>

  <refsect1>
    <title>Run State Awareness</title>
    <para>
  The XLM72ScalerGUI is only allowed to query the XLM72 while a run is not in progress. When a run is in progress (i.e. the VM-USB is in data acquisition mode rather than interactive mode), all of the GUI components become disabled except for the Exit button. When a run ends, the GUI components become active again. The idea is that the XLM72ScalerGUI is really a diagnostics tool rather than a tool for data acquisition. In order to respond to run state transitions, the GUI needs to have some run state awareness. Two mechanisms provide this to form some redundancy. The primary means by which it obtains run state information is through a sclclient program attached to the ringbuffer filled by the VMUSBReadout program. This is why the user must provide the name of the ringbuffer, when starting up the GUI. The sclclient communicates with a TclServer embedded into the GUI and manages a variable called RunState. Unfortunately, this approach is leaves a small chance that the GUI sends a request after the run has started but before the sclclient has alerted the TclServer of the change. In this scenario, the second redundancy kicks in because the first thing that happens before a request is a request from the slow-controls server to return the run state. If the run state is not idle, then it is assumed that a run is in progress. Otherwise, the requests proceed as usual. 
    </para>

    <para>
      This may seem overkill but there is a good reason for doing it this way that is tied to how the slow-controls server handles requests while in acquisition mode. Should a request come in that mode, the VMUSB will exit acquisition mode, process the request, and then resume acquisition. Unfortunately, ending a run usually lasts about a second or two, which causes long wait times. To avoid repeated interruptions like this, the above scheme ensures that at most, one interruption can occur. Understand that no data is ever lost in these scenarios, the data stream is simply interrupted for a period of time. 
    </para>
  </refsect1>
  
</refentry>

      <refentry id="vmusb3-AXLM72">
        <refmeta>
           <refentrytitle>AXLM72</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>AXLM72</refname>
           <refpurpose>TCL base class for JTech XLM72 family of devices</refpurpose>
        </refnamediv>
    
        <refsynopsisdiv>
            <cmdsynopsis>
                <command>
package require xlm72
                </command>
            </cmdsynopsis>
          
        <cmdsynopsis>
            <command>
AXLM72 <replaceable>name slot</replaceable>
            </command>
        </cmdsynopsis>
        
        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> GetVariable <replaceable>v</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> Read <replaceable>ctlr dev address</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> Write <replaceable>ctlr dev address data</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> ReadSBLT <replaceable>ctlr dev address words</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> ReadNBLT <replaceable>ctlr ndev naddr mask dev addr</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> AccessBus <replaceable>ctlr code</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> ReleaseBus <replaceable>ctlr</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> BootFPGA <replaceable>ctlr</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> SetFPGABoot <replaceable>ctlr source</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> Configure <replaceable>ctlr filename</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> ExecuteLongStack <replaceable>ctlr stack</replaceable>
            </command>
        </cmdsynopsis>
      
        <formalpara> 
          <title>Stack Building Methods</title>
          <para></para>
        </formalpara> 
  
        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sRead <replaceable>stack dev addr</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sWrite <replaceable>stack dev addr data</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sReadSBLT <replaceable>stack dev addr words</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sReadNBLT <replaceable>stack ndev naddr mask dev addr</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sAccessBus <replaceable>stack code</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sReleaseBus <replaceable>stack code</replaceable>
            </command>
        </cmdsynopsis>

        </refsynopsisdiv>

        <refsect1>
           <title>DESCRIPTION</title>
           <para>
 This is the IncrTcl base class for the family of XLM72 devices. It provides
 a large number of convenience functions that derived classes can use
 in their drivers. The JTech XLM72 family of devices are general purpose
 logic modules that have no real function independent of the firmware
 loaded onto them. For this reason, derived classed typically handle
 how to interact with devices that are running a specific firmware.
           </para>
        </refsect1>
        <refsect1>
           <title>
              COMMANDS
           </title>

           <variablelist>

             <varlistentry>
               <term><cmdsynopsis><command>
AXLM72 <replaceable>name slot</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Constructs an AXLM72 object for a device seated in
                      slot <parameter>slot</parameter>
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> GetVariable <replaceable>v</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Returns the value of the variable named <parameter>v</parameter>
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> Read <replaceable>ctlr dev address</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Immediately performs an A32/D32 read from the address $<parameter>dev</parameter>+$<parameter>address</parameter>. The access is performed through the swig wrapped CVMUSB class provided as <parameter>ctlr</parameter>. The method returns the value of read from the device.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> Write <replaceable>ctlr dev address data</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Immediately performs an A32/D32 write of <parameter>data</parameter> to the address $<parameter>dev</parameter>+$<parameter>address</parameter>. The access is performed through the swig wrapped CVMUSB class provided as <parameter>ctlr</parameter>. The returns the status of the write operation (success = 0, failure otherwise).
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> ReadSBLT <replaceable>ctlr dev address words</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Immediately performs a block transfer (A32/D32) of <parameter>words</parameter> transfers beginning at address $<parameter>dev</parameter>+$<parameter>address</parameter>. The access is performed through the swig wrapped CVMUSB class provided as <parameter>ctlr</parameter>. The method returns a swig wrapped std::vector&lt;uint8_t&gt; so one must use the cvmusb::uint8_vector_get and cvmusb::uint8_vector_size procs to handle it. The VMUSBDriverSupport::convertBytesListToTclList will convert it to a tcl list of 32-bit integer values if that is desired and sensible.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> ReadNBLT <replaceable>ctlr ndev naddr mask dev addr</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Immediately performs a block transfer (A32/D32) whose transfer count is determined by read data from the address $<parameter>ndev</parameter>+$<parameter>naddr</parameter> and applying the mask <parameter>mask</parameter> to the result. This read is an unprivileged A32/D32 read. A subsequent block transfer then begins at address $<parameter>dev</parameter>+$<parameter>address</parameter>. The access is performed through the swig wrapped CVMUSB class provided as <parameter>ctlr</parameter>. The method returns a swig wrapped std::vector&lt;uint8_t&gt; so one must use the cvmusb::uint8_vector_get and cvmusb::uint8_vector_size procs to handle it. The VMUSBDriverSupport::convertBytesListToTclList will convert it to a tcl list of 32-bit integer values if that is desired and sensible.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> AccessBus <replaceable>ctlr code</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Convenience function for gaining access of an internal bus. This is 
                      two single shot operations. The first requests the bus of interest
                      and the second inhibits the FPGA and DSP from gaining mastership.
                      The valid values for <parameter>code</parameter> are any bitwise OR of bus A (0x1), bus B (0x2), 
                      bus X (0x1000), and bus D (0x2000). The <parameter>ctlr</parameter> is a 
   swig cvmusb::CVMUSB object.

                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> ReleaseBus <replaceable>ctlr</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
   Convenience function for releasing ownership of the internal busses. 
   This is similar to the AccessBus method but writes 0 to both the bus
   request and bus inhibit addresses. The <parameter>ctlr</parameter> is a 
   swig cvmusb::CVMUSB object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> BootFPGA <replaceable>ctlr</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
   Convenience function for booting the device. The operation only boots
   the FPGA. This is accomplished by first writing 1's to the reset bits 
   of the FPGA and DSP and then writing a 1 to the DSP and a 0 to the FPGA. 
   This causes the FPGA to boot and the DSP remains in reset mode (i.e. its 
   reset bit is still set). The <parameter>ctlr</parameter> is a 
   swig cvmusb::CVMUSB object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> SetFPGABoot <replaceable>ctlr source</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
   A convenience method for writing to the FPGA boot source register.
   Valid values for <parameter>source</parameter> are : 0x0, 0x1, 0x2, 0x3, and 0x10000. The meanings
   are as follows: 
                  </para>
  <informaltable frame="all">
    <tgroup cols='2'>
    <tbody>
      <row>
        <entry>Boot Source Value</entry>
        <entry>Description</entry> 
      </row>
      <row>
        <entry>0x0</entry>
        <entry>Sector 0 flash</entry>
      </row>
      <row>
        <entry>0x1</entry>
        <entry>Sector 1 flash</entry>
      </row>
      <row>
        <entry>0x2</entry>
        <entry>Sector 2 flash</entry>
      </row>
      <row>
        <entry>0x3</entry>
        <entry>Sector 3 flash</entry>
      </row>
      <row>
        <entry>0x10000</entry>
        <entry>SRAM A</entry>
      </row>
    </tbody>
    </tgroup>
  </informaltable>
                    <para>
    The <parameter>ctlr</parameter> is a swig cvmusb::CVMUSB object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> Configure <replaceable>ctlr filename</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Loads firmware into SRAMA and then boots the device from SRAMA. The firmware is
    loaded from <parameter>filename</parameter>. The <parameter>ctlr</parameter> is a swig cvmusb::CVMUSB object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> ExecuteLongStack <replaceable>ctlr stack</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
   Converts the <parameter>stack</parameter> tcl list of raw stack commands into a 
   cvmusbreadoutlist::CVMUSBReadoutList object that gets 
   subsequently executed. Before returning the value data it is 
   parsed using the VMUSBDriverSupport::convertBytesListToTclList
   because the executeList command returns a vector of bytes.
   The <parameter>ctlr</parameter> is a swig cvmusb::CVMUSB object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sRead <replaceable>stack dev addr</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
   Adds an A32/D32 read from $<parameter>dev</parameter>+$<parameter>addr</parameter> to <parameter>stack</parameter>. <parameter>stack</parameter> is a swig cvmusbreadoutlist::CVMUSBReadoutList object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sWrite <replaceable>stack dev addr data</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
   Adds a A32/D32 write of <parameter>data</parameter> to $<parameter>dev</parameter>+$<parameter>addr</parameter> to <parameter>stack</parameter>. <parameter>stack</parameter> is a swig cvmusbreadoutlist::CVMUSBReadoutList object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sReadSBLT <replaceable>stack dev addr words</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Adds a standard block read of <parameter>words</parameter> transfers beginning at <parameter>dev</parameter>+<parameter>addr</parameter> to <parameter>stack</parameter>. <parameter>stack</parameter> is a swig cvmusbreadoutlist::CVMUSBReadoutList object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sReadNBLT <replaceable>stack ndev naddr mask dev addr words</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      This adds the same functionality of ReadNBLT to <parameter>stack</parameter>. See documentation for ReadNBLT for explanation of its functionality.
                    </para>
                </listitem>
            </varlistentry>
           
             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sAccessBus <replaceable>stack code</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Adds a bus access command to the <parameter>stack</parameter> readoutlist. See documentation for AccessBus for the allowed values.
                    </para>
                </listitem>
            </varlistentry>
           
             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sReleaseBus <replaceable>stack</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Adds a command to the <parameter>stack</parameter> readoutlist to release acquisition of any previously acquired busses.
                    </para>
                </listitem>
            </varlistentry>

          </variablelist>
        </refsect1>

    </refentry>

      <refentry id="vmusb3-AXLM72Scaler">
        <refmeta>
           <refentrytitle>AXLM72Scaler</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>AXLM72Scaler</refname>
           <refpurpose>Driver for an XLM72 running 32-channel scaler firmware</refpurpose>
        </refnamediv>
    
        <refsynopsisdiv>
            <cmdsynopsis>
                <command>
package require scalerxlm72
                </command>
            </cmdsynopsis>
          
        <cmdsynopsis>
            <command>
AXLM72Scaler <replaceable>name slot</replaceable>
            </command>
        </cmdsynopsis>
        
        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> GetFirmware <replaceable>ctlr</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> Reset <replaceable>ctlr</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> Latch <replaceable>ctlr</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> SetTrigger <replaceable>ctlr bit</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> SetTriggetBit <replaceable>ctlr bit value</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> SetTriggerBits <replaceable>ctlr bitset</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> ReadTrigger <replaceable>ctlr</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> SetEnable <replaceable>ctlr onoff</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> ReadEnable <replaceable>ctlr</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> ReadAll <replaceable>ctlr</replaceable>
            </command>
        </cmdsynopsis>

        <formalpara> 
          <title>Stack Building Methods</title>
          <para></para>
        </formalpara> 

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sEnable <replaceable>stack</replaceable>
            </command>
        </cmdsynopsis>
  
        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sDisable <replaceable>stack</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sLatch <replaceable>stack</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sReadAll <replaceable>stack</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sReset <replaceable>stack</replaceable>
            </command>
        </cmdsynopsis>

        </refsynopsisdiv>

        <refsect1>
           <title>DESCRIPTION</title>
           <para>
 This device is mostly just a 32-bit latching scaler but has the feature
 that channel inputs can be redirected as a trigger output. The trigger 
 output is the result of OR'ing all of the input signals of channels
 whose trigger bits are set. 
          </para>

          <para>
 The scaler can be enabled/disabled and atomically cleared (aka reset).
           </para>
        </refsect1>
        <refsect1>
           <title>
              COMMANDS
           </title>

           <variablelist>

             <varlistentry>
               <term><cmdsynopsis><command>
AXLM72Scaler <replaceable>name slot</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Constructs an AXLM72Scaler object for a device seated in
                      slot <parameter>slot</parameter>
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> GetFirmware <replaceable>ctlr</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Reads and returns the firmware signature. The <parameter>ctlr</parameter> is
                      a cvmusb::CVMUSB object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> Reset <replaceable>ctlr</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                    Atomically resets all scaler values by writing a 1 and then a 0 to the lowest
                    address of the FPGA address space. Returns 0 on success or a negative value for failure.
                    The <parameter>ctlr</parameter> is a cvmusb::CVMUSB object. 
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> Latch <replaceable>ctlr</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Latch the current values of the scaler counters into SRAMA for readout. 
                      The <parameter>ctlr</parameter> is a cvmusb::CVMUSB object.

                    </para>
                    <para>
                      The return value of this is either 0 for success or -1 for failure.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> SetTrigger <replaceable>ctlr bit</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
   As a result of history, this relies on the state of the
   trigger array to determine what to write. This ultimately
   calls SetTriggerBits after properly setting the requested
   bit. The <parameter>ctlr</parameter> is a cvmusb::CVMUSB object.
                    </para>
                    <para>
    The return value of this is either 0 for success or -1 for failure.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> SetTriggerBits <replaceable>ctlr bitset</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
   As opposed to the previous two methods, this replaces the
   entire trigger register value rather than manipulating 
   specific bits. It is therefore a lower level method but
   it enables one to write all bits at once. The value of <parameter>bitset</parameter>
   is written to the entire register. The <parameter>ctlr</parameter> is a 
   cvmusb::CVMUSB object.
                    </para>
                    <para>
    The return value of this is either 0 for success or -1 for failure.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> ReadTrigger <replaceable>ctlr</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Read the trigger register.
    The <parameter>ctlr</parameter> parameter is a cvmusb::CVMUSB object.
                    </para>
                    <para>
    The return value of this the value of the trigger register. 
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> SetEnable <replaceable>ctlr onoff</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Write the value of <parameter>onoff</parameter> to the enable register. Valid
    values for <parameter>onoff</parameter> are 0 (i.e. enable on) and 1 (i.e. enable off).
    The <parameter>ctlr</parameter> parameter is a cvmusb::CVMUSB object.
                    </para>
                    <para>
    Returns either 0 for success or -1 for failure.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> ReadEnable <replaceable>ctlr</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Read and return the value of the enable register. 
    The <parameter>ctlr</parameter> parameter is a cvmusb::CVMUSB object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> ReadAll <replaceable>ctlr</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Read and return the value of all 32 scaler counters.
    The <parameter>ctlr</parameter> parameter is a cvmusb::CVMUSB object.
                    </para>
                    <para>
    The return value of this is a tcl list of all 32 channels of scaler values.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sEnable <replaceable>stack</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Appends a write of 1 to the enable register onto <parameter>stack</parameter>.
    The <parameter>stack</parameter> parameter is a cvmusbreadoutlist::CVMUSBReadoutList object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sDisable <replaceable>stack</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Appends a write of 0 to the enable register onto <parameter>stack</parameter>.
    The <parameter>stack</parameter> parameter is a cvmusbreadoutlist::CVMUSBReadoutList object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sLatch <replaceable>stack</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Adds a command to <parameter>stack</parameter> to latch the current value of the scaler
    counter into the SRAMA memory for later readout. The <parameter>stack</parameter> parameter is a cvmusbreadoutlist::CVMUSBReadoutList object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sReadAll <replaceable>stack</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Adds a readout cycle to <parameter>stack</parameter>. The values of the counters are
    latched and then are readout using a BLT. After the BLT, the SRAMA data is reset. This handles the acquisition of the appropriate busses. The <parameter>stack</parameter> parameter is a cvmusbreadoutlist::CVMUSBReadoutList object. 
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sReset <replaceable>stack</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Adds a write of 0 to SRAMA[0] to reset the data. The <parameter>stack</parameter> parameter is a cvmusbreadoutlist::CVMUSBReadoutList object.
                    </para>
                </listitem>
            </varlistentry>
          </variablelist>
        </refsect1>

    </refentry>

   <!-- caenchain command - aggregate 785's into CBLT chains -->

<!-- /manpage -->
<!-- manpage 5vmusb -->

    <refentry id="vmusb5-slowcontrols-protocol">
      <refmeta>
         <refentrytitle>VMUSB slow controls protocol</refentrytitle>
         <manvolnum>5vmusb</manvolnum>
      </refmeta>
      <refnamediv>
         <refname>VMUSB Slow controls protocol</refname>
         <refpurpose>VMUSB Slow controls protocol</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
        <cmdsynopsis>
        <command>
Set <replaceable>module-name parameter-name value</replaceable>
        </command>
        </cmdsynopsis>
          <cmdsynopsis>
              <command>
Get <replaceable>module-name parameter-name</replaceable>
              </command>
          </cmdsynopsis>
          <cmdsynopsis>
              <command>
mon <replaceable>module-name</replaceable>
              </command>
          </cmdsynopsis>

      </refsynopsisdiv>
      <refsect1>
         <title>DESCRIPTION</title>
         <para>
          The slow controls protocol allows control panel software
          to be built that communicates with slow controls drivers
          in the VM-USB raadout framework.   This is intended to allow
          the contruction of control panels for devices that have slow
          controls drivers.  Note that the <classname>vmusb</classname>
          controller allows drivers to be written for devices
          that don't have slow controls drivers yet.
         </para>
         <para>
          The slow controls server listens for connections on the port
          specified by the Readout program's <option>--port</option>
          option or <literal>27000</literal> if that option is not
          specified.
         </para>
         <para>
          Connected clients send commands to the server as lines
          of text and get back singe line replies.  Replies are
          expected to begin with <literal>OK</literal> if the request
          was successful and <literal>ERROR</literal> otherwise.
          The text that follows the header text depends on the
          driver.
         </para>
      </refsect1>
      <refsect1>
          <title>
             COMMANDS
          </title>
          <variablelist>
              <varlistentry>
                  <term><command>Set <replaceable>module-name module-parameter value</replaceable></command></term>
                  <listitem>
                      <para>
                          Attempts to set a parameter
                          <parameter>module-parameter</parameter>
                          in a module <parameter>module-name</parameter>
                          to a new <parameter>value</parameter>.
                      </para>
                      <para>
                          <parameter>module-name</parameter> is the name
                          of a module that has been defined by the
                          control configuration file.
                          <parameter>module-parameter</parameter>
                          is a parameter that must be recognized by
                          the driver that manage that module.
                          <parameter>value</parameter> must be a valid
                          new value for that parameter.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><command>Get <replaceable>module-name module-parameter</replaceable></command></term>
                  <listitem>
                      <para>
                          Retrives a parameter (<parameter>module-parameter</parameter>)
                          from a module (<parameter>module-name</parameter>).   
                      </para>
                      <para>
                          <parameter>module-name</parameter> is the name
                          of a module that has been defined by the
                          control configuration file.
                          <parameter>module-parameter</parameter>
                          is a parameter that must be recognized by
                          the driver that manage that module.
                          It is entirely up to the module driver to
                          decide what is returned, however by
                          convention, as described above, the string
                          returned will begin either with
                          <literal>OK</literal> or
                          <literal>ERROR</literal>.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><command>mon <replaceable>module-name</replaceable></command></term>
                  <listitem>
                      <para>
                          Returns data that is monitored by the
                          device.  Again it is up to the driver
                          to decide exactly what should be returned.
                      </para>
                  </listitem>
              </varlistentry>
              
          </variablelist>
       </refsect1>

    </refentry>


        
        
<!-- /manpage -->
