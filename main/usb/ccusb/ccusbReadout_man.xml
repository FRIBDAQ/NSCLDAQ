<!-- manpage 3ccusb -->
    <refentry id='ccusb3-addtcldriver'>
        <refmeta>
           <refentrytitle>addtcldriver</refentrytitle>
           <manvolnum>3ccusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>addtcldriver</refname>
           <refpurpose>Register Tcl command ensemble as a device module</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
addtcldriver <replaceable>tcl-command</replaceable>
            </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Registers the base of a Tcl command ensemble (e.g. an object
            instance command) as a device module that can be used in
            module lists such as the <option>-modules</option> option of a
            <command>stack</command> command.
           </para>
           <para>
                The <parameter>tcl-command</parameter> is the command
                to regsiter.
           </para>
        </refsect1>
        <refsect1>
            <title>EXAMPLE</title>
            <para>
                The command below:
            </para>
            <informalexample>
                <programlisting>
addtclcommand sometclinstance
                </programlisting>
            </informalexample>
            <para>
                Registers the Tcl command <command>sometclinstance</command>
                as a module.  The name of the module is the same as the
                name of the command (<literal>sometclinstance</literal>).
            </para>
            </refsect1>

      </refentry>


	 <refentry id="ccusb3-ad811">
	   <refmeta>
	      <refentrytitle>ad811</refentrytitle>
	      <manvolnum>3ccusb</manvolnum>
	   </refmeta>
	   <refnamediv>
	      <refname>ad811</refname>
	      <refpurpose>Support the Ortec AD811 ADC</refpurpose>
	   </refnamediv>
	   
	   <refsynopsisdiv>
	     <cmdsynopsis>
	     <command>
ad811 create <replaceable>module-name   ?option...?</replaceable>
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
ad811 config <replaceable>module-name ?option...?</replaceable>
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
ad811 cget <replaceable>module-name</replaceable>
	     </command>
	     </cmdsynopsis>
	   </refsynopsisdiv>
	   <refsect1>
	      <title>DESCRIPTION</title>
	      <para>
	       This command ensemble provides support for the ORTEC AD811
	       8 channel peak sensing ADC.  This module requires about 80
	       microseconds to convert.  All channels convert unconditionally.
	      </para>
	      <para>
		  <parameter>module-name</parameter> is either the name to be
		  given to an ADC in the <command>create</command> subcommand
		  or the name given to a previously created module in the
		  <command>config</command> or <command>cget</command> commands.
	      </para>
	      <para>
	       Both <command>create</command> and <command>config</command> take
	       configuration options.   Each option is a keyword value pair where
	       the keyword defines what the option is and the value is a value
	       associated with that option.  See OPTIONS below for more information
	       about the options supported by <command>ad811</command>.
	      </para>
	      <para>
	       The <command>cget</command> option returns the configuration options
	       for the named module as a Tcl list.  Each element of the list is
	       a two element sublist.  The first element of each sublist is
	       the configuration parameter name, and the second the value associated
	       with that name.
	      </para>
	   </refsect1>
	   <refsect1>
	    <title>
	       OPTIONS
	    </title>
	    <para>
	       The <command>ad811</command> configuration options are:
	    </para>
	    <variablelist>
	       <varlistentry>
		  <term><option>-id</option> <replaceable>vsn</replaceable></term>
		  <listitem>
		     <para>
			   Each module has an identifier which, for historical
			   reasons is called a <firstterm>virtual slot number</firstterm>,
			   or <firstterm>vsn</firstterm>.  To maximize the decode
			   error detection the virtual slot numbers for each
			   module should be unique.  This option allows you
			   to set the virtual slot number for the module.
		     </para>
		     </listitem>
	       </varlistentry>
	       <varlistentry>
		  <term><option>-slot</option> <replaceable>slotnum</replaceable></term>
		  <listitem>
		     <para>
			The value of this parameter tells the readout software
			which CAMAC crate slot houses the module.  Recall that
			CAMAC is slot addressable.  Slots number from 1 on the
			left, with an increasing slot number towards the right.
			The right two slots are reserved for the CAMAC Crate
			controller (in our case a CC-USB).
		     </para>
		  </listitem>
	       </varlistentry>
	    </variablelist>
	   </refsect1>
	   <refsect1>
	      <title>EXAMPLE</title>
	      <para>
	       The example below creates and configures an AD811 that is in
	       slot 2 of the CAMAC crate and, when read will have a virtual
	       slot number of 2:
	      </para>
	      <example>
		  <title>AD811 configuration file example</title>
		  <programlisting>
ad811  create adc -slot 2 -id 2
		  </programlisting>
	      </example>
	   </refsect1>
	 
	 </refentry>
         
<refentry id="ccusb3-c1205">
  <refmeta>
     <refentrytitle>c1205</refentrytitle>
     <manvolnum>3ccusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>c1205</refname>
     <refpurpose>Manage CAEN C1205 QDC modules.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
    <command>
c1205 create <replaceable>module-name ?option...?</replaceable>
    </command>
    </cmdsynopsis>
<cmdsynopsis>
<command>
c1205 config <replaceable>module-name ?option...?</replaceable>
</command>
</cmdsynopsis>
<cmdsynopsis>
<command>
c1205 config <replaceable>module-name</replaceable>
</command>
</cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
	      <para>
		  This command ensemble allows you to create and configure
		  CAEN model C1205 QDC modules.  The C1205 is a sixteen
		  channel charge integrating ADC.
	      </para>
	      <para>
		  The <command>create</command> command
		  allows you to create a new module and assign a
		  <parameter>module-name</parameter> to it so that it can
		  be referred to in subsequent configuration commands.
		  You may optionally include configuration switch value pairs
		  on the <command>create</command> command line.
	      </para>
	      <para>
		  The <command>config</command> subcommand allows you to
		  set the configuration parameters for an existing module.
		  <parameter>module-name</parameter> is the name assigned to
		  that module whe it was created.
	      </para>
	      <para>
		  The <command>cget</command> command returns as its value
		  the module configuration as a Tcl list where each list element
		  is a sublist containing the name and value of a configuration
		  parameter.
	      </para>
	      <para>
		  Configuration options are name/value pairs.   The name
		  of a configuration option is sometimes called a
		  <firstterm>switch</firstterm> because it resembles the
		  command line switches of command shell commands.
		  For a full description of these options see OPTIONS below.
	      </para>
  </refsect1>
  <refsect1>
      <title>OPTIONS</title>
      <para>
	 The CAEN C1205 supports the following configuration option switches.
	 The switches and values can be supplied to both the
	 <command>create</command> and the <command>config</command>
	 subcommands.
      </para>
      <variablelist>
	 <varlistentry>
	 <term><option>-slot</option> <replaceable>n</replaceable></term>
	 <listitem>
	    <para>
	       Specifies the slot in which the module is installed
	       to <literal>n</literal>.
	       If this is not set correctly, the Readout program will
	       not be able to communicate with the module and will emit
	       a warning, if the slot <literal>n</literal> is empty.
	       This parameter must be provided.
	    </para>
	 </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-id</option> <replaceable>n</replaceable></term>
	    <listitem>
	       <para>
		  Sets the id of the module to <literal>n</literal>.
		  The module id is placed as a marker word prior
		  to the data from the module.  It is used by the
		  unpacking software to unambiguously identify The
		  data from each module.  For the C1205, the id
		  value is also programmed into the lower 8 bits of the
		  control status register and will therefore also
		  appear in the bottom 8 bits of the header word
		  read from the module.
	       </para>
	       <para>
		  While the <option>-id</option> value defaults to
		  0, and need not be unique, your data is most
		  reliably decoded if each module in your system has
		  a unique id value.
	       </para>
	    </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-usepedestals</option> <replaceable>true|false</replaceable></term>
	    <listitem>
	       <para>
		  The value of this configuration parameter determines how
		  bit 12 of the control status register is initialized.
		  If <literal>true</literal> (default value), the bit is
		  set to one which enables pedestal subtraction from the input
		  signal.
	       </para>
	    </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-hires</option> <replaceable>true|false</replaceable></term>
	    <listitem>
	       <para>
		  The value of this configuration parameter determins how
		  bit 16 of the module control status register is
		  initialized.  If <literal>true</literal> (default value)
		  the bit is set to zero enabling high resolution mode.
		  If set <literal>false</literal> low resolution mode
		  is selected.
		  High resolution
		  mode provides 12 bits of data resolution while low
		  resolution mode provides only 10 bits of data resolution.
		  High resolution comes at a cost of an additional 1.5
		  microseconds of conversion time (5.5 microseconds compared
		  with 4 microseconds for low resolution).
	       </para>
	    </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-thresholds</option> <replaceable>threshold-list</replaceable></term>
	    <listitem>
	       <para>
		  Provides the channel threshold registers.  This is a Tcl
		  list of 16 integers in the range <literal>0-4095</literal>.
		  Data is read from a module only if the data value for the
		  module's low range is greater than the corresponding element
		  of the list.  The thresholds default to a list of 16 zeroes.
	       </para>
	    </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-lopedestals</option> <replaceable>pedestal-list</replaceable></term>
	    <listitem>
	       <para>
		  Provides a list of 16 integers (0-4095) which are subtracted
		  from the data values to  produce the low range value.
	       </para>
	    </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-midpedestals</option> <replaceable>pedestal-list</replaceable></term>
	    <listitem>
	       <para>
		  Same  as <option>-lopedestals</option> but the pedestals
		  are applied to the mid level conversion.
	       </para>
	    </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-hipedestal</option> <replaceable>pedestal-list</replaceable></term>
	    <listitem>
	       <para>
		  Same as <option>-lopedestals</option> but the pedestals
		  are applied to the low level conversion.
	       </para>
	    </listitem>
	 </varlistentry>
	 <varlistentry>
	    <term><option>-rangemode</option> <replaceable>mode</replaceable></term>
	    <listitem>
	       <para>
		  Sets the module range mode.  The value for
		  <replaceable>mode</replaceable> must be one of the following:
		  <variablelist>
		     <varlistentry>
			<term><literal>all</literal></term>
			<listitem>
			   <para>
			      Conversions from all ranges appear in each event.
			      In this mode, some of the conversions will likely
			      have negative values.
			   </para>
			</listitem>
		     </varlistentry>
		     <varlistentry>
			<term><literal>auto</literal></term>
			<listitem>
			   <para>In this mode (default) only the  range
			      the conversion falls in will appear in the
			      data fromt he mdule.
			   </para>
			</listitem>
		     </varlistentry>
		     <varlistentry>
			<term><literal>sparse</literal></term>
			<listitem>
			   <para>Same as auto, but only data from channels
			      are above the channel thresholds set
			      via the <option>-thresholds</option> option
			      appear in the data from the module.
			   </para>
			</listitem>
		     </varlistentry>
			      
		  </variablelist>
	       </para>
	    </listitem>
	 </varlistentry>
	 
      </variablelist>
  </refsect1>
</refentry>

<refentry id="ccusb3-c257">
  <refmeta>
     <refentrytitle>c257</refentrytitle>
     <manvolnum>cccusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>c257</refname>
     <refpurpose>Manages the C257 scaler module</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
    <command>
c257 create <replaceable>name ?options...?</replaceable>
    </command>
    </cmdsynopsis>
    <cmdsynopsis>
    <command>
c257 config <replaceable>name ?options...?</replaceable>   
    </command>
    </cmdsynopsis>
   <cmdsynopsis>
   <command>
c257 cget <replaceable>name</replaceable>   
   </command>
   </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
	 <para>
	     This command ensemble allows you to create and configure
	     CAEN model C257 scaler modules.  The C257 is a 16 channel
	     scaler module.  Support is intended to be used with the
	     scaler stack.  The C257 is capable of cascading channels
	     to produce very wide counters, however this mode is not supported
	     by this release of the software limiting the width of each
	     scaler to 24 bits.  Thus, to use the module with this
	     software requires that all of the module jumpers be set to the
	     <literal>SINGLE</literal> position rather than to
	     <literal>CASCADE</literal>.
	 </para>
	 <para>
	     The <command>create</command> command
	     allows you to create a new module and assign a
	     <parameter>module-name</parameter> to it so that it can
	     be referred to in subsequent configuration commands.
	     You may optionally include configuration switch value pairs
	     on the <command>create</command> command line.
	 </para>
	 <para>
	     The <command>config</command> subcommand allows you to
	     set the configuration parameters for an existing module.
	     <parameter>module-name</parameter> is the name assigned to
	     that module whe it was created.
	 </para>
	 <para>
	     The <command>cget</command> command returns as its value
	     the module configuration as a Tcl list where each list element
	     is a sublist containing the name and value of a configuration
	     parameter.
	 </para>
	 <para>
	     Configuration options are name/value pairs.   The name
	     of a configuration option is sometimes called a
	     <firstterm>switch</firstterm> because it resembles the
	     command line switches of command shell commands.
	     For a full description of these options see OPTIONS below.
	 </para>
  </refsect1>
  <refsect1>
   <title>
      OPTIONS
   </title>
   <para>
      The module is configured via the following set of options.
   </para>
   <variablelist>
      <varlistentry>
	 <term><option>-slot</option> <replaceable>slotnumber</replaceable></term>
	 <listitem>
	    <para>
	       Specifies <parameter>slotnumber</parameter> as the CAMAC
	       crate slot in which the module  is inserted.  This must
	       be correct or else the software will not be able to
	       communicate with the module.
	    </para>
	 </listitem>
      </varlistentry>
      <varlistentry>
	  <term><option>-id</option> <replaceable>module-id</replaceable></term>
	  <listitem>
	      <para>
	       Specifies a module id for the unit.  If the
	       <option>-insertid</option> configuration parameter is
	       <literal>true</literal> this id is inserted prior to the
	       scaler data readout by the stack.  This option, and
	       <option>-insertid</option> should not be used in the scaler
	       stack and is intended as latent support for using the
	       scaler in an event stack (e.g. for supplying an event
	       timestamp).
	      </para>
	  </listitem>
      </varlistentry>
      <varlistentry>
	  <term><option>-insertid</option> <replaceable>true|false</replaceable></term>
	  <listitem>
	      <para>
	       If this parameter is <literal>true</literal> the value specified
	       by the <option>-id</option> option will be inserted in the data
	       buffer prior to the
	       data from this module.
	       This should be <literal>false</literal> (the default) if
	       the module is used in the scaler stack.
	      </para>
	      <para>
		  <option>-id</option> and <option>-insertid</option>
		  are intended as latent support for using the scaler module
		  in the event stack (e.g. to supply an event timestamp).
	      </para>
	  </listitem>
      </varlistentry>
      <varlistentry>
	  <term><option>-readinhibit</option> <replaceable>true | false</replaceable></term>
	  <listitem>
	      <para>
	       If this parameter is <literal>true</literal> (the default), the
	       CAMAC crate is held inhibited while the scaler module is
	       being read, and the module is read with an F2 Q-scan.
	       If <literal>false</literal> the module is read via 16
	       F0's directed at specific subaddresses followed by an
	       F9 to reset the counters.
	      </para>
	  </listitem>
      </varlistentry>
   </variablelist>
  </refsect1>

</refentry>
      <refentry id="ccusb3_ccusb_command">
        <refmeta>
           <refentrytitle id='ccusb3_ccusb_command_title'>ccusb (command)</refentrytitle>
           <manvolnum>3ccusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>ccusb (command)</refname>
           <refpurpose>Configure and read scalers from CC-USB module</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
          <command>
ccusb create name ?options?
          </command>
          </cmdsynopsis>
          <cmdsynopsis>
            <command>
ccusb config name ?options?
            </command>
          </cmdsynopsis>
          <cmdsynopsis>
            <command>
ccusb cget name
            </command>
            </cmdsynopsis>
        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            <command>ccusb</command> provides a readout module that allows you
            to configure many of the resources of the CCUSB as well as
            providing the capability of rerading the module internal scalers.
            Note that owing to the way the framework operates, you must include
            CCUSB modules in either the event or scaler stack in order to
            configure them, even if you don't intend to readout the scalers.
           </para>
           <para>
            For the configuration options see <literal>OPTIONS</literal>
            below.
           </para>
           <para>
            The resources you can control are the module internal gate and delay
            generators, the module internal scalers, the meaning of the
            Module NIM outputs and inputs and the meaning of the front panel
            LED displays.
           </para>
        </refsect1>
            <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
            <varlistentry>
                <term><option>-gdgasource</option></term>
                <listitem>
                    <para>
                        Defines the start of the module internal gate and delay
                        generator A.  This can be one of:
                        <literal>disabled, in1, in2, in3, event, eventend, usbtrigger, </literal>
                        or <literal>pulser</literal>.   Sections 3.3.6 and 3.3.7
                        of the CCUSB manual provide more information about the
                        Gate and delay generators.
                    </para>
                    <para>This option defaults to <literal>disabled</literal></para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-gdgbsource</option></term>
                <listitem>
                    <para>
                        Same as <option>-gdgasource</option>, however the
                        B gate and delay generator start is set.  The same set
                        of values accepted for <option>-gdgasource</option>
                        are accepted for this option.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-gdgawidth</option></term>
                <listitem>
                    <para>
                        Sets the output width of the A Gate and delay generator.
                        This can be a value from <literal>0</literal> through
                        <literal>0xffff</literal> and is in 10ns units.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-gdgbwidth</option></term>
                <listitem>
                    <para>
                        Sets the output width of the B gate and delay generator.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-gdgadelay</option></term>
                <listitem>
                    <para>
                        Sets the output delay on the A gdg output. This can be
                        in the range <literal>0</literal> through
                        <literal>0xffffffff</literal>.  It winds up setting both
                        a field in the
                        <literal>DGG_A</literal> register and the
                        <literal>DGG_Ext</literal> register.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-gdgbdelay</option></term>
                <listitem>
                    <para>
                        Sets the output delay on the B gdg output.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-red</option></term>
                <listitem>
                    <para>
                        Sets the signal that is reflected on the red LED on the
                        module front panel.  This is modified by the
                        <option>-redinvert</option> and <option>-redlatch</option>
                        options described below.
                    </para>
                    <para>
                        Legal values are
                        <literal>event, busy, usboutnotempty</literal> and
                        <literal>usbinnotfull</literal>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-redinvert</option></term>
                <listitem>
                    <para>
                        This boolean parameter, if <literal>true</literal>
                        inverts the sense of the red front panel LED.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>-redlatch</term>
                <listitem>
                    <para>
                        If true, this boolean parameter latches the red front panel
                        LED on once the condition required to ligth it is met.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-green</option></term>
                <listitem>
                    <para>
                        This enumerated parmeter, together with
                        <option>-greeninvert</option> and <option>-greenlatch</option>,
                        determines when the green LED should be lit.  Valid values
                        are:
                        <literal>acquire, nimi1, nimi2, usbinnotemtpy</literal>
                        and <literal>usbtrigger</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-greeninvert</option></term>
                <listitem>
                    <para>
                        Inverts the sense of the green front panel LED.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-greenlatch</option></term>
                <listitem>
                    <para>
                        Latches the green LED on when the condition to light it
                        is met.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-yellow</option></term>
                <listitem>
                    <para>
                        Together with <option>-yellowinvert</option> and
                        <option>-yellowlatch</option> when the yellow front
                        panel LED is lit.  This can be one of the following values:
                        <literal>nimi1, nimi3, busy</literal> or
                        <literal>usbinfifionotempty</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-scalara</option></term>
                <listitem>
                    <para>
                        Defines what makes the A scaler count.  This can have
                        any of the following values:
                        <literal>disabled, nimi1, nimi2, nimi3, event, carryb, dgga</literal>
                        or <literal>dggb</literal>.  The <literal>carryb</literal>
                        increments the scaler when the B scale overflows.  This
                        provides the ability to make the A scaler the most significant
                        24 bits of a 48 bit scaler with the B scaler the least
                        significant 24 bits.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-scalerb</option></term>
                <listitem>
                    <para>
                        Defines what makes scaler B count.  This can have any of
                        the following values:
                         <literal>disabled, nimi1, nimi2, nimi3, event, carrya, dgga</literal>
                        or <literal>dggb</literal>. The <literal>carrya</literal>
                        increments the scaler when the A scale overflows.  This
                        provides the ability to make the B scaler the most significant
                        24 bits of a 48 bit scaler with the A scaler the least
                        significant 24 bits.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-out1</option></term>
                <listitem>
                    <para>
                        Together with <option>-out1invert</option>
                        and <option>-out1latch</option> determines the condition
                        that drives the O1 NIM output.  This can be one of the
                        following values:
                        <literal>busy, event, gdga</literal> or
                        <literal>gdgb</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-out1invert</option></term>
                <listitem>
                    <para>
                        Inverts the sense of the O1 NIM output.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-out1latch</option></term>
                <listitem>
                    <para>
                        Latches the state of O1 once the condition needed to
                        make it a logic true has been detected.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-out2</option></term>
                <listitem>
                    <para>
                        Together with <option>-out2invert</option> and
                        <option>-out2latch</option> determines when the
                        NIM O2 signal is asserted.  This can be one of the
                        following values:
                        <literal>acquire, event, gdga, </literal> or
                        <literal>gdgb</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-out2invert</option></term>
                <listitem>
                    <para>
                        Inverts the sense of the O2 NIM output.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-out2latch</option></term>
                <listitem>
                    <para>
                        Latches the NIM O2 state when the condition to assert
                        it has been met.  This condition is determined by
                        both <option>-out2</option> and
                        <option>-out2invert</option>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-out3</option></term>
                <listitem>
                    <para>
                        Together with <option>-out3invert</option>
                        and <option>-out3latch</option> determines the behavior
                        of the NIM O3 output.  This can be any of the following
                        values: <literal>busyend, busy, gdga, </literal> or
                        <literal>gdgb</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-o3invert</option></term>
                <listitem>
                    <para>
                        Inverts the condition that asserts O3.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-o3latch</option></term>
                <listitem>
                    <para>
                        Latches O3 in the asserted state when the condition
                        to assert it is met.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-readscalers</option></term>
                <listitem>
                    <para>
                        Boolean that when true enables the readout of the A and
                        B scalers in the stack this module is in.  The A scaler
                        is read first then the B scaler.  
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-incremental</option></term>
                <listitem>
                    <para>
                        This boolean parameters only matters when
                        <option>-readscalers</option> is true.  It causes
                        the scalers to be cleared once they have been read.
                        Note that in general some counts may be lost as there
                        is no way to atomically read and clear the scaler counters.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-bulktransfermode</option></term>
                <listitem>
                    <para>
                        This enum parameter provides user control over the 
                        criteria for a usb bulk transfers. This can be any
                        of the following: <literal>default, nbuffers, timeout</literal>.
                        The <literal>default</literal> provides the default behavior of 
                        timeout of 1 second. The nbuffers <literal>nbuffers</literal> 
                        allows the user to specify a number of data buffers to be 
                        bundled in a given USB bulk write. The user must specify the
                        <literal>-nbuffers2transfer</literal> options. The <literal>timeout</literal>
                        generate a packet end after the time specified for the timeout.
                        The user must specify the <literal>-bulktransfertimeout</literal>
                        option for this mode. 
                   </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-nbuffers2transfer</option></term>
                <listitem>
                    <para>
                      This integer parameter specifies the number of buffers to 
                      bundle in a given usb bulk write. This must be a number between
                      1 and 255.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-bulktransfertimeout</option></term>
                <listitem>
                    <para>
                        Specifies the timeout value for a the usb bulk transfer mode.
                        Values are between 0 and 15 and specify the number of seconds 
                        beyond 1 second to timeout.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-bufferlength</option></term>
                <listitem>
                    <para>
                        Enum that specifies the buffer size used by the CCUSB. This can
                        be any of the following values: 4096, 2048, 1024, 512, 256, 128, 
                        64, singleevent
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-forcescalerdump</option></term>
                <listitem>
                    <para>
                      When true, this causes the CC-USB to flush its buffers
                      after every scaler stack execution. It is very useful
                      when there is either a very low data rate or only
                      a scaler stack defined. The default value is false.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-mixedbuffer</option></term>
                <listitem>
                    <para>
                      When true, this allows the CC-USB to put scaler-type data
                      and event-type data in the same buffer. This defaults to
                      false.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-triggerlatch</option></term>
                <listitem>
                    <para>
                      When true, the execution of a scaler stack causes the
                      the event stack to execute immediately at completion.
                      The default value is false.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term><option>-printconfig</option></term>
                <listitem>
                    <para>
                      When true, all register values for the CC-USB are read and
                      printed at the completion of the initialization stage.
                      This is useful for inspecting the exact register contents
                      used for an ongoing run. The default value is false.
                    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>

      </refentry>

	 <refentry id="lccusb3-rs2228">
	   <refmeta>
	      <refentrytitle>lrs2228</refentrytitle>
	      <manvolnum>3ccusb</manvolnum>
	   </refmeta>
	   <refnamediv>
	      <refname>lrs2228</refname>
	      <refpurpose>Manages the LRS2228 TDC</refpurpose>
	   </refnamediv>
	   
	   <refsynopsisdiv>
	     <cmdsynopsis>
	     <command>
lrs2228 create <replaceable>module-name ?option...?</replaceable>
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
lrs2228 config <replaceable>module-name ?option...?</replaceable>
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
lrs2228 cget <replaceable>module-name</replaceable>
	     </command>
	     </cmdsynopsis>
	     
	   </refsynopsisdiv>
	   <refsect1>
	      <title>DESCRIPTION</title>
	      <para>
		  This command ensemble allows you to create and configure
		  LeCroy model LRS 2228 TDC modules.  The LRS 2228 is an eight
		  channel Time digitizer.
	      </para>
	      <para>
		  The <command>create</command> command
		  allows you to create a new module and assign a
		  <parameter>module-name</parameter> to it so that it can
		  be referred to in subsequent configuration commands.
		  You may optionally include configuration switch value pairs
		  on the <command>create</command> command line.
	      </para>
	      <para>
		  The <command>config</command> subcommand allows you to
		  set the configuration parameters for an existing module.
		  <parameter>module-name</parameter> is the name assigned to
		  that module whe it was created.
	      </para>
	      <para>
		  The <command>cget</command> command returns as its value
		  the module configuration as a Tcl list where each list element
		  is a sublist containing the name and value of a configuration
		  parameter.
	      </para>
	      <para>
		  Configuration options are name/value pairs.   The name
		  of a configuration option is sometimes called a
		  <firstterm>switch</firstterm> because it resembles the
		  command line switches of command shell commands.
		  For a full description of these options see OPTIONS below.
	      </para>
	   </refsect1>
	   <refsect1>
	    <title>OPTIONS</title>
	    <para>
	       The following options are recognized by the
	       <command>lrs2228 create</command> and
	       <command>lrs2228 config</command> commands.
	    </para>
	    <variablelist>
	       <varlistentry>
		  <term><option>-id</option> <replaceable>vsn</replaceable></term>
		  <listitem>
		     <para>
			Each module should be assigned a unique virtual
		        number.  If not assigned this will be 0.  The data packet
			returned by the module will be prefixed by the ID.
			This provides error checking for the code that wil be
			unpacking the raw data.
		     </para>
		  </listitem>
	       </varlistentry>
	       <varlistentry>
		  <term><option>-slot</option> <replaceable>camac-slot</replaceable></term>
		  <listitem>
		     <para>
			Provides the number of the slot in which the CAMAC
			module has been installed (<parameter>camac_slot</parameter>).
			This must match the physical slot the module has been
			stuffed in in order to ensure the proper module is
			initialized and reads.
		     </para>
		  </listitem>
	       </varlistentry>
	    </variablelist>
	   </refsect1>
	   <refsect1>
	      <title>EXAMPLES</title>
	      <para>
		  The following is an example of the <command>create</command>
		  command for the LRS2228:
	      </para>
	      <example>
	       <title>LRS2228 creation example</title>
	       <programlisting>
lrs2228 create tdc -slot 6 -id 4		  
	       </programlisting>
	      </example>
	   </refsect1>
	 </refentry>
	 <refentry id="ccusb3-lrs2249">
	   <refmeta>
	      <refentrytitle>lrs2249</refentrytitle>
	      <manvolnum>3ccusb</manvolnum>
	   </refmeta>
	   <refnamediv>
	      <refname>lrs2249</refname>
	      <refpurpose>Manage LeCroy 2249 QDC modules</refpurpose>
	   </refnamediv>
	   
	   <refsynopsisdiv>
	     <cmdsynopsis>
	     <command>
lrs2249 create <replaceable>module-name ?option...?</replaceable>
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
lrs2249 config <replaceable>module-name ?option...?</replaceable>
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
lrs2249 cget <replaceable>module-name</replaceable>
	     </command>
	     </cmdsynopsis>
	   </refsynopsisdiv>
	   <refsect1>
	      <title>DESCRIPTION</title>
	      <para>
	       The <command>lrs2249</command> command ensemble
	       allows you to read out
	       LeCroy model LRS 2249 modules.  The LRS 2249 is a charge integrating
	       ADC (QDC).
	      </para>
	      <para>
	       The <command>create</command> subcommand creates
	       a new module assigning it the <parameter>module-name</parameter>
	       you supply.  The <parameter>module-name</parameter> can be used
	       to refer to the module in future commands.  You may optionally
	       provide cofiguration information when creating the module.
	      </para>
	      <para>
	       The <command>config</command> subcommand configures an existing
	       module by providing configuration options for an existing
	       <parameter>module-name</parameter> (created via the
	       <command>create</command> subcommand).  Configuration options are
	       name/value pairs that are also sometimes called switches because
	       of their resemblance to shell command switches.  For a list of
	       the valid configuration options for the LRS 2249 module, see
	       the OPTIONS section below.
	      </para>
	      <para>
	       The <command>cget</command> subcommand returns the configuration
	       parameters for <parameter>module-name</parameter> as a Tcl list
	       of items.  Each item is itself a two element sublist containing
	       in order the name and value of a configuration option.
	      </para>
	   </refsect1>
	   <refsect1>
	    <title>OPTIONS</title>
	    <para>
	       The <command>lrs2249</command> command has the following configuration
	       options:
	    </para>
	    <variablelist>
	       <varlistentry>
		  <term><option>-id</option> <replaceable>vsn</replaceable></term>
		  <listitem>
		     <para>
			Sets the module virtual slot number to <parameter>vsn</parameter>.
			The virtual slot number prefixes the data packet read from this
			module and is used by SpecTcl as a check on the validity
			the event.  Each module should have a unique <parameter>vsn</parameter>.
			If the <option>-id</option> option does not set the virtual
			slot it defaults to 0.
		     </para>
		  </listitem>
	       </varlistentry>
	       <varlistentry>
		  <term><option>-slot</option> <replaceable>slot</replaceable></term>
		  <listitem>
		     <para>
			Provides the module <parameter>slot</parameter>.  This
			parameter must match the number of the slot in the
			CAMAC crate in which the module is installed.
		     </para>
		  </listitem>
	       </varlistentry>
	    </variablelist>
	       
	   </refsect1>
        </refentry>
	 <refentry id="ccusb3-lrs2551">
	   <refmeta>
	      <refentrytitle>lrs2551</refentrytitle>
	      <manvolnum>3ccusb</manvolnum>
	   </refmeta>
	   <refnamediv>
	      <refname>lrs2551</refname>
	      <refpurpose>Manage LRS 2551 modules</refpurpose>
	   </refnamediv>
	   
	   <refsynopsisdiv>
	     <cmdsynopsis>
	     <command>
lrs2551 create <replaceable>module-name ?options...?</replaceable> 
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
lrs2551 config <replaceable>module-name ?options...?</replaceable> 	     
	     </command>
	     </cmdsynopsis>
	     <cmdsynopsis>
	     <command>
lrs2551 cget <replaceable>module-name</replaceable> 	     
	     </command>
	     </cmdsynopsis>
	   </refsynopsisdiv>
	   <refsect1>
	      <title>DESCRIPTION</title>
	      <para>
	       The <command>lrs2551</command> command allows you to create and
	       configure LeCroy LRS 2551 scaler modules.  The LRS 2551 is a
	       12 channel scaler.  While it is normally read in the periodic
	       scaler stack, it is also possible to read it in the event
	       stack when properly configured.
	      </para>
	      <para>
	       The <command>create</command> subcommand creates a new module
	       assigning it the name <parameter>module-name</parameter>.
	       <parameter>module-name</parameter> should be used to refer
	       to the module in future commands. Optional configuration data
	       can also be appended to the <command>create</command> subcommand.
	      </para>
	      <para>
	       The <command>config</command> subcommand configures an existing
	       <parameter>module-name</parameter>.  The configuration items are
	       name value pairs.  See OPTIONS below for more information about
	       the options supported by the <command>lrs2551</command> command.
	      </para>
	      <para>
	       The <command>cget</command> subcommand returns the current
	       module configuration.  The configuration is returned as a Tcl list.
	       Each element of the list is a two element sublist that contains
	       the configuration name and value in that order.
	      </para>
	   </refsect1>
	   <refsect1>
	    <title>OPTIONS</title>
	    <para>
	        The <command>lrs2551</command> command supports the following
		configuration options:
	    </para>
	    <variablelist>
	       <varlistentry>
		  <term><option>-cumulative</option> <replaceable>on|off</replaceable></term>
		  <listitem>
		     <para>
			If <option>-cumulative</option> is false (default),
			the scaler module is cleared after each readout providing
			the counts between each readout as the value of each
			channel. This shoulid be false when used with the NSCLDAQ
			scaler display program in the scaler stack.
		     </para>
		  </listitem>
	       </varlistentry>
	       <varlistentry>
		  <term><option>-id</option> <replaceable>vsn</replaceable></term>
		  <listitem>
		     <para>
			Supplies the virtual slot number; <replaceable>vsn</replaceable>
			for the module.  This only needs to be supplied if the
			module is going to be read in the event stack.
			Note that currently unpacking scaler data from the event
			stack is not supported.
		     </para>
		  </listitem>
	       </varlistentry>
	       <varlistentry>
		  <term><option>-insertid</option> <replaceable>true|false</replaceable></term>
		  <listitem>
		     <para>
			If <literal>true</literal> (the default is <literal>false</literal>),
			the virtual slot number set by the <option>-id</option>
			configuration value is inserted in the data block from
			the scaler.  If <literal>false</literal> it is not.
			If used with the NSCLDAQ Scaler display in the scaler stack,
			this should be <literal>false</literal>.
		     </para>
		  </listitem>
	       </varlistentry>
	       <varlistentry>
		  <term><option>-slot</option> <replaceable>slot</replaceable></term>
		  <listitem>
		     <para>
			Sets the <parameter>slot</parameter> configuration.
			When installed in the CAMAC crate, the module should
			be inserted in the <parameter>slot</parameter> specified
			by this option.
		     </para>
		  </listitem>
		  </varlistentry>
	    </variablelist>
	    
	   </refsect1>
	   <refsect1>
	      <title>EXAMPLES</title>
	      <para>
	       This example creates an LRS 2551 scaler:
	      </para>
	      <example>
	       <title>The lrs2551 command</title>
	       <programlisting>
lrs2551 create counters -slot 4
	       </programlisting>
	      </example>
	   </refsect1> 
</refentry>
<refentry id="ccusb3-marker">
  <refentryinfo>
    <author>
            <personname>
                    <firstname>Ron</firstname>
                    <surname>Fox</surname>
            </personname>
    </author>
    <productname>NSCLDAQ</productname>
    <productnumber></productnumber>
  </refentryinfo>
  <refmeta>
     <refentrytitle id='ccusb3-marker-title'>marker</refentrytitle>
     <manvolnum>ccusb3</manvolnum>
     <refmiscinfo class='empty'></refmiscinfo>
  </refmeta>
  <refnamediv>
     <refname>marker</refname>
     <refpurpose>Create/manipulate marker instances</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
        <command>
marker create <replaceable>name ?options?</replaceable>
   </command>
    </cmdsynopsis>
     <cmdsynopsis>
         <command>
marker config <replaceable>name options...</replaceable>
         </command>
     </cmdsynopsis>
     <cmdsynopsis>
         <command>
marker cget <replaceable>name</replaceable>
         </command>
     </cmdsynopsis>
     
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
     <para>
         Markers are CCUSB stack objects that insert a constant
         16 bit value into the data. The <command>marker</command>
         command allows you to create and configure marker objects.
         As with all <filename>daqconfig.tcl</filename> objects
         the marker must be put in a stack (event or scaler) to
         contribute data to the output stream.
     </para>
  </refsect1>
  <refsect1>
     <title>
        OPTIONS
     </title>
     <variablelist>
         <varlistentry>
             <term><option>-value</option> <replaceable>uint16</replaceable></term>
             <listitem>
                 <para>
                     Defines the unsigned integer 16 value that will be
                     inserted into the buffer when the
                     marker is in a triggered stack.
                 </para>
             </listitem>
         </varlistentry>
         
     </variablelist>
  </refsect1>

</refentry>

         <refentry id="ccusb3-ph7xxx">
           <refmeta>
              <refentrytitle>ph7xxx</refentrytitle>
              <manvolnum>3ccusb</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>ph7xxx</refname>
              <refpurpose>Define Phillips ADC/TDC/QDC modules</refpurpose>
           </refnamediv>
           
           <refsynopsisdiv>
             <cmdsynopsis>
         	<command>
ph7xxx create <replaceable>name</replaceable> <optional>?option value ...?</optional>         	
         	</command>
             </cmdsynopsis>
                 <cmdsynopsis>
                     <command>
ph7xxx config <replaceable>name  option value...</replaceable>
                     </command>
                 </cmdsynopsis>
                  <cmdsynopsis>
                      <command>
ph7xxx cget <replaceable>name</replaceable>
                      </command>
                  </cmdsynopsis>
                
           </refsynopsisdiv>
           <refsect1>
              <title>DESCRIPTION</title>
              <para>
               Creates, configures and interrogates the configuration of Philips
               CAMAC digitizers.
              </para>
              <para>
               The <command>create</command> command creates
               a new digitizer <replaceable>name</replaceable> configuration.
               The <replaceable>name</replaceable> parameter must be unique.
               The optional <optional>option value</optional> pairs that follow
               specify the configuration for that module.  This configuration
               can  be supplemented or overridden by subsequent
               <command>config</command> operations on the module.
              </para>
               <para>
                  The <command>config</command> subcommand configures the existing
                  module <replaceable>name</replaceable>.  The remainder of the
                  command line are option value pairs described in the section
                  OPTIONS below.  The module <replaceable>name</replaceable> must
                  have already been created via the <command>create</command>
                  subcommand.  Note that configuration options are processed
                  from left to right, if a configuration option appears more than
                  once, the last instance takes effect.
               </para>
               <para>
                  The <command>cget</command> subcommand returns the configuration
                  of the module.  This can be used in more advanced scripts to
                  analyze the configuration of the system.  The configuration of
                  a module <replaceable>name</replaceable> is returned as a
                  properly formatted Tcl list.  Each element of the list is itself
                  a pair (a two element sublist).  The first element of each pair
                  is the configuration parameter name, the second element the
                  value, which may itself be  a list (e.g. for the
                  <literal>-llt</literal> option.
               </para>
           </refsect1>
           <refsect1>
              <title>
         	OPTIONS
              </title>
              <variablelist>
         	<varlistentry>
         	    <term><option>-slot</option> <replaceable>slotnumber</replaceable></term>
         	    <listitem>
         		<para>
                           This option configures the slot in which the module
                           will be installed.  All modules must be in unique slots,
                           although that is not verified by the configuration manager.
                           The slot must be an integer number from one through 23
                           (slot 24/25 holds the CAMAC crate controller).
         		</para>
                        <para>
                           The default value for this parameter is illegal (0),
                           so you must specify this parameter.
                        </para>
         	    </listitem>
         	</varlistentry>
		<varlistentry>
		     <term><option>-id</option> <replaceable>vsn</replaceable></term>
		     <listitem>
			<para>
			   Each module has an identifier which, for historical
			   reasons is called a <firstterm>virtual slot number</firstterm>,
			   or <firstterm>vsn</firstterm>.  To maximize the decode
			   error detection the virtual slot numbers for each
			   module should be unique.  This option allows you
			   to set the virtual slot number for the module.
			</para>
		        <para>
			   If the <option>-id</option> is not supplied, it defaults
			   to zero.
			</para>
		     </listitem>
		</varlistentry>
                <varlistentry>
                  <term><option>-sparse</option> <replaceable>bool</replaceable></term>
                  <listitem>
                     <para>
                        If the value of this configuration is true, the module
                        is read in sparse readout mode (A Q-Stop of F4@A0).
                        SpecTcl expects this to be true and that is also the default
                        value.
                     </para>
                     <para>
                        The values
                        <literal>true</literal>,
                        <literal>yes</literal>,
                        <literal>1</literal>,
                        <literal>on</literal> and
                        <literal>enabled</literal> are all recognized as true
                        values while the values
                        <literal>false</literal>,
                        <literal>no</literal>,
                        <literal>0</literal>,
                        <literal>off</literal>, and
                        <literal>disabled</literal> are all recognized as false
                        values.
                     </para>
                  </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-readhits</option> <replaceable>bool</replaceable></term>
                     <listitem>
                        <para>
                           If the value of this configuration is true,the module's
                           hit register is read prior to the channels (F6@A1).
                           SpecTcl requires this parameter to be true, and that's the
                           default value.
                        </para>
                        <para>
                           SpecTcl will use this value to determine the number of
                           digitizer data words that follow for this module.
                        </para>
                        <para>
                        The values
                        <literal>true</literal>,
                        <literal>yes</literal>,
                        <literal>1</literal>,
                        <literal>on</literal> and
                        <literal>enabled</literal> are all recognized as true
                        values while the values
                        <literal>false</literal>,
                        <literal>no</literal>,
                        <literal>0</literal>,
                        <literal>off</literal>, and
                        <literal>disabled</literal> are all recognized as false
                        values.
                     </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-pedestals</option> <replaceable>int[16]</replaceable></term>
                     <listitem>
                        <para>
                           Supplies the pedestals for each channel.  This must be
                           a 16 element list of integers.  These values are
                           initialized to zero.  Note that the pedestals are
                           ignored unless <option>-usepdestals</option> is true.
                        </para>
                        <para>
                           The best way to construct this list of pedestals is to
                           use the Tcl <command>list</command> command for example:
                        </para>
                        <example>
                           <title>Using the <command>list</command> command to
                                  construct pedestals</title>
                           <programlisting>
                           <command>
ph7xxx config someadc -pedestals [list 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20]
                           </command>
                           </programlisting>
                        </example>
                        <para>
                           Note that pedestals can be specified as decimal values
                           (as shown in the example above), hexadecimal value
                           by preceding a number with the text <literal>0x</literal>
                           or octal by preceding the number with a leading <literal>0</literal>.
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-llt</option> <replaceable>int[16]</replaceable></term>
                     <listitem>
                        <para>
                           Supplies the low level thresholds for each channel.  This must
                           be a 16 element list of integers.  These values are initialized
                           to zero.  Note that the low level thresholds are ignored unless
                           <option>-usellt</option> is true.
                        </para>
                        <para>
                           See the description of <option>-pedestals</option> above
                           for more information about how to construct this list.
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-hlt</option> <replaceable>int[16]</replaceable></term>
                     <listitem>
                        <para>
                           Supplies the high level thresholds for each channel. This
                           must be a 16 element list of integers.  These values
                           are initialized to full scale (<literal>4095</literal>).
                           The high level thresholds are ignored unless the
                           parameter <option>-usehlt</option> is true.
                        </para>
                        <para>
                           See the description of <option>-pedestals</option>
                           above for more information about how to construct
                           this list.
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-usellt</option> <replaceable>boolean</replaceable></term>
                     <listitem>
                        <para>
                           Enables or disables the low level threshold (sets or clears
                           the <literal>LT Enable</literal> bit in the control
                           register).  This is useful if
                           <option>-llt</option> has been used to program
                           low level thresholds and <option>-sparse</option>
                           has been set to true.
                       </para>
                       <para>
                        The values
                        <literal>true</literal>,
                        <literal>yes</literal>,
                        <literal>1</literal>,
                        <literal>on</literal> and
                        <literal>enabled</literal> are all recognized as true
                        values while the values
                        <literal>false</literal>,
                        <literal>no</literal>,
                        <literal>0</literal>,
                        <literal>off</literal>, and
                        <literal>disabled</literal> are all recognized as false
                        values.
                     </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-usehlt</option> <replaceable>bool</replaceable></term>
                     <listitem>
                        <para>
                           Enables or disables the high level threshold (sets or
                           clears the <literal>UT Enable</literal> bit in the
                           module control register).  This is useful if
                           <option>-hlt</option> has been used to set the high
                           level thresholds and <option>-sparse</option> has
                           been set to true.
                        </para>
                       <para>
                        The values
                        <literal>true</literal>,
                        <literal>yes</literal>,
                        <literal>1</literal>,
                        <literal>on</literal> and
                        <literal>enabled</literal> are all recognized as true
                        values while the values
                        <literal>false</literal>,
                        <literal>no</literal>, 
                        <literal>0</literal>,
                        <literal>off</literal>, and
                        <literal>disabled</literal> are all recognized as false
                        values.
                     </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-usepedestals</option> <replaceable>bool</replaceable></term>
                     <listitem>
                        <para>
                           Enables or disables per chanel pedestal subtraction.
                           This is most useful when <option>-pedestals</option>
                           has been used to program a set of pedestals into
                           the module.
                        </para>
                       <para>
                        The values
                        <literal>true</literal>,
                        <literal>yes</literal>,
                        <literal>1</literal>,
                        <literal>on</literal> and
                        <literal>enabled</literal> are all recognized as true
                        values while the values
                        <literal>false</literal>,
                        <literal>no</literal>,
                        <literal>0</literal>,
                        <literal>off</literal>, and
                        <literal>disabled</literal> are all recognized as false
                        values.
                     </para>
                     </listitem>
                  </varlistentry>
              </variablelist>
           </refsect1>
           <refsect1>
              <title>EXAMPLES</title>
              <para>
                  The example below creates a Phillips module named
                  <literal>adc1</literal> and programs all of the configuration
                  options.  Note that in many cases you won't need to do this
                  (e.g. for ADC's the high level thresholds usually can be left
                  up at <literal>4095</literal>
              </para>
              <example>
                  <title>Sample <command>ph7xxx</command> commands</title>
                  <programlisting>
ph7xxx create adc1 -slot 5
ph7xxx config adc1 -sparse enabled -readhits true -usellt true -usehlt false
ph7xxx config adc1 -usepedestals enabled
ph7xxx config adc1 -pedestals [list 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 ]
ph7xxx config adc1 -llt [list 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10 10]
ph7xxx config adc1 -hlt [list 3000 3000 3000 3000 3000 3000 3000 \
                              3000 3000 3000 3000 3000 3000 3000 3000 3000 ]
                  </programlisting>
              </example>
           </refsect1>

         </refentry>
         <refentry id="ccusb3-stack">
           <refmeta>
              <refentrytitle>stack</refentrytitle>
              <manvolnum>3ccusb</manvolnum>
           </refmeta>
           <refnamediv>
              <refname>stack</refname>
              <refpurpose>Create and configure CC-USB stacks.</refpurpose>
           </refnamediv>
           
           <refsynopsisdiv>
             <cmdsynopsis>
         	<command>
stack create <replaceable>name</replaceable>

         	</command>
             </cmdsynopsis>
               <cmdsynopsis>
                   <command>
stack config <replaceable>name option value...</replaceable>
                   </command>
               </cmdsynopsis>
            <cmdsynopsis>
                <command>
stack cget <replaceable>name</replaceable>
                </command>
            </cmdsynopsis>
           
           </refsynopsisdiv>
           <refsect1>
              <title>DESCRIPTION</title>
              <para>
         	Creates and configures CC-USB stacks.  Stacks are lists of
                CAMAC operations that are loaded into the CC-USB for autonomous
                execution.  There are two types of stacks; an
                <firstterm>event</firstterm> stack that is executed when
                a front panel trigger or a specified LAM is detected, and
                a <firstterm>scaler</firstterm> stack that can be periodically
                triggered.
              </para>
               <para>
                  Stacks contain lists of modules.  The modules themselves
                  determine the set of readout instructions that make up each
                  stack.  
               </para>
               <para>
                  The <command>create</command> subcommand creates a new stack.
                  The name of the new stack is <replaceable>name</replaceable>.
                  This <replaceable>name</replaceable> will be used to refer to
                  this stack in future configuration commands.
               </para>
               <para>
                  The <command>config</command> subcommand configures the stack
                  <replaceable>name</replaceable>.  The configuration is
                  specified as a set of option value pairs.  The options
                  are described in the section OPTIONS below.
               </para>
               <para>
                  The <command>cget</command> subcommand returns the configuration
                  of the stack <replaceable>name</replaceable> as its command value.
                  This subcommand is intended for advanced applications that may
                  analyze the configuration of the stack.  The configuration is
                  returned as a properly formatted Tcl list.  Each element of the list
                  is itself a two element sublist (pair).  The first element of each
                  pair is the name of a configuration parameter the second, that
                  configuration parameter's value.  Note that the value may itself
                  be a list.
               </para>
           </refsect1>
           <refsect1>
              <title>
         	OPTIONS
              </title>
               <para>
                  Options are used to configure the stack.  Each option has associated
                  with it a keyword that selects it and a value.  The option s supported
                  by the <command>stack</command> command are subdivided into three groups:
                  <orderedlist>
                     <listitem>
                        <para>Options used for both event and scaler stacks.</para>
                     </listitem>
                     <listitem>
                        <para>Options that are only used for event stacks and are ignored
                           for scaler stacks</para>
                     </listitem>
                     <listitem>
                        <para>Options that are only used for scaler stacks, and are
                           ignored for event stacks.
                        </para>
                     </listitem>
                  </orderedlist>
               </para>
               <formalpara>
                  <title>Options for all stack types</title>
                  <para>
                  </para>
               </formalpara>
               <variablelist>
                  <varlistentry>
         	     <term><option>-type</option> <replaceable>stack-type</replaceable></term>
         	     <listitem>
         		<para>
                           Defines the type of stack that is being used.  This
                           can be one of the keywords
                           <literal>event</literal> for event stacks or
                           <literal>scaler</literal> for scaler stacks.
                           The CC-USB only supports one scaler and one event stack.
                           The current version of the configuration engine allows
                           you to create more than one of each stack. In that case,
                           it is not well defined which stacks are actually loaded.
         		</para>
                        <para>
                           The default <option>-type</option> is <literal>event</literal>.
                        </para>
         	     </listitem>
                  </varlistentry>
		  <varlistentry>
		    <term><option>-incremental</option> <replaceable>bool</replaceable></term>
		    <listitem>
		      <para>
			If <literal>true</literal> (the default), scaler ring items are marked as
			incremental.  If not they are marked as non-incremental.
		      </para>
		    </listitem>
		  </varlistentry>
                  <varlistentry>
                     <term><option>-modules</option> <replaceable>module-list</replaceable></term>
                     <listitem>
                        <para>
                           This option defines the set of modules that are added
                           to the stack.  <replaceable>module-list</replaceable> is a
                           properly formatted Tcl list of names of modules
                           (ph7xxx's in this implementation) that will be read
                           by this stack.  See the EXAMPLES section below
                           for more information.
                        </para>
                     </listitem>
                  </varlistentry>
               </variablelist>
               <formalpara>
                  <title>Event stack options</title>
                  <para>
                  </para>
               </formalpara>
               <variablelist>
                  <varlistentry>
                     <term><option>-lams</option>   <replaceable>mask</replaceable></term>
                     <listitem>
                        <para>
                           Specifies the mask of LAMs that can trigger the list.
                           I suggest leaving this value at zero, and deriving a
                           trigger signal for the NIM IN1 input as the readout
                           trigger.
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-lamtimeout</option> <replaceable>microseconds</replaceable></term>
                     <listitem>
                        <para>
                           The <command>ph7xxx</command> command delays the read
                           of the module until it is signalling a LAM.
                           <replaceable>microseconds</replaceable> specifies the
                           total number of microseconds the stack should wait for
                           this LAM.  The value should be on the order of the
                           conversion time of the module.  Defaults to zero.
                        </para>
                     </listitem>
                  </varlistentry>
                  <varlistentry>
                     <term><option>-delay</option> <replaceable>microseconds</replaceable></term>
                     <listitem>
                        <para>
                           Delays the execution of the stack for <replaceable>microseconds</replaceable>
                           microseconds after the trigger condition is detected.
                           This can be used to ensure the digitization hardware
                           has sufficient time to complete its digitization prior
                           to stack execution. Defaults to zero.
                        </para>
                     </listitem>
                  </varlistentry>
               </variablelist>
               <formalpara>
                  <title>Options only available for scalers stacks</title>
                  <para>
                     The options below are only legal for stacks of
                     <option>-type</option> <literal>scaler</literal>
                  </para>
               </formalpara>
               <variablelist>
                  <varlistentry>
                     <term><option>-period</option> <replaceable>seconds</replaceable></term>
                     <listitem>
                        <para>
                           Number of seconds between execution of the scaler stack.
                           This defaults to 2.
                        </para>
                     </listitem>
                  </varlistentry>
               </variablelist>
            
           </refsect1>
           <refsect1>
               <title>EXAMPLES</title>
               <para>
                  The example below extends the example in the
                  <xref linkend="ccusb3-ph7xxx" /> command reference
                  reading the defined modules in an event stack:
               </para>
               <example>
                  <title>Example of the <command>stack</command> command.</title>
                  <programlisting>
ph7xxx create adc1 -slot 6
ph7xxx create adc2 -slot 7                                  <co id="defmodules" />


stack create events                                         <co id="stackdef" />
stack config events -type event -modules [list adc1 adc2]   <co id="typemods" />
stack config events -delay 10 -lamtimeout 8                 <co id ="timing" />
                  </programlisting>
               </example>
               <calloutlist>
                  <callout arearefs="defmodules">
                     <para>
                        These two lines define the modules that we will be using
                        for the experimental setup.
                     </para>
                  </callout>
                  <callout arearefs="stackdef">
                     <para>
                        Creates a new stack called <literal>events</literal>
                        In subsequent lines I'm going to configure this stack
                        to handle the event trigger.
                     </para>
                  </callout>
                  <callout arearefs="typemods">
                     <para>
                        The stack is configured to be the event stack, and
                        the two modules we created <literal>adc1</literal>
                        and <literal>adc2</literal> are added to the stack
                        in that order.  When the stack is loaded, it will
                        contain the instructions to read out these two modules.
                     </para>
                  </callout>
                  <callout arearefs="timing">
                     <para>
                        Configures the stack so that the CC-USB will start
                        stack execution 10 microseconds after the IN1 trigger.
                        Stack instructions that wait for a lam on their target
                        module will wait at most 8 microseconds.  Since the
                        <option>-lams</option> option is left to default to zero,
                        CAMAC lams will not be able to trigger the list.
                     </para>
                  </callout>
               </calloutlist>
               
                  
           </refsect1>
         </refentry>
      <refentry id="ccusb3-Module">
        <refmeta>
           <refentrytitle>Module</refentrytitle>
           <manvolnum>3ccusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>Module</refname>
           <refpurpose>Create and manipulate slow control device instances</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
         <command>
Module create <replaceable>name type</replaceable>
          </command>
          </cmdsynopsis>
          <cmdsynopsis>
            <command>
Module config <replaceable>name options....</replaceable>
            </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
Module cget <replaceable>name</replaceable>
                </command>
            </cmdsynopsis>
        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            The Module command creates and manipulates instances of slow
            control devices.  It must appear in the control configuration script
            rather than the daq configuration script.  The <command>create</command>
            subcommand creates an object with the specified <parameter>type</parameter>
            and <parameter>name</parameter>. The ORDERING OF TYPE AND NAME ARE OPPOSITE
            THAT OF VMUSBREADOUT!!! Currently the following device types
            are supported:
            <variablelist>
                <varlistentry>
                    <term>caen894</term>
                    <listitem>
                        <para>
                            A CAEN C894 16 channel leading edge discriminator.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>ph7106</term>
                    <listitem>
                        <para>
                            A Phillips Ph7106 leading edge discriminator.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>ccusb</term>
                    <listitem>
                        <para>
                            Allows a remote client to execute stacks on
                            the CC-USB controlled by this CCUSBReadout program.
                            (The CCCUSBRemote class serves as the
                            remote client.)
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </para>
           <para>
            The <command>config</command> subcommand configures the named module.
            In most cases the configuration of a slow control module is pretty
            minimal as the assumption is that there is a slow control
            panel associated with the device.  Typical configuration consists
            of a <option>-slot</option> which provides the CAMAC slot in which
            the module is installed and a <option>-file</option> which provides
            the initial settings of the device (the file is usually maintained
            by the control panel).  Note that the <literal>ph7106</literal>
            currently only supports the <option>-slot</option> option.
            (This code was contributed by Lakshmi SoundaraPandian of the
            University of Massachussets Lowell).
           </para>
           <para>
                The <command>cget</command> subcommand retrieves the
                configuration of the named modules as a
                well formatted Tcl list of name
                value pairs where the name is an option name and the value is
                the value of that option. e.g.
                <informalexample>
                    <programlisting>
{ {-slot 5} {-file /user/fox/config.camac/led.settings}}
                    </programlisting>
                </informalexample>
            </para>
        </refsect1>
        </refentry>

        <refentry id="ccusb3-CamacCrate">
          <refmeta>
            <refentrytitle>CamacCrate</refentrytitle>
            <manvolnum>3ccusb</manvolnum>
          </refmeta>

          <refnamediv>
            <refname>CamacCrate</refname>
            <refpurpose>group modules into a crate</refpurpose>
          </refnamediv>

          <refsynopsisdiv>
            <cmdsynopsis>
              <command>
                CamacCrate create <replaceable>name base</replaceable>
              </command>
            </cmdsynopsis>
            
            <cmdsynopsis>
              <command>
                CamacCrate config <replaceable>name option value ...</replaceable>
              </command>
            </cmdsynopsis>
        
            <cmdsynopsis>
              <command>
                CamacCrate cget <replaceable>name</replaceable>
              </command>
            </cmdsynopsis>

          </refsynopsisdiv>
        
        <refsect1>
            <title>DESCRIPTION</title>
     <para>
The CamacCrate command defines a container-type driver that holds a registry of modules. It is designed to make it trivial to convert a daqconfig.tcl script that sets up a crate running on a CBD8210 branch to one being controlled by a CC-USB. Contrary to the CBDCamacCrate, this does not need to be registered to a CAMAC branch and can instead be loaded directly into a stack.
     </para>

  <para>
At the start of every run, the initialization procedures will be called for all of the registered modules in the order the modules were listed.
  </para>

  <para>
At the end of every run, the end of run procedures will be called for all of the registered module in the order the modules were listed.
  </para>

  <para>
During stack execution initiated by an event trigger, the event-wise procedures of each of the registered modules will be executed in the order that they were listed.
  </para>

  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	    <varlistentry>
	      <term><command>-crate</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
        Specifies the crate index. Default is 0.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-modules</command> <replaceable>list</replaceable></term>
	      <listitem>
		    <para>
        Specify a proper tcl list of modules to be registered with this crate. these must all be compatible with a CC-USB controller. The order in which modules are listed will be the order in which each module is serviced. A single module can be registered to multiple CamacCrates. Default is an empty list. 
		    </para>
	       </listitem>
	    </varlistentry>
  </variablelist>

  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
          <title>A simple crate setup containing a single scaler</title>
         <programlisting>
LeCroy2551 create sclr -slot 10

# Create a crate to stick it in
CamacCrate create crate0 -crate 1
CamacCrate config crate0 -modules [list sclr]
         </programlisting>
      </example>
      <para>
       Defines a camac crate with a single LeCroy2551 to operate on with a CBD8210 branch driver. This crate is labeled with index 1 on the branch and the branch is labeled with index 0.
      </para>
  </refsect1>
</refentry>

<refentry id="ccusb3-LeCroy4300B">
  <refmeta>
     <refentrytitle>LeCroy4300B</refentrytitle>
     <manvolnum>3ccusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>LeCroy4300B</refname>
     <refpurpose>control a LeCroy 4300B FERA</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
LeCroy4300B create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
    <command>
LeCroy4300B config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
LeCroy4300B cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
  <para>
  This provides control over a LeCroy 4300B FERA that lives in a crate controlled by a CC-USB. This is the counterpart to the CBDLeCroy4300B driver that is functional in the VMUSBReadout framework. The currently described driver needn't be registered to a CamacCrate to function. 
  </para>
  <para>
There are a number of options that are provided to ultimately control the command register of the device. The command register is what establishes how the FERA will read out its data. Two options must be specified to operate the device, -pedestals and slot. If either of these are not specified, the initialization of the module will fail. 
  </para>

  <para>
  During initialization the following operations occur:
    <orderedlist>
     <listitem> 
        <para> Clear the module </para>
     </listitem>
     <listitem>
      <para> Write all pedestals passed to the -pedestal option </para>
     </listitem>
     <listitem>
      <para> Compute the command register from user define options and write it to the module </para>
     </listitem>
  </orderedlist>
  </para>

  <para>
  At the end of the run, no actions are taken. 
  </para>

  <para>
  During stack execution initiated by an event trigger, this driver will operate based on the following logic:
  <programlisting>

  if "-camacclear" is true
      Clear the module

  </programlisting>
  
  </para>
  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	    <varlistentry>
	      <term><command>-slot</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
        Specifies the slot of the CAMAC crate the target module is occupying. DEFAULT is 1.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-pedestals</command> <replaceable>list</replaceable></term>
	      <listitem>
		    <para>
          A proper tcl list of 16 integer parameters defining the pedestals for each of the 16 channels. The first element of the list will configure the first channel of the FERA, the second element will configure the second channel, and so on. REQUIRED
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-vsn</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
The virtual station number to associate with the target device. This will be included in the header if data compression is enabled. 
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-eclpedsub</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
        	Specify whether to use pedestal subtraction in ECL port readout (aka. EPS). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-eclcompression</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specify whether to enable a data compression cycle before ECL port readout (aka. ECE). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-eclenable</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
        	Specify whether to enable ECL port readout (aka. EEN). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-camacpedsub</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specify whether to use pedestal subtraction in CAMAC readout (aka. CPS). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-camaccompression</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specify whether to enable a data compression cycle before CAMAC readout (aka. CCE). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-camacseqrdo</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specify whether to configure the device for sequential readout in CAMAC (aka. CSR). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-camaclam</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specify whether the allow the device to emit a LAM when data is available to be read (aka. CLE). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-overflowsuppress</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specify whether to suppress output of overflows as well as zeros (aka. OAFS). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
   </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
          <title>A simple setup of one FERA</title>
         <programlisting>
LeCroy4300B create fera -slot 10 
LeCroy4300B config fera -pedestals \
          [list 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]
LeCroy4300B config fera -eclenable on
LeCroy4300B config fera -eclpedsub on
LeCroy4300B config fera -eclcompression on
LeCroy4300B config fera -camacclear off
         </programlisting>
      </example>
      <para>
        Sets up a LeCroy 4300B module with all pedestals 1 to be read out by the ECL ports. The FERA resides in slot 10.
      </para>
  </refsect1>
</refentry>

<refentry id="ccusb3-LeCroy4434">
  <refmeta>
     <refentrytitle>LeCroy4434</refentrytitle>
     <manvolnum>3ccusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>LeCroy4434</refname>
     <refpurpose>control a LeCroy 4434 Scaler</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
LeCroy4434 create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
      <command>
LeCroy4434 config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
LeCroy4434 cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
    <para>
The LeCroy4434 is intended to control a LeCroy 4434 scaler situated on in a crate controlled by a CC-USB. It is the counterpart to the CBDLeCroy4434 module that is functional in the VMUSBReadout framework. 
  </para>

  <para>
The CBDLeCroy4434 can be registered directly to a stack or to a CamacCrate. 
  </para>

  <para>
  During initialization, all scalers are cleared and the auxiliary bus is disabled. 
  </para>

  <para>
  At the end of the run, no actions are taken. 
  </para>

  <para>
  During stack execution initiated by an event trigger, this driver will operate based on the following logic:
  <programlisting>

  Read all channels
  if "-incremental" is true
      Clear the module
  </programlisting>

  Just as a note, the latch and the clear are not atomic.
  </para>
  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	    <varlistentry>
	      <term><command>-slot</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
        Specifies the slot of the CAMAC crate the target module is occupying. Default is 1.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-incremental</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specifies whether to clear the scalers on each event after latching them. Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
   </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
         <title>A simple setup of one scaler</title>
         <programlisting>
LeCroy4434 create sclr -slot 10
         </programlisting>
      </example>
      <para>
        Sets up a LeCroy 4434 scaler module in slot 10.
      </para>
  </refsect1>
</refentry>
  
<refentry id="ccusb3-LeCroy2551">
  <refmeta>
     <refentrytitle>LeCroy2551</refentrytitle>
     <manvolnum>3ccusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>LeCroy2551</refname>
     <refpurpose>control a LeCroy 2551 Scaler</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
LeCroy2551 create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
      <command>
LeCroy2551 config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
LeCroy2551 cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
    <para>
The LeCroy2551 is intended to control a LeCroy 2551 scaler situated on a crate controlled by a CC-USB. It is the counterpart to the CBDLeCroy4434 driver that lives in the VMUSBReadout framework. In this case, the LeCroy2551 can be registered directly to a stack and does not need to be registered first to a CamacCrate. There is no reason you cannot register it to a CamacCrate though.
  </para>

  <para>
  During initialization, all scalers are cleared. 
  </para>

  <para>
  At the end of the run, no actions are taken. 
  </para>

  <para>
  During stack execution initiated by an event trigger, all 12 scaler channels are read individually.
  </para>

  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	    <varlistentry>
	      <term><command>-slot</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
        Specifies the slot of the CAMAC crate the target module is occupying. Default is 1.
		    </para>
	       </listitem>
	    </varlistentry>
   </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
          <title>A simple setup of a single scaler</title>
         <programlisting>
LeCroy2551 create sclr -slot 10
         </programlisting>
      </example>
      <para>
        Sets up a LeCroy 2551 scaler module in slot 10.
      </para>
  </refsect1>
</refentry>

<refentry id="ccusb3-ULMTrigger">
  <refmeta>
     <refentrytitle>ULMTrigger</refentrytitle>
     <manvolnum>3ccusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>ULMTrigger</refname>
     <refpurpose>control a LeCroy 2637 ULM running trigger firmware</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
ULMTrigger create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
ULMTrigger config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
ULMTrigger cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
    <para>
The ULMTrigger is intended to control a LeCroy 2367 ULM situated in a crate controlled by a CC-USB. It is the counterpart to the CBDULMTrigger driver that lives in the VMUSBReadout framework. In this case, the ULMTrigger does not need to be registered first to a CamacCrate, though it still can be. Instead, it can be directly registered to a stack.
  </para>

  <para>
Two options need to be specified to function properly. The first is firmware which defines the location of the firmware file to load. The second is the slot number in the camac crate it lives in. This will only work properly if running the usbtrig.bit firmware that Daniel Bazin has written. 
  </para>

  <para>
  On initialization the module will always be cleared and the GO bit set to 1.
  </para>

  <para>
  At the end of the run, the GO bit is set to 0.
  </para>

  <para>
  During stack execution initiated by an event trigger, the following logic is carried out:

  <programlisting>
if "-registerRead" is true
    Read the register

if "-eventwiseClear" is true
    Clear the register
  </programlisting>
  
  By default, both -registerRead and -eventwiseClear are set to false.
  </para>

  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	    <varlistentry>
	      <term><command>-slot</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
        Specifies the slot of the CAMAC crate the target module is occupying. Default is 1.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-firmware</command> <replaceable>path</replaceable></term>
	      <listitem>
		    <para>
        The path to the firmware file usbtrig.bit. Default is "".
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-readRegister</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
        Specifies whether to add a hit register read into the event stack. Defaults to true.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-eventwiseClear</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
        Specifies whether to send a clear command via the CAMAC dataway at the end of the event. Defaults to true.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-forceFirmwareLoad</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
        By default, the ULM will only load the firmware if it fails to validate the configuration. This occurs always after a bad firmware load or after a crate has been power cycled. Firmware loads take a bit of time so it is worthwhile to skip reloading the firmware on every run. However, sometimes it may be considered useful. This option causes the firmware to be loaded at the start of EVERY run. Defaults to false.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-configuration</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Specifies the number that will be used to validate a successful firmware configuration. This number is compared to the value returned by the function A=15 F=0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-pcDelay</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-pcWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-scDelay</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-scWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-ccWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-ssDelay</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-bypasses</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-pdFactor</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-sdFactor</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-triggerBox</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-inspect1</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-inspect2</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-inspect3</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-inspect4</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-adcWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-qdcWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-tdcWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-coincWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Unknown. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
   </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
         <title>A simple setup of a single ULM</title>
         <programlisting>
# Define values for each parameter in TRIGGER array
ULMTrigger create sclr -slot 23
ULMTrigger config ulm firmware /user/s800/server/fpga/usbtrig.bit
ULMTrigger config ulm -pcDelay $TRIGGER(PCDelay) \
                  -pcWidth $TRIGGER(PCWidth) \
                  -scDelay $TRIGGER(SCDelay) \
                  -scWidth $TRIGGER(SCWidth) \
                  -psDelay $TRIGGER(PSDelay) \
                  -ccWidth $TRIGGER(CCWidth) \
                  -ssDelay $TRIGGER(SSDelay) \
                  -bypasses $TRIGGER(Bypasses) \
                  -pdFactor $TRIGGER(PDFactor) \
                  -sdFactor $TRIGGER(SDFactor) \
                  -triggerBox $TRIGGER(TriggerBox) \
                  -inspect1 $TRIGGER(Inspect1) \
                  -inspect2 $TRIGGER(Inspect2) \
                  -inspect3 $TRIGGER(Inspect3) \
                  -inspect4 $TRIGGER(Inspect4) \
                  -adcWidth $TRIGGER(ADCWidth) \
                  -qdcWidth $TRIGGER(QDCWidth) \
                  -tdcWidth $TRIGGER(TDCWidth) \
                  -coincWidth $TRIGGER(CoincidenceWidth) \
                  -configuration $TRIGGER(configuration) 
ULMTrigger config trig -forceFirmwareLoad off
ULMTrigger config trig -readRegister on
ULMTrigger config trig -eventwiseClear off
         </programlisting>
      </example>
      <para>
        Sets up a ULM module in slot 23.
      </para>
  </refsect1>

      </refentry>
      <refentry id="ccusb3-ControlProtocol">
        <refmeta>
           <refentrytitle>Slow controls protocol</refentrytitle>
           <manvolnum>3ccusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>Slow controls protocol</refname>
           <refpurpose>TCP/IP slow control protocol</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
            <command>
Update <replaceable>name</replaceable>               
            </command>
          </cmdsynopsis>
          <cmdsynopsis>
            <command>
Set <replaceable>name parameter value</replaceable>
            </command>
          </cmdsynopsis>
          <cmdsynopsis>
            <command>
Get <replaceable>name parameter</replaceable>
            </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            The protocol which communicates with the slow control server is
            a set of commands that are submitted to a Tcl interpreter that
            is running in the server.  Three commands result in
            dispatch to slow controls drivers.  If the run is active, the dispatch
            to the driver functions is preceeded by pausing the run and
            succeeded by resuming the run.  This allows driver functions
            unimpeded access to the CCUSB.
           </para>
           <para>
            Each driver is assumed to implement a set of named parameters.
            These parameters have values which are passed to and from the
            driver without interpretation.  Commands that result errors return
            strings to the client that begin with the text <literal>ERROR - </literal>
            with an english error message appended to that prefix.
           </para>
        </refsect1>
        <refsect1>
           <title>
              SUBCOMMANDS
           </title>
           <variablelist>
                <varlistentry>
                    <term>Update <replaceable>name</replaceable></term>
                    <listitem>
                        <para>
                            Asks the driver for the instance <replaceable>name</replaceable>
                            to update any internal state it maintains from the
                            device or, alternatively, depending on the driver
                            refresh any device state from internal state.
                            Normally this is used for devices that have write-only
                            registers, for those devices, typically the driver
                            must retain some concept of what it believes the
                            state of the physical device is.  This command is
                            then used to ensure the actual state of the device
                            matches the believed state.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Set <replaceable>name parameter-name value</replaceable></term>
                    <listitem>
                        <para>
                            Note the capital S in <command>Set</command> to
                            distinguish it from the similar Tcl command.
                            This command is used by a client to alter
                            a parameter value.  <replaceable>name</replaceable>
                            is the name of a Module instance,
                            <replaceable>parameter-name</replaceable> is the
                            name of a parameter maintained by the driver for
                            that device and <replaceable>value</replaceable> is
                            the new requested value for the parameter.
                        </para>
                        <para>
                            On success the client is returned a line containing
                            the string <literal>OK</literal> otherwise
                            <literal>ERROR -</literal> along with a message
                            is returned as describedin DESCRIPTION above.
                        </para>
                        <para>
                            Note that the legal parameter names and their legal
                            values are soley determined by the device driver.
                            See the device specific sections below for
                            more information.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>Get <replaceable>name parameter-name</replaceable></term>
                    <listitem>
                        <para>
                            Returns the value of the parameter
                            <replaceable>parameter-name</replaceable> from
                            the Module instance <replaceable>name</replaceable>.
                            If this is successful, the value of the parameter
                            will be returned to the client.  Otherwise a line
                            beginnning with <literal>ERROR - </literal> will
                            be returned along with a textual error message.
                        </para>
                    </listitem>
                </varlistentry>
           </variablelist>
        </refsect1>
        <refsect1>
            <title>PARAMETERS FOR SUPPORTED DEVICES</title>
            <refsect2>
                <title>ph7106</title>
                <para>
                    The following parameters are supported by the
                    driver for the Phillips PH7106 leading edge
                    discriminator.  As this device has read/write
                    registers, <command>Update</command> is a no-op
                    and the <command>Get</command> operation fetches
                    state directly from the device.
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>threshold</literal></term>
                        <listitem>
                            <para>
                                Represents the single module threshold.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>mask</literal></term>
                        <listitem>
                            <para>
                                Represents the module mask parameter.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>mode</literal></term>
                        <listitem>
                            <para>
                                Represents the control mode of the device.
                                this can be one of <literal>camac</literal>
                                or <literal>local</literal>.  This parameter
                                is read-only and represents the state of a
                                switch on the module front panel.
                                If the module is in <literal>local</literal>
                                mode, no changes can be made by CAMAC
                                operations.
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
        
            </refsect2>
            <refsect2>
                <title>caen894</title>
                <para>
                    The following parameters are suppoerted by the
                    CAEN C894 device support.  These are all read/write
                    parameters, although Get accesses internal driver
                    memory of the last settings done as the actual
                    hardware is write-only.
                </para>
                <variablelist>
                    <varlistentry>
                        <term><literal>threshold</literal><replaceable>n</replaceable></term>
                        <listitem>
                            <para>
                                Represents the value of the threshold for
                                channel <replaceable>n</replaceable> e.g.
                                <literal>threshold10</literal> represents
                                the threshold value for channel 10.
                                Thresholds number from <literal>[0-15]</literal>
                                and have values between <literal>[0-255]</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>width</literal><replaceable>n</replaceable></term>
                        <listitem>
                            <para>
                                Represents the output width of channel
                                <replaceable>n</replaceable>.  Legal values
                                are in the range <literal>[0-255]</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term><literal>inhibits</literal></term>
                        <listitem>
                            <para>
                                Represents the module inhibits mask.
                                This 16 bit value has one bit for each channel.
                                The least significant bit represents channel 0
                                the most significant bit channel 15.
                                Set bits represent channnels that are inhibited.
                            </para>
                        </listitem>
                    </varlistentry> 
                    <varlistentry>
                        <term><literal>majority</literal></term>
                        <listitem>
                            <para>
                                Represents the majority level.  This value
                                is in the range <literal>[1-20]</literal>
                            </para>
                        </listitem>
                    </varlistentry>
                </variablelist>
                </refsect2>
        </refsect1>
      </refentry>
         
	 <refentry id="ccusb3-CCCUSB">
       <refmeta>
          <refentrytitle>CCCUSB</refentrytitle>
          <manvolnum>3ccusb</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CCCUSB</refname>
          <refpurpose>Provide access to a CC-USB device.</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <programlisting>
        <synopsis>
            class <ooclass><classname>CCCUSB</classname></ooclass> {
            <methodsynopsis>
                <modifier>static</modifier>
                <type>std::vector&lt;struct usb_device*&gt;</type>
                <methodname>enumerate</methodname>
                <void />
            </methodsynopsis>
            
            <methodsynopsis>
                <modifier>static</modifier>
                <type>std::string</type>
                <methodname>serialNo</methodname>
                <methodparam>
                    <type>struct usb_device*</type><parameter>dev</parameter>
                </methodparam>
            </methodsynopsis>
            
           <constructorsynopsis>
          <methodname>CCCUSB</methodname>
          <methodparam>
            <type>struct usb_device*</type><parameter>vmUsbDevice</parameter>
          </methodparam>
           </constructorsynopsis>
            <methodsynopsis>
              <type>void</type>
              <methodname>writeActionRegister</methodname>
              <methodparam>
                <type>uint16_t</type> <parameter>value</parameter>
              </methodparam>
            </methodsynopsis>
            <methodsynopsis>
              <type>int</type>
              <methodname>simpleWrite16</methodname>
              <methodparam>
                <type>int</type><parameter>n</parameter>
              </methodparam>
              <methodparam>
                <type>int</type><parameter>a</parameter>
              </methodparam>
              <methodparam>
                <type>int</type><parameter>f</parameter>
              </methodparam>
              <methodparam>
                <type>uint16_t</type><parameter>data</parameter>
              </methodparam>
              <methodparam>
                <type>uint16_t&amp;</type><parameter>qx</parameter>
              </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>simpleWrite24</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>data</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t&amp;</type> <parameter>qx</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>simpleRead16</methodname>
                <methodparam>
                    <type>int</type><parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type><parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t&amp;</type> <parameter>data</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t&amp;</type> <parameter>qx</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>simpleRead24</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t&amp;</type><parameter>data</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t&amp;</type> <parameter>qx</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>simpleControl</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type><parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t&amp;</type> <parameter>qx</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readFirmware</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readGlobalMode</methodname>
                <methodparam>
                    <type>uint16_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeGlobalMode</methodname>
                <methodparam>
                    <type>uint16_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readDelays</methodname>
                <methodparam>
                    <type>uint16_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeDelays</methodname>
                <methodparam>
                    <type>uint16_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type>  <methodname>readScalerControl</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeScalerControl</methodname>
                <methodparam>
                    <type>uint32_t</type><parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readLedSelector</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeLedSelector</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readOutputSelector</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeOutputSelector</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readDeviceSourceSelectors</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type><parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeDeviceSourceSelectors</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readDGGA</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readDGGB</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readDGGExt</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeDGGA</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeDGGB</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeDGGExt</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readScalerA</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readScalerB</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readLamTriggers</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeLamTriggers</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readCAMACLams</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>readUSBBulkTransferSetup</methodname>
                <methodparam>
                    <type>uint32_t&amp;</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>writeUSBBulkTransferSetup</methodname>
                <methodparam>
                    <type>uint32_t</type> <parameter>value</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>c</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>z</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>inhibit</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>uninhibit</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>bool</type> <methodname>isInhibited</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>executeList</methodname>
                <methodparam>
                    <type>CCCUSBReadoutList&amp;</type> <parameter>list</parameter>
                </methodparam>
                <methodparam>
                    <type>void*</type><parameter>pReadBuffer</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t</type><parameter>readBufferSize</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t*</type><parameter>bytesRead</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>loadList</methodname>
                <methodparam>
                    <type>uint8_t</type><parameter>listNumber</parameter>
                </methodparam>
                <methodparam>
                    <type>CCCUSBReadoutList&amp;</type><parameter>list</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>int</type> <methodname>usbRead</methodname>
                <methodparam>
                    <type>void*</type> <parameter>data</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t</type> <parameter>bufferSize</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t*</type><parameter> transferCount</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>timeout</parameter>
                    <initializer> 2000</initializer>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>setDefaultTimeout</methodname>
                <methodparam>
                    <type>int</type> <parameter>ms</parameter>
                </methodparam>
            </methodsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::ActionRegister::startDAQ</varname><initializer>1</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::ActionRegister::usbTrigger</varname><initializer>2</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::ActionRegister::clear</varname><initializer>4</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::ActionRegister::scalerDump</varname><initializer>0x10</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::FirmwareRegister::revisionMask</varname>
                <initializer>0xff</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::FirmwareRegister::revisionShift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::FirmwareRegister::yearMask</varname>
                <initializer>0xf00</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::FirmwareRegister::yearShift</varname>
                <initializer>8</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::FirmwareRegister::monthMask</varname>
                <initializer>0xf000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::FirmwareRegister::monthShift</varname><initializer> 12</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLenMask</varname>
                <initializer>0xf</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLenShift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLen4K</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLen2K</varname>
                <initializer>1</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLen1K</varname>
                <initializer>2</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLen512</varname>
                <initializer>3</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t </type>
                <varname>CCCUSB::GlobalModeRegister::bufferLen256</varname>
                <initializer>4</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLen128</varname>
                <initializer>5</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLen64</varname>
                <initializer>6</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::bufferLenSingle</varname>
                <initializer>7</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::mixedBuffers</varname>
                <initializer>0x20</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::doubleHeader</varname>
                <initializer>0x100</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::GlobalModeRegister::enableSecondary</varname>
                <initializer>0x1000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::DelayRegister::triggerDelayMask</varname>
                <initializer>0xff</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::DelayRegister::triggerDelayShift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::DelayRegister::lamTimeoutMask</varname>
                <initializer>0xff00</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::DelayRegister::lamTimeoutShift</varname>
                <initializer>8</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::ScalerControlRegister::eventsCountMask</varname>
                <initializer>0xffff</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::ScalerControlRegister::eventsCountShift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::ScalerControlRegister::timeIntervalMask</varname>
                <initializer>0xff0000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::ScalerControlRegister::timeIntervalShift</varname>
                <initializer>16</initializer>
            </fieldsynopsis>
            
            <!--
   // Red LED: -->
            <fieldsynopsis>
                <modifier>static const</modifier>
                <type>uint32_t</type> <varname>CCCUSB::LedSourceRegister::redEventTrigger</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::redBusy</varname>
                <initializer>1</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::redUSBOutFifoNotEmpty</varname>
                <initializer>2</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::redUSBInFifoNotEmpty</varname>
                <initializer>3</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::redInvert</varname>
                <initializer>0x10</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::redLatch</varname>
                <initializer>0x20</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::redShift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <!--
    // Green LED: -->
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::greenShift</varname>
                <initializer>8</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::greenAcquire</varname>
                <initializer>(0 &lt;&lt; greenShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::greenNimI1</varname>
                <initializer>(1 &lt;&lt; greenShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::greenUSBInFifoNotEmpty</varname>
                <initializer>(2 &lt;&lt; greenShift</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::greenUSBTrigger</varname>
                <initializer>(3 &lt;&lt; greenShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::greenInvert</varname>
                <initializer>(0x10 &lt;&lt; greenShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::greenLatch</varname>
                <initializer>(0x20 &lt;&lt; greenShift)</initializer>
            </fieldsynopsis>
            <!--
    // Red LED: -->
        
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::yellowShift</varname>
                <initializer>= 16</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::yellowNimI2</varname>
                <initializer>(0 &lt;&lt; yellowShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::yellowNimI3</varname>
                <initializer>(1 &lt;&lt; yellowShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::yellowBusy</varname>
                <initializer>(2 &lt;&lt; yellowShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::yellowUsbInFifoNotEmpty</varname>
                <initializer>(3 &lt;&lt; yellowShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::yellowInvert</varname>
                <initializer>(0x10 &lt;&lt; yellowShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::LedSourceRegister::yellowLatch</varname>
                <initializer>(0x20 &lt;&lt; yellowShift)</initializer>
            </fieldsynopsis>
    
            <!-- Output source selection register -->
            

<!--    // NIM O1 source: -->

            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO1Shift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO1Busy</varname>
                <initializer>(0 &lt;&lt; nimO1Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO1Event</varname>
                <initializer>(1 &lt;&lt; nimO1Shift</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO1DGGA</varname>
                <initializer>(2 &lt;&lt; nimO1Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO1DGGB</varname>
                <initializer>(3 &lt;&lt; nimO1Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO1Invert</varname>
                <initializer>(0x10 &lt;&lt; nimO1Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO1Latch</varname>
                <initializer>(0x20 &lt;&lt; nimO1Shift)</initializer>
            </fieldsynopsis>

 <!--   // NIM O2 source:   -->
 
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO2Shift</varname>
                <initializer>8</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO2Acquire</varname>
                <initializer>(0 &lt;&lt;nimO2Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO2Event</varname>
                <initializer>(1 &lt;&lt; nimO2Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO2DGGA</varname>
                <initializer>(2 &lt;&lt; nimO2Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO2DGGB</varname>
                <initializer>3 &lt;&lt; nimO2Shift</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO2Invert</varname>
                <initializer>(0x10 &lt;&lt; nimO2Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO2Latch</varname>
                <initializer>(0x20 &lt;&lt; nimO2Shift)</initializer>
            </fieldsynopsis>

<!--    // NIM O3 source:  -->

            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO3Shift</varname>
                <initializer>16</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>nimO3BusyEnd</varname>
                <initializer>(0 &lt;&lt; nimO3Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO3Busy</varname>
                <initializer>(1 &lt;&lt; nimO3Shift</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO3DGGA</varname>
                <initializer>(2 &lt;&lt; nimO3Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO3DGGB</varname>
                <initializer>(3 &lt;&lt; nimO3Shift</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO3Invert</varname>
                <initializer>(0x10 &lt;&lt; nimO3Shift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::OutputSourceRegister::nimO3Latch</varname>
                <initializer>(0x20 &lt;&lt; nimO3Shift)</initializer>
            </fieldsynopsis>         
    <!-- DeviceSourceSelectorsRegister - -->
    
   <!-- // Scaler A source/control -->
   
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAShift</varname>
                <initializer>0</initializer>
                </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerADisabled</varname>
                <initializer>(0 &lt;&lt; scalerAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerANimI1</varname>
                <initializer>(1 &lt;&lt; scalerAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerANimI2</varname>
                <initializer>(2 &lt;&lt; scalerAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerANimI3</varname>
                <initializer>(3 &lt;&lt; scalerAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAEvent</varname>
                <initializer>(4 &lt;&lt; scalerAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAScalerBCarry</varname>
                <initializer>(5 &lt;&lt; scalerAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier>
                <type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerADGGA</varname>
                <initializer>(6 &lt;&lt; scalerAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerADGGB</varname>
                <initializer>(7 &lt;&lt; scalerAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAEnable</varname>
                <initializer>(0x10 &lt;&lt; scalerAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAReset</varname>
                <initializer>(0x20 &lt; scalerAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAFreeze</varname>
                <initializer>(0x40 &lt;&lt; scalerAShift)</initializer>
            </fieldsynopsis>
            
            <!-- // Scaler B source/control -->
            
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>scalerBShift</varname><initializer> 8</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBDisabled</varname>
                <initializer>(0 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t </type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBNimI1</varname>
                <initializer>(1 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBNimI2</varname>
                <initializer>(2 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBNimI3</varname>
                <initializer>(3 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBEvent</varname>
                <initializer>(4 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>int32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBScalerACarry</varname>
                <initializer>(5 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBDGGA</varname>
                <initializer>(6 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBDGGB </varname>
                <initializer>(7 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t </type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBEnable</varname>
                <initializer>(0x10 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBReset</varname>
                <initializer>(0x20 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBFreeze</varname>
                <initializer>(0x40 &lt;&lt; scalerBShift)</initializer>
            </fieldsynopsis>
            
            <!-- // DGGA source -->
            
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGAShift</varname>
                <initializer>16</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGADisabled</varname>
                <initializer>(0 &lt;&lt; DGGAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGANimI1</varname>
                <initializer>(1 &lt;&lt; DGGAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGANimI2</varname>
                <initializer>(2 &lt;&lt; DGGAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGANimI3</varname>
                <initializer>(3 &lt;&lt; DGGAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGAEvent</varname>
                <initializer>(4 &lt;&lt; DGGAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGABusyEnd</varname>
                <initializer>(5 &lt;&lt; DGGAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGAUSBTrigger</varname>
                <initializer>(6 &lt;&lt; DGGAShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGAPulser</varname>
                <initializer>(7 &lt;&lt; DGGAShift)</initializer>
            </fieldsynopsis>

            <!--  // DGGB source -->
            
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGBShift</varname>
                <initializer>24</initializer>
                </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGBDisabled </varname>
                <initializer>(0 &lt;&lt; DGGBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGBNimI1</varname>
                <initializer>(1 &lt;&lt; DGGBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGBNimI2</varname>
                <initializer>(2 &lt;&lt; DGGBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGBNimI3</varname>
                <initializer>(3 &lt;&lt; DGGBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGBEvent</varname>
                <initializer>(4 &lt;&lt; DGGBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGBBusyEnd</varname>
                <initializer>(5 &lt;&lt; DGGBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGBUSBTrigger</varname>
                <initializer>(6 &lt;&lt; DGGBShift)</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCUSB::DeviceSourceSelectorsRegister::DGGBPulser</varname>
                <initializer>(7 &lt;&lt; DGGBShift)</initializer>
            </fieldsynopsis>    



            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DGGAndPulserRegister::dggFineDelayMask</varname>
                <initializer>0xffff</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DGGAndPulserRegister::dggFineDelayShift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DGGAndPulserRegister::dggGateWidthMask</varname>
                <initializer>0xffff0000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DGGAndPulserRegister::dggGateWidthShift</varname>
                <initializer>16</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DGGCoarseRegister::ACoarseMask</varname>
                <initializer>xffff;</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCUSB::DGGCoarseRegister::ACoarseShift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DGGCoarseRegister::BCoarseMask</varname>
                <initializer>0xffff0000</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCUSB::DGGCoarseRegister::BCoarseShift</varname>
                <initializer>16</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type>uint32_t</type>
                <varname>CCCCUSB::TransferSetupRegister::multiBufferCountMask</varname>
                <initializer>0xff</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t </type>
                <varname>CCCCUSB::TransferSetupRegister::multiBufferCountShift</varname>
                <initializer>0</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier><type> uint32_t</type>
                <varname>CCCCUSB::TransferSetupRegister::timeoutMask</varname>
                <initializer>0xf00</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint32_t</type>
                <varname>CCCCUSB::TransferSetupRegister::timeoutShift</varname>
                <initializer>8</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::Q</varname>
                <initializer>1</initializer>
            </fieldsynopsis>
            <fieldsynopsis>
                <modifier>static const</modifier> <type>uint16_t</type>
                <varname>CCCUSB::X</varname>
                <initializer>2</initializer>
            </fieldsynopsis>
            };
       </synopsis>
        </programlisting>   
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            The <classname>CCCUSB</classname> class represents a connection
            to a CC-USB controller.  The static members <methodname>enumerate</methodname>
            and <methodname>serialNo</methodname> allow programs to become
            aware of the set of interfaces that are currently plugged in
            and powered up, and to associated them with serial number strings.
          </para>
          <para>
            Constructing an object around a specific <classname>usb_device*</classname>
            allows you to interact with the device represented by that struct.
            The class exports a rich set of methods which are described in the
            METHODS section below.  Bits and bit fields are defined as class
            constants described in PUBLIC VARIABLES, TYPES and CONSTANTS below.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <para>
            In the functions listed below, any function that returns an <type>int</type>
            returns <literal>0</literal> on success, <literal>-1</literal> if
            the write operation to the device failed or <literal>-2</literal>
            if the read operation failed.  Negative values result in the
            <varname>errno</varname> variable set to the actual reason for the
            failure.
          </para>
            <variablelist>
                <varlistentry>
                    <term><methodsynopsis><modifier>static</modifier>
                    <type>std::vector&lt;struct usb_device*&gt;</type>
                    <methodname>enumerate</methodname>
                    <void /></methodsynopsis></term>
                    <listitem>
                        <para>
                            Enumerates the set of CC-USB devices that are attached
                            and powered up on the host.  The return value
                            is a vector of <classname>usb_device*</classname> pointers
                            each of which represents one of those devices.
                        </para>
                        <para>
                            You can use a <classname>usb_device*</classname> pointer
                            to construct a <classname>CCCUSB</classname> object
                            or to query the serial number of that device.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><methodsynopsis><modifier>static</modifier>
                        <type>std::string</type>
                        <methodname>serialNo</methodname>
                        <methodparam>
                            <type>struct usb_device*</type><parameter>dev</parameter>
                        </methodparam></methodsynopsis> </term>
                    <listitem>
                        <para>
                            Returns the serial number string for the CC-USB
                            represented by the <parameter>dev</parameter>
                            parameter.  <parameter>dev</parameter> should have
                            been gotten from a call to <function>CCCUSB::enumerate</function>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><constructorsynopsis>
                    <methodname>CCCUSB</methodname>
                    <methodparam>
                      <type>struct usb_device*</type><parameter>vmUsbDevice</parameter>
                    </methodparam>
                     </constructorsynopsis></term>
                    <listitem>
                        <para>
                            Constructs a <classname>CCCUSB</classname> object.
                            The resulting object can be used to communicate
                            with the CC-USB represented by the
                            <parameter>vmUsbDevice</parameter> object.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                        <type>void</type>
                        <methodname>writeActionRegister</methodname>
                        <methodparam>
                          <type>uint16_t</type> <parameter>value</parameter>
                        </methodparam>
                      </methodsynopsis></term>
                    <listitem>
                        <para>
                            THIS IS A PURELY VIRTUAL METHOD.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                         <type>int</type>
                         <methodname>simpleWrite16</methodname>
                         <methodparam>
                           <type>int</type><parameter>n</parameter>
                         </methodparam>
                         <methodparam>
                           <type>int</type><parameter>a</parameter>
                         </methodparam>
                         <methodparam>
                           <type>int</type><parameter>f</parameter>
                         </methodparam>
                         <methodparam>
                           <type>uint16_t</type><parameter>data</parameter>
                         </methodparam>
                         <methodparam>
                           <type>uint16_t&amp;</type><parameter>qx</parameter>
                         </methodparam>
                       </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a CAMAC write operations with a
                            16 bit wide data transfer.
                            The parameters <parameter>n,a,f</parameter>
                            specify the slot, subaddress and function code
                            respectively while the <parameter>data</parameter>
                            parameter provides the data to write.  The
                            <parameter>qx</parameter> parameter receives a
                            bit encoding of the Q and X responses of the
                            operation.  See PUBLIC VARIABLES, TYPES and CONSTANTS
                            for the <varname>CCCUSB::Q</varname> and
                            <varname>CCCUSB::X</varname> bit field definitions.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>simpleWrite24</methodname>
                            <methodparam>
                                <type>int</type> <parameter>n</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>a</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>f</parameter>
                            </methodparam>
                            <methodparam>
                                <type>uint32_t</type> <parameter>data</parameter>
                            </methodparam>
                            <methodparam>
                                <type>uint16_t&amp;</type> <parameter>qx</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>simpleWrite16</methodname> above,
                            however the least significant 24 bits of
                            <parameter>data</parameter> are written.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                           <type>int</type> <methodname>simpleRead16</methodname>
                           <methodparam>
                               <type>int</type><parameter>n</parameter>
                           </methodparam>
                           <methodparam>
                               <type>int</type> <parameter>a</parameter>
                           </methodparam>
                           <methodparam>
                               <type>int</type><parameter>f</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint16_t&amp;</type> <parameter>data</parameter>
                           </methodparam>
                           <methodparam>
                               <type>uint16_t&amp;</type> <parameter>qx</parameter>
                           </methodparam>
                       </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a 16 bit read from a CAMAC module.
                            <parameter>n,a,f</parameter> define the slot, subaddress and
                            function code respectively while <parameter>data</parameter>
                            will receive the data from the operation.
                            <parameter>qx</parameter> will contain a
                            bit encoding of the dataway Q and X responses.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                       <methodsynopsis>
                        <type>int</type> <methodname>simpleRead24</methodname>
                        <methodparam>
                            <type>int</type> <parameter>n</parameter>
                        </methodparam>
                        <methodparam>
                            <type>int</type> <parameter>a</parameter>
                        </methodparam>
                        <methodparam>
                            <type>int</type> <parameter>f</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint32_t&amp;</type><parameter>data</parameter>
                        </methodparam>
                        <methodparam>
                            <type>uint16_t&amp;</type> <parameter>qx</parameter>
                        </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>simpleRead16</methodname>, however the data
                            transfer is 24 bits.  These are placed in the least
                            significant 24 bits of <parameter>data</parameter>.
                            The top 8 bits are zeroed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>simpleControl</methodname>
                            <methodparam>
                                <type>int</type> <parameter>n</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>a</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type><parameter>f</parameter>
                            </methodparam>
                            <methodparam>
                                <type>uint16_t&amp;</type> <parameter>qx</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs the non-data transfer operation (control
                            function) specified by <parameter>n,a,f</parameter>.
                            As usuall the dataway Q and X responses are stored
                            in the <parameter>qx</parameter> parameter.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readFirmware</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the firmware id register storing it in the
                            <parameter>value</parameter> parameter.  This field
                            is bit encoded.  See the Firmware Register
                            subsection of PUBLIC VARIABLES, TYPES and CONSTANTS
                            below for symbols that allow you to extract the
                            firmware register fields.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readGlobalMode</methodname>
                            <methodparam>
                                <type>uint16_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the global mode register of the CC-USB.
                            The value of that register is stored in the
                            <parameter>value</parameter> parameter.  The
                            global mode register consists of several bits and
                            bit fields.  See the Global Mode subsection of
                            PUBLIC VARIABLES, TYPES and CONSTANTS below for
                            symbolic definitions of those bits and bit fields.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeGlobalMode</methodname>
                            <methodparam>
                                <type>uint16_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes the global mode register so that it contains
                            <parameter>value</parameter>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readDelays</methodname>
                            <methodparam>
                                <type>uint16_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the delays register into <parameter>value</parameter>.
                            The delays register contains bit fields that control
                            the trigger delay and lam timeout of lam waits.
                            See the Delays Register section of
                            PUBLIC VARIABLES, TYPES and CONSTANTS below
                            for symbolic definitions of this register's contents.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                    <methodsynopsis>
                        <type>int</type>
                        <methodname>writeDelays</methodname>
                        <methodparam>
                            <type>uint16_t</type> <parameter>value</parameter>
                        </methodparam>
                    </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> into the
                            CC-USB's delays register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type>  <methodname>readScalerControl</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the CC-USB scaler control register into
                            <parameter>value</parameter>.  This regtister contains
                            bit fields that are defined in the
                            Scaler Control Register subsection of
                            PUBLIC VARIABLES, TYPES and CONSTANTS
                            below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeScalerControl</methodname>
                            <methodparam>
                                <type>uint32_t</type><parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> into the
                            scaler control register of the CC-USB.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readLedSelector</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the value of the LED selector register
                            into <parameter>value</parameter>.  The
                            LED selector register defines the meaning of the
                            lights on the CC-USB front panel.  The bit field
                            definitions and values are described in
                            LED Selector Register below in
                            PUBLIC VARIABLES, TYPES and CONSTANTS
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeLedSelector</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> into the
                            LED selector register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readOutputSelector</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Read the value of the Output Selector register
                            into <parameter>value</parameter>.  The
                            Output selector register determines the functions
                            of the NIM output connectors on the front panel
                            of the CC-USB.  The bit field and code definitions
                            of this register have symbolic definitions that are
                            described in Output Selector Register in
                            PUBLIC VARIABLES, TYPES and CONSTANTS
                            below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeOutputSelector</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Write <parameter>value</parameter> into the
                            output selector register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readDeviceSourceSelectors</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type><parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Read the device source selectors register into
                            <parameter>value</parameter>.  This register
                            determines the input sources for various CC-USB
                            onboard resources, specifically the two scalers
                            and two gate generators.  The bit fields in this
                            register are described in
                            Device Source Selector register in
                            PUBLIC VARIABLES, TYPES and CONSTANTS below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeDeviceSourceSelectors</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> into the
                            device source selector register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readDGGA</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                        <methodsynopsis>
                            <type>int</type> <methodname>readDGGB</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                        <methodsynopsis>
                            <type>int</type> <methodname>readDGGExt</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            These functions read registers that set up the
                            parameters that control the two gate and delay
                            generators in the CC-USB into the <parameter>value</parameter>
                            parameter.  The bit fields definitions for these
                            registers are described in Gate and Delay Generators
                            below in
                            PUBLIC VARIABLES, TYPES and CONSTANTS
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeDGGA</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeDGGB</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeDGGExt</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> into the
                            registers that control the two gate and delay
                            generators in the CC-USB.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readScalerA</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                        <methodsynopsis>
                            <type>int</type> <methodname>readScalerB</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the current value of scaler A or B internal
                            to the CC-USB into the <parameter>value</parameter>
                            parameter.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readLamTriggers</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the contents of the lam trigger register
                            into <parameter>value</parameter>.
                            The LAM trigger register is a mask of LAMs which
                            if matched by the dataway LAM pattern will trigger
                            the event list.  If zero, readout is triggered by
                            front panel inputs.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeLamTriggers</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Write <parameter>value</parameter> to the LAM trigger
                            register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readCAMACLams</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the contents of the CAMAC LAM register. This register
                            mirrors the state of the LAM lines of the CAMAC crate. Only
                            the lower 24-bits are returned by this function.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>readUSBBulkTransferSetup</methodname>
                            <methodparam>
                                <type>uint32_t&amp;</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reads the value of the USB Bulk transfer register
                            into <parameter>value</parameter>.  The bulk transfer
                            register contains two bit fields which are defined
                            in the USB Bulk Transfer Register under the
                            PUBLIC VARIABLES, TYPES and CONSTANTS section
                            below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>writeUSBBulkTransferSetup</methodname>
                            <methodparam>
                                <type>uint32_t</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> into the
                            USB Bulk transfer register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>c</methodname>
                            <void />
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a dataway C cycle.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                           <type>int</type> <methodname>z</methodname>
                           <void />
                       </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a data way Z cycle.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>inhibit</methodname>
                            <void />
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Sets the dataway Inhibit line.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>uninhibit</methodname>
                            <void />
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Unsets the dataway Inhibit line.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>bool</type> <methodname>isInhibited</methodname>
                            <void />
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para> 
                            Reads the state of the dataway I line (inhibit). This is only
                            meaningful if the firmware version is greater than 0x8e000601. Otherwise,
                            the behavior is undefined.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>executeList</methodname>
                            <methodparam>
                                <type>CCCUSBReadoutList&amp;</type> <parameter>list</parameter>
                            </methodparam>
                            <methodparam>
                                <type>void*</type><parameter>pReadBuffer</parameter>
                            </methodparam>
                            <methodparam>
                                <type>size_t</type><parameter>readBufferSize</parameter>
                            </methodparam>
                            <methodparam>
                                <type>size_t*</type><parameter>bytesRead</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            THIS IS A PURELY VIRTUAL METHOD. See CCUSBusb and CCCUSBRemote classes for
                            implementation.
                        </para>
                        <para>
                            Performs a CAMAC list operation in immediate mode.
                            In order to do this data taking mode must not
                            be on.   The <parameter>list</parameter> is built up
                            by constructing a <classname>CCCUSBReadoutList</classname>
                            (see <xref linkend='ccusb3-CCCUSBReadoutList' />)
                            object and using its methods to add the appropriate
                            set of instructions to the list.
                        </para>
                        <para>
                            <parameter>pReadBuffer</parameter> is a pointer to
                            a buffer you have prepared to receive the results
                            of the read operations in the list.  This buffer
                            has <parameter>readBufferSize</parameter> bytes
                            of data.  On successful return,
                            <parameter>bytesRead</parameter> will contain the
                            actual number of bytes transferred into your buffer.
                            On failure (return value other than <literal>0</literal>),
                            the value of <parameter>bytesRead</parameter> is not
                            well defined.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                           <type>int</type> <methodname>loadList</methodname>
                           <methodparam>
                               <type>uint8_t</type><parameter>listNumber</parameter>
                           </methodparam>
                           <methodparam>
                               <type>CCCUSBReadoutList&amp;</type><parameter>list</parameter>
                           </methodparam>
                       </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            THIS IS A PURELY VIRTUAL METHOD. See CCUSBusb and CCCUSBRemote classes for
                            implementation.
                        </para>
                        <para>
                            Loads a list into the CC-USB. The <parameter>listNumber</parameter>
                            must be 0 for the event list and 1 for the scaler list.
                            If it is any value other than this, the function
                            will return <literal>-4</literal>.
                            <parameter>list</parameter>   is the
                            <classname>CCCUSBReadoutList</classname> to load.
                            See <xref linkend='ccusb3-CCCUSBReadoutList' /> for
                            information about this parameter and how to build it.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>usbRead</methodname>
                            <methodparam>
                                <type>void*</type> <parameter>data</parameter>
                            </methodparam>
                            <methodparam>
                                <type>size_t</type> <parameter>bufferSize</parameter>
                            </methodparam>
                            <methodparam>
                                <type>size_t*</type><parameter> transferCount</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>timeout</parameter>
                                <initializer>2000</initializer>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            THIS IS A PURELY VIRTUAL METHOD. See CCUSBusb and CCCUSBRemote classes for
                            implementation.
                        </para>
                        <para>
                            Pefroms a bulk read on the data transfer endpoint
                            of the CC-USB.  Normally this only needs to be called
                            by the CCUSBReadout framework when in data taking mode.
                            <parameter>data</parameter> is a buffer
                            into which data read should be transferred.
                            <parameter>bufferSize</parameter> is the number
                            of bytes that can be stored in <parameter>buffer</parameter>
                            <parameter>transferCount</parameter> points to a
                            buffer that will contain the number of bytes actually
                            transferred to the buffer. <parameter>timeout</parameter>
                            is the number of milliseconds to wait for the transfer
                            to complete before ending with a timeout condition.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>setDefaultTimeout</methodname>
                            <methodparam>
                                <type>int</type> <parameter>ms</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Most of the immediate operations require a write to the
                            CC-USB followed by a read to get status and/or data.
                            This function allows you to override the default
                            timeout for the read. <parameter>ms</parameter> is
                            the number of milliseconds in the new timeout.
                            Normally you will not need to call this.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>  
       </refsect1>
        <refsect1>
           <title>PUBLIC VARIABLES, TYPES and CONSTANTS</title>
           <para>
                The <classname>CCCUSB</classname> class exports several
                public constants that provide symbolic constants that help you
                to build up the contents of CC-USB registers.  The subsections
                in this section describe these values for each register.
           </para>
           <refsect2>
            <title>Action Register</title>
            <para>
                The Action register is a write-only register. Setting bit
                patterns in the Action register cause the CC-USB to take
                specific actions.
            </para>
            <variablelist>
                    <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::ActionRegister::startDAQ</varname><initializer>1</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            When this bit is set, the CC-USB enters data taking
                            mode.  In data taking mode the CC-USB responds to triggers
                            for the Event and Scaler stacks by executing them
                            and buffering their data for read via
                            <methodname>usbRead</methodname>.  Prior
                            to executing immediate actions you must clear this
                            bit and drain any buffered event data from the
                            module.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                           <modifier>static const</modifier> <type>uint16_t</type>
                           <varname>CCCUSB::ActionRegister::usbTrigger</varname><initializer>2</initializer>
                       </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Setting this bit performs a one-time trigger
                            of the event readout list.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::ActionRegister::clear</varname><initializer>4</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This bit is "intended primarily for use during
                            firmware debugging" it should not be set by
                            ordinary users like us.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::ActionRegister::scalerDump</varname><initializer>0x10</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Setting this bit triggers execution of the scaler
                            list.
                        </para>
                    </listitem>
                </varlistentry>    
            </variablelist>
            <para>
                Note that all bits except the <varname>startDAQ</varname> are
                one-shots that automatically reset after 150ns.
            </para>
           </refsect2>
           <refsect2>
            <title>Firmware Register</title>
            <para>
                This register contains the current revision of the device
                firmware.  This is a set of bit fields in a 32 bit word:
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::FirmwareRegister::revisionMask</varname>
                            <initializer>0xff</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::FirmwareRegister::revisionShift</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            These two value define the revision field.
                            If <varname>d</varname> contains the
                            firmware revision register, you can extract
                            the revisionfield by performing:
                            <informalexample>
                                <programlisting>
uint32_t revision = (d &amp; CCCUSB::FirmwareRegister::revisionMask)
                    >> CCCUSB::FirmwareRegister::revisionShift;
                                </programlisting>
                            </informalexample>
                        </para>
                        <para>
                            The remaining fields are defined in this way,
                            by a mask and a shift count.  Analagous operations
                            can be used to extract  the value of the
                            field given the full firmware revision register
                            value.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::FirmwareRegister::yearMask</varname>
                            <initializer>0xf00</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::FirmwareRegister::yearShift</varname>
                            <initializer>8</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the field that gives the year in which the
                            firmware version was finalized.
                            The manual does not define what a <literal>0</literal>
                            in this field means.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::FirmwareRegister::monthMask</varname>
                            <initializer>0xf000</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::FirmwareRegister::monthShift</varname><initializer> 12</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the month field.  This field contains
                            the month in which the firmware was finalized.
                            Presumably this is a value between
                            <literal>[1..12]</literal>.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>Global Mode Register</title>
            <para>
                The global mode register is described in section 3.3.2 of the
                CC-USB manual.  This register can be built up by bitwise
                or-ing together the values described in this section.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLenMask</varname>
                            <initializer>0xf</initializer>
                        </fieldsynopsis>
                    </term>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLenShift</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            These values define the field in the global mode
                            register that sets the lengt of the data buffer
                            produced by the CC-USB.
                        </para>
                        <para>
                            For actual values you can or into the register
                            see the fields bufferLenxx below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLen4K</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects buffers that are <literal>4096</literal>
                            <classname>uint16_t</classname> units long.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLen2K</varname>
                            <initializer>1</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Use an output buffer length of <literal>2048</literal>
                            <classname>uint16_t</classname> units long.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLen1K</varname>
                            <initializer>2</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Use an output buffer length of
                            <literal>1024</literal>   <classname>uint16_t</classname>
                            units long.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLen512</varname>
                            <initializer>3</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Use an output buffer length of
                            <literal>512</literal> <classname>uint16_t</classname>
                            units long.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t </type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLen256</varname>
                            <initializer>4</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Use an output buffer length of
                            <literal>256</literal> <classname>uint16_t</classname>
                            units long.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLen128</varname>
                            <initializer>5</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Use  a <literal>128</literal> <classname>uint16_t</classname>
                            unit large output buffer.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLen64</varname>
                            <initializer>6</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Use a <literal>64</literal> <classname>uint16_t</classname>
                            unit large output buffer.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::bufferLenSingle</varname>
                            <initializer>7</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Use a buffer that holds only a single event.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::mixedBuffers</varname>
                            <initializer>0x20</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Mix scaler and event data together in the same scaler
                            buffer.  If zero, buffers are homogenous with respect
                            to the stack that contributes data to them.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::doubleHeader</varname>
                            <initializer>0x100</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            If set the buffer header will include a second
                            word that contains the number of words in the
                            buffer.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::GlobalModeRegister::enableSecondary</varname>
                            <initializer>0x1000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            If set, CAMAC bus arbitration is enabled, allowing
                            the use of an Auxiliary crate controller.
                            In this case you must cable the Aux controller
                            to request mastership via RQ, GIN, and GOUT
                            signals on the front of the controller.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>Delay Register</title>
            <para>
                This register has fields for controlling the delay between the trigger
                and stack execution as well as the LAM timeout interval.
                Both fields are in units of microseconds.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::DelayRegister::triggerDelayMask</varname>
                            <initializer>0xff</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::DelayRegister::triggerDelayShift</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                           Mask and shift counts for the trigger delay field.
                           This field controls the amount of time between
                           the receipt of a trigger and execution of the
                           event stack.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::DelayRegister::lamTimeoutMask</varname>
                            <initializer>0xff00</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::DelayRegister::lamTimeoutShift</varname>
                            <initializer>8</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Mask and shift counts for the lam timeout field.
                            This field controls the number of microseconds
                            stack lines with the <literal>LM</literal> (lam
                            wait mode) bit set will wait for a LM from the
                            station specified.
                        </para>
                    </listitem>
                </varlistentry>     
            </variablelist>
           </refsect2>
           <refsect2>
            <title>Scaler Control register</title>
            <para>
                The manual (3.3.4) refers to this as tyhe ACS control register,
                its function, however is to determine when the scaler
                (Auxilliary stack) is triggered.
                There are two fields. Both can be non-zero allowing for two
                trigger conditions.  One trigger condition allows scalers to
                be triggered after a fixed number of events have been read.
                The second condition allows readout of scalers at fixed time
                intervals.
            </para>
            <para>
                If a field is zero, that trigger condition is disabled.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::ScalerControlRegister::eventsCountMask</varname>
                            <initializer>0xffff</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::ScalerControlRegister::eventsCountShift</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Define the field that controls scaler triggers
                            every fixed number of events.  If this field is
                            non zero, it specifies the number of events
                            between scaler reads.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type> uint32_t</type>
                            <varname>CCCUSB::ScalerControlRegister::timeIntervalMask</varname>
                            <initializer>0xff0000</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::ScalerControlRegister::timeIntervalShift</varname>
                            <initializer>16</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the field that sets up the time periodic
                            trigger.  If this is nonzero, it represents the
                            scaler readout period in 0.5second units.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>LED Source Register</title>
            <para>
                This register contains a set of bit fields that describe
                the signal source that lights each of the LEDs on the front
                panel.  Normally this register will be written with a logical
                or of values of one item from each bit field.  The fields
                are named after the colors of the LED each field controls.
            </para>
            <note>
                <title>Firmware changes</title>
                <para>
                    It appears that these definitions are for firmware
                    revisions &lt; 1.01.  These definitions will be updated
                    in the future to reflect the updated definitions.
                </para>
            </note>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>  <type> uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redEventTrigger</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The red LED will light on an event trigger.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redBusy</varname>
                            <initializer>1</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The red led will light when the CC-USB is busy.
                            Busy means that the CC-USB is processing the event
                            or scaler stack.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redUSBTrigger</varname>
                            <initializer>2</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the red LED when the software requests a USB
                            trigger of the event stack by writing the
                            <varname>CCCUSB::ActionRegister::usbTrigger</varname>
                            bit to the action register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redUSBOutFifoNotEmpty</varname>
                            <initializer>3</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the red LED whenever the USB output fifo
                            is not empty.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redUSBInFifoNotFull</varname>
                            <initializer>4</initializer>
                        </fieldsynopsis>
                        </term>
                    <listitem>
                        <para>
                            Lights the red led whenever the USB input fifo is not
                            ful.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redAcquire</varname>
                            <initializer>6;</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the red LED when acquisition mode is turned on
                            (that is the last write to the action register
                            set the
                            <varname>CCCUSB::ActionRegister::startDAQ</varname> bit).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redCAMACF2</varname>
                            <initializer>7</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the red LED whenever the 2's bit is set in the
                            current CAAMC function being performed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redInvert</varname>
                            <initializer>0x10</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Inverts the state of the read LED.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::redLatch</varname>
                            <initializer>0x20</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            When the trigger condition for the led exists, latches the
                            led on until this bit is toggled off then on.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::greenAcquire</varname>
                            <initializer>0x000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Sets the green LED when data acquisition is enabled.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::greenCAMACF1</varname>
                            <initializer>0x100</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Sets the green LED whe the F1 line is set on the last
                            CAMAC operation.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::greenEventTrigger</varname>
                            <initializer>0x300</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Turns on the green LED whenever the event trigger is
                            being processed.
                        </para>
                        </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname> CCCUSB::LedSourceRegister::greenCAMACN</varname>
                            <initializer>0x400</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the green LED whhen a CAMAC operation has occured.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::greenI1</varname>
                            <initializer>0x600</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the green LED if the I1 input has a NIM
                            true presented on it.
                        </para>
                    </listitem>
                    </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::greenUSBInFifoNotEmpty</varname>
                            <initializer>0x700</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the green LED if the input FIFO is not empty.
                        </para>
                    </listitem>
                    </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::greenInvert</varname>
                            <initializer>0x1000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Invert the sense of the green led.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::greenLatch</varname>
                            <initializer>0x2000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Latch the green led.  When the condition to light the
                            LED occurs, the led stays on until this bit is
                            toggled off (and then back on if the latch condition
                            should be re-established).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowI3</varname>
                            <initializer>0x00000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Light the yellow LED if the I3 input is active.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowBusy</varname>
                            <initializer>0x10000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Ligths the yellow  LED when the CC-USB is busy
                            executing one of the command stacks.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowI2</varname>
                            <initializer>0x20000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Light the Yellow LED when the I2 input is active.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowCAMACS1</varname>
                            <initializer>0x30000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the yellow LED when the S1 signal on the CAMAC
                            dataway is active.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowCAMACS2</varname>
                            <initializer>0x40000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the yellow LED when the CAMAC S2 dataway line
                            is active.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowUSBInFifoNotEmpty</varname>
                            <initializer>0x50000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the Yellow LED when the USB input FIFO
                            is not empty.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowScalerReadout</varname>
                            <initializer>0x60000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the Yellow led when the scaler stack is
                            being executed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowUSBTrigger</varname>
                            <initializer>0x70000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Lights the yellow LED when event stack execution
                            has been requested by a USB write to the Action
                            register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowInvert</varname>
                            <initializer>0x100000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Inverts the sense of the Yellow LED.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::LedSourceRegister::yellowLatch</varname>
                            <initializer>0x200000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Enables latch mode for the yellow LED.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>Output source selection register.</title>
            <para>
                This register has several coded bit fields that select
                which signals are presented at the module nim outputs
                O1, O2, and O3.
            </para>
            <note>
                <title>Firmware &lt; 1.01</title>
                <para>
                    Thie definitions shwon here are only valid for firmware
                    revisions &lt; 1.01.  This section and the header files
                    themselves must be updated to reflect the current
                    reduced set of output functionality.
                </para>
            </note>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO1Busy</varname>
                            <initializer>0x000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            O1 is asserted when the CC-USB is executing a stack.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO1EventTrigger</varname>
                            <initializer>0x000001</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Ouptut 1 reflects that an event trigger has been
                            recently received.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO1DGGA</varname>
                            <initializer>0x000002</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            O1 reflets the output gate and delay generator A.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO1DGGB</varname>
                            <initializer>0x000003</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            O1 reflects the output of gate and delay generator
                            B.
                            </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO1Latch</varname>
                            <initializer>0x000010M</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            O1 is latched when set until this bit is toggled.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>    <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO1Invert</varname>
                            <initializer>0x000020</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            O1 is inverted relative to the code that selets its
                            output.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO2Acquire</varname>
                            <initializer>0x000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Asserts O1 when acquisition mode is turned on via
                            the action register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>   <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO2Event</varname>
                            <initializer>0x000200</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Turns O2 on when an event trigger has been recently
                            received.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO2DGGA</varname>
                            <initializer>0x000400</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reflects the output of gate and delay generator A
                            in the O2 output.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO2DGGB</varname>
                            <initializer>0x000600</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Reflects the output of gate and delay generator B
                            to the O2 output.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO2Latch</varname>
                            <initializer>0x001000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Sets the O2 register in latching mode.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO2Invert</varname>
                            <initializer>0x002000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Inverts the sense of O2.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO3EndOfBusy</varname>
                            <initializer>0x000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Asserts O3 when busy ends.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO3Busy</varname>
                            <initializer>0x020000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Asserts O3 when the CC-USB is executing a stack.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO3DGGA</varname>
                            <initializer>0x040000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            O3 reflects the output of gate and delay generator A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternim03DGGB</varname>
                            <initializer>0x060000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            O3 reflects the state of gate and delay generator B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO3Latch</varname>
                            <initializer>0x100000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Latches the state of O3.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::OutputSourceRegisternimO3Invert</varname>
                            <initializer>0x200000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Inverts the sense of the O3 output.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>Device source register</title>
            <para>
                This register contains several fields that control the
                input sources to the scalers and gate and delay generators
                implemented in the CC-USB.  The register contains four fields
                which are called <literal>scalerA</literal>, <literal>scalerB</literal>
                <literal>dggA</literal>  and <literal>dggB</literal>. Typically
                you will bitwise or a code from each of the fields.  In the case
                of the scaler fields there are three bits, <literal>Enable</literal>,
                <literal>Reset</literal>, and <literal>FreezeReg</literal>
                that can also be ored into the codes.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerADisabled</varname>
                            <initializer>0x00000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Scale A has no input, effectively disabling it.
                            Note that if code is not use you will need
                            to set the enable bit as well to enable the scaler
                            to count.
                            </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAI1</varname>
                            <initializer>0x00000001</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects I1 as the input to Scaler A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAI2</varname>
                            <initializer>0x00000002</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects I2 as the input to scaler A.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAI3</varname>
                            <initializer>0x00000003</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects I3 to be the input to scalerA.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier>   <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAEvent</varname>
                            <initializer>0x00000004</initializer>
                        </fieldsynopsis>
                        </term>
                    <listitem>
                        <para>
                            Selects the event trigger to be the source for
                            Scaler A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerACarryB</varname>
                            <initializer>0x00000005</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects the carry out of scalerB to increment
                            ScalerA  this allows you to gang ScalerB (LSBs)
                            and Scaler A (MSBs) into a single 48 bit scaler.
                        </para>
                    </listitem>
                    </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerADGGA</varname>
                            <initializer>0x00000006</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Scaler A will count when DGGA snds an output pulse.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerADGGB</varname>
                            <initializer>0x00000007</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Counts scaler A when when DGGB sends an output pulse.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const </modifier><type> uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAEnable</varname>
                            <initializer>0x00000010</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Enables Scaler A to count.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAScalerAReset</varname>
                            <initializer>0x00000020</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Resets scaler A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerAFreezReg</varname>
                            <initializer>0x00000040</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Any operation that writes this register with this
                            bit set will not modify the effective code for selecting
                            the inputs for scaler A.  This allows you to enable/disable/clear
                            scaler A without needing to know the actual
                            scaler source.  Note that since there is no
                            corresponding freeze bit for the dggA/B sources this
                            capability is of limited utility.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBDisabled</varname>
                            <initializer>0x00000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Directs to inputs to Scaler B.  Note that if another
                            input is used it's still necessary to also set
                            the <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBEnable</varname>
                            bit to enable the scaler to count.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBI1</varname>
                            <initializer>0x00000100</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            I1 is the input to ScalerB.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBI2</varname>
                            <initializer>0x00000200</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects I2 as the input for Scaler B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBI3</varname>
                            <initializer>0x00000300</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selecst I3 as the input for Scaler B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBEvent</varname>
                            <initializer>0x00000400</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects the event trigger as the input for
                            scaler B.  Presumably using this allows the scaler
                            to count the number of events acquired.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBCarryA</varname>
                            <initializer>0x00000500</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Selects the carry from Scaler A as the input to
                            scalerB this enables the use of ScalerA/B as
                            a 48 bit scaler with the LSBs in ScalerA
                            and MSBs in ScalerB.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBDGGA</varname>
                            <initializer>0x00000600</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Enables the output of gate and delay generator A
                            to be the input to scaler B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBDGGB</varname>
                            <initializer>0x00000700</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Enables the output of gate and delay generator B
                            to be the input of scaler B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBEnable</varname>
                            <initializer>0x00001000</initializer>
                            </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This bit can be ored in with the selected Scaler B
                            code values.  It enables scaler B to count.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBReset</varname>
                            <initializer>0x00002000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Resets scaler B
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::scalerBFreezeReg</varname>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Freezes the scaler B input selector field.  This
                            allows one to write Reset and Enable bits without
                            disturbing the event source.  Note that you still
                            must regenerate the DGGA and DGGB source selectors.
                        </para>
                        </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggADisabled</varname>
                            <initializer>0x00000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Provides no input signal to Gate and delay generator
                            A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAI1</varname>
                            <initializer>0x00010000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Routes the I1 front panel input to the input of
                            gate and delay generator A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAI2</varname>
                            <initializer>0x00020000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Routes the I2 front panel input to the input of
                            gate and delay generator A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAI3</varname>
                            <initializer>0x00030000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Routes the I3 front panel input to the input of
                            gate and delay generator A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAEvent</varname>
                            <initializer>0x00040000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Routes the event trigger to the input of
                            gate and delay generator A
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAEndOfEvent</varname>
                            <initializer>0x00050000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Pulses the inpt of gate and delay generator A when
                            event readout has completed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAUSBTrigger</varname>
                            <initializer>0x00060000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Pulses the input of gate and delay generator A
                            when a USB stack trigger is written to the
                            action register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggAPulser</varname>
                            <initializer>0x00070000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Pulses the input of gate and delay generator A
                            from the output of the pulser.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBDisabled</varname>
                            <initializer>0x00000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Provides no input to gate and delay generator B.
                            </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBI1</varname>
                            <initializer>0x01000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Routes the I1 input signal to the input of
                            Gate and delay generator B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBI2</varname>
                            <initializer>0x02000000</initializer>
                        </fieldsynopsis>
                   </term>
                    <listitem>
                        <para>
                            Routes the I2 input signal to the input of
                            Gate and delay generator B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBI3</varname>
                            <initializer>0x03000000</initializer>
                        </fieldsynopsis>
                   </term>
                    <listitem>
                        <para>
                            Routes the I3 input signal to the input of
                            Gate and delay generator B.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBEvent</varname>
                            <initializer>0x04000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Puses the input of gate and delay generator B
                            when an event trigger is processed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBEndOfTrigger</varname>
                            <initializer>0x05000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Pulses the input of DGGB at the end of processing
                            an event trigger.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBUSBTrigger</varname>
                            <initializer>0x06000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Pulses the input of gate and delay generator B
                            when a USB trigger is written to the Actino regsiter.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DeviceSourceSelectorsRegister::dggBPulser</varname>
                            <initializer>0x07000000</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Connects the pulser output to the input of gate
                            and delay generator B
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>Gate and delay generator and pulser set up registers.
            </title>
            <para>
                Several registers are used to set the timing of gate and
                delay registers.  The timing parameters for gate and delay
                generator A also determine the timing for the pulser as showin
                in section 3.3.7 of the CC-USB manual.
            </para>
            <para>
                This section describes the bit fields in these registers.
                Each field is descdribed as a mask and shift count.
                The mask removes all extraneous bits from the register except
                the desired field and the shift count, when used to shift the
                result right right justifies the field data.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DGGAndPulserRegister::dggFineDelayMask</varname>
                            <initializer>0xffff</initializer>
                        </fieldsynopsis>                            
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DGGAndPulserRegister::dggFineDelayShift</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the fine delay field.  See the course delays
                            below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DGGAndPulserRegister::dggGateWidthMask</varname>
                            <initializer>0xffff0000</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DGGAndPulserRegister::dggGateWidthShift</varname>
                            <initializer>16</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the gate width field.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DGGCoarseRegister::ACoarseMask</varname>
                            <initializer>xffff;</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCUSB::DGGCoarseRegister::ACoarseShift</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the course delay fields for the a pulser.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DGGCoarseRegister::BCoarseMask</varname>
                            <initializer>0xffff0000</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCUSB::DGGCoarseRegister::BCoarseShift</varname>
                            <initializer>16</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the B course delay field.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>Transfer setup register</title>
            <para>
                This regiseter allows you to read several buffers from the
                CC-USB in a single read, as well as setting a time bound
                on how long before the CC-USB terminates a multibuffer read.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type>uint32_t</type>
                            <varname>CCCCUSB::TransferSetupRegister::multiBufferCountMask</varname>
                            <initializer>0xff</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type> uint32_t </type>
                            <varname>CCCCUSB::TransferSetupRegister::multiBufferCountShift</varname>
                            <initializer>0</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Defines the number of buffers that can be batched
                            into a single usb_bulk_read request.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier><type> uint32_t</type>
                            <varname>CCCCUSB::TransferSetupRegister::timeoutMask</varname>
                            <initializer>0xf00</initializer>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint32_t</type>
                            <varname>CCCCUSB::TransferSetupRegister::timeoutShift</varname>
                            <initializer>8</initializer>
                        </fieldsynopsis>
                        </term>
                    <listitem>
                        <para>
                            Determines the number of seconds after which
                            the CC-USB will terminate a bulk transfer if not
                            all of the buffers determined by themultiBuffer
                            count have been transferred.
                            </para>
                    </listitem>
                </varlistentry>
            </variablelist>
           </refsect2>
           <refsect2>
            <title>X and Q</title>
            <para>
                The <parameter>qx</parameter> parameter on the simple
                CAMAC operations allow you access to the dataway
                Q and X lines.  The bit encoding of that parameter is:
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::Q</varname>
                            <initializer>1</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            If this bit was set in the <parameter>qx</parameter>
                            parameter, the module asserted a Q on the dataway.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>static const</modifier> <type>uint16_t</type>
                            <varname>CCCUSB::X</varname>
                            <initializer>2</initializer>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            If this bit is set in the <parameter>qx</parameter>
                            parameter, the module asserted an X on the dataway.
                        </para>
                    </listitem>
                    </varlistentry>
            </variablelist>
           </refsect2>    
        </refsect1>
        <refsect1>
            <title>SEE ALSO</title>
            <para>
                <xref linkend='ccusb3-CCCUSBReadoutList' />
            </para>
        </refsect1>
     </refentry>

	 <refentry id="ccusb3-CCCUSBusb">
       <refmeta>
          <refentrytitle>CCCUSBusb</refentrytitle>
          <manvolnum>3ccusb</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CCCUSBusb</refname>
          <refpurpose>Provide access to a connected CC-USB device.</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <programlisting>
        <synopsis>
            class <ooclass><classname>CCCUSBusb</classname></ooclass> : public <ooclass><classname>CCCUSB</classname></ooclass> {
            
           <constructorsynopsis>
             <methodname>CCCUSBusb</methodname>
              <methodparam>
                <type>struct usb_device*</type><parameter>UsbDevice</parameter>
              </methodparam>
             </constructorsynopsis>
            
            <methodsynopsis>
              <type>void</type>
              <methodname>writeActionRegister</methodname>
              <methodparam>
                <type>uint16_t</type> <parameter>value</parameter>
              </methodparam>
            </methodsynopsis>

            <methodsynopsis>
                <type>int</type> <methodname>executeList</methodname>
                <methodparam>
                    <type>CCCUSBReadoutList&amp;</type> <parameter>list</parameter>
                </methodparam>
                <methodparam>
                    <type>void*</type><parameter>pReadBuffer</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t</type><parameter>readBufferSize</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t*</type><parameter>bytesRead</parameter>
                </methodparam>
            </methodsynopsis>

            <methodsynopsis>
                <type>int</type> <methodname>loadList</methodname>
                <methodparam>
                    <type>uint8_t</type><parameter>listNumber</parameter>
                </methodparam>
                <methodparam>
                    <type>CCCUSBReadoutList&amp;</type><parameter>list</parameter>
                </methodparam>
            </methodsynopsis>

            <methodsynopsis>
                <type>int</type> <methodname>usbRead</methodname>
                <methodparam>
                    <type>void*</type> <parameter>data</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t</type> <parameter>bufferSize</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t*</type><parameter> transferCount</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>timeout</parameter>
                    <initializer> 2000</initializer>
                </methodparam>
            </methodsynopsis>

            <methodsynopsis>
                <type>void</type> <methodname>setDefaultTimeout</methodname>
                <methodparam>
                    <type>int</type> <parameter>ms</parameter>
                </methodparam>
            </methodsynopsis>
          };
       </synopsis>
        </programlisting>   
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
          This class is the low level support for the Wiener/JTEC CCUSB module.
          the CCUSB is a USB CAMAC controller.  To use this class you must first locate
          a module by invoking enumerate.  enumerate  returns a vector of
          usb_device*s.   One of those can be used to instantiate the CCCUSBusb 
          object which can the ben operated on.
          </para>
          <para>
          Most all of the functionality is implemented in te base class CCCUSB. 
          The methods defined in this class are the minimum needed to be implemented
          in order to attach to a locally connected usb device (i.e. the usb device
          is directly connected to the computer).
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <para>
            In the functions listed below, any function that returns an <type>int</type>
            returns <literal>0</literal> on success, <literal>-1</literal> if
            the write operation to the device failed or <literal>-2</literal>
            if the read operation failed.  Negative values result in the
            <varname>errno</varname> variable set to the actual reason for the
            failure.
          </para>
            <variablelist>
                <varlistentry>
                    <term><constructorsynopsis>
                    <methodname>CCCUSBusb</methodname>
                    <methodparam>
                      <type>struct usb_device*</type><parameter>ccUsbDevice</parameter>
                    </methodparam>
                     </constructorsynopsis></term>
                    <listitem>
                        <para>
                            Constructs a <classname>CCCUSB</classname> object.
                            The resulting object can be used to communicate
                            with the CC-USB represented by the
                            <parameter>ccUsbDevice</parameter> object.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                        <type>void</type>
                        <methodname>writeActionRegister</methodname>
                        <methodparam>
                          <type>uint16_t</type> <parameter>value</parameter>
                        </methodparam>
                      </methodsynopsis></term>
                    <listitem>
                        <para>
                            Writes the CCUSB's action register. The class also
                            supplies symoblic definitions for bits in the action
                            register.  See the Action register section of 
                            PUBLIC VARIABLES, TYPES and CONSTANTS below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>executeList</methodname>
                            <methodparam>
                                <type>CCCUSBReadoutList&amp;</type> <parameter>list</parameter>
                            </methodparam>
                            <methodparam>
                                <type>void*</type><parameter>pReadBuffer</parameter>
                            </methodparam>
                            <methodparam>
                                <type>size_t</type><parameter>readBufferSize</parameter>
                            </methodparam>
                            <methodparam>
                                <type>size_t*</type><parameter>bytesRead</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a CAMAC list operation in immediate mode.
                            In order to do this data taking mode must not
                            be on.   The <parameter>list</parameter> is built up
                            by constructing a <classname>CCCUSBReadoutList</classname>
                            (see <xref linkend='ccusb3-CCCUSBReadoutList' />)
                            object and using its methods to add the appropriate
                            set of instructions to the list.
                        </para>
                        <para>
                            <parameter>pReadBuffer</parameter> is a pointer to
                            a buffer you have prepared to receive the results
                            of the read operations in the list.  This buffer
                            has <parameter>readBufferSize</parameter> bytes
                            of data.  On successful return,
                            <parameter>bytesRead</parameter> will contain the
                            actual number of bytes transferred into your buffer.
                            On failure (return value other than <literal>0</literal>),
                            the value of <parameter>bytesRead</parameter> is not
                            well defined.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                           <type>int</type> <methodname>loadList</methodname>
                           <methodparam>
                               <type>uint8_t</type><parameter>listNumber</parameter>
                           </methodparam>
                           <methodparam>
                               <type>CCCUSBReadoutList&amp;</type><parameter>list</parameter>
                           </methodparam>
                       </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Loads a list into the CC-USB. The <parameter>listNumber</parameter>
                            must be 0 for the event list and 1 for the scaler list.
                            If it is any value other than this, the function
                            will return <literal>-4</literal>.
                            <parameter>list</parameter>   is the
                            <classname>CCCUSBReadoutList</classname> to load.
                            See <xref linkend='ccusb3-CCCUSBReadoutList' /> for
                            information about this parameter and how to build it.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>usbRead</methodname>
                            <methodparam>
                                <type>void*</type> <parameter>data</parameter>
                            </methodparam>
                            <methodparam>
                                <type>size_t</type> <parameter>bufferSize</parameter>
                            </methodparam>
                            <methodparam>
                                <type>size_t*</type><parameter> transferCount</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>timeout</parameter>
                                <initializer>2000</initializer>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Pefroms a bulk read on the data transfer endpoint
                            of the CC-USB.  Normally this only needs to be called
                            by the CCUSBReadout framework when in data taking mode.
                            <parameter>data</parameter> is a buffer
                            into which data read should be transferred.
                            <parameter>bufferSize</parameter> is the number
                            of bytes that can be stored in <parameter>buffer</parameter>
                            <parameter>transferCount</parameter> points to a
                            buffer that will contain the number of bytes actually
                            transferred to the buffer. <parameter>timeout</parameter>
                            is the number of milliseconds to wait for the transfer
                            to complete before ending with a timeout condition.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>setDefaultTimeout</methodname>
                            <methodparam>
                                <type>int</type> <parameter>ms</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Most of the immediate operations require a write to the
                            CC-USB followed by a read to get status and/or data.
                            This function allows you to override the default
                            timeout for the read. <parameter>ms</parameter> is
                            the number of milliseconds in the new timeout.
                            Normally you will not need to call this.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>  
       </refsect1>
        <refsect1>
            <title>SEE ALSO</title>
            <para>
                <xref linkend='ccusb3-CCCUSBReadoutList' />
                <xref linkend='ccusb3-CCCUSB' />
            </para>
        </refsect1>
     </refentry>
	 <refentry id="ccusb3-CCCUSBRemote">
       <refmeta>
          <refentrytitle>CCCUSBRemote</refentrytitle>
          <manvolnum>3ccusb</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CCCUSBRemote</refname>
          <refpurpose>Provide remote access to a CC-USB device through CCUSBReadout's slow-controls server.</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <programlisting>
        <synopsis>
            class <ooclass><classname>CCCUSBRemote</classname></ooclass> : public <ooclass><classname>CCCUSB</classname></ooclass> {
            
           <constructorsynopsis>
             <methodname>CCCUSBRemote</methodname>
              <methodparam>
                <type>std::string</type><parameter>moduleName</parameter>
              </methodparam>
              <methodparam>
                <type>std::string</type><parameter>host</parameter>
              </methodparam>
              <methodparam>
                <type>unsigned int</type><parameter>port</parameter>
              </methodparam>
             </constructorsynopsis>
            
            <methodsynopsis>
              <type>void</type>
              <methodname>writeActionRegister</methodname>
              <methodparam>
                <type>uint16_t</type> <parameter>value</parameter>
              </methodparam>
            </methodsynopsis>

            <methodsynopsis>
                <type>int</type> <methodname>executeList</methodname>
                <methodparam>
                    <type>CCCUSBReadoutList&amp;</type> <parameter>list</parameter>
                </methodparam>
                <methodparam>
                    <type>void*</type><parameter>pReadBuffer</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t</type><parameter>readBufferSize</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t*</type><parameter>bytesRead</parameter>
                </methodparam>
            </methodsynopsis>

            <methodsynopsis>
                <type>int</type> <methodname>loadList</methodname>
                <methodparam>
                    <type>uint8_t</type><parameter>listNumber</parameter>
                </methodparam>
                <methodparam>
                    <type>CCCUSBReadoutList&amp;</type><parameter>list</parameter>
                </methodparam>
            </methodsynopsis>

            <methodsynopsis>
                <type>int</type> <methodname>usbRead</methodname>
                <methodparam>
                    <type>void*</type> <parameter>data</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t</type> <parameter>bufferSize</parameter>
                </methodparam>
                <methodparam>
                    <type>size_t*</type><parameter> transferCount</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>timeout</parameter>
                    <initializer> 2000</initializer>
                </methodparam>
            </methodsynopsis>

            <methodsynopsis>
                <type>std::string</type> <methodname>getHost</methodname>
                <void/>
            </methodsynopsis>

            <methodsynopsis>
                <type>unsigned int</type> <methodname>getPort</methodname>
            <void/>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>reconnect</methodname>
                <void/>
            </methodsynopsis>


            <methodsynopsis>
                <type>void</type> <methodname>connect</methodname>
            <void/>
            </methodsynopsis>

            <methodsynopsis>
                <type>void</type> <methodname>disconnect</methodname>
                <void/>
            </methodsynopsis>

            <methodsynopsis>
                <type>std::string</type> <methodname>marshallList</methodname>
                <methodparam>
                  <type>CCCUSBReadoutList&amp;</type> <parameter>list</parameter>
                </methodparam>
            </methodsynopsis>

            <methodsynopsis>
                <type>size_t</type> <methodname>marshallOutputData</methodname>
                <methodparam>
                  <type>void*</type> <parameter>pOutputBuffer</parameter>
                </methodparam>
                <methodparam>
                  <type>const char*</type> <parameter>reply</parameter>
                </methodparam>
                <methodparam>
                  <type>size_t</type> <parameter>maxOutputSize</parameter>
                </methodparam>
            </methodsynopsis>
          };
       </synopsis>
        </programlisting>   
       </refsynopsisdiv>
       <refsect1>
         <title>DESCRIPTION</title>
         <para>
           This class provides remote access to the CC-USB through the
           CCUSBModule support in the tcl server.
           An external program can link to libCCUSB, instantiate
           this class and pretty much have its way with the CC-USB
           as if it owned it.  
         </para>
         <para>Restrictions:</para>
         <itemizedlist>
           <listitem>
             <para>
               lists cannot be downloaded (only immediate lists can be run).
             </para>
           </listitem>
           <listitem>
             <para> 
               the action register is not accessible.
             </para>
           </listitem>
           <listitem>
             <para> 
               The IRQ Mask cannot be written as that abomination requires 
               action register operations
             </para>
           </listitem>
           <listitem>
             <para> 
               while internal registers can be manipulated be aware that
               This may cause an active readout to have undefined results.
               Registers you write may be overwritten by Readout's startup 
               code.
             </para>
           </listitem>
         </itemizedlist>
       </refsect1>

        <refsect1>
          <title>
         METHODS
          </title>
            <variablelist>
                <varlistentry>
                    <term><constructorsynopsis>
                    <methodname>CCCUSBRemote</methodname>
                    <methodparam>
                      <type>std::string</type><parameter>moduleName</parameter>
                    </methodparam>
                    <methodparam>
                      <type>std::string</type><parameter>host</parameter>
                    </methodparam>
                    <methodparam>
                      <type>unsigned int</type><parameter>port</parameter>
                    </methodparam>
                     </constructorsynopsis></term>
                    <listitem>
                        <para>
                            Constructs a <classname>CCCUSBRemote</classname> object.
                            The resulting object can be used to communicate with
                            a CC-USB controlled by a CCUSBReadout program if it has
                            a ccusb module loaded into the slow-controls server named
                            <parameter>moduleName</parameter>. A CException is thrown
                            if the connection with the slow-controls server at <parameter>host</parameter> and 
                            <parameter>port</parameter> is unsuccessful.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                        <type>void</type>
                        <methodname>writeActionRegister</methodname>
                        <methodparam>
                          <type>uint16_t</type> <parameter>value</parameter>
                        </methodparam>
                      </methodsynopsis></term>
                    <listitem>
                        <para>
                            The writeAction register method is not fully implemented in the CCCUSBRemote.
                            It maintains an implementation that does nothing more than print a message
                            to the screen stating that it does nothing.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>executeList</methodname>
                            <methodparam>
                                <type>CCCUSBReadoutList&amp;</type> <parameter>list</parameter>
                            </methodparam>
                            <methodparam>
                                <type>void*</type><parameter>pReadBuffer</parameter>
                            </methodparam>
                            <methodparam>
                                <type>size_t</type><parameter>readBufferSize</parameter>
                            </methodparam>
                            <methodparam>
                                <type>size_t*</type><parameter>bytesRead</parameter>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a CAMAC list operation in immediate mode.
                            In order to do this, data taking mode must not
                            be on.   The <parameter>list</parameter> is built up
                            by constructing a <classname>CCCUSBReadoutList</classname>
                            (see <xref linkend='ccusb3-CCCUSBReadoutList' />)
                            object and using its methods to add the appropriate
                            set of instructions to the list.
                        </para>
                        <para>
                            <parameter>pReadBuffer</parameter> is a pointer to
                            a buffer you have prepared to receive the results
                            of the read operations in the list.  This buffer
                            has <parameter>readBufferSize</parameter> bytes
                            of data.  On successful return,
                            <parameter>bytesRead</parameter> will contain the
                            actual number of bytes transferred into your buffer.
                            On failure (return value other than <literal>0</literal>),
                            the value of <parameter>bytesRead</parameter> is not
                            well defined.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                           <type>int</type> <methodname>loadList</methodname>
                           <methodparam>
                               <type>uint8_t</type><parameter>listNumber</parameter>
                           </methodparam>
                           <methodparam>
                               <type>CCCUSBReadoutList&amp;</type><parameter>list</parameter>
                           </methodparam>
                       </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The loadList method is not fully supported in the CCCUSBRemote 
                            class. Instead, it is just a method that prints to the terminal
                            that it is not supported. 
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>usbRead</methodname>
                            <methodparam>
                                <type>void*</type> <parameter>data</parameter>
                            </methodparam>
                            <methodparam>
                                <type>size_t</type> <parameter>bufferSize</parameter>
                            </methodparam>
                            <methodparam>
                                <type>size_t*</type><parameter> transferCount</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>timeout</parameter>
                                <initializer>2000</initializer>
                            </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Like the loadList and writeActionRegister methods, this is not
                            fully implemented. It only prints a message to the terminal to
                            indicate that it is not implemented.
                        </para>
                    </listitem>
                </varlistentry>


                <varlistentry>
                    <term>
                      <methodsynopsis>
                         <type>void</type> <methodname>reconnect</methodname>
                         <void/>
                       </methodsynopsis>
                    </term>
                    <listitem>
                      <para>
                        Forcibly disconnects from the slow controls server and connects using the
                        host and port provided at construction. It is essentially just a call to
                        disconnect followed by a call to connect.
                      </para>
                    </listitem>
                </varlistentry>

                <varlistentry>
                    <term>
                      <methodsynopsis>
                         <type>void</type> <methodname>connect</methodname>
                     <void/>
                       </methodsynopsis>
                    </term>
                    <listitem>
                      <para>
                        Connects to the server identified by the 
                        host and port parameters provided at construction. It also does create
                        a new TCL interpreter instance for communicating. A CException can be
                        thrown if the connection fails.
                      </para>
                    </listitem>
                </varlistentry>

                <varlistentry>
                    <term>
                      <methodsynopsis>
                         <type>void</type> <methodname>disconnect</methodname>
                         <void/>
                       </methodsynopsis>
                    </term>
                    <listitem>
                      <para>
                        Forcibly disconnects from the server. The current TCL interpreter owned by
                        by the class instance is also deleted.
                      </para>
                    </listitem>
                </varlistentry>

                <varlistentry>
                    <term>
                      <methodsynopsis>
                         <type>std::string</type> <methodname>marshallList</methodname>
                         <methodparam>
                            <type>CCCUSBReadoutList&amp;</type> <parameter>list</parameter>
                         </methodparam>
                       </methodsynopsis>
                    </term>
                    <listitem>
                      <para>
                        This converts a CCCUSBReadoutList into a string format equivalent to a list. The format
                        produced is actually a list of lists. The first list element contains the max size of 
                        the read buffer and the second element is the list of commands.                     
                      </para>
                    </listitem>
                </varlistentry>

                <varlistentry>
                    <term>
                      <methodsynopsis>
                         <type>size_t</type> <methodname>marshallOutputData</methodname>
                         <methodparam>
                            <type>void*</type> <parameter>pBuffer</parameter>
                         </methodparam>
                         <methodparam>
                            <type>const char*</type> <parameter>reply</parameter>
                         </methodparam>
                       <methodparam>
                         <type>size_t</type> <parameter>maxOutputSize</parameter>
                       </methodparam>
                     </methodsynopsis>
                    </term>
                    <listitem>
                      <para>
                        This transfers the <parameter>reply</parameter> from the server
                        into the user's buffer, i.e. <parameter>pBuffer</parameter>. The 
                        maximum size of the user's buffer is provided by <parameter>maxOutputSize</parameter>.
                        The value returned from the method is the number of bytes that were actually
                        transferred into the user's buffer.                        
                      </para>
                    </listitem>
                </varlistentry>
            </variablelist>  
       </refsect1>
        <refsect1>
            <title>SEE ALSO</title>
            <para>
                <xref linkend='ccusb3-CCCUSBReadoutList' />
                <xref linkend='ccusb3-CCCUSB' />
            </para>
        </refsect1>
     </refentry>
         
	 <refentry id="ccusb3-CCCUSBReadoutList">
       <refmeta>
          <refentrytitle>CCCUSBReadoutList</refentrytitle>
          <manvolnum>3ccusb</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CCCUSBReadoutList</refname>
          <refpurpose>Create lists of CAMAC commands for CC-USB controllers.</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>
            class <ooclass><classname>CCCUSBReadoutList</classname></ooclass> {          
           <constructorsynopsis>
          <methodname> CCCUSBReadoutList</methodname>
          <void />
           </constructorsynopsis>
           <constructorsynopsis>
            <methodname> CCCUSBReadoutList</methodname>
            <methodparam>
                <modifier>const</modifier> <type>std::vector&lt;uint16_t&gt;&amp;</type>
                <parameter>list</parameter>
            </methodparam>
           </constructorsynopsis>
           <constructorsynopsis>
            <methodname> CCCUSBReadoutList</methodname>
            <methodparam>
                <modifier>const</modifier> <type>CCCUSBReadoutList&amp;</type>
                <parameter>rhs</parameter>
            </methodparam>
           </constructorsynopsis>
            <methodsynopsis>
                <type>std::vector&lt;uint16_t&gt;</type>
                <methodname>get</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>size_t</type> <methodname>size</methodname>
                <void /><modifier>const</modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>clear</methodname>
                <void />
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type><methodname>addWrite16</methodname>
                <methodparam>
                    <type>int</type><parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t</type> <parameter>data</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addWrite24</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint32_t</type> <parameter>data</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addRead16</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type><parameter>lamWait</parameter>
                    <initializer>false</initializer>
                </methodparam>
            </methodsynopsis>           
            <methodsynopsis>
                <type>void</type> <methodname>addRead24</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type><parameter>lamWait</parameter>
                    <initializer>false</initializer>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addControl</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addQStop</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t</type> <parameter>max</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type><parameter>lamWait</parameter>
                    <initializer>false</initializer>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addQStop24</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t</type> <parameter>max</parameter>
                </methodparam>

                <methodparam>
                    <type>bool</type><parameter>lamWait</parameter>
                    <initializer>false</initializer>
                </methodparam>
            </methodsynopsis>
            <methodsynopsis>
                <type>void</type> <methodname>addQScan</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>uint16_t</type> <parameter>max</parameter>
                </methodparam>                
                <methodparam>
                    <type>bool</type><parameter>lamWait</parameter>
                    <initializer>false</initializer>
                </methodparam>
            </methodsynopsis>

            <methodsynopsis>
                <type>void</type> <methodname>addRepeat</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type><parameter>lamWait</parameter>
                    <initializer>false</initializer>
                </methodparam>
            </methodsynopsis>

            <methodsynopsis>
                <type>void</type> <methodname>addAddressPatternRead16</methodname>
                <methodparam>
                    <type>int</type> <parameter>n</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>a</parameter>
                </methodparam>
                <methodparam>
                    <type>int</type> <parameter>f</parameter>
                </methodparam>
                <methodparam>
                    <type>bool</type><parameter>lamWait</parameter>
                    <initializer>false</initializer>
                </methodparam>
            </methodsynopsis>

            <methodsynopsis>
                <type>void</type> <methodname>addMarker</methodname>
                <methodparam>
                    <type>uint16_t</type> <parameter>value</parameter>
                </methodparam>
           </methodsynopsis>
           };
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            <classname>CCCUSBReadoutList</classname> provides a class whose instances can
            build up lists (stacks) of CAMAC operations that can either be
            submitted to a CC-USB for direct execution via <methodname>CCCUSB::executeList</methodname>,
            or loaded as an event or scaler stack via <methodname>CCCUSB::loadStack</methodname>.
          </para>
       </refsect1>
       <refsect1>
          <title>METHODS</title>
            <variablelist>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                       <methodname>CCCUSBReadoutList</methodname>
                       <void />
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Constructs a new readout list.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                       <methodname>CCCUSBReadoutList</methodname>
                       <methodparam>
                          <modifier>const</modifier> <type>std::vector&lt;uint16_t&gt;&amp;</type>
                          <parameter>list</parameter>
                        </methodparam> 
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Constructs a new readout list from a raw list of stack commands. 
                            The contents of the list passed into the constructor will be copied into
                            the list managed by this object. All subsequent commands will be appended
                            to the new list.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                         <methodname>CCCUSBReadoutList</methodname>
                         <methodparam>
                             <modifier>const</modifier> <type>CCCUSBReadoutList&amp;</type>
                             <parameter>rhs</parameter>
                         </methodparam>
                        </constructorsynopsis>
                        </term>
                    <listitem>
                        <para>
                            Constructs a readout list that will be a duplicate
                            of the readout list in <parameter>rhs</parameter>
                            (Copy construction).
                        </para>
                        </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>std::vector&lt;uint16_t&gt;</type>
                             <methodname>get</methodname>
                             <void /><modifier>const</modifier>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns a <type>std::list&lt;uint16_t&gt;</type> where
                            each element of the list is a stack line that has
                            been built up so far.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>size_t</type> <methodname>size</methodname>
                             <void /><modifier>const</modifier>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Returns the number of <type>uint16_t</type>
                            stack lines built so far.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>clear</methodname>
                             <void />
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Clears the stack.  Once this is performed, the object
                            represents an empty stack.
                            </para>
                        </listitem>
                </varlistentry>     
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type><methodname>addWrite16</methodname>
                             <methodparam>
                                 <type>int</type><parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>uint16_t</type> <parameter>data</parameter>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Adds a 16 bit CAMAC write opearation to the list.
                            <parameter>n,a,f</parameter> specify the
                            slot, subaddress and function code respectively.
                            The <parameter>data</parameter> parameter is transferred
                            to the device when the command is executed.
                            Note that this method does not perform any CAMAC operations.
                            The specified operation is simply encoded as stack lines
                            in the object.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addWrite24</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>uint32_t</type> <parameter>data</parameter>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>addWrite16</methodname> however
                            the least significant 24 bits of <parameter>data</parameter>
                            will be written when this stack line is executed.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addRead16</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>bool</type><parameter>lamWait</parameter>
                                 <initializer>false</initializer>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            A 16 bit read operation whose slot, subaddress
                            and function code are specified by <parameter>n,a,f</parameter>
                            is encoded as a stack line and added to the list.
                            If the stack line is executed in immediate mode
                            (via <methodname>CCCUSB::executeList</methodname>),
                            the data read will be put in the input buffer passed
                            to that method.  IF the stack line loaded as a scaler
                            or event stack asnd executed in response to the appropriate
                            trigger condition, the data are put in the event buffer.
                        </para>
                        <para>
                            If the <parameter>lamWait</parameter>  parameter is
                            <literal>true</literal> the stack will stall until
                            either the lam timeout period is reached or the
                            slot the operation is directed to signals its LAM.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addRead24</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>bool</type><parameter>lamWait</parameter>
                                 <initializer>false</initializer>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>addRead16</methodname>, however a
                            <type>uint32_t</type>
                            is put in the buffer (event or buffer given to
                            <methodname>CCCUSB::executeStack</methodname> depending
                            on why the stack is being executed).  The format
                            of the uint32_t is shown in the figure just at the
                            end of chapter 4 of the CC-USB manual:
                            The bottom 24 bits are the data transferred from the
                            module.  Bit 24 is set if there was a Q response
                            and bit 25 is set if there was an X response
                            (bits are numbered from 0 least significant bit
                            is bit 0).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addControl</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Adds a non data transfer operation to the stack.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addQStop</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                            <methodparam>
                                <type>uint16_t</type> <parameter>max</parameter>
                            </methodparam>
                             <methodparam>
                                 <type>bool</type><parameter>lamWait</parameter>
                                 <initializer>false</initializer>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Adds a Q-stop block transfer to the stack.  Q-stop
                            operations perform the same <parameter>n,a,f</parameter>
                            read operation until either the module does not
                            return a Q response or until the <parameter>max</parameter>
                            number of transfers specified have been performed.
                            The <parameter>lamWait</parameter> parameter allows
                            you to wait for a LAM from the targe module before
                            doing the transfer.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addQStop24</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                            <methodparam>
                                <type>uint16_t</type> <parameter>max</parameter>
                            </methodparam>
                             <methodparam>
                                 <type>bool</type><parameter>lamWait</parameter>
                                 <initializer>false</initializer>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Same as <methodname>addQStop</methodname> except
                            that 24 bits of data are transferred on each
                            operation.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addQScan</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                            <methodparam>
                                <type>uint16_t</type> <parameter>max</parameter>
                            </methodparam>
                             <methodparam>
                                 <type>bool</type><parameter>lamWait</parameter>
                                 <initializer>false</initializer>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a Q-scan (sometimes called an address
                            scan) operation.  <parameter>n,a,f</parameter>
                            specify a starting slot, subaddress and function code.
                            After each operation a is incremented.   The CC-USB
                            documentation does not make it clear if this is a
                            full Q-Scan (ACA) operation as defined by the ESONE
                            block transfer specification.  If this operation is
                            a full address scan, then after each operation, the
                            subaddress is incremented.  If A was 15 or a Q=0
                            response occured, the
                            subaddress should be set to 0 and the slot incremented.
                            This continues until either <parameter>max</parameter>
                            transfers have occured or both Q and X are zero.
                        </para>
                        <para>
                            The documentation only describes the subadress as
                            being incremented so that may be all you can count on
                            for this opertaion.  It also does not provide a statement
                            about what happens when Q=0 or X=0.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                         <methodsynopsis>
                             <type>void</type> <methodname>addRepeat</methodname>
                             <methodparam>
                                 <type>int</type> <parameter>n</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>a</parameter>
                             </methodparam>
                             <methodparam>
                                 <type>int</type> <parameter>f</parameter>
                             </methodparam>
                            <methodparam>
                                <type>uint16_t</type> <parameter>max</parameter>
                            </methodparam>                             
                             <methodparam>
                                 <type>bool</type><parameter>lamWait</parameter>
                                 <initializer>false</initializer>
                             </methodparam>
                         </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Performs a block repeat operation.  The specified
                            CAMAC operation is performed <parameter>max</parameter>
                            times regardless of the X/Q responses.
                        </para>
                    </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term>
                        <methodsynopsis>
                          <type>void</type>
                          <methodname>addAddressPatternRead16</methodname>
                          <methodparam>
                            <type>int</type> <parameter>n</parameter>
                          </methodparam>
                          <methodparam>
                            <type>int</type> <parameter>a</parameter>
                          </methodparam>
                          <methodparam>
                            <type>int</type> <parameter>f</parameter>
                          </methodparam>
                          <methodparam>
                            <type>bool</type><parameter>lamWait</parameter>
                            <initializer>false</initializer>
                          </methodparam>
                        </methodsynopsis>
                      </term>
                      <listitem>
                        <para>
                          Adds an address pattern read to the stack. The data
                          read by the provided NAF is interpreted as a list of 
                          A values to use when calling the NAF of the
                          subsequent command in the stack. For each nonzero bit
                          in the data returned, the subsequent command's N and
                          F values are used with each of the present A values
                          to form an NAF command.  In other words, if the NAF
                          of this read returns a value of 0x7 and the next
                          command in the stack is N(4)AF(0), then three
                          commands will be executed in succession:
                          N(4)A(0)F(0), N(4)A(1)F(0), and N(4)A(2)F(0). Note
                          that this is a setup command for the next NAF
                          operation that is added to the stack. If the lamWait
                          is true, the read will wait until a LAM is identified
                          or a timeout occurs. 
                        </para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term>
                        <methodsynopsis>
                          <type>void</type> <methodname>addMarker</methodname>
                             <methodparam>
                                 <type>uint16_t</type> <parameter>value</parameter>
                             </methodparam>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The literal word <parameter>value</parameter> is
                            written to the output buffer.
                        </para>
                    </listitem>
                </varlistentry>             

            </variablelist>
       </refsect1>
        <refsect1>
           <title>SEE ALSO</title>
           <para>
            <xref linkend='ccusb3-CCCUSB' />
            </para>
        </refsect1>
    </refentry>
         
    <refentry id="ccusb3-CConfigurableObject">
       <refmeta>
          <refentrytitle id="ccusb3-CConfigurableObject-title">CConfigurableObject</refentrytitle>
          <manvolnum>3ccusb</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CConfigurableObject</refname>
          <refpurpose>base class for devices that have a configuration</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>
            class <ooclass><classname>CConfigurableObject</classname></ooclass> {
           <constructorsynopsis>
          <methodname>CConfigurableObject</methodname>
          <methodparam>
            <type>std::string</type> <parameter>name</parameter>    
          </methodparam>
        </constructorsynopsis>
        <methodsynopsis>
            <type>std::string </type> <methodname>getName</methodname>
            <void /><modifier> const</modifier>
            </methodsynopsis>
        <methodsynopsis>
            <type>std::string</type> <methodname>cget</methodname>
            <methodparam>
                <type>std::string</type>  <parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>ConfigurationArray</type> <methodname>cget</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>int</type> <methodname>getIntegerParameter</methodname>
            <methodparam>
                <type>std::string</type><parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>unsigned int</type> <methodname> getUnsignedParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
                </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>bool</type> <methodname>getBoolParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>double</type> <methodname>getFloatParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>std::vector&lt;int&gt;</type><methodname>getIntegerList</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addParameter</methodname>
            <methodparam>
                <type>std::string</type><parameter> name</parameter>
            </methodparam>
            <methodparam>
                <type>typeChecker</type> <parameter>checker</parameter>
            </methodparam>
            <methodparam>
                <type>void*</type> <parameter>arg</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>defaultValue</parameter>
                <initializer>std::string("")</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>clearConfiguration</methodname>
            <void />
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>configure</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>value</parameter>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addIntegerParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>defaultVal</parameter>
                <initializer>0</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addIntegerParameter</methodname>
            <methodparam>
                <type>std::string</type>  <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>low</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>high</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>defaultVal</parameter>
                <initializer>0</initializer>
                </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addBooleanParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>bool</type> <parameter>defaultVal</parameter>
                <initializer> true</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type><methodname>addEnumParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <modifier>const</modifier> <type>char**</type>
                <parameter>pValues</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>defaultValue</parameter>
                <initializer>std::string("")</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type><methodname>addBoolListParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>unsigned</type><parameter>size</parameter>
            </methodparam>
            <methodparam>
                <type>bool</type>   <parameter> defaultVal</parameter>
                <initializer>true</initializer>
            </methodparam>
            </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addBoolListParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>unsigned</type> <parameter>minLength</parameter>
            </methodparam>
            <methodparam>
                <type>unsigned</type> <parameter>maxLength</parameter>
            </methodparam>
            <methodparam>
                <type>bool</type> <parameter>defaultVal</parameter>
                <initializer>true</initializer>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter> defaultSize</parameter>
                <initializer>-1</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addIntListParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>unsigned</type> <parameter>size</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>defaultVal</parameter>
                <initializer>0</initializer>
            </methodparam>
            </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addIntListParameter</methodname>
            <methodparam>
                <type>std::string</type>  <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>unsigned</type> <parameter>minlength</parameter>
            </methodparam>
            <methodparam>
                <type>unsigned</type> <parameter>maxLength</parameter>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>defaultVal</parameter>
                <initializer>0</initializer>
            </methodparam>
            <methodparam>
                <type>int</type> <parameter>defaultSize</parameter>
                <initializer>-1</initializer>
            </methodparam>
            </methodsynopsis>
        <methodsynopsis>
            <type>void</type><methodname>addBooleanParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>bool</type> <parameter>defaultVal</parameter>
                <initializer>true</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addEnumParameter</methodname>
            <methodparam>
                <type>std::string</type> <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <modifier>const</modifier> <type>char**</type>
                <parameter>pValues</parameter>
            </methodparam>
            <methodparam>
                <type>std::string</type> <parameter>defaultValue</parameter>
                <initializer>std::string("")</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
            <type>void</type> <methodname>addBoolListParameter</methodname>
            <methodparam>
                <type>std::string</type>  <parameter>name</parameter>
            </methodparam>
            <methodparam>
                <type>unsigned</type> <parameter>size</parameter>
            </methodparam>
            <methodparam>
                <type>bool</type> <parameter>defaultVal</parameter>
                <initializer>true</initializer>
            </methodparam>
        </methodsynopsis>
        <methodsynopsis>
         <type> void</type> <methodname>addBoolListParameter</methodname>
         <methodparam>
           <type>std::string</type> <parameter>name</parameter>
         </methodparam>
         <methodparam>
           <type>unsigned</type> <parameter>minLength</parameter>
         </methodparam>
         <methodparam>
           <type>unsigned</type> <parameter>maxLength</parameter>
         </methodparam>
         <methodparam>
            <type>bool</type> <parameter>defaultVal</parameter> 
            <initializer>true</initializer>
         </methodparam>
         <methodparam>
            <type>int</type> <parameter>defaultSize</parameter>
            <initializer>-1</initializer>
         </methodparam>
       </methodsynopsis>
       <methodsynopsis>
         <type>void</type> <methodname>addIntListParameter</methodname>
         <methodparam>
            <type>std::string</type> <parameter>name</parameter>
         </methodparam>
         <methodparam>
            <type>unsigned</type> <parameter>size</parameter>
         </methodparam>
         <methodparam>
            <type>int</type> <parameter>defaultVal</parameter>
            <initializer>0</initializer>
         </methodparam>
      </methodsynopsis>
      <methodsynopsis>
         <type>void</type> <methodname>addIntListParameter</methodname>
         <methodparam>
            <type>std::string</type> <parameter>name</parameter>
         </methodparam>
         <methodparam>
            <type>unsigned</type> <parameter>minlength</parameter>
         </methodparam>
         <methodparam>
            <type>unsigned</type> <parameter>maxLength</parameter>
         </methodparam>
         <methodparam>
            <type>int</type> <parameter>defaultVal</parameter>
            <initializer>0</initializer>
         </methodparam>
         <methodparam>
            <type>int</type> <parameter>defaultSize</parameter> 
            <initializer>-1</initializer>
         </methodparam>
      </methodsynopsis>
      <methodsynopsis>
        <type>void</type> <methodname>addStringListParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>size</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>defaultVal</parameter>
            <initializer>""</initializer>
        </methodparam>
      </methodsynopsis>
      <methodsynopsis>
        <type>void</type> <methodname>addStringListParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>minLength</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>maxLength</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>defaultVal</parameter>
            <initializer>""</initializer>
        </methodparam>
        <methodparam>
            <type>int</type> <parameter>defaultLength</parameter>
            <initializer>-1</initializer>
        </methodparam>
      </methodsynopsis>
      <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isInteger</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type><parameter>arg</parameter>
        </methodparam>
      </methodsynopsis>
      <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isBool</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
      </methodsynopsis>
      <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isEnum</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isList</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isBoolList</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isIntList</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isStringList</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>isEnumParameter</type>
        <methodname>makeEnumSet</methodname>
        <methodparam>
            <modifier>const</modifier> <type>char**</type><parameter>values</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>strToBool</methodname>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <fieldsynopsis>
        <modifier>typedef</modifier> <type>std::pair&lt;typeChecker, void*&gt;</type>
        <varname>TypeCheckInfo</varname>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>typedef</modifier>
        <type>std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt;</type>
        <varname>ConfigurationArray</varname>
    </fieldsynopsis>
    

      struct  <type>limit</type> {
      <fieldsynopsis>
          <type>bool</type>   <varname>s_checkMe</varname>
      </fieldsynopsis>
      <fieldsynopsis>
          <type>long</type> <varname>s_value</varname>
      </fieldsynopsis>
      <constructorsynopsis>
          <methodname>limit</methodname>
          <void />
      </constructorsynopsis>
      <constructorsynopsis>
          <methodname>limit</methodname>
          <methodparam>
              <type>long</type>    <parameter>value</parameter>
          </methodparam>
      </constructorsynopsis>
    } ;
    <fieldsynopsis>
        <modifier>typedef</modifier>
        <type>std::pair&lt;limit, limit&gt;</type><varname>Limits</varname>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>typedef</modifier>
        <type>std::set&lt;std::string&gt;</type> <varname>isEnumParameter</varname>
    </fieldsynopsis>
    typedef struct <type>_ListSizeConstraint</type> {
        <fieldsynopsis>
            <type>limit</type> <varname>s_atLeast</varname>
        </fieldsynopsis>
        <fieldsynopsis>
            <type>limit</type> <varname>s_atMost</varname>
        </fieldsynopsis>
    } <type>ListSizeConstraint</type>
    typedef struct <type>_isListParameter</type> {
      <fieldsynopsis>
        <type>ListSizeConstraint</type> <varname>s_allowedSize</varname>
      </fieldsynopsis>
      <fieldsynopsis>
        <type>TypeCheckInfo</type> <varname>s_checker</varname>
      </fieldsynopsis>
    } <type>isListParameter</type>;
    <fieldsynopsis>
        <modifier>typedef</modifier>
            <type>void</type><varname>(*ConstraintFreer)(void*)</varname>
    </fieldsynopsis>

     typedef struct <type>_DynamicConstraint</type> { 
      <fieldsynopsis>
        <type>ConstraintFreer</type> <varname>s_Releaser</varname>
      </fieldsynopsis>
      <fieldsynopsis>
        <type>void*</type> <varname>s_pObject</varname>
      </fieldsynopsis>
    } <type>DynamicConstraint</type>, <type>*pDynamicConstraint</type>;
  
    struct  <type>flimit</type> {
      <fieldsynopsis>
        <type>bool</type>   <varname>s_checkMe</varname>
      </fieldsynopsis>
      <fieldsynopsis>
        <type>float</type> <varname>s_value</varname>
      </fieldsynopsis>
      <constructorsynopsis>
        <methodname>flimit</methodname><void />
      </constructorsynopsis>    
      <constructorsynopsis>
        <methodname>flimit</methodname>
        <methodparam>
            <type>float</type> <parameter>value</parameter>
        </methodparam>
      </constructorsynopsis>    
    };
    <fieldsynopsis>
        <modifier>typedef</modifier> <type>std::pair&lt;flimit, flimit&gt;</type>
        <varname>FloatingLimits</varname>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>typedef</modifier> <type>std::vector&lt;isEnumParameter*&gt;</type>
        <varname>EnumCheckers</varname>
    </fieldsynopsis>

};
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            This class is the ultimate base class of the <classname>CReadoutModule</classname>
            object passed to device driver <methodname>onAttach</methodname> methods.
            It manages the configuration database of a configurable object.
          </para>
          <para>
            The interaction of a configurable object or an object that embeds
            configuration via delegation is:
            <orderedlist>
                <listitem>
                    <para>
                        The object defines a configuration that consists of
                        a set of named parameters and initial values.  Each
                        configuration value can have a constraint function
                        attached to it that is called prior to allowing the
                        value to assume a new value.
                    </para>
                    <para>
                        Through these constraint functions parameter values can'
                        be very strongly typed (e.g. not just parameter
                        must be an integer but parameter must be an integer
                        in this range).
                    </para>
                    <para>
                        Pre packaged constraint functions and convenience functions
                        make it easy to set up most types of constraints, however
                        if something special is required client code can implement
                        a special constraint.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        At some point in the lifetime of a configurable object,
                        the object is configured.  This is usually done by creating
                        (the CCUSB framework does this for you) a command or
                        command ensemble that accepts configuration name/value
                        pairs and passes them to the <methodname>configure</methodname>
                        method.  This method will invoke the constraint checker
                        and, if successful, modify the value of the configuration
                        parameter.  If the new value fails the constraint, a
                        <type>std::string</type> exception is thrown and should
                        be caught and reported at some level by the caller.
                    </para>
                    <para>
                        Again for CCUSB device drivers this is transparent.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        Configurable objects can query their configuration.
                        The constraint checkers ensure that each value has
                        the type and range constraints required of that parameter.
                        Semantics, however must be enforced and applied
                        by the object that
                        uses the configuration.
                    </para>
                    <para>
                        It is always possible to get a stringified value for
                        each configuration item (in fact configuration items
                        are stored as strings).  Convenience methods allow
                        for clients to fetch conversions of those strings to
                        a rich set of types.
                    </para>
                    <para>
                        CCUSB device drivers normally fetch and process their
                        configurations when their
                        <methodname>Initialize</methodname>
                        and <methodname>addReadoutList</methodname> methods
                        are invoked.
                    </para>
                </listitem>
            </orderedlist>
          </para>
          <para>
            For the full set of methods see the METHODS section below.  The
            pre-defined constraint checkers additionally make use of
            several data types which are described in
            PUBLIC VARIABLES, TYPES and CONSTANTS further below.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
        <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis>
                   <methodname>CConfigurableObject</methodname>
                   <methodparam>
                     <type>std::string</type> <parameter>name</parameter>    
                   </methodparam>
                 </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs a configurable object.  CCUSB device
                        drivers have this construction performed for them.
                        Configurable objects have names to allow them to be
                        placed in some sort of configuration dictionary by the
                        application. the <parameter>name</parameter>
                        parameter supplies the configuration name.
                    </para>
                    <para>
                        If names are used, it's likely a good thing to ensure
                        that unique names are chose for each configuration
                        namespace the application maintains.  This is not
                        enforced by the constructor, however.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>std::string </type> <methodname>getName</methodname>
                     <void /><modifier> const</modifier>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the name of the configuration. This is the
                        value of the parameter passed to the constructor.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>std::string</type> <methodname>cget</methodname>
                     <methodparam>
                         <type>std::string</type>  <parameter>name</parameter>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns the string value of the configuration parameter
                        <parameter>name</parameter>.  If the parameter was
                        not defined a string exception is thrown.
                    </para>
                    <para>
                        In situations where you don't know the set of configuration
                        parameters that have been defined, see the overloaded
                        <methodname>cget</methodname> method described next.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>CConfigurableObject::ConfigurationArray</type>
                     <methodname>cget</methodname>
                     <void />
                 </methodsynopsis>
                 </term>
                 <listitem>
                    <para>
                        Gets the entire configuration of the module as name
                        value pairs.
                        <type>CConfigurableObject::ConfigurationArray</type> is
                        described fully in PUBLIC VARIABLES, TYPES and CONSTANTS
                        below, however you can think iof it as a vector of
                        <type>std::string</type> pairs of configuration
                        parameter name and value.
                    </para>
                 </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>int</type> <methodname>getIntegerParameter</methodname>
                     <methodparam>
                         <type>std::string</type><parameter>name</parameter>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Invokes <methodname>cget</methodname> on the
                        <parameter>name</parameter> configuration parameter.
                        The resulting string is converted to an integer and
                        returned, if possible.  If the string is not a valid integer,
                        a string exception is thrown.
                    </para>
                    <para>
                        Note that this and other convenience methods for
                        getting parameter values converted to specific data
                        types pass any exceptions from <methodname>cget</methodname>
                        on up to the caller.
                    </para>
                </listitem>
                </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>unsigned int</type> <methodname> getUnsignedParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                         </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Same as <methodname>getIntegerParameter</methodname>,
                        however the conversion to an unsigned value is attempted.
                        This is recommended for e.g. base addresses.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>bool</type> <methodname>getBoolParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Invokes <methodname>cget</methodname> and attempts
                        to convert the resulting string to a <type>bool</type>
                        value which is returned if successful.   A rather
                        rich set of values can be converted to bools.
                    </para>
                    <informaltable>
                        <tgroup cols="2">
                        <colspec colname='string' /> <colspec colname='value' />
                        <thead>
                            <row>
                                <entry>String</entry>
                                <entry>Bool Value</entry>
                            </row>
                        </thead>
                        <tbody>
                            <row>
                                <entry>true</entry><entry>true</entry>
                            </row>
                            <row>
                                <entry>yes</entry><entry>true</entry>
                            </row>
                            <row><entry>1</entry><entry>true</entry></row>
                            <row><entry>on</entry><entry>true</entry></row>
                            <row><entry>enabled</entry><entry>true</entry></row>
                            <row><entry>false</entry><entry>false</entry></row>
                            <row><entry>no</entry><entry>false</entry></row>
                            <row><entry>0</entry><entry>false</entry></row>
                            <row><entry>off</entry><entry>false</entry></row>
                            <row><entry>disabled</entry><entry>false</entry></row>
                        </tbody>
                        </tgroup>
                    </informaltable>
                    <para>
                        Failure to convert to a <type>bool</type> throws
                        a string exception.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>double</type> <methodname>getFloatParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Uses <methodname>cget</methodname> to retrieve the
                        value of the <parameter>name</parameter> configuration
                        parameter.  The string is converted to a
                        <type>float</type> and
                        returned.  If the string is not a valid
                        <type>float</type>, a string exception is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>std::vector&lt;int&gt;</type><methodname>getIntegerList</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Uses the <methodname>cget</methodname> method to
                        obtain the configuration parameter <parameter>name</parameter>.
                        The string is treated as a Tcl list which is composed
                        entirely of integers.  If this assumption is correct,
                        a <type>std::vector</type> of the integers that made
                        up the list is returned.  If the string is either
                        an invalid list or not entirely composed of elements
                        that can be converted to <type>int</type>,
                        a string exception is thrown.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>addParameter</methodname>
                     <methodparam>
                         <type>std::string</type><parameter> name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>typeChecker</type> <parameter>checker</parameter>
                     </methodparam>
                     <methodparam>
                         <type>void*</type> <parameter>arg</parameter>
                     </methodparam>
                     <methodparam>
                         <type>std::string</type> <parameter>defaultValue</parameter>
                         <initializer>std::string("")</initializer>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is the base mechanism for defining a configuration
                        parameter. See the convenience methods below before using
                        this as they may be easier to use.
                    </para>
                    <para>
                        <parameter>name</parameter>  is the name of the parameter
                        being added.  By convention, this starts with the
                        <literal>-</literal> character (like options in Tk).
                        For example a module slot might be defined as a
                        <literal>-slot</literal> configuration parameter.
                    </para>
                    <para>
                        <parameter>checker</parameter> is a pointer to the
                        constraint checking function.  If no constraint checking
                        is required (e.g. the paramter is a pure string), pass
                        <literal>NULL</literal> for this parameter.
                    </para>
                    <para>
                        <parameter>arg</parameter>  is a parameter that is passed
                        without interpretation to the constraint checker.
                        See CONSTRAINT CHECKING below for more about how
                        constraint checkers are defined and called.
                        See also the descriptions of the built in constraint
                        checkers that are static members of this class, documented
                        later in this section.
                    </para>
                    <para>
                        <parameter>defaultValue</parameter> is the initial
                        value supplied to the parameter.  Note that this is
                        <emphasis>not</emphasis> constraint checked.  This is
                        intentional as it allows you to require a parameter
                        setting by providing an invalid initial parameter
                        value.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>clearConfiguration</methodname>
                     <void />
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Clear the configuration.  This removes any parameter
                        definitions as well as their value from the configuration
                        database.  In most cases this function is not necessary.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>configure</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>std::string</type> <parameter>value</parameter>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Attempts to configure a parameter <parameter>name</parameter>
                        should be a configuration parameter name that has been
                        defined by <methodname>addParameter</methodname> or its
                        convenience methods. <parameter>value</parameter>
                        is the new proposed value of the parameter.
                        The constraint checker, if any, is called for that parameter
                        and if it fails a string exception is thrown.  Otherwise,
                        the new parameter value replaces the old one.
                        </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>addIntegerParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter>defaultVal</parameter>
                         <initializer>0</initializer>
                     </methodparam>
                 </methodsynopsis>
                 </term>
                <listitem>
                    <para>
                        Convenience method to add an parameter
                        <parameter>name</parameter>  which is constrained
                        to be an integer parameter that has no range
                        requirements.  The initial value of this parameter
                        will be <parameter>defaultVal</parameter>
                        </para>
                    </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>addIntegerParameter</methodname>
                     <methodparam>
                         <type>std::string</type>  <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter>low</parameter>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter>high</parameter>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter>defaultVal</parameter>
                         <initializer>0</initializer>
                         </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Convenience methos that creates a parameter
                        (<parameter>name</parameter>) that is constrained
                        to be an integer in the range
                        [<parameter>low</parameter>..<parameter>high</parameter>].
                    </para>
                    <para>
                        The initial value of the parameters is set to
                        <parameter>defaultVal</parameter> which is not
                        checked against the limits.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>addBooleanParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>bool</type> <parameter>defaultVal</parameter>
                         <initializer> true</initializer>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a parameter <parameter>name</parameter> to the
                        configuration database which is contrained to be
                        a string that converts to a <type>bool</type>.
                        The initial value of the parameter will be
                        <parameter>defaultVal</parameter>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type><methodname>addEnumParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <modifier>const</modifier> <type>char**</type>
                         <parameter>pValues</parameter>
                     </methodparam>
                     <methodparam>
                         <type>std::string</type> <parameter>defaultValue</parameter>
                         <initializer>std::string("")</initializer>
                     </methodparam>
                 </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a parameter <parameter>name</parameter>   that is
                        constrained to be one of the values pointed to by the
                        <parameter>pValues</parameter> array.
                        The initial value is <parameter>defaultValue</parameter>
                    </para>
                    <para>
                        The <parameter>pValues</parameter> parameter should
                        be a pointer to a null terminated set of character pointers.
                        This sounds much harder than it is:
                        <informalexample>
                            <programlisting>
const char* enumValues[] = {"red", "green", "blue", NULL};
                            </programlisting>
                        </informalexample>
                        In the code fragment above, <varname>enumValues</varname>
                        can be passed in as the <parameter>pValues</parameter>
                        argument and will constrain the values of the configuration
                        parameter to be in the set
                        {<literal>red</literal>, <literal>greeen</literal>, <literal>blue</literal>}.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type><methodname>addBoolListParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>unsigned</type><parameter>size</parameter>
                     </methodparam>
                     <methodparam>
                         <type>bool</type>   <parameter> defaultVal</parameter>
                         <initializer>true</initializer>
                     </methodparam>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a new configuration parameter
                        <parameter>name</parameter> that is constrained to be
                        a valid Tcl list of <type>bool</type> strings of
                        exactly <parameter>size</parameter> elements long.
                    </para>
                    <para>
                        The initial value will be set to <parameter>size</parameter>
                        elements of <parameter>defaultVal</parameter>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>addBoolListParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>unsigned</type> <parameter>minLength</parameter>
                     </methodparam>
                     <methodparam>
                         <type>unsigned</type> <parameter>maxLength</parameter>
                     </methodparam>
                     <methodparam>
                         <type>bool</type> <parameter>defaultVal</parameter>
                         <initializer>true</initializer>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter> defaultSize</parameter>
                         <initializer>-1</initializer>
                     </methodparam>
                 </methodsynopsis>
                 </term>
                <listitem>
                    <para>
                        Same as the previous method, however the
                        list size is constrained to be at least
                        <parameter>minLength</parameter> and at most
                        <parameter>maxLength</parameter> elements long.
                        The initial value is <parameter>defaultSize</parameter>
                        elements of <parameter>defaultVal</parameter>
                        If <parameter>defaultSize</parameter> is outside
                        the length limits, it is forced to the closest limit.
                    </para>
                </listitem>
                </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>addIntListParameter</methodname>
                     <methodparam>
                         <type>std::string</type> <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>unsigned</type> <parameter>size</parameter>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter>defaultVal</parameter>
                         <initializer>0</initializer>
                     </methodparam>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Adds a parameter that is constrained to be  a fixed
                        length Tcl list of <parameter>size</parameter>
                        integer values.
                        The initial value of the list is <parameter>size</parameter>
                        copies of <parameter>defaultValue</parameter>
                        </para>
                    <para>
                        The range of values in the list is unconstrained.
                        See the overloads below however.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                 <methodsynopsis>
                     <type>void</type> <methodname>addIntListParameter</methodname>
                     <methodparam>
                         <type>std::string</type>  <parameter>name</parameter>
                     </methodparam>
                     <methodparam>
                         <type>unsigned</type> <parameter>minlength</parameter>
                     </methodparam>
                     <methodparam>
                         <type>unsigned</type> <parameter>maxLength</parameter>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter>defaultVal</parameter>
                         <initializer>0</initializer>
                     </methodparam>
                     <methodparam>
                         <type>int</type> <parameter>defaultSize</parameter>
                         <initializer>-1</initializer>
                     </methodparam>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Same as the previous method however the list can
                        have a size in the range
                        [<parameter>minlength</parameter>..<parameter>maxLength</parameter>].
                        the initial value of the list is <parameter>defaultSize</parameter>
                        elements of <parameter>defaultVal</parameter>.
                    </para>
                    <para>
                        As for <methodname>addBoolListParameter</methodname>,
                        if the <parameter>defaultSize</parameter> parameter
                        is outside the range of valid list length it is forced
                        to the closest value.  Thus the default value really
                        creates <parameter>minlength</parameter> elements.
                        </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>isInteger</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>name</parameter>
                      </methodparam>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                      <methodparam>
                          <type>void*</type><parameter>arg</parameter>
                      </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is a static method that can be used as a constraint
                        checker for integer parameters.  When it is used,
                        the constraint parameter shoule be <literal>NULL</literal>
                        if no range checking is desired or a pointer to a
                        <type>Limits</type> struct as described in
                        PUBLIC VARIABLES, TYPES and CONSTANTS to describe
                        which limits are desired and their values.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>isBool</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>name</parameter>
                      </methodparam>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                      <methodparam>
                          <type>void*</type> <parameter>arg</parameter>
                      </methodparam>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is a static method that can be used as a constraint
                        checker for boolean parameters.  When used, the
                        constraint parameter should be <literal>NULL</literal>.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>isEnum</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>name</parameter>
                      </methodparam>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                      <methodparam>
                          <type>void*</type> <parameter>arg</parameter>
                      </methodparam>
                  </methodsynopsis>
                    </term>
                <listitem>
                    <para>
                        Constriaint checker fora n enumerated type.
                        When used, the constraint parameter should be
                        a pointer to an <type>std::set&lt;string&gt;</type>
                        which  has elements for each valid enumerator value.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                  <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>isList</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>name</parameter>
                      </methodparam>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                      <methodparam>
                          <type>void*</type> <parameter>arg</parameter>
                      </methodparam>
                  </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        General constraint checker for a parameter that must
                        look like a Tcl list.  The constraint parameter
                        is a pointer to an <type>isListParameter</type>
                        struct as defined in PUBLIC VARIABLES, TYPES and CONSTANTS
                        This structure should be filled in to provide limits on
                        the number of list elements the list can have.  A constraint
                        checker that is applied to each list element can also be
                        supplied.
                        </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                  <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>isBoolList</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>name</parameter>
                      </methodparam>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                      <methodparam>
                          <type>void*</type> <parameter>arg</parameter>
                      </methodparam>
                  </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Constraint checker for a Tcl formatted list of
                        booleans.  The constraint parameter shouild be a
                        pointer to a <type>ListSizeConstraint</type>
                        described in PUBLIC VARIABLES, TYPES and CONSTANTS.
                        This should set limits on the size of the list.
                        <methodname>isBoolList</methodname> will ensure
                        that the elements of the list are booleans.
                        </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                  <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>isIntList</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>name</parameter>
                      </methodparam>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                      <methodparam>
                          <type>void*</type> <parameter>arg</parameter>
                      </methodparam>
                  </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Constraint checker for a list of integers. The constraint
                        parameter should be a <type>ListSizeConstraint</type>
                        that describes the allowed list sizes.  The
                        checker will ensure that the elements fo the list are
                        all valid integers. At present, this checker does not
                        support checking the values of the list elemeents against
                        range limits.
                    </para>
                    <para>
                        You could manually construct the <type>isListParameter</type>
                        structure to do this and use <methodname>isList</methodname>
                        if required.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                  <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>isStringList</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>name</parameter>
                      </methodparam>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                      <methodparam>
                          <type>void*</type> <parameter>arg</parameter>
                      </methodparam>
                  </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Constraint checker for lists of strings.   The
                        constraint parametr is a <type>ListSizeConstraint</type>
                        that defines the allowed sizes of the list.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                  <methodsynopsis>
                      <modifier>static</modifier> <type>isEnumParameter</type>
                      <methodname>makeEnumSet</methodname>
                      <methodparam>
                          <modifier>const</modifier> <type>char**</type><parameter>values</parameter>
                      </methodparam>
                  </methodsynopsis>
                  </term>
                <listitem>
                    <para>
                        Helper function that converts a null terminated array
                        of pointers to strings into a
                        <type>isEnumParameter</type> constraint parameter.
                    </para>
                </listitem>
                </varlistentry>
            <varlistentry>
                <term>
                  <methodsynopsis>
                      <modifier>static</modifier> <type>bool</type> <methodname>strToBool</methodname>
                      <methodparam>
                          <type>std::string</type> <parameter>value</parameter>
                      </methodparam>
                  </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Convenience function that converts a string to a boolean
                        or throws an exception if the resulting string cannot
                        be converted.
                    </para>
                </listitem>
            </varlistentry>
        </variablelist>
       </refsect1>
        <refsect1>
           <title>PUBLIC VARIABLES, TYPES and CONSTANTS</title>
           <para>
                The class definition in the SYNOPSIS section above shows a
                large number of type definitions for this class.
                Almost all of these types are structures used by the
                built in constraint checkers.In most cases,
                if you use the convenience functions to define your parameters
                you won't need to know the details of these types.
           </para>
           <para>
                The remainder of this section describes these types and the
                constraint checkers they belong to.
            </para>
            <variablelist>
                <varlistentry>    
                    <term>
                        <fieldsynopsis>
                            <modifier>typedef</modifier>
                            <type>std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt;</type>
                            <varname>ConfigurationArray</varname>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <type>ConfigurationArray</type> is returned from
                            one of the overloads of the <methodname>cget</methodname>
                            method.  This type is a vector of pair.  The first element of each pair
                            is the name of a parameter while the second element is it's current
                            value.
                        </para>
                        <para>
                            The following fragment of code shows how to use this
                            to dump the current configuration of a configurable
                            object pointed to by <varname>pConfig</varname>
                        </para>
                        <informalexample>
                            <programlisting>
ConfigurationArray config = pConfig-&gt;cget();
for (int i = 0; i &lt; config.size(); i++) {
   cout &lt;&lt; config[i].first &lt;&lt; " is set to " &lt;&lt; config[i].second &lt;&lt; endl;
}
                            </programlisting>
                        </informalexample>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        struct  <type>limit</type> {
                        <fieldsynopsis>
                            <type>bool</type>   <varname>s_checkMe</varname>
                        </fieldsynopsis>
                        <fieldsynopsis>
                            <type>long</type> <varname>s_value</varname>
                        </fieldsynopsis>
                        <constructorsynopsis>
                            <methodname>limit</methodname>
                            <void />
                        </constructorsynopsis>
                        <constructorsynopsis>
                            <methodname>limit</methodname>
                            <methodparam>
                                <type>long</type>    <parameter>value</parameter>
                            </methodparam>
                        </constructorsynopsis>
                      } ;
                    </term>
                    <term>
                      <fieldsynopsis>
                          <modifier>typedef</modifier>
                          <type>std::pair&lt;limit, limit&gt;</type><varname>Limits</varname>
                      </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            These data types are used with the
                            <methodname>isInteger</methodname> constraint
                            checker.  Each <type>limit</type> data type
                            represents a range limit that may or may  not be
                            checked according to the state of its
                            <varname>s_checkMe</varname> flag.
                        </para>
                        <para>
                            <type>Limits</type> is a pair of <type>limit</type>
                            structs where the first one represents the lower
                            limit and the second one the upper limit.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>                      
                        <fieldsynopsis>
                            <modifier>typedef</modifier>
                            <type>std::set&lt;std::string&gt;</type>
                            <varname>isEnumParameter</varname>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The <type>isEnumParameter</type> is used by the
                            <methodname>isEnum</methodname> method
                            to validate parameters that are enumerate parameter.
                            The actual type is a set of the character strings
                            that are allowed to be assigned to the parameter value.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <fieldsynopsis>
                            <modifier>typedef</modifier> <type>std::pair&lt;typeChecker, void*&gt;</type>
                            <varname>TypeCheckInfo</varname>
                        </fieldsynopsis>
                    </term> 
                    <term>
                        typedef struct <type>_ListSizeConstraint</type> {
                            <fieldsynopsis>
                                <type>limit</type> <varname>s_atLeast</varname>
                            </fieldsynopsis>
                            <fieldsynopsis>
                                <type>limit</type> <varname>s_atMost</varname>
                            </fieldsynopsis>
                        } <type>ListSizeConstraint</type>
                    </term>
                    <term>
                        typedef struct <type>_isListParameter</type> {
                          <fieldsynopsis>
                            <type>ListSizeConstraint</type> <varname>s_allowedSize</varname>
                          </fieldsynopsis>
                          <fieldsynopsis>
                            <type>TypeCheckInfo</type> <varname>s_checker</varname>
                          </fieldsynopsis>
                        } <type>isListParameter</type>;
                    </term>
                    <listitem>
                        <para>
                            This set of types are used to validate lists.
                            The <type>isListParameter</type>
                            is what is used to validate lists.  This consists
                            of two chunks;
                        </para>
                        <para>
                            <varname>s_allowedSize</varname> is used
                            to validate the size of a list.  It is a
                            <type>ListSizeConstraint</type> which allows you to
                            specify minimum and maximum list sizes.  The list
                            size limits are inclusive so you can specify a
                            fixed size list by setting both
                            <varname>s_atLeast</varname> and <varname>s_atMost</varname>
                            to be the same.
                        </para>
                        <para>
                            <varname>s_checker</varname> is a constraint
                            checker and its parameter used to validate each
                            item in the list.  This is applied after the
                            string is determined to be a valid list and
                            after the size of the list has been checked against
                            the limits defined by <varname>s_allowedSize</varname>
                            <varname>s_checker</varname>
                            <type>TypeCheckInfo</type> which is a pair whose
                            first element is a pointer to the actual constraint
                            checking function and whose second is a pointer to data
                            passed to the constraint checker without
                            interpretation. For more information about how
                            constratin checkers work see
                            CONSTRAINT CHECKING below.
                            </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>  
                        struct  <type>flimit</type> {
                          <fieldsynopsis>
                            <type>bool</type>   <varname>s_checkMe</varname>
                          </fieldsynopsis>
                          <fieldsynopsis>
                            <type>float</type> <varname>s_value</varname>
                          </fieldsynopsis>
                          <constructorsynopsis>
                            <methodname>flimit</methodname><void />
                          </constructorsynopsis>    
                          <constructorsynopsis>
                            <methodname>flimit</methodname>
                            <methodparam>
                                <type>float</type> <parameter>value</parameter>
                            </methodparam>
                          </constructorsynopsis>    
                        };
                    </term>
                    <term>
                        <fieldsynopsis>
                            <modifier>typedef</modifier> <type>std::pair&lt;flimit, flimit&gt;</type>
                            <varname>FloatingLimits</varname>
                        </fieldsynopsis>
                    </term>
                    <listitem>
                        <para>
                            These types specify floating point limits in a
                            mannger analgous to integer limits.
                            </para>
                    </listitem>
                </varlistentry>
                
            </variablelist>           
        </refsect1>
        <refsect1>
            <title>CONSTRAINT CHECKING</title>
            <para>
                Constraint checking is the <classname>CConfigurableObject</classname>
                class's way to enforce type safety and other constraints on
                the values of configuration parameters.
                When a parameter is created with <methodname>addParameter</methodname>,
                The caller has an option to provide a constraint checker and
                a parameter that provides extra information to the constraint
                checker that can parameterize the constraints it checks.
            </para>
            <para>
                A constraint checker is just a function of the form:
                <informalexample>
                    <programlisting>
bool myConstraintChecker(std::string name, std::string newValue,
                        void* pClientData);
                    </programlisting>
                </informalexample>
            </para>
            <para>
                When the <methodname>configure</methodname> method is called
                for a parameter name that has a constraint checker
                attached to it, that checker is called and passed the parameters
                shown in the code fragment above:
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                        <parameter>name</parameter>
                    </term>
                    <listitem><para>
                        Is the name of the parameter being configured.
                        </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <parameter>newValue</parameter>
                    </term>
                    <listitem>
                        <para>Is the proposed new value for the parameter.
                        </para></listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <parameter>pClientData</parameter>
                    </term>
                    <listitem>
                        <para>
                            Is the constraint parameter passed to
                            <methodname>addParameter</methodname>
                            passed without interpretation or modification.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                The constraint checker is expected to return
                <literal>true</literal> if the proposed <parameter>newValue</parameter>
                is acceptable by the constraint checker and <literal>false</literal>
                if not.  If <literal>true</literal> is returned the parameter
                value is modified to <parameter>newValue</parameter> otherwise
                a string exception is thrown and the parameter value is not
                modified.
            </para>
            <para>
                The CCUSB framework catches string exceptions thrown by
                <classname>CConfigurableObject</classname> and converts those
                into configuration file processing error messages.  Any configuration
                file processing error is reported and aborts the start of the
                run that caused it.
            </para>
        </refsect1>
     </refentry>
       <refentry id="ccusb3-cccusb">
         <refmeta>
            <refentrytitle>cccusb</refentrytitle>
            <manvolnum>3ccusb</manvolnum>
         </refmeta>
         <refnamediv>
            <refname>cccusb</refname>
            <refpurpose>Swig wrapping of the CCCUSB C++ class.</refpurpose>
         </refnamediv>
         
         <refsynopsisdiv>
            <cmdsynopsis>
                <command>
cccusb::CCCUSB_enumerate
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
cccusb::usb_device_vector_get  <replaceable>CCCUSB-enumeration  index</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
cccusb::usb_device_vector_size <replaceable>CCUSB-enumeration</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::cccusb::CCCUSB <replaceable>name</replaceable> <replaceable>usb-device</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::cccusb::CCCUSB <replaceable>-args usb-device</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::cccusb::CCCUSB <replaceable>?name?</replaceable> -this <replaceable>ptrName</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> c
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> executeList <replaceable>readout-list maxread</replaceable>                
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> inhibit
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> loadList <replaceable>listNum readout-list</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readDGGA
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readDGGB
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readDGGExt
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readDelays
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readDeviceSourceSelectors
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readFirmware
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable>readGlobalMode
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readLamTriggers
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readLedSelector
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readOutputSelector
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readScalerA
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readScalerB
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readScalerControl
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> readUSBBulkTransferSetup
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
cccusb::CCCUSB_serialNo <replaceable>usb-device</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> setDefaultTimeout <replaceable>ms</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> simpleControl <replaceable>n a f</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> simpleRead16 <replaceable>n a f</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> simpleRead24 <replaceable>n a f</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> simpleWrite16 <replaceable>n a f d</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> simpleWrite24 <replaceable>n a f d</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> uninhibit
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeActionRegister <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeDGGA <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeDGGB <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>

            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeDGGExt <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeDelays <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeDeviceSourceSelectors <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeGlobalMode <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeLamTriggers <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeLedSelector <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeOutputSelector <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeScalerControl <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> writeUSBBulkTransferSetup <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> Z
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> -delete
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
cccusb::string_to_char <replaceable>string-object</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::cccusb::uint16_vector_get <replaceable>vector-object index</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::cccusb::uint16_vector_size <replaceable>vector-object</replaceable>
                </command>
            </cmdsynopsis>
         </refsynopsisdiv>
         <refsect1>
            <title>DESCRIPTION</title>
            <para>
                This set of commands is a Tcl wrapper around the
                CCCUSB C++ class (see <xref linkend='ccusb3-CCCUSB' />.  The
                interface consists of several static methods and object sub
                commands.
            </para>
            <para>
                The static methods include methods that support
                device enumeration and construction.  Enumeration returns
                data types that require additional static methods to
                unpack.  See DEVICE ENUMERATION below.
            </para>
            <para>
                Command lists (see <xref linkend='ccusb3-cccusbreadoutlist' />)
                can be executed in immediate mode or loaded.  At present
                the usb bulk read function is not supported so a pure Tcl
                data taking system cannot yet be written.  If you want support
                for that, request it as that can be added easily enough.
            </para>
            <para>
                Immediate list execution also produces data types that require
                additional static member functions to unpack.  See
                LIST EXECUTION below for more information.
            </para>
         </refsect1>
         <refsect1>
            <title>COMMAND DETAILS</title>
            <variablelist>
                <varlistentry>
                    <term><command>cccusb::CCCUSB_enumerate</command></term>
                    <listitem>
                        <para>
                            Produces an enumeration of the powered up CC-USB
                            devices attached to the host.  The result of this
                            command is a wrapped std::vector&lt;usb_device*&gt;
                            See DEVICE ENUMERATION for recipes for using
                            this result.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>cccusb::usb_device_vector_get  <replaceable>CCCUSB-enumeration  index</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Gets a specific element of the return value from
                            <command>cccusb::CCCUSB_enumerate</command>.
                            <parameter>CCCUSB-enumeration</parameter> is the
                            value returned from that command.
                            <parameter>index</parameter>
                            is the index into the vector.
                            Indices start from 0.  See DEVICE ENUMERATION
                            below for some enumeration recipes.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>cccusb::usb_device_vector_size <replaceable>CCUSB-enumeration</replaceable></command></term>
                    <listitem>
                        <para>
                            Returns the size of the enumeration vector
                            <parameter>CCCUSB-enumeration</parameter>.
                            This parameter is a value returned from
                            <command>cccusb::CCCUSB_enumerate</command>
                        </para>
                        <para>
                            See DEVICE ENUMERATION below for some device enumeration
                            recipes.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::cccusb::CCCUSB <replaceable>name</replaceable> <replaceable>usb-device</replaceable>
                    </command></term>
                    <listitem>
                        <para>
                            Constructs a CCCUSB object whose command will be
                            <parameter>name</parameter>.
                            <parameter>usb-device</parameter> is an element
                            from a device enumeration that was gotten
                            from <command>cccusb::CCCUSB_enumerate</command>.
                        </para>
                        <para>
                            For recipes involving device enumeration and
                            construction see DEVICE ENUMERATION below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::cccusb::CCCUSB <replaceable>-args usb-device</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Constructs a CCCUSB object with a unique
                            object instance command name chosen
                            by the constructor.  <parameter>usb-device</parameter>
                            is an element of an enumeration returned from
                            <command>cccusb::CCCUSB_enumerate</command>.
                        </para>
                        <para>
                            Normally this is used in constructs like e.g:
                        </para>
                        <informalexample>
                            <programlisting>
set controller [cccusb::CCCUSB -args $device]
$controller c
$controller z
                            </programlisting>
                        </informalexample>
                        <para>
                            For more enumeration and construction recipes
                            see DEVICE ENUMERATION below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::cccusb::CCCUSB <replaceable>?name?</replaceable>
                    -this <replaceable>ptrName</replaceable></command></term>
                    <listitem>
                        <para>
                            Constructs  CCCUSB object from an object pointer
                            <parameter>ptrName</parameter>.
                            Object pointers are gotten either by requesting
                            the <option>-this</option> from another object or,
                            in the CCUSBReadout framework by being passed in
                            from the framework to a Tcl driver.
                        </para>
                        <para>
                            If the optional <parameter>name</parameter>
                            is provided it will be the object instance command.
                            If not the object instance command will be the
                            value of <parameter>ptrName</parameter>
                        </para>
                        <para>
                            For example.
                        </para>
                        <informalexample>
                            <programlisting>
proc example pointer {
   cccusb::CCCUSB controller -this $pointer
   controller c
   
   cccusb::CCCUSB -this $pointer
   $pointer z
}
                            </programlisting>
                        </informalexample>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> c </command></term>
                    <listitem>
                        <para>
                            Performs a C cyle on the dataway connected to
                            <parameter>object</parameter>.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> executeList
                    <replaceable>readout-list maxread</replaceable></command></term>
                    <listitem>
                        <para>
                            Executes a <classname>cccusbreadoutlist::CCCUSBReadoutList</classname>
                            (see <xref linkend='ccusb3-cccusbreadoutlist' />).
                            <parameter>readout-list</parameter> is the name
                            of the list and <parameter>maxread</parameter>
                            the maximum number of 16 bit words that can
                            be read by this list (written data is inline in the
                            list).  <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                        <para>
                            The return value is the name of an
                            encapsulated std::vector&lt;uint16_t&gt;.
                            See EXECUTING LISTS for recipes for executing lists
                            and getting data from the result.
                            See as well <command>cccusb::uint16_vector_get</command>,
                            <command>cccusb::uint16_vector_size</command>.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> inhibit</command></term>
                    <listitem>
                        <para>
                            Sets the inhibit line on the CAMAC crate controlled
                            by <parameter>object</parameter>.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> loadList
                    <replaceable>listNum readout-list</replaceable></command>
                    </term>
                    <listitem>
                        <para>Loads a <classname>cccusbreadoutlist::CCCUSBReadoutList</classname>
                        object for later execution in response to an event or
                        scaler trigger.
                        </para>
                        <para>
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                            <parameter>listNum</parameter> is the number of the
                            list to be loaded.  The list numbers is either
                            <literal>0</literal> for the event list or
                            <literal>1</literal> for the scaler list.
                        </para>
                        <para>
                            <parameter>readout-list</parameter> is a
                            <classname>cccusbreadoutlist::CCUSBReadoutList</classname>
                            object instance name.  See
                            <xref linkend='ccusb3-cccusbreadoutlist' /> for
                            information about how to create these.
                        </para>
                        <para>
                            The command returns
                            <literal>0</literal> on successful completion,
                            a negative number is returned on failure.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readDGGA</command></term>
                    <listitem>
                        <para>
                            Reads the DGGA register of the CC-USB module
                            represented by <parameter>object</parameter>.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                            The DGGA register controls the width and
                            delay of one of the CC-USB's gate and delay generators.
                            See section 3.3.7 of the CC-USB manual for
                            more information about this register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readDGGB</command></term>
                    <listitem>
                        <para>
                            Same as <command>readDGGA</command> but reads the
                            B gate and delay register control register.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readDGGExt</command></term>
                    <listitem>
                        <para>
                            Reads the CC-USB Gate and delay generated extended
                            range register.  See Section 3.3.7 of the CC-USB
                            manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readDelays</command></term>
                    <listitem>
                        <para>
                            Reads the delays register of the CC-USB.  See
                            Section 3.3.3 of the CC-USB manual for a
                            description of this register.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readDeviceSourceSelectors</command></term>
                    <listitem>
                        <para>
                            Reads the CCUSB device source selectors register.
                            This is described in section 3.3.6 of the CC-USB
                            manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readFirmware</command></term>
                    <listitem>
                        <para>
                            Reads the CC-USB firmware id register.
                            The bit fields of this register are described by
                            section 3.3.1 of the CC-USB manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>readGlobalMode</command></term>
                    <listitem>
                        <para>
                            Reads the CC-USB global mode register.  This register
                            iis described in section 3.3.2 of the CC-USB
                            manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readLamTriggers</command>
                    </term>
                    <listitem>
                        <para>
                            Reads the LAM trigger register.  The CC-USB
                            manual calls this register the LAM Mask register
                            and describes it in section 3.3.9.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readLedSelector</command>
                    </term>
                    <listitem>
                        <para>
                            Reads the LED Selector register.   This register is
                            descsribed in section 3.3.5 of the CC-USB manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readOutputSelector</command>
                    </term>
                    <listitem>
                        <para>
                            Reads the output selector register.   This register
                            is described in section 3.3.5 of the CC-USB manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readScalerA</command></term>
                    <listitem>
                        <para>
                            Read the counts in Scaler A.  The scalers are
                            described in Section 3.3.8 of the CC-USB manual
                            with how to define what makes them count described
                            in section 3.3.6.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readScalerB
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Same as <command>readScalerA</command> however
                            the B scaler is read.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readScalerControl
                        </command>
                        </term>
                    <listitem>
                        <para>
                            Read the Scaler readout control register.
                            The CC-USB manual refers to this as the
                            ACS (Auxiliary Camac Stack) register in some places
                            and the Scaler Readout Control register in others.
                            It is described in section 3.3.4 of the manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> readUSBBulkTransferSetup</command>
                    </term>
                    <listitem>
                        <para>
                            Reads the USB Bulk transfer setup register.  This
                            is described in section 3.3.10 of the CC-USB
                            manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>cccusb::CCCUSB_serialNo <replaceable>usb-device</replaceable></command></term>
                    <listitem>
                        <para>
                            Reads the serial number of the device selected by
                            <parameter>usb-device</parameter>.  <parameter>usb-device</parameter>
                            is a usb device object that comes from one of the elements
                            of the enumerator returned by
                            <command>cccusb::CCCUSB_enumerate</command>.  The
                            serial number is returned as a string object handle
                            that must be converte via <command>cccusb::string_to_char</command>.
                            For more information about device enumeration and serial
                            number strings see DEVICE ENUMERATION below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> setDefaultTimeout <replaceable>ms</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Most CC-USB operations require a USB bulk transfer to
                            the CC-USB and a transfder from the CC-USB.  These
                            transfers are done with a timeout so that if
                            the target does not respond, the request eventually
                            does terminate. This sets the timeout for
                            those requests to be <parameter>ms</parameter>
                            milliseconds.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> simpleControl
                        <replaceable>n a f</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Performs a non-data transfer operation.
                            <parameter>n</parameter> specifies the CAMAC slot
                            that will be the target of this operation.
                            <parameter>a</parameter> specifies the subaddress
                            and <parameter>f</parameter> specifies the
                            function code.  The function code must be in one
                            of the ranges: <literal>[8..15] [24..31]</literal>.
                            The command returns a mask of the Q and X
                            responses from the dataway.  See VARIABLES below
                            for the Q and X bits in this mask.
                        </para>
                        <para>
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> simpleRead16
                        <replaceable>n a f</replaceable> </command>
                    </term>
                    <listitem>
                        <para>
                            Performs a 16 bit read from the module and sub
                            address specified by <parameter>n</parameter> and
                            <parameter>a</parameter>.  The CAMAC function
                            code <parameter>f</parameter> must be in the range
                            <literal>[0..7]</literal>.
                        </para>
                        <para>
                            The command returns the data in the lower 16 bits
                            of the value and the Q/X resonse in the upper byte
                            (bits 24 through 31).  Thus to extract the Q/X:    
                            <informalexample>
                                <programlisting>
set data [c simpleRead16 1 0 0]
set qx [expr {$data >> 24}]
set data [expr {$data &amp; 0xffff}]
                                </programlisting>
                            </informalexample>
                            See VARIABLES below for information about the
                            how to extract the Q and X bits from the
                            <varname>qx</varname> variable in the example
                            above.
                        </para>
                        <para>
                           <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> simpleRead24
                        <replaceable>n a f</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Same as <command>simpleRead16</command> above,
                            however the data transferred is 24 bits wide.
                            The Q/X response is still in bits 24 through 31.
                            The example below shows how to extract the data
                            and the Q/X resopnse:
                            <informalexample>
                                <programlisting>
set data [c simpleRead16 1 0 0]
set qx [expr {$data >> 24}]
set data [expr {$data &amp; 0xffffff}]
                                </programlisting>
                            </informalexample>
                        </para>
                        <para>
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> simpleWrite16
                        <replaceable>n a f d</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Performs a write of the 16 bit data <parameter>d</parameter>
                            to the module and subaddress specified by
                            <parameter>n</parameter> and <parameter>a</parameter>
                            via the CAMAC function code <parameter>f</parameter>.
                            <parameter>f</parameter> must be in the range
                            <literal>[16..23]</literal>.  The command returns
                            the Q and X mask. See VARIABLES below for information
                            about which bits are Q and which X.
                        </para>
                        <para>
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> simpleWrite24
                        <replaceable>n a f d</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Same as <command>simpleWrite16</command> however
                            the bottom 24 bits of <parameter>d</parameter>
                            are transferred.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> uninhibit</command></term>
                    <listitem>
                        <para>
                            Removes the dataway inhibit.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> writeActionRegister
                        <replaceable>value</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Writes the CC-USB action register.
                            This register is described in section 3.2.1
                            of the CC-USB manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> writeDGGA
                        <replaceable>value</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter>
                            to the control register for Gate and Delay
                            A.  This register is described in section
                            3.3.7 of the CC-USB manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> writeDGGB
                        <replaceable>value</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Same as <command>writeDGGA</command> however the
                            control register for gate and delay generator B
                            is written.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> writeDGGExt
                        <replaceable>value</replaceable></command></term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to
                            the gate and delay extended delay register.
                            See section 3.3.7 of the CC-USB manual for a description
                            of this registers.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> writeDelays
                    <replaceable>value</replaceable></command></term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to the delays
                            register.  This register is described in section
                            3.3.3 of the CC-USB manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        writeDeviceSourceSelectors <replaceable>value</replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to the
                            device source selector register.  This
                            register is described in section 3.3.6 of the
                            CC-USB manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        writeGlobalMode <replaceable>value</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to the global
                            mode register. See section 3.3.2 of the CC-USB
                            manual for a description of this register.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        writeLamTriggers <replaceable>value</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to the LAM
                            triggers register.  The CC-USB manual refers
                            to this register as the LAM Maks register
                            and describes it in section 3.3.9
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        writeLedSelector <replaceable>value</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to
                            the LED selector register. This register
                            is described in section 3.3.5 of the CC-USB manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                      writeOutputSelector <replaceable>value</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to the
                            output selectors register of the CC-USB.
                            This register is described in section 3.3.5 of
                            the CC-USB manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        writeScalerControl <replaceable>value</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to
                            the scaler control register/ACS Control
                            register.  This register is described in section
                            3.3.4 of the CC-USB manual.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        writeUSBBulkTransferSetup <replaceable>value</replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Writes <parameter>value</parameter> to the USB
                            bulk transfer setup register. Section 3.3.10 of
                            the CC-USB manual describes this register.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        Z</command>
                    </term>
                    <listitem>
                        <para>
                            Performs a Z cycle on the camac dataway.
                            <parameter>object</parameter> is a CCCUSB object
                            constructed by any of the methods described above.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> -delete</command></term>
                    <listitem>
                        <para>
                            Deletes a swig wrapper for a <classname>CCCUSB</classname>
                            wrapper.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>cccusb::string_to_char <replaceable>string-object</replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Returns a Tcl string equivalent of a
                            std::string object identifier
                            <parameter>string-objecdt</parameter>.
                            std::string
                            object identifiers are returned from the
                            <command>serialNo</command> method. See
                            DEVICE ENUMERATION below for more information.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::cccusb::uint16_vector_get
                        <replaceable>vector-object index</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Returns  element
                            <parameter>index</parameter>
                            of <parameter>vector-object</parameter>
                            where that is an object identifier for a
                            <type>std::vector&lt;uint16_t&gt;</type>.
                            This is required to fetch items out of the data
                            that comes back from the <command>executeList</command>
                            command.  For more information see EXECUTING LISTS
                            below.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::cccusb::uint16_vector_size
                        <replaceable>vector-object</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Returns the size of <parameter>vector-object</parameter>
                            where <parameter>vector-object</parameter> is an
                            object identifier for a
                            <type>std::vector&lt;uint16_t&gt;</type>.  This
                            is typically used when processing data from running
                            a list.  See EXECUTING LISTS Below for more information.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
         </refsect1>
         <refsect1>
            <title>DEVICE ENUMERATION</title>
            <para>
                The USB bus is a hotplug bus.  Device enumeration is the
                process of determining the set of devices plugged into the USB
                bus at a point in time.  The goal of device enumeration is normally
                to access a specific device of the desired device type.
                In our case we are interested in creating a CCCUSB object
                connected to  CC-USB with a specific serial number.
            </para>
            <para>
                If you are using the CCUSBReadout framework, you normally don't
                need to do this.   The framework has already enumerated and
                opened the device and is passes you the appropriate object id.
                If you are writing a pure Tcl CC-USB application, you will need
                to read and understand this section.
            </para>
            <para>
                The starting point of device enumeration is the
                <command>cccusb::CCCUSB_enumerate</command>  command.
                This returns an object id for a
                <type>std::vector&lt;usb_device*&gt;</type>. This is unfortunately
                not directly accessible in Tcl.
            </para>
            <para>
                the cccusb package provides two commands to tear apart the
                return from a call to <command>cccusb::CCCUSB_enumerate</command>:
            </para>
            <variablelist>
                <varlistentry>
                    <term><command>cccusb::usb_device_vector_size</command></term>
                    <listitem><para>
                        which returns the size of the returned vector
                        </para></listitem>
                    </varlistentry>
                <varlistentry>
                    <term><command>cccusb::usb_device_vector_get</command></term>
                    <listitem><para>Which fetches a specific
                        <type>usb_device</type> pointer object id.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
            <para>
                Once you have a <type>usb_device</type> pointer object id
                you can do two things with it.  You can obtain the serial
                number string of the associated CC-USB controller or create
                a CCCUSB object with which you can perform operations on the
                controller and the CAMAC modules in its crate.
            </para>
            <para>
                Normally you want to do both, you want to enumerate the
                controllers and either match them against a desired serial
                number or display them for the user to choose.
                The example below enumerates the CC-USB's and displays
                their serial numbers on stdout:
            </para>
            <example>
                <title>Listing CC-USB Serial numbers (Tcl).</title>
                <programlisting>
lappend auto_path /usr/opt/daq/10.1/lib
package require cccusb

set e [cccusb::CCCUSB_enumerate]

set ccount [cccusb::usb_device_vector_size $e]
for {set i 0} {$i &lt; $ccount} {incr i} {
    set usbdev [cccusb::usb_device_vector_get $e $i]
    set serial [cccusb::string_to_char [cccusb::CCCUSB_serialNo $usbdev]]
    puts $serial
}
                </programlisting>
            </example>
            <para>
                Note how <command>cccusb::usb_device_vector_size</command>
                and <command>cccusb::usb_device_vector_get</command> are used
                to get <type>usb_device*</type> object ids.
                Note as well how a specific object id is then passed to
                <command>cccusb::CCCUBS_serialNo</command> and the output of
                that converted to a Tcl string via
                <command>cccusb::string_to_char</command>
           </para>
            <para>
                The next example demonstrates a Tcl proc that returns
                a CCCUSB object command name that is connected to a specific
                CC-USB specified by serial number or generates an error
                if that serial number does not exist.
            </para>
            <example>
                <title>Creating a CCCUSB object by serial number (Tcl).</title>
                <programlisting>
lappend auto_path /usr/opt/daq/10.1/lib
package require cccusb
...
proc openCamac serialNo {
    set e [cccusb::CCCUSB_enumerate]
    set ccount [cccusb::usb_device_vector_size $e]
    for {set i 0} {$i &lt; $ccount} {incr i} {
        set usbdev [cccusb::usb_device_vector_get $e $i]
        set serial [cccusb::string_to_char [cccusb::CCCUSB_serialNo $usbdev]]
        if {$serial eq $serialNo} {
            return [cccusb::CCCUSB -args $usbdev]
        }
    }
    error "No CC-USB with serial number $serialNo is available"
 
}
                </programlisting>
            </example>
            <para>
                The pattern of this code follows the pattern of the previous
                example.  The only difference is that when the serial number
                matches the requested <varname>serialNo</varname> parameter,
                a CCCUSB object is created.  SWIG is allowed to choose the
                object command (the <option>-args</option> option does that),
                which is returned to the caller.
            </para>
         </refsect1>
         <refsect1>
            <title>EXECUTING LISTS</title>
            <para>
                The CC-USB has the ability to execute list of camac instructions.
                Immediate list execution is supported by the cccusb package
                via the <command>executeList</command> command.  Lists can also
                be downloaded to CC-USB memory for execution in data acquisition
                mode in response to event and scaler triggers.  This is supported
                via the <command>loadList</command> command.
            </para>
            <para>
                This section describes how to use <command>executeList</command>
                and how to access any data read by those lists (written data
                is stored in the list itself).  Please refer to
                <xref linkend='ccusb3-CCCUSBReadoutList'/> for reference
                material on the Tcl package for constructing these lists.
            </para>
            <para>
                In order to execute a list on an existing CCCUSB class/command
                you must
            </para>
            <itemizedlist>
                <listitem>
                    <para>Construct the list of operations to perform</para>
                </listitem>
                <listitem>
                    <para>
                        Use <command>executeList</command> to perform the
                        operations in the list, specifying a maximum number of
                        16 bit words of data to be read by the list.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        The value of the <command>executeList</command>
                        command is an object id for a
                        <type>std::vector&lt;uint16_t&gt;</type>.
                        Use the <command>cccusb::uint16_vector_size</command>
                        command to determine how many words were actually read.
                        Use the <command>cccusb::uint16_vector_get</command>
                        command to fetch elements of that vector.
                    </para>
                </listitem>
            </itemizedlist>
            <para>
                The code fragment below shows how to extract data from the
                returned data.  In it, assume that the variable
                <varname>c</varname> holds a
                CCCUSB object command and the variable <varname>l</varname>
                holds the object command of a CCCUSBReadoutList object.
                The creates a hexadecimal dump of the returned words:
            </para>
            <informalexample>
                <programlisting>
set result [$c executeList $l 1000];   # No more than 1000 wds to read.
set nRead [cccusb::uint16_vector_size $result]
for {set i 0} {$i &lt; $nRead} {incr i} {
     puts [format %x [cccusb::uint16_vector_get $result $i]]
}
                </programlisting>
                
            </informalexample>
            <para>
                Note that the <command>executeList</command> requires
                a number which is the maximum number of <type>uint16_t</type>
                values that will be read by the list.  This is used to allocate
                the read buffer.  The actual count of the words read is then
                used to fill the vector returned by that command.
            </para>
        </refsect1>
        <refsect1>
            <title>VARIABLES</title>
            <para>
                The cccusb package exports the following variables:
            </para>
            <variablelist>
                <varlistentry>
                    <term><varname>cccusb::CCCUSB_X</varname></term>
                    <listitem>
                        <para>
                            Contains the mask of the X response in a
                            Q/X word.   For the simple control and write
                            operations,
                            you can directly test these bits against the
                            command return value.  For simple read operations,
                            you need to take the return value and shift
                            right 24 bits before checking for this bit.
                            </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><varname>cccusb::CCCUSB_Q</varname></term>
                    <listitem>
                        <para>
                            Contain the max of the Q response.  See above
                            for how to use it to check for Q responses in operations.
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
        </refsect1>
        <refsect1>
            <title>SEE ALSO</title>
            <para>
                <xref linkend='ccusb3-CCCUSB' />
                <xref linkend='ccusb3-cccusbreadoutlist' />
                <xref linkend='ccusb3-CCCUSBReadoutList'/>
            </para>
        </refsect1>
       </refentry>
       <refentry id="ccusb3-cccusbreadoutlist">
         <refmeta>
            <refentrytitle>cccusbreadoutlist</refentrytitle>
            <manvolnum>3ccusb</manvolnum>
         </refmeta>
         <refnamediv>
            <refname>cccusbreadoutlist</refname>
            <refpurpose>Tcl wrapping of <classname>CCCUSBReadoutList</classname></refpurpose>
         </refnamediv>
         
         <refsynopsisdiv>
            <cmdsynopsis>
                <command>
::cccusbreadoutlist::CCCUSBReadoutList <replaceable>name</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::cccusbreadoutlist::CCCUSBReadoutList -args
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
::cccusbreadoutlist::CCCUSBReadoutList <replaceable>?name?</replaceable> -this <replaceable>ptr</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> -delete              
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> get
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable>  size
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable>  clear
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addWrite16 <replaceable>n a f d </replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable>  addWrite24 <replaceable>n a f d </replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRead16 <replaceable>n a f ?lamwait?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable>  addRead24 <replaceable>n a f ?lamwait</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addControl <replaceable>n a f</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addQStop <replaceable>n a f max ?lamwait?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addQStop24 <replaceable>n a f max ?lamwait? </replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable>  addQScan <replaceable>n a f max ?lamwait?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRepeat <replaceable>n a f count ?lamwait?</replaceable>
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addMarker <replaceable>value</replaceable>
                </command>
            </cmdsynopsis>

         </refsynopsisdiv>
         <refsect1>
            <title>DESCRIPTION</title>
            <para>
                This Tcl package is a SWIG wrapper around the
                <classname>CCCUSBReadoutList</classname> C++ package.
                The purpose of this class is to construct list of CC-USB
                operations which can either be executed immediately or
                loaded for execution in response to an event or scaler trigger
                in data taking mode.
            </para>
            <para>
                This extension is an object oriented package.  Users construct
                lists, they stock them with commands, execute or load them and
                then destroy the list.
            </para>
         </refsect1>
         <refsect1>
            <title>
               COMMAND DETAILS
            </title>
            <variablelist>
                <varlistentry>
                    <term><command>::cccusbreadoutlist::CCCUSBReadoutList
                        <replaceable>name</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Constructs a new readout list giving it the object
                            name/id <parameter>name</parameter>. The command
                            returns a wrapped pointer to the underlying
                            <classname>CCCUSBReadoutList</classname> object.
                        </para>
                    </listitem>
                </varlistentry>
               <varlistentry>
                    <term><command>::cccusbreadoutlist::CCCUSBReadoutList -args
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Creates a new readout list allowing SWIG to choose
                            the name of the command bound to it.  The
                            return value of the command is the object command e.g.:
                        </para>
                        <informalexample>
                            <programlisting>
...
set l [cccusbreadoutlist::CCCUSBReadoutList -args]
$l addWrite16 $n $a $f $d
...
                            </programlisting>
                        </informalexample>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command>::cccusbreadoutlist::CCCUSBReadoutList
                        <replaceable>?name?</replaceable> -this <replaceable>ptr</replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Wraps a SWIG object id for a readout list in a new
                            object.  If the optional <parameter>name</parameter>
                            parameter is supplied it specifies the object command
                            name, otherwise the object pointer will be the
                            name of the object command.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> -delete</command>
                    </term>
                    <listitem>
                        <para>
                            Destroys a CCCUSBReadoutList SWIG object.
                            <parameter>object</parameter> is the command name of
                            a SWIG CCCUSBReadoutList object that has been gotten
                            from one of the forms of
                            <command>cccusbreadoutlist::CCCUSBReadoutList</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> get</command>
                    </term>
                    <listitem>
                        <para>
                            Returns an object id for a
                            <type>std::vector&lt;uint16_t&gt;</type> that
                            contains the values of the list.  The elements
                            of this vector can gotten by using
                            <command>ccccusb::uint16_vector get</command>
                            See <xref linkend='ccusb3-cccusb' /> for more
                            information about that command.
                        </para>
                        <para>
                            <parameter>object</parameter> is the command name of
                            a SWIG CCCUSBReadoutList object that has been gotten
                            from one of the forms of
                            <command>cccusbreadoutlist::CCCUSBReadoutList</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> size</command>
                    </term>
                    <listitem>
                        <para>
                            Returns the number of 16 bit words currently in the list
                            <parameter>object</parameter> is the command name of
                            a SWIG CCCUSBReadoutList object that has been gotten
                            from one of the forms of
                            <command>cccusbreadoutlist::CCCUSBReadoutList</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable> clear</command></term>
                    <listitem>
                        <para>
                            Clears the list making it emtpy.
                            <parameter>object</parameter> is the command name of
                            a SWIG CCCUSBReadoutList object that has been gotten
                            from one of the forms of
                            <command>cccusbreadoutlist::CCCUSBReadoutList</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        addWrite16 <replaceable>n a f d </replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Adds a 16 bit CAMAC write of <parameter>d</parameter>
                            to a list.
                            <parameter>n</parameter> and <parameter>
                            a</parameter> determine the module and subaddress
                            targeted by this opertion.  <parameter>f</parameter>
                            specifies the function code which must be in the range
                            <literal>[16..23]</literal>
                        </para>
                        <para>
                            <parameter>object</parameter> is the command name of
                            a SWIG CCCUSBReadoutList object that has been gotten
                            from one of the forms of
                            <command>cccusbreadoutlist::CCCUSBReadoutList</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        addWrite24 <replaceable>n a f d </replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Same as <command>addWrite16</command> but adds a
                            16 bit write to the list.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        addRead16 <replaceable>n a f ?lamwait?</replaceable></command>
                    </term>
                    <listitem>
                        <para>
                            Adds a 16 bit read to the list.  The CAMAC read is
                            specified by <parameter>n</parameter> (slot),
                            <parameter>a</parameter> (subaddress) and
                            <parameter>f</parameter> (function code). Valid read
                            function codes must be in the range
                            <literal>[0..7]</literal>.
                            If the optional <parameter>lamwait</parameter>
                            parameter is present and true (nonzero)
                            it specifies that the CC-USB
                            should stall until either the module's slot signals
                            a LAM or the LAM times out.  This should not be true
                            for lists that are executed in immediate mode, but only
                            for lists that execute in data acquisition mode.
                        </para>
                        <para>
                            <parameter>object</parameter> is the command name of
                            a SWIG CCCUSBReadoutList object that has been gotten
                            from one of the forms of
                            <command>cccusbreadoutlist::CCCUSBReadoutList</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        addRead24 <replaceable>n a f ?lamwait</replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Same as <command>addRead16</command> above, however
                            24 bits of data and the Q, X will be transferred as
                            shown in section 4.6 of the CC-USB manual. Note that
                            the CCUSB Readout Framework will remove those bits
                            from data in the Scaler stack as it is assumed that
                            all of those transfers are 24 bits and that the
                            scaler stack will eventually be passed off to
                            scaler display programs that won't know the
                            Q/X bits are present.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        addControl <replaceable>n a f</replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Adds a CAMAC non data transfer (control) operation
                            to the list.  <parameter>n</parameter> and
                            <parameter>a</parameter> identify the module
                            slot and subaddress targeted by the operation and
                            <parameter>f</parameter> is the CAMAC function
                            code to be performed.  <parameter>f</parameter>
                            by CAMAC standard must be in the ranges
                            <literal>[8..15], [24..31]</literal>.
                        </para>
                        <para>
                            <parameter>object</parameter> is the command name of
                            a SWIG CCCUSBReadoutList object that has been gotten
                            from one of the forms of
                            <command>cccusbreadoutlist::CCCUSBReadoutList</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        addQStop <replaceable>n a f max ?lamwait?</replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Adds a Q-stop operation to the list.  Q-Stop operations
                            are block transfers that perform the Same operation
                            at the same target until a transfer count
                            is exhausted or an operation does not result in a
                            Q response from the module.
                        </para>
                        <para>
                            <parameter>n</parameter>, and <parameter>a</parameter>
                            identify the slot and subaddress to which the
                            function code <parameter>f</parameter> is addressed.
                            The assumption is that the operation is a
                            read, that is <parameter>f</parameter> is in the
                            range <literal>[0..7]</literal>.  <parameter>max</parameter>
                            is the maximum number of transfers allowed.
                            If the optional <parameter>lamwait</parameter> parameter
                            is true (default is false), the CC-USB will wait for
                            the module to signal a LAM (or LAM timeout) prior to
                            performing the operation.
                            <parameter>lamwait</parameter> should not be set to
                            true on lists performed in via <command>executeList</command>.
                        </para>
                        <para>
                            <parameter>object</parameter> is the command name of
                            a SWIG CCCUSBReadoutList object that has been gotten
                            from one of the forms of
                            <command>cccusbreadoutlist::CCCUSBReadoutList</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        addQStop24 <replaceable>n a f max ?lamwait? </replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Same as <command>addQStop</command> above but the
                            data transfers are 24 bits wide rather than 16 bits
                            wide.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        addQScan <replaceable>n a f max ?lamwait?</replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Same as <command>addQStop</command> however the
                            operation is a Q-Scan.  In a Q-Scan, after each
                            operation the subaddress is incremented.
                            If the subaddress would be <literal>16</literal>
                            the slot is incremented and the subaddress
                            reset to zero.
                        </para>
                        <para>
                            If there is no Q response, the sub address is
                            reset to zero and the slot incremented.  The
                            transfer terminates if either <parameter>max</parameter>
                            operations have taken place or if a transfer
                            results in a false X response (indicating the
                            scan advanced to an empty slot).
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        addRepeat <replaceable>n a f count ?lamwait?</replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            This is the same as <command>addQStop</command>
                            however <parameter>count</parameter> operations
                            are unconditionally performed.
                        </para>
                        <para>
                            <parameter>object</parameter> is the command name of
                            a SWIG CCCUSBReadoutList object that has been gotten
                            from one of the forms of
                            <command>cccusbreadoutlist::CCCUSBReadoutList</command>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term><command><replaceable>object</replaceable>
                        addMarker <replaceable>value</replaceable>
                        </command>
                    </term>
                    <listitem>
                        <para>
                            Writes the 16 bit literal 
                            <parameter>value</parameter> to the output
                            buffer.  For immediate operations this is the
                            buffer of data returned by the <command>executeList</command>
                            operation.  For data acquisition lists, this is the
                            event buffer.
                        </para>
                        <para>
                            <parameter>object</parameter> is the command name of
                            a SWIG CCCUSBReadoutList object that has been gotten
                            from one of the forms of
                            <command>cccusbreadoutlist::CCCUSBReadoutList</command>
                        </para>
                    </listitem>
                </varlistentry>
            </variablelist>
         </refsect1>
        <refsect1>
            <title>SEE ALSO</title>
            <para>
                <xref linkend='ccusb3-cccusb' />
                <xref linkend='ccusb3-CCCUSB' />
                <xref linkend='ccusb3-CCCUSBReadoutList' />
            </para>
        </refsect1>
       </refentry>

<!-- #include &lt;CModuleFactory.h&gt;           -->

	 <refentry id="ccusb3-cmodulefactory">
       <refmeta>
          <refentrytitle id="ccusb3-cmodulefactory-title">CModuleFactory</refentrytitle>
          <manvolnum>3ccusb</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CModuuleFactory</refname>
          <refpurpose>Creates specific slow control drivers</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>
            class <ooclass><classname>CModuleFactory</classname></ooclass> {
           <methodsynopsis>
            <modifier>static</modifier> 
            <type>CModuleFactory*</type>
             <methodname> instance</methodname>
             <void />
             
             <modifier></modifier>
           </methodsynopsis>
            <methodsynopsis>
                <modifier></modifier>
                <type>void </type>
                <methodname>addCreator</methodname>
                <methodparam>
                    <type>std::string</type><parameter> type</parameter>
                </methodparam>
                <methodparam>
                    <type> CModuleCreator*</type><parameter> pCreator</parameter>
                </methodparam>
                
                <modifier></modifier>
            </methodsynopsis>
            <methodsynopsis>
                <type>CControlHardware*</type>
                <methodname>create</methodname>
                <methodparam>
                    <type>std::string</type><parameter> type</parameter>
                </methodparam>
                <methodparam>
                    <type>std::string</type><parameter> name</parameter>
                </methodparam>
            </methodsynopsis>   
};
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            This class provides a factory that allows the
            <command>Module create</command> slow control server command to
            instantiate driver objects from the name of the class.
            The factory operates by matching a driver type with a
            <link linkend='ccusb3-cmodulecreator'>creator object</link>.
            The creator object then instantiates the actual object.
          </para>
          <para>
            Note that <classname>CModuleFactory</classname> is a
            <ulink url='http://en.wikipedia.org/wiki/Singleton_pattern'>
                singleton</ulink>.  See <methodname>instance</methodname>
                in METHODS below for information about how to get a
                pointer to the singleton instance of this class,.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                     <modifier>static</modifier> 
                     <type>CModuleFactory*</type>
                      <methodname> instance</methodname>
                      <void />
                      
                      <modifier></modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Returns a pointer to the
                        <ulink url='http://en.wikipedia.org/wiki/Singleton_pattern'>
                        singleton</ulink> instance of this class.  The class
                        constructor and destructor are
                        private to the class so this is the only
                        clean C++ mechanism to gain access to a
                        <classname>CModuleFactory</classname> object.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                     <methodsynopsis>
                         <modifier></modifier>
                         <type>void </type>
                         <methodname>addCreator</methodname>
                         <methodparam>
                             <type>std::string</type><parameter> type</parameter>
                         </methodparam>
                         <methodparam>
                             <type> CModuleCreator*</type><parameter> pCreator</parameter>
                         </methodparam>
                         
                         <modifier></modifier>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Associates a new creator object with a module type.
                        <parameter>type</parameter> is the  name of the
                        module type.  When this type is used in a
                        <command>Module create</command> command,
                        the creator specified by <parameter>pCreator</parameter>
                        is used to generate the module object.
                    </para>
                    <para>
                        Note that the object pointed to by
                        <parameter>pCreator</parameter> must live for
                        the duration of the program.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                     <methodsynopsis>
                         <type>CControlHardware*</type>
                         <methodname>create</methodname>
                         <methodparam>
                             <type>std::string</type><parameter> type</parameter>
                         </methodparam>
                         <methodparam>
                             <type>std::string</type><parameter> name</parameter>
                         </methodparam>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Creates a specific <parameter>type</parameter> of
                        slow control driver named <parameter>name</parameter>.
                        The driver object is dynamically created.  If it is necessary
                        to destroy it that must be done with <literal>delete</literal>.
                    </para>
                </listitem>
            </varlistentry>
          </variablelist>
       </refsect1>
     </refentry>     


<!-- #include &lt;CModuleCreator.h&gt;     -->

	 <refentry id="ccusb3-cmodulecreator">
       <refmeta>
          <refentrytitle id="ccusb3-cmodulecreator-title">CModuleCreator</refentrytitle>
          <manvolnum>3ccusb</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CModuleCreator</refname>
          <refpurpose>Object creational ABC for <classname>CModuleFactory</classname></refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>
            class <ooclass><classname>CModuleCreator</classname></ooclass> {
           <methodsynopsis>
            <modifier>virtual</modifier>  
            <type>CControlHardware*</type>
             <methodname>operator()</methodname>
             <methodparam>
                <type>std::string</type> <parameter> name</parameter>
             </methodparam>
             
             <modifier> = 0</modifier>
           </methodsynopsis>
};
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            <classname>CModuleCreator</classname> provides an abstract base class
            for module creators.  Module creators are objects that are
            registered with the
            <link linkend='ccusb3-cmodulefactory'
                  endterm='ccusb3-cmodulefactory-title' />
            singleton.  Objects that are instances of a concrete derivation from
            this class are matched up with object type names (used in the
            <command>Module create</command> command) and are responsible for
            creating objects of the specified type.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <variablelist>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual</modifier>  
                        <type>CControlHardware*</type>
                         <methodname>operator()</methodname>
                         <methodparam>
                            <type>std::string</type> <parameter> name</parameter>
                         </methodparam>
                         
                         <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Pure virtual method that concrete classes must define/supply.
                        <parameter>name</parameter>  is the name of the item being
                        created by the <command>Module create</command> command
                        that caused this method to be called.
                    </para>
                </listitem>
            </varlistentry>
          </variablelist>
       </refsect1>
     </refentry>     

<!-- #include &lt;CControlHardware.h&gt;    -->
	 <refentry id="ccusb3-ccontrolhardware">
       <refmeta>
          <refentrytitle id="ccusb3-ccontrolhardware-title">CControlHardware</refentrytitle>
          <manvolnum>3ccusb</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CControlHardware</refname>
          <refpurpose>Base class (ABC) of a slow controls driver</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>
           class <ooclass><classname>CControlHardware</classname></ooclass> {
           <constructorsynopsis>
          <methodname>CControlHardware</methodname>
          <methodparam>
            <type>std::string</type> <parameter>name</parameter>
          </methodparam>
          
           </constructorsynopsis>
           <methodsynopsis>
                <modifier>virtual</modifier>
               <type>void </type>
               <methodname>onAttach</methodname>
               <methodparam>
                <type>CControlModule&amp;</type><parameter>configuration</parameter>
               </methodparam>
               
               <modifier> = 0</modifier>
             </methodsynopsis>
             <methodsynopsis>
                 <modifier>virtual </modifier>
                 <type>void</type>
                 <methodname> Initialize</methodname>
                 <methodparam>
                    <type>CCCUSB&amp;</type><parameter>crate</parameter>
                 </methodparam>
                 
                 <modifier></modifier>
             </methodsynopsis>  
             <methodsynopsis>
                 <modifier>virtual </modifier>
                 <type>std::string </type>
                 <methodname>Update</methodname>
                 <methodparam>
                    <type>CCCUSB&amp;</type><parameter>crate</parameter>
                 </methodparam>
                 
                 <modifier> = 0</modifier>
             </methodsynopsis>  
             <methodsynopsis>
                 <modifier> virtual </modifier>
                 <type>std::string </type>
                 <methodname>Set </methodname>
                 <methodparam>
                    <type>CCCUSB&amp;</type><parameter>crate</parameter>
                 </methodparam>
                 <methodparam>
                    <type>std::string</type><parameter> parameter</parameter>
                 </methodparam>
                 <methodparam>
                    <type>std::string</type><parameter> value</parameter>
                 </methodparam>
                 
                 <modifier> = 0</modifier>
             </methodsynopsis>
            <methodsynopsis>
                <modifier>virtual</modifier>
                <type> std::string</type>
                <methodname> Get</methodname>
                <methodparam>
                    <type>CCCUSB&amp;</type><parameter> crate</parameter>
                </methodparam>
                <methodparam>
                    <type>std::string</type> <parameter>parameter</parameter>
                </methodparam>
                
                <modifier> = 0</modifier>
            </methodsynopsis>
           <methodsynopsis>
               <modifier>virtual </modifier>
               <type>void </type>
               <methodname>clone</methodname>
               <methodparam>
                <modifier>const</modifier><type> CControlHardware&amp;</type>
                <parameter>rhs</parameter>
               </methodparam>
               
               <modifier> = 0</modifier>
           </methodsynopsis>  

};
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            <classname>CControlHardware</classname> is the abstract base class
            for slow controls drivers.  See METHODS below for the set of methods
            a driver must implement. See
            <link linkend='ccusb3-cmodulefactory' endterm='ccusb3-cmodulefactory-title' />
            and
            <link linkend='ccusb3-cmodulecreator' endterm='ccusb3-cmodulecreator-title' />
            for information about how to make the <command>Module create</command>
            command aware of your driver so that it instantiate it.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <variablelist>
            <varlistentry>
                <term>
                    <constructorsynopsis> 
                        <methodname>CControlHardware</methodname>
                        <methodparam>
                          <type>std::string</type> <parameter>name</parameter>
                        </methodparam>
                        
                    </constructorsynopsis>
                </term>
                <listitem>
                    <para>
                        The base class constructor is how a module name gets
                        associated with a module driver instance.  The
                        <parameter>name</parameter> parameter specifies
                        the name of the module.  This is normally passed in
                        from the name in the <command>Module create</command>
                        command.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                         <modifier>virtual</modifier>
                        <type>void </type>
                        <methodname>onAttach</methodname>
                        <methodparam>
                         <type>CControlModule&amp;</type><parameter>configuration</parameter>
                        </methodparam>
                        
                        <modifier> = 0</modifier>
                      </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Each driver instance has a configuration associated with
                        it wrapped inside a <classname>ControlModule</classname>
                        object.  This packaging provides the transparent configuration
                        and command dispatching required to decouple the
                        code required by the device driver from the code that
                        makes use of the device driver.
                    </para>
                    <para>
                        A driver instance and its <classname>CControlModule</classname>
                        get bound together soon after the driver instance and
                        <classname>CControlModule</classname> are created.  At that
                        time, the framework code invokes the
                        <methodname>OnAttach</methodname> method of the driver
                        passing in <parameter>configuration</parameter>, a
                        reference to the instance's <classname>CControlModule</classname>
                        object.
                    </para>
                    <para>
                        The driver normally needs to save <parameter>configuration</parameter>
                        so that it an access its configuration in later operations.
                        The driver also should create configuration parameters
                        when <methodname>OnAttach</methodname> is called.
                        In most cases a driver will at least neaed to define
                        a <literal>slot</literal> configuration parameter
                        that can be configured with the slot in which the hardware
                        has been installed.
                    </para>
                    <para>
                        This method is pure virtual in the base class and
                        therefore must be implemented in concrete derived classes.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                      <methodsynopsis>
                          <modifier>virtual </modifier>
                          <type>void</type>
                          <methodname> Initialize</methodname>
                          <methodparam>
                             <type>CCCUSB&amp;</type><parameter>crate</parameter>
                          </methodparam>
                          
                          <modifier></modifier>
                      </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is called after the control configuration
                        script has completely run.  It provides for one-time
                        initialiation to set the device into a known state.
                        The <parameter>crate</parameter> parameter is a
                        controller object that allows the method to
                        perform CAMAC operations.
                    </para>
                    <para>
                        The base class method does nothing but is defined.
                        Therefore concrete classes that do not require
                        device initialization may omit this method.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                      <methodsynopsis>
                          <modifier>virtual </modifier>
                          <type>std::string </type>
                          <methodname>Update</methodname>
                          <methodparam>
                             <type>CCCUSB&amp;</type><parameter>crate</parameter>
                          </methodparam>
                          
                          <modifier> = 0</modifier>
                      </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is intended for devices with write only
                        registers.  It allows internal shadow state to be
                        written to the device.  The <parameter>crate</parameter>
                        parameter is the controller object that allows the
                        method to perform CAMAC operations.
                    </para>
                    <para>
                        On success this method is supposed to return
                        <literal>OK</literal> while on failure, it should
                        return a string of the form:
                        <literal>ERROR - </literal>
                        <replaceable>Some human readable error message</replaceable>.
                        </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                      <methodsynopsis>
                          <modifier> virtual </modifier>
                          <type>std::string </type>
                          <methodname>Set </methodname>
                          <methodparam>
                             <type>CCCUSB&amp;</type><parameter>crate</parameter>
                          </methodparam>
                          <methodparam>
                             <type>std::string</type><parameter> parameter</parameter>
                          </methodparam>
                          <methodparam>
                             <type>std::string</type><parameter> value</parameter>
                          </methodparam>
                          
                          <modifier> = 0</modifier>
                      </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is called by the framework whena a client
                        has requested a slow control parameter be set.
                        The <parameter>crate</parameter> parameter
                        is the controller object that allows the driver to perform
                        CAMAC operations.
                    </para>
                    <para>
                        Each device defines a set of settable parameters.
                        These are given names by the driver.  The client
                        specifies the name of the parameter to be
                        set and its value.  These are transmitted to the driver's
                        <methodname>Set</methodname> method via the
                        <parameter>parameter</parameter> and
                        <parameter>value</parameter> parameters respectively.
                    </para>
                    <para>
                        The driver is supposed to set the named
                        <parameter>parameter</parameter> to
                        <parameter>value</parameter>.  On success,
                        the driver should return the string <literal>OK</literal>
                        If the driver detects an error it should return a string
                        of the form:
                        <literal>ERROR - </literal><replaceable>Some human readable error string</replaceable>
                    </para>
                    <para>
                        This method is pure virtual in this base class so it must
                        be defined in concrete drivers.  Device drivers that
                        manage devices without settable parameters can
                        simple return an error string.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                     <methodsynopsis>
                         <modifier>virtual</modifier>
                         <type> std::string</type>
                         <methodname> Get</methodname>
                         <methodparam>
                             <type>CCCUSB&amp;</type><parameter> crate</parameter>
                         </methodparam>
                         <methodparam>
                             <type>std::string</type> <parameter>parameter</parameter>
                         </methodparam>
                         
                         <modifier> = 0</modifier>
                     </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        The <methodname>Get</methodname> method is called when
                        a client requests a parameter from a device.  The
                        <parameter>crate</parameter> parameter is the controller
                        object and can be used to perform CAMAC operations.
                    </para>
                    <para>
                        As with <methodname>Set</methodname> the driver defines
                        a set of named parameters that can be read.  The
                        client provides this as the <parameter>parameter</parameter>
                        parameter.  The driver is supposed to retrive the value
                        of <parameter>parameter</parameter> from the hardware,
                        convert it to text and return that text as its value.
                        If the driver detects an error, it returns a string
                        of the form
                        <literal>ERROR</literal><replaceable>Some human readable error message</replaceable>
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <methodsynopsis>
                        <modifier>virtual </modifier>
                        <type>void </type>
                        <methodname>clone</methodname>
                        <methodparam>
                         <modifier>const</modifier><type> CControlHardware&amp;</type>
                         <parameter>rhs</parameter>
                        </methodparam>
                        
                        <modifier> = 0</modifier>
                    </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method is used to support virtual copy construction.
                        The driver should copy the state of
                        the <parameter>rhs</parameter> objet into its own state.
                        The copy should be done safely so that destruction
                        of <parameter>rhs</parameter> won't implicitly destroy
                        parts of the copied state.
                    </para>
                    <para>
                        The driver is guaranteed that the actual type of
                        <parameter>rhs</parameter> is the same as the class
                        of the driver itself.
                    </para>
                </listitem>
            </varlistentry>
          </variablelist>
       </refsect1>
     </refentry>     
	 <refentry id="ccusb3-ccontrolmodule">
       <refmeta>
          <refentrytitle id="ccusb3-ccontrolmodule-title">CControlModule</refentrytitle>
          <manvolnum>3ccusb</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CControlModule</refname>
          <refpurpose>Configuration and wrapper for CControlHardware</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>
            class <ooclass><classname>CControlModule : public CConfigurableObject</classname></ooclass> {
           <constructorsynopsis>
          <methodname>CControlModule</methodname>
          <methodparam>
            <type>std::string</type><parameter> name</parameter>
          </methodparam>
          <methodparam>
            <type>CControlHardware&amp;</type><parameter>hardware</parameter>
          </methodparam>
          
           </constructorsynopsis>
           <methodsynopsis>
               <modifier></modifier>
               <type>void</type>
               <methodname>Initialize</methodname>
               <methodparam>
                <type>CCCUSB&amp;</type> <parameter>crate</parameter>
               </methodparam>
               
               <modifier></modifier>
           </methodsynopsis>
           <methodsynopsis>
               <modifier></modifier>
               <type>std::string</type>
               <methodname> Update</methodname>
               <methodparam>
                <type>CCCUSB&amp;</type><parameter> crate</parameter>   
               </methodparam>
               
               <modifier></modifier>
           </methodsynopsis>  
            <methodsynopsis>
                <modifier></modifier>
                <type>std::string</type>
                <methodname> Set</methodname>
                <methodparam>
                    <type>CCCUSB&amp;</type><parameter> crate</parameter>
                </methodparam>
                <methodparam>
                    <modifier>const</modifier><type> char*</type>
                    <parameter> what</parameter>
                </methodparam>
                <methodparam>
                    <modifier>const</modifier><type> char*</type>
                    <parameter>value</parameter>
                </methodparam>
                
                <modifier></modifier>
            </methodsynopsis>  
            <methodsynopsis>
                <modifier></modifier>
                <type>std::string </type>
                <methodname>Get</methodname>
                <methodparam>
                    <type>CCCUSB&amp;</type><parameter> crate</parameter>
                </methodparam>
                <methodparam>
                    <modifier>const</modifier><type> char*</type>
                    <parameter>what</parameter>
                </methodparam>
                
                <modifier></modifier>
            </methodsynopsis>  
};           
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            <classname>CControlModule</classname> objects serve a dual purpose.
            On the one hand, the methods supplied by them wrap the
            driver objects (
            <link linkend='ccusb3-ccontrolhardware' endterm='ccusb3-ccontrolhardware-title' />
            derived objects).
            On the other hand, by inheriting from
            <link linkend='ccusb3-CConfigurableObject'
                  endterm='ccusb3-CConfigurableObject-title' />, this object
            provides a configuration database for those driver object.
          </para>
       </refsect1>

     </refentry>     

     <refentry id="ccusb3-CCCUSBControl">
       <refmeta>
         <refentrytitle id="ccusb3-CCCUSBControl-title">CCCUSBControl</refentrytitle>
         <manvolnum>3ccusb</manvolnum>
       </refmeta>
       <refnamediv>
         <refname>CCCUSBControl</refname>
         <refpurpose>A slow-controls driver for receiving and executing remote commands</refpurpose>
       </refnamediv>

       <refsynopsisdiv>
         <synopsis>
           class <ooclass><classname>CCCUSBControl : public CControlHardware</classname></ooclass> {

           <constructorsynopsis>
             <methodname>CCCUSBControl</methodname>
             <methodparam>
               <type>std::string</type><parameter> name</parameter>
             </methodparam>
           </constructorsynopsis>

           <methodsynopsis>
             <modifier></modifier>
             <type>void</type>
             <methodname>Initialize</methodname>
             <methodparam>
               <type>CCCUSB&amp;</type> <parameter>crate</parameter>
             </methodparam>

             <modifier></modifier>
           </methodsynopsis>
           <methodsynopsis>
             <modifier></modifier>
             <type>std::string</type>
             <methodname> Update</methodname>
             <methodparam>
               <type>CCCUSB&amp;</type><parameter> crate</parameter>   
             </methodparam>

             <modifier></modifier>
           </methodsynopsis>  
           <methodsynopsis>
             <modifier></modifier>
             <type>std::string</type>
             <methodname> Set</methodname>
             <methodparam>
               <type>CCCUSB&amp;</type><parameter> crate</parameter>
             </methodparam>
             <methodparam>
               <modifier>const</modifier><type> char*</type>
               <parameter> what</parameter>
             </methodparam>
             <methodparam>
               <modifier>const</modifier><type> char*</type>
               <parameter>value</parameter>
             </methodparam>

             <modifier></modifier>
           </methodsynopsis>  
           <methodsynopsis>
             <modifier></modifier>
             <type>std::string </type>
             <methodname>Get</methodname>
             <methodparam>
               <type>CCCUSB&amp;</type><parameter> crate</parameter>
             </methodparam>
             <methodparam>
               <modifier>const</modifier><type> char*</type>
               <parameter>what</parameter>
             </methodparam>

             <modifier></modifier>
           </methodsynopsis>  
           };           
         </synopsis>
       </refsynopsisdiv>
       <refsect1>
         <title>DESCRIPTION</title>
         <para>
           CCCUSBControl allows arbitrary CAMAC access by a client and is the receiver of 
           commands executed by the CCCUSBRemote class. The only method implemented
           with functionality is Set. All of the other methods do nothing. The idea is that a set command
           will provide a remote procedure call for the CCCUSB::executeList method.
           The syntax is
         </para>
         <programlisting>
           Set name [list hexadecimalized-vmusbreadoutlist read-buffer-requirements]
         </programlisting>
         <para>
           Where 
         </para>
         <itemizedlist>
           <listitem> 
             <para>
               <literal>hexadedimalized-vmusbreadoutlist</literal> is the contents of a CCCUSBReadoutList converted to a
               Tcl list of hexadecimal long words.
             </para>
           </listitem>
           <listitem>
             <para>
               <literal>read-buffer-requirements</literal> is the size of the required read buffer for the readout list.
             </para>
           </listitem>
         </itemizedlist>
         <para>
           Success will return:  OK hexadecimalized-output-buffer
           Where <literal>hexadecimalized-output-buffer</literal> is the reply buffer converted to a hexadecimal representation
           of each byte as a Tcl list.  Note that if no output data are available, an empty list will
           be returned.
         </para>
         <para>
           Note that this function can therefore also provide all single shot operations as those are just
           lists with one element... however if the run is active each list execution will pause/resume
           the run so be aware and use with caution.
         </para>
       </refsect1>

     </refentry>     
     <refentry id="manpage.ccusbcamac">
       <refmeta>
         <refentrytitle>ccusbcamac</refentrytitle>
         <manvolnum>3ccusb</manvolnum>
       </refmeta>
       <refnamediv>
         <refname>ccusbcamac</refname>
         <refpurpose>Tcl Script CAMAC access CCUSBReadout slow-controls server</refpurpose>
       </refnamediv>

       <refsynopsisdiv>
         <cmdsynopsis>
           <command>
             package require ccusbcamac
           </command>
         </cmdsynopsis>

         <cmdsynopsis>
           <command>
             ccusbcamac::cdconn  b c host port module 
           </command>
         </cmdsynopsis>
         <cmdsynopsis>
           <command>
             ccusbcamac::cdreg  b c n 
           </command>
         </cmdsynopsis>
         <cmdsynopsis>
           <command>
             ccusbcamac::cfsa   reg f a ?d?       
           </command>
         </cmdsynopsis>
         <cmdsynopsis>
           <command>
             ccusbcamac::cssa   reg f a ?d?       
           </command>
         </cmdsynopsis>
         <cmdsynopsis>
           <command>
             ccusbcamac::qstop  reg f a ?maxn?    
           </command>
         </cmdsynopsis>
         <cmdsynopsis>
           <command>
             ccusbcamac::qscan  reg f a ?maxn?    
           </command>
         </cmdsynopsis>
         <cmdsynopsis>
           <command>
             ccusbcamac::cblock reg f a num      
           </command>
         </cmdsynopsis>
         <cmdsynopsis>
           <command>
             ccusbcamac::isOnline b c
           </command>
         </cmdsynopsis>
         <cmdsynopsis>
           <command>
             ccusbcamac::getGl    b 
           </command>
         </cmdsynopsis>
         <cmdsynopsis>
           <command>
             ccusbcamac::C        b c 
           </command>
         </cmdsynopsis>
         <cmdsynopsis>
           <command>
             ccusbcamac::Z        b c
           </command>
         </cmdsynopsis>
         <cmdsynopsis>
           <command>
             ccusbcamac::isInhibited b c 
           </command>
         </cmdsynopsis>
         <cmdsynopsis>
           <command>
             ccusbcamac::Inhibit  b c  bool
           </command>
         </cmdsynopsis>
         <cmdsynopsis>
           <command>
             ccusbcamac::ReadLams b c 
           </command>
         </cmdsynopsis>
       </refsynopsisdiv>
       <refsect1>
         <title>DESCRIPTION</title>
         <para>
           Summary of the command
         </para>
       </refsect1>
       <refsect1>
         <title>
           PACKAGE COMMANDS
         </title>
         <para>
           The commands below share many of the same parameters:
           <variablelist>
             <varlistentry>
               <term><replaceable>b</replaceable></term>
               <listitem>
                 <para>
                   The branch index to use when computing the CC-USB's
                   unique index.
                 </para>
               </listitem>
             </varlistentry>
             <varlistentry>
               <term><replaceable>c</replaceable></term>
               <listitem>
                 <para>
                   A CAMAC crate number to be used when computing the 
                   CC-USB's unique index.
                 </para>
               </listitem>
             </varlistentry>
             <varlistentry>
               <term><replaceable>n</replaceable></term>
               <listitem>
                 <para>
                   The slot number of a module in a CAMAC crate.  Slots in
                   a CAMAC crate are numbered from 1 starting at the left.
                 </para>
               </listitem>
             </varlistentry>
             <varlistentry>
               <term><replaceable>a</replaceable></term>
               <listitem>
                 <para>
                   The subaddress within a module.   A CAMAC modules is
                   defined to have 16 subaddresses numbered 0-15.
                   Each module uses this set of subaddresses differently.\
                 </para>
               </listitem>
             </varlistentry>
             <varlistentry>
               <term><replaceable>reg</replaceable></term>
               <listitem>
                 <para>
                   A CAMAC module handle.  These are produced using the
                   <command>ccusbcamac::cdreg</command> command below.  This is
                   used to select the CAMAC module operated on by several
                   of the commands.
                 </para>
               </listitem>
             </varlistentry>
           </variablelist>
         </para>
         <cmdsynopsis>
           <command>
             package require ccusbcamac
           </command>
         </cmdsynopsis>
         <para>
           Loads the commands in the <literal>ccusbcamac</literal> package
           into the interpreter provided that the NSCLDAQ Tcl package repository
           and lib directory are in the interpreter search path.  See
           <link linkend='intro.ccusbcamac'>The ccusbcamac Tcl Package</link> chapter
           for information about how to add the NSCLDAQ Tcl package repository to
           the interpreter search path.
         </para>
         <cmdsynopsis>
           <command>
             ccusbcamac::cdconn  b c host port module 
           </command>
         </cmdsynopsis>
         <para>
           Registers the name of the host running the CCUSBReadout program 
           (i.e. <parameter>host</parameter>), the
           port it listens for connections on (i.e. <parameter>port</parameter>), 
           and the name of the module loaded
           into the slow-controls server (i.e. <parameter>module</parameter>) into a connection information database.
           The <parameter>b</parameter> and <parameter>c</parameter> parameters are
           used to compute a unique index to associate the connection information
           to. For any given <parameter>b</parameter> and <parameter>c</parameter>
           combination, this MUST be called before any other procs sharing the same
           comabination of <parameter>b</parameter> and <parameter>c</parameter>.
         </para>
         <cmdsynopsis>
           <command>
             ccusbcamac::cdreg  b c n
           </command>
         </cmdsynopsis>
         <para>
           Creates a handle to a module in the CAMAC system.  
           The command returns a handle which is the <parameter>reg</parameter>
           parameter in subsequent commands that operate on a module. A connection
           is established with the slow-controls server using the information passed
           in the <command>cdconn</command> proc.
         </para>
         <cmdsynopsis>
           <command>
             ccusbcamac::cfsa   reg f a ?d?       
           </command>
         </cmdsynopsis>
         <para>
           Performs a CAMAC operation on the module <parameter>reg</parameter>.
           <parameter>reg</parameter> is a module handle created by a call to
           <command>cdreg</command>.  If the function transfers data the least
           significant 24 bits of data are transferred.  If the function is a write
           operation, the <parameter>d</parameter> parameter is required and is the
           data to write.
         </para>
         <para>
           The return value is a 3 element Tcl list.  The second element of the list
           is the Q response.  The third element of the list is the X response. The
           meaning of the first element of the list depends on the <parameter>f</parameter>
           parameter.  If <parameter>f</parameter> is the read operation, this
           will be the value read from the module.  If <parameter>f</parameter> is
           a write operation, this will be the <parameter>d</parameter> parameter.
           If <parameter>f</parameter> is a control operation (non data transfer),
           this will be zero.
         </para>
         <cmdsynopsis>
           <command>
             ccusbcamac::cssa   reg f a ?d?       - perform a 16 bit camac operation
           </command>
         </cmdsynopsis>
         <para>
           Identical to <command>ccusbcamac::cfsa</command> however all data transfers
           only transfer the least significant 16 bits.  Since the data path to the
           controller is only 16 bits, this is significantly faster than 24 bit transfers
           when the top bits are not required.
         </para>
         <cmdsynopsis>
           <command>
             ccusbcamac::qstop  reg f a ?maxn?    
           </command>
         </cmdsynopsis>
         <para>
           Performs the same read operation until the operation no longer returns
           a Q.  If the optional <parameter>maxn</parameter> parameter is present
           this also sets an upper limit in the number of transferrs.  The return
           value from this is a list of the data read from the module.  Only read functions
           are suportedby this and all block functions. At the moment, these only
           support 16-bit dataway operations.
         </para>
         <cmdsynopsis>
           <command>
             ccusbcamac::qscan  reg f a ?maxn?    
           </command>
         </cmdsynopsis>
         <para>
           Performs a Qscan block transfer.  After each read operation,
           the subaddress is incremented.  Once a module no longer responds
           with a Q, the subaddress is reset to zero and the slot is incremented.
           This continues until no X response is returned.  If the optional
           parameter <parameter>maxn</parameter> is provided, it limits the
           maximum transfer count to <parameter>maxn</parameter>. At the moment,
           these only support 16-bit dataway operations.
         </para>
         <para>
           The return value is a list of data that was returned from the module.
           These are textual ascii values, not a binary block.
         </para>
         <cmdsynopsis>
           <command>
             ccusbcamac::cblock reg f a num       
           </command>
         </cmdsynopsis>
         <para>
           Peforms <parameter>num</parameter> read operations on the module
           specified by <parameter>reg</parameter>.  Data read are returned as the
           module's result in a Tcl list.
         </para>
         <cmdsynopsis>
           <command>
             ccusbcamac::isOnline b c     
           </command>
         </cmdsynopsis>
         <para>
           Returns true if the specified VME create is online (attached to the
           controller and powered up).
         </para>  
         <cmdsynopsis>
           <command>
             ccusbcamac::getGl    b        
           </command>
         </cmdsynopsis>
         <para>
           NOT IMPLEMENTED in the ccusbcamac package because there is not meaningful
           translation of it to a CC-USB.
         </para>
         <cmdsynopsis>
           <command>
             ccusbcamac::C        b c       
           </command>
         </cmdsynopsis>
         <para>
           Peforms a C cycle on the selected crate
         </para>
         <cmdsynopsis>
           <command>
             ccusbcamac::Z        b c       
           </command>
         </cmdsynopsis>
         <para>
           Performs a Z cycle on the selected crate.
         </para>
         <cmdsynopsis>
           <command>
             ccusbcamac::isInhibited b c
           </command>
         </cmdsynopsis>
         <para>
           Returns non zero if te specified crate is inhibited
         </para>
         <cmdsynopsis>
           <command>
             ccusbcamac::Inhibit  b c  bool
           </command>
         </cmdsynopsis>
         <para>
           Sets or clears the inhibits for the selected crate.
           If <parameter>bool</parameter> is on zero the crate is
           inhibited otherwise it's uninhibited.
         </para>
         <cmdsynopsis>
           <command>
             ccusbcamac::ReadLams b c  
           </command>
         </cmdsynopsis>
         <para>
           Reads the crate LAM register.
         </para>
       </refsect1>

     </refentry>


<!-- /manpage -->



