<!-- manpage 3vmusb -->
	 <refentry id="vmusb3-CVMUSBRemote">
       <refmeta>
          <refentrytitle id='vmusb3-CVMUSBRemote-title'>CVMUSBRemote</refentrytitle>
          <manvolnum>3vmusb</manvolnum>
       </refmeta>
       <refnamediv>
          <refname>CVMUSBRemote</refname>
          <refpurpose>Execute lists remotely on VMUSBReadout</refpurpose>
       </refnamediv>
       
       <refsynopsisdiv>
        <synopsis>
#include &lt;CVMUSBRemote.h&gt;

class <ooclass><classname>CVMUSBRemote</classname></ooclass> {
    <constructorsynopsis>
        <methodname>CVMUSBRemote</methodname>
        <methodparam>
            <type>std::string</type> <parameter>deviceName</parameter>
            <initializer>"vmusb"</initializer>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>host</parameter>
            <initializer>"localhost"</initializer>
        </methodparam>
        <methodparam>
            <type>unsigned int</type> <parameter>port</parameter>
            <initializer>27000</initializer>
        </methodparam>
    </constructorsynopsis>
    <destructorsynopsis>
        <modifier>virtual</modifier><methodname>~CVMUSBRemote</methodname><void />
    </destructorsynopsis>
    <methodsynopsis>
        <type>uint32_t</type> <methodname>readFirmwareID</methodname><void />
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname>writeGlobalMode</methodname>
        <methodparam>
            <type>uint16_t</type><parameter>value)</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>uint16_t</type><methodname>readGlobalMode</methodname><void />
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname>writeDAQSettings</methodname>
        <methodparam>
            <type>uint32_t</type> <parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>uint32_t</type> <methodname>readDAQSettings</methodname><void />
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname>writeLEDSource</methodname>
        <methodparam>
            <type>uint32_t</type> <parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>uint32_t</type> <methodname>readLEDSource</methodname>
        <void />
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname>writeDeviceSource</methodname>
        <methodparam>
            <type>uint32_t</type> <parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>uint32_t</type> <methodname>readDeviceSource</methodname><void />
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname>writeDGG_A</methodname>
        <methodparam>
            <type>uint32_t</type> <parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>uint32_t</type><methodname>readDGG_A</methodname>
        <void />
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname>writeDGG_B</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>uint32_t</type> <methodname>readDGG_B</methodname>
        <void />
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname>writeDGG_Extended</methodname>
        <methodparam>
            <type>uint32_t</type> <parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>uint32_t</type> <methodname>readDGG_Extended</methodname>
        <void />
    </methodsynopsis>
    <methodsynopsis>
        <type>uint32_t</type><methodname>readScalerA</methodname>
        <void />
    </methodsynopsis>
    <methodsynopsis>
        <type>uint32_t</type><methodname>readScalerB</methodname>
        <void />
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname>writeVector</methodname>
        <methodparam>
            <type>int</type> <parameter>which</parameter>
            </methodparam>
        <methodparam>
            <type>uint32_t</type> <parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>uint32_t</type><methodname>readVector</methodname>
        <methodparam>
            <type>int</type> <parameter>which</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname>writeBulkXferSetup</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>uint32_t</type><methodname>readBulkXferSetup</methodname>
        <void />
    </methodsynopsis>
    <methodsynopsis>
        <type>int</type> <methodname>vmeWrite32</methodname>
        <methodparam>
            <type>uint32_t</type> <parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>aModifier</parameter>
        </methodparam>
        <methodparam>
            <type>uint32_t</type><parameter>data</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>int</type><methodname>vmeRead32</methodname>
        <methodparam>
            <type>uint32_t</type> <parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>aModifier</parameter>
        </methodparam>
        <methodparam>
            <type>uint32_t*</type> <parameter>data</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>int</type><methodname>vmeWrite16</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>aModifier</parameter>
        </methodparam>
        <methodparam>
            <type>uint16_t</type><parameter>data</parameter>
        </methodparam>
        </methodsynopsis>
    <methodsynopsis>
        <type>int</type><methodname>vmeRead16</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type> <parameter>aModifier</parameter>
        </methodparam>
        <methodparam>
            <type>uint16_t*</type><parameter>data</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>int</type> <methodname>vmeWrite8</methodname>
        <methodparam>
            <type>uint32_t</type> <parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>aModifier</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>data</parameter>
        </methodparam>
        </methodsynopsis>
    <methodsynopsis>
        <type>int</type> <methodname>vmeRead8</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
            </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>aModifier</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t*</type> <parameter>data</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>int</type><methodname>vmeBlockRead</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>baseAddress</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>aModifier</parameter>
            </methodparam>
        <methodparam>
            <type>void*</type><parameter>data</parameter>
        </methodparam>
        <methodparam>
            <type>size_t</type><parameter>transferCount</parameter>
        </methodparam>
        <methodparam>
            <type>size_t*</type><parameter>countTransferred</parameter>
        </methodparam>
        </methodsynopsis>
    <methodsynopsis>
        <type>int</type><methodname>vmeFifoRead</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type> <parameter>aModifier</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type><parameter>data</parameter>
        </methodparam>
        <methodparam>
            <type>size_t</type><parameter>transferCount</parameter>
        </methodparam>
        <methodparam>
            <type>size_t*</type><parameter>countTransferred</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>int</type><methodname>vmeReadBlockCount8</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint32_t</type> <parameter>mask</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>amod</parameter>
        </methodparam>
        </methodsynopsis>
    <methodsynopsis>
        <type>int</type><methodname>vmeReadBlockCount16</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint32_t</type><parameter>mask</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>amod</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>int</type> <methodname>vmeReadBlockCount32</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint32_t</type><parameter>mask</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>amod</parameter>
        </methodparam>
        </methodsynopsis>
    <methodsynopsis>
        <type>int</type><methodname>vmeVariableBlockRead</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>amod</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type><parameter>data</parameter>
        </methodparam>
        <methodparam>
            <type>size_t</type><parameter>maxCount</parameter>
        </methodparam>
        <methodparam>
            <type>size_t*</type><parameter>countTransferred</parameter>
            </methodparam>
        </methodsynopsis>
    <methodsynopsis>
        <type>int</type><methodname>vmeVariableFifoRead</methodname>
        <methodparam>
            <type>uint32_t</type><parameter>address</parameter>
        </methodparam>
        <methodparam>
            <type>uint8_t</type><parameter>amod</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type><parameter>data</parameter>
        </methodparam>
        <methodparam>
            <type>size_t</type><parameter>maxCount</parameter>
            </methodparam>
        <methodparam>
            <type>size_t*</type><parameter>countTransferred</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>int</type><methodname>executeList</methodname>
        <methodparam>
            <type>CVMUSBReadoutList&amp;</type><parameter>list</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type><parameter>pReadBuffer</parameter>
        </methodparam>
        <methodparam>
            <type>size_t</type><parameter>readBufferSize</parameter>
        </methodparam>
        <methodparam>
            <type>size_t*</type><parameter>bytesRead</parameter>
        </methodparam>
    </methodsynopsis>


    // Register bit definintions.

public:
    class <ooclass><classname>RegisterOffsets</classname></ooclass> {
    public:
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>FIDRegister</varname><initializer>0</initializer>
            </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>GMODERegister</varname><initializer>4</initializer>
            </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>DAQSetRegister</varname><initializer>8</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>LEDSrcRegister</varname><initializer>0xc</initializer>
            </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>DEVSrcRegister</varname><initializer>0x10</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>DGGARegister</varname><initializer>0x14</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>DGGBRegister</varname><initializer>0x18</initializer>
            </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>ScalerA</varname><initializer>0x1c</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>ScalerB</varname><initializer>0x20</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>ExtractMask</varname><initializer>0x24</initializer>
            </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>ISV12</varname><initializer>0x28</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>ISV34</varname><initializer>0x2c</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>ISV56</varname><initializer>0x30</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>ISV78</varname><initializer>0x34</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>DGGExtended</varname><initializer>0x38</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>USBSetup</varname><initializer>0x3c</initializer>
            </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>USBVHIGH1</varname><initializer>0x40</initializer>
            </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>unsigned int</type>
            <varname>USBVHIGH2</varname><initializer>0x44</initializer>
        </fieldsynopsis>
    };

    class <ooclass><classname>ActionRegister</classname></ooclass>
    public:
        <fieldsynopsis>        
            <modifier>static const</modifier><type>uint16_t</type>
            <varname>startDAQ</varname><initializer>1</initializer>
            </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>uint16_t</type>
            <varname>usbTrigger</varname><initializer>2</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>uint16_t</type>
            <varname>clear</varname><initializer>4</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>uint16_t</type>
            <varname>sysReset</varname><initializer>8</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier><type>uint16_t</type>
            <varname>scalerDump</varname><initializer>0x10</initializer>
        </fieldsynopsis>
    };
   class <ooclass><classname>FirmwareRegister</classname></ooclass> {
    public:
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>minorRevMask</varname><initializer>0x000000ff</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>minorRevShift</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>majorRevMask</varname><initializer>0x0000ff00</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>majorRevShift</varname><initializer>8</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>betaVersionMask</varname><initializer>0x00ff0000</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>betaVersionShift</varname><initializer>16</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>yearMask</varname><initializer>0x0f000000</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>yearShift</varname><initializer>24</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>monthMask</varname><initializer>0xf0000000</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>monthshift</varname><initializer>27</initializer>
    </fieldsynopsis>
    };

    class <ooclass><classname>GlobalModeRegister</classname></ooclass> {
    public:
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLenMask</varname><initializer>0xf</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLenShift</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLen13K</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLen8K</varname><initializer>1</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLen4K</varname><initializer>2</initializer>
        </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLen2K</varname><initializer>3</initializer>
        </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLen1K</varname><initializer>4</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLen512</varname><initializer>5</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLen256</varname><initializer>6</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLen128</varname><initializer>7</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLen64</varname><initializer>8</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>bufferLenSingle</varname><initializer>9</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>mixedBuffers</varname><initializer>0x20</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>doubleSeparater</varname><initializer>0x40</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>align32</varname><initializer>0x80</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>doubleHeader</varname><initializer>0x100</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>flushScalers</varname><initializer>0x200</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>busReqLevelMask</varname><initializer>0x7000</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint16_t</type>
        <varname>busReqLevelShift</varname><initializer>12</initializer>
    </fieldsynopsis>
    };
    class <ooclass><classname>DAQSettingsRegister</classname></ooclass> {
    public:
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>readoutTriggerDelayMask</varname><initializer>0xff</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>readoutTriggerDelayShift</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>scalerReadoutPeriodMask</varname><initializer>0xff00</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>scalerReadoutPeriodShift</varname><initializer>8</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>scalerReadoutFrequenyMask</varname><initializer>0xffff0000</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>scalerReadoutFrequencyShift</varname><initializer>16</initializer>
    </fieldsynopsis>
    };
    class <ooclass><classname>LedSourceRegister</classname></ooclass> {
    public:
        // Top yellow led:
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>topYellowOutFifoNotEmpty</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>topYellowInFifoNotEmpty</varname><initializer>1</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>topYellowScalerEvent</varname><initializer>2</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>topYellowInFifoFull</varname><initializer>3</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>topYellowDTACK</varname><initializer>4</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>topYellowBERR</varname><initializer>5</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>topYellowBusRequest</varname><initializer>6</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>topYellowBusGranted</varname><initializer>7</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>topYellowInvert</varname><initializer>0x8</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>topYellowLatch</varname><initializer>0x10</initializer>
    </fieldsynopsis>

        // Red LED:
        
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>redEventTrigger</varname><initializer>(0 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>redNimInput1</varname><initializer>(1 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>redNimInput2</varname><initializer>(2 &lt;&lt; 8)</initializer>
        </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>redBusy</varname><initializer>(3 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>redDTACK</varname><initializer>(4 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>redBERR</varname><initializer>(5 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>redBusRequest</varname><initializer>(6 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>redBusGranted</varname><initializer>(7 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>redInvert</varname><initializer>(8 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>redLatch</varname><initializer>(0x10 &lt;&lt; 8)</initializer>
    </fieldsynopsis>

        // Green led:

    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>greenAcquire</varname><initializer>(0 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>greenStackNotEmpty</varname><initializer>(1 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>greenEventReady</varname><initializer>(2 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>greenEventTrigger</varname><initializer>(3 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>greenDTACK</varname><initializer>(4 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>greenBERR</varname><initializer>(5 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>greenBusRequest</varname><initializer>(6 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>greenBusGranted</varname><initializer>(7 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>greenInvert</varname><initializer>(8 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>greenLatch</varname><initializer>(0x10 &lt;&lt; 16)</initializer>
    </fieldsynopsis>

        // Bottom yellow LED

    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>bottomYellowNotArbiter</varname><initializer>(0 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>bottomYellowUsbTrigger</varname><initializer>(1 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>bottomYellowUSBReset</varname><initializer>(2 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>bottomYellowBERR1</varname><initializer>(3 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>bottomYellowDTACK</varname><initializer>(4 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>bottomYellowBERR</varname><initializer>(5 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>bottomYellowBusRequest</varname><initializer>(6 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>bottomYellowBusGranted</varname><initializer>(7 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>bottomYellowInvert</varname><initializer>(8 &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier><type>uint32_t</type>
        <varname>bottomYellowLatch</varname><initializer>(0x10 &lt;&lt; 24)</initializer>
    </fieldsynopsis>

    };
    class <ooclass><classname>CVMUSB::DeviceSourceRegister</classname></ooclass> {
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1Busym</varname><initializer>0</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1Trigger</varname><initializer>1</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1BusRequest</varname><initializer>2</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1EventToBuffer</varname><initializer>3</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1DGGA</varname><initializer>4</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1DGGB</varname><initializer>5</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1EndOfEvent</varname><initializer>6</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1UsbTrigger</varname><initializer>7</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1Invert</varname><initializer>8M</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO1Latch</varname><initializer>0x10</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2UsbTrigger1</varname><initializer>(0 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2VMEExecuting</varname><initializer>(1 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2VMEAS</varname><initializer>(2 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2DataToUsbFIFO</varname><initializer>(3 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2DGGA</varname><initializer>(4 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2DGGB</varname><initializer>(5 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2EndOfEvent</varname><initializer>(6 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2UsbTrigger</varname><initializer>(7 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2Invert</varname><initializer>(8 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>nimO2Latch</varname><initializer>(0x10 &lt;&lt; 8)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerADisabled</varname><initializer>(0   &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerANIMI1</varname><initializer>(1   &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerANIMI2</varname><initializer>(2   &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerAEvent</varname><initializer>(2   &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerAEnable</varname><initializer>(8   &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerAReset</varname><initializer>(0x10 &lt;&lt; 16)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBDisabled</varname><initializer>(0   &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBNIMI1</varname><initializer>(1   &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBNIMI2</varname><initializer>(2   &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBEvent</varname><initializer>(2   &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBEnable</varname><initializer>(8   &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>scalerBReset</varname><initializer>(0x10 &lt;&lt; 20)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggADisabled</varname><initializer>(0   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggANIMI1</varname><initializer>(1   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggANIMI2</varname><initializer>(2   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggAEventTrigger</varname><initializer>(3   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggAEndOfEvent</varname><initializer>(4   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggAUsbTrigger</varname><initializer>(5   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggAPulser</varname><initializer>(6   &lt;&lt; 24)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBDisabled</varname><initializer>(0   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBNIMI1</varname><initializer>(1   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBNIMI2</varname><initializer>(2   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBEventTrigger</varname><initializer>(3   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBEndOfEvent</varname><initializer>(4   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBUsbTrigger</varname><initializer>(5   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    <fieldsynopsis>
        <modifier>static const</modifier> <type>uint32_t</type>
        <varname>dggBPulser</varname><initializer>(6   &lt;&lt; 28)</initializer>
    </fieldsynopsis>
    };
    class <ooclass><classname>CVMUSB::DGGAndPulserRegister</classname></ooclass> {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>dggFineDelayMask</varname><initializer>0xffff</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>dggFineDelayShift</varname><initializer>0</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>dggGateWidthMask</varname><initializer>0xffff0000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>dggGateWidthShift</varname><initializer>16</initializer>
        </fieldsynopsis>
    
    };
    class <ooclass><classname>CVMUSB::DGGCoarseRegister</classname></ooclass> {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>ACoarseMask</varname><initializer>0xffff</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>ACoarseShift</varname><initializer>0</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BCoarseMask</varname><initializer>0xffff0000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BCoarseShift</varname><initializer>16</initializer>
        </fieldsynopsis>
    
    }; 
    class <ooclass><classname>CVMUSB::ISVRegister</classname></ooclass> {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AVectorMask</varname><initializer>= 0xff</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AVectorShift</varname><initializer>0</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AIPLMask</varname><initializer>0x700</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AIPLShift</varname><initializer>8</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AStackIDMask</varname><initializer>0x7000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>AStackIDShift</varname><initializer>12</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BVectorMask</varname><initializer>0xff0000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BVectorShift</varname><initializer>16</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BIPLMask</varname><initializer>0x7000000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BIPLShift</varname><initializer>24</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BStackIDMask</varname><initializer>0x70000000</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>BStackIDShift</varname><initializer>28</initializer>
        </fieldsynopsis>
    };
    class <ooclass><classname>CVMUSB::TransferSetupRegister</classname></ooclass> {
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>multiBufferCountMask</varname><initializer>0xff</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>multiBufferCountShift</varname><initializer>0</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>timeoutMask</varname><initializer>0xf00</initializer>
        </fieldsynopsis>
        <fieldsynopsis>
            <modifier>static const</modifier> <type>uint32_t</type>
            <varname>timeoutShift</varname><initializer>8</initializer>
        </fieldsynopsis>
    };

}; 
 
        </synopsis>
       </refsynopsisdiv>
       <refsect1>
          <title>DESCRIPTION</title>
          <para>
            Provides remote access to the VM-USB via the VMUSBReadout's
            slow controls server.  This class is a proxy and transparently
            performs network operations with the slow control server to
            execute each method.
          </para>
       </refsect1>
       <refsect1>
          <title>
         METHODS
          </title>
          <para>
            With the exception of the constructor, please refer to
            <link linkend='vmusb3-CVMUSB' endterm='vmusb3-CVMUSB-title' />
            for per method documentation.
            The constructor forms a connection with the VMUSBReadout's
            control server or throws an exception if that is not possible.
          </para>
          <para>
            The parameter constrcutors are:
          </para>
          <variablelist>
            <varlistentry>
                <term>
                    <fieldsynopsis>
                        <type>std::string</type> <varname>deviceName</varname>
                        <initializer>"vmusb"</initializer>
                    </fieldsynopsis>
                    </term>
                <listitem>
                    <para>
                        The n ame of the device driver to direct requests to.
                        This is the name of the driver instance
                        created by the <command>Module</command> command
                        in the control configuration file.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                    <fieldsynopsis>
                        <type>std::string</type> <varname>host</varname>
                        <initializer>"localhost"</initializer>
                    </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The host in which the readout software is running.
                    </para>
                    </listitem>
                </varlistentry>
            <varlistentry>
                <term>
                    <fieldsynopsis>
                        <type>unsigned int</type> <varname>port</varname>
                        <initializer>27000</initializer>
                    </fieldsynopsis>
                </term>
                <listitem>
                    <para>
                        The port on which the control server is running.
                    </para>
                </listitem>
            </varlistentry>
          </variablelist>
       </refsect1>
     </refentry>     
         
        <refentry id="vmusb3-CConfigurableObject">
          <refmeta>
             <refentrytitle>CConfigurableObject</refentrytitle>
             <manvolnum>3vmusb</manvolnum>
          </refmeta>
          <refnamediv>
             <refname>CConfigurableObject</refname>
             <refpurpose>Configuration database</refpurpose>
          </refnamediv>
          <refsynopsisdiv>
           <synopsis>
#include &lt;CConfigurableObject.h&gt;
class <ooclass><classname>CConfigurableObject</classname></ooclass>
{
    <constructorsynopsis>
      <methodname>CConfigurableObject</methodname>
      <methodparam>
          <type>std::string</type> <parameter>name</parameter>
      </methodparam>
    </constructorsynopsis>
    <constructorsynopsis>
        <methodname>CConfigurableObject</methodname>
        <methodparam>
            <modifier>const</modifier> <type>CConfigurableObject&amp;</type>
            <parameter>rhs</parameter>
        </methodparam>
    </constructorsynopsis>
    <methodsynopsis>
        <type>std::string</type><methodname>getName</methodname>
        <void /><modifier>const</modifier>
    </methodsynopsis>
    <methodsynopsis>
        <type>std::string</type> <methodname>cget</methodname>
        <methodparam>
            <type>std::string</type><parameter>name</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>ConfigurationArray</type> <methodname>cget</methodname>
        <void />
    </methodsynopsis>
    <methodsynopsis>
        <type>int</type> <methodname>getIntegerParameter</methodname>
        <methodparam>
            <type>std::string</type><parameter>name</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>unsigned int</type> <methodname>getUnsignedParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>bool</type> <methodname>getBoolParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>double</type> <methodname>getFloatParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>std::vector&lt;int&gt;</type> <methodname>getIntegerList</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type> <methodname>addParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>typeChecker</type> <parameter>checker</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>defaultValue</parameter>
            <initializer>std::string(""))</initializer>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type> <methodname>clearConfiguration</methodname>
        <void />
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type> <methodname>configure</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type> <methodname>addIntegerParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>int</type> <parameter>defaultVal</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type>
        <methodname>addIntegerParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>int</type> <parameter>low</parameter>
        </methodparam>
        <methodparam>
            <type>int </type> <parameter>high</parameter>
        </methodparam>
        <methodparam>
            <type>int</type>    <parameter>defaultVal</parameter>
            <initializer>0</initializer>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname> addBooleanParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>bool</type> <parameter>defaultVal</parameter>
            <initializer>true</initializer>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type><methodname> addEnumParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>const char**</type> <parameter>pValues</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>defaultValue</parameter>
            <initializer>std::string(""))</initializer>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type> <methodname>addBoolListParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>size</parameter>
        </methodparam>
        <methodparam>
            <type>bool</type> <parameter>defaultVal</parameter>
            <initializer>true</initializer>
        </methodparam>
    </methodsynopsis>  
    <methodsynopsis>
        <type>void</type> <methodname>addBoolListParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>minLength</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>maxLength</parameter>
        </methodparam>
        <methodparam>
            <type>bool</type> <parameter>defaultVal</parameter>
            <initializer>true</initializer>
        </methodparam>
        <methodparam>
            <type>int</type> <parameter>defaultSize</parameter>
            <initializer>-1</initializer>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type> <methodname>addIntListParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>size</parameter>
        </methodparam>
        <methodparam>
            <type>int</type> <parameter>defaultVal</parameter>
            <initializer>0</initializer>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type> <methodname>addIntListParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>minlength</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>maxLength</parameter>
        </methodparam>
        <methodparam>
            <type>int</type> <parameter>defaultVal</parameter>
            <initializer>0</initializer>
        </methodparam>
        <methodparam>
            <type>int</type> <parameter>defaultSize</parameter>
            <initializer>-1</initializer>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier></modifier>
        <type>void</type>
        <methodname>addIntListParam</methodname>
        <methodparam><type>std::string</type> <parameter>name</parameter></methodparam>
        <methodparam><type>int</type> <parameter>minvalue</parameter></methodparam>
        <methodparam><type>int</type> <parameter>maxvalue</parameter></methodparam>
        <methodparam><type>unsigned</type> <parameter>minlength</parameter></methodparam>
        <methodparam><type>unsigned</type> <parameter>maxlength</parameter></methodparam>
         <methodparam>
            <type>int</type> <parameter>defaultVal</parameter>
        </methodparam>
        <methodparam>
            <type>int</type> <parameter>defaultSize</parameter>
        </methodparam>       
        
        <exceptionname></exceptionname>
        <modifier></modifier>
    </methodsynopsis>  
    <methodsynopsis>
        <type>void</type> <methodname>addStringListParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>size</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type><parameter>defaultVal</parameter>
            <initializer>""</initializer>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <type>void</type> <methodname>addStringListParameter</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>minLength</parameter>
        </methodparam>
        <methodparam>
            <type>unsigned</type> <parameter>maxLength</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>defaultVal</parameter>
            <initializer>""</initializer>
        </methodparam>
        <methodparam>
            <type>int</type> <parameter>defaultLength</parameter>
            <initializer>-1</initializer>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier><type>bool</type> <methodname>isInteger</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type><methodname> isBool</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type><methodname> isEnum</methodname>
        <methodparam>
            <type>std::string</type><parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type><parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type><methodname> isFloat</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier><type>bool</type>
        <methodname>isList</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type><parameter> value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isBoolList</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isIntList</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>isStringList</methodname>
        <methodparam>
            <type>std::string</type> <parameter>name</parameter>
        </methodparam>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
        <methodparam>
            <type>void*</type> <parameter>arg</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>isEnumParameter</type>
        <methodname>makeEnumSet</methodname>
        <methodparam>
            <modifier>const</modifier> <type>char**</type> <parameter>values</parameter>
        </methodparam>
    </methodsynopsis>
    <methodsynopsis>
        <modifier>static</modifier> <type>bool</type> <methodname>>strToBool</methodname>
        <methodparam>
            <type>std::string</type> <parameter>value</parameter>
        </methodparam>
    </methodsynopsis>
    
    typedef <type>std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt; ConfigurationArray</type>;
    
    struct  limit {
    <fieldsynopsis>
        <type>bool</type> <varname>s_checkMe</varname>
    </fieldsynopsis>
    <fieldsynopsis>
        <type>long</type> <varname>s_value</varname>
    </fieldsynopsis>
    <constructorsynopsis>
        <methodname>limit</methodname><void />
    </constructorsynopsis>
    <constructorsynopsis><methodname>limit</methodname>
        <methodparam>
            <type>long</type> <parameter>value</parameter>
        </methodparam>
    </constructorsynopsis>

  typedef <type>std::pair&lt;limit, limit&gt;   LimitsM</type>
  typedef <type>std::set&lt;std::string&gt; isEnumParameter</type>
  
  typedef struct _ListSizeConstraint {
    <fieldsynopsis>
        <type>limit</type> <varname>s_atLeast</varname>
    </fieldsynopsis>
    <fieldsynopsis>
        <type>limit</type> <varname>s_atMost</varname>
    </fieldsynopsis>    
  } ListSizeConstraint;

  struct isListParameter {
  <fieldsynopsis>
    <type>ListSizeConstraint</type> <varname>s_allowedSize</varname>
  </fieldsynopsis>
  <fieldsynopsis>
    <type>TypeCheckInfo</type> <varname>s_checker</varname>
  </fieldsynopsis>
  <constructorsynopsis>
    <methodname>isListParameter</methodname>
    <methodparam>
        <type>limit</type> <parameter>atLeast</parameter>
    </methodparam>
    <methodparam>
        <type>limit</type> <parameter>atMost</parameter>
    </methodparam>
    <methodparam>
        <type>TypeCheckInfo</type> <parameter>checker</parameter>
    </methodparam>
  </constructorsynopsis>
  <constructorsynopsis>
    <methodname>isListParameter</methodname>
    <methodparam>
        <type>ListSizeConstraint</type> <parameter>limits</parameter>
    </methodparam>
    <methodparam>
        <type>TypeCheckInfo</type> <parameter>checker</parameter>
    </methodparam>
  </constructorsynopsis>
  <constructorsynopsis>
    <methodname>isListParameter</methodname>
    <void />
  </constructorsynopsis>
  
  };
    
  struct  flimit {
  <fieldsynopsis>
    <type>bool</type> <varname>s_checkMe</varname>
  </fieldsynopsis>
  <fieldsynopsis>
    <type>float</type> <varname>s_value</varname>
  </fieldsynopsis>
  <constructorsynopsis>
    <methodname>flimit</methodname><void />
  </constructorsynopsis>
  <constructorsynopsis>
    <methodname>flimit</methodname>
    <methodparam>
        <type>float</type> <parameter>value</parameter>
    </methodparam>
  </constructorsynopsis>
  };
  
  typedef <type>?std::pair&lt;flimit, flimit&gt;</type> <varname>FloatingLimits</varname>;
  typedef <type>std::vector&lt;isEnumParameter*&gt;</type> <varname>EnumCheckers</varname>;

}

           </synopsis>
          </refsynopsisdiv>
          <refsect1>
             <title>DESCRIPTION</title>
             <para>
                Each VM-USB device driver object contains an instance of
                a <classname>CConfigurableObject</classname>.  The driver
                defines its configuration parameters within that object and
                the object is transparently hooked into the driver command's
                config and cget methods so that the driver code does not have
                to worry about handling those commands.
             </para>
             <para>
                <classname>CConfigurableObject</classname> provides mechanisms
                for not only defining and retrieving configuration parameters, but
                for enforcing constraints on those parameters.  Constraint checking
                can include not only checking the type of a parameter but
                checking for completely arbitrary constraints on the values
                of the confgiguration parameter.
             </para>
             <para>
                Constraint checking is accomplished by associating a validity
                checking function with each parameter.  A set of pre-defined
                validity checking functions, implemented as static class methods
                mean that for most cases you don't need to define your own
                constraint checkers.
             </para>
             <para>
                Another side enforcing strong parameter typing and constraints is
                a set of parameter getters that transparently convert the
                string representation of a parameter to a form that is meaningful
                to the driver.
            </para>
            <para>
                As a simple example, consider a threshold value that must be
                an integer in the range of <literal>[0..4095]</literal>.
                This can be easily defined as a configuration parameter that
                uses the predefined <methodname>isInteger</methodname>
                constraint checker passed an appropriate limit checking
                structure.  When retrieving the paramter, since the <command>config</command>
                subcommand has already perfromed type and range checking, the
                driver can simply use <methodname>getIntegerParameter</methodname>
                to retrieve the parameter value without worrying about
                having any illegal values for the parameter.
            </para>
          </refsect1>
          <refsect1>
             <title>
            METHODS
             </title>
             <para>
                This section describes the bulk of the methods provided by
                <classname>CConfigurableObject</classname>.  The sections
                UTILITY METHODS and BUILT IN TYPE CHECKERS provide information
                about utility methods provided to objects and the built in
                constraint checking methods respetively.
             </para>
             <variablelist>
                <varlistentry>
                    <term><constructorsynopsis>
                    <methodname>CConfigurableObject</methodname>
                    <methodparam>
                        <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                  </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Basic constructor for a configurable object.
                            Each configuratino has a <parameter>name</parameter>
                            under which it is registered with the device configuration
                            database.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>std::string</type><methodname>getName</methodname>
                            <void /><modifier>const</modifier>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the name of the configuable object.
                                
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>std::string</type> <methodname>cget</methodname>
                            <methodparam>
                                <type>std::string</type><parameter>name</parameter>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                All configuration values are stored as strings.
                                This method returns the configuration value of
                                the configuration parameter named <parameter>name</parameter>.
                            </para>
                            <para>
                                Note  that other methods exist that convert the
                                string ot a more natural type given for
                                parameters with specific semantics.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>ConfigurationArray</type> <methodname>cget</methodname>
                            <void />
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns a <classname>ConfigurationArray</classname>
                                that contains the entire device configuration.
                                For information about the shape of a
                                <classname>CConfigurationArray</classname>  see
                                the TYPES section below.
                            </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                            <type>int</type> <methodname>getIntegerParameter</methodname>
                            <methodparam>
                                <type>std::string</type><parameter>name</parameter>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the value of the configuration parameter
                                <parameter>name</parameter> converted to a
                                signed integer.  Care should be taken when
                                using this with a parameter that is not validated
                                vai <methodname>isIntegerParameter</methodname>.
                                If the underlying string is not a valid integer,
                                this method will throw a <type>std::string</type>
                                exception.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>unsigned int</type> <methodname>getUnsignedParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Same as <methodname>getIntegerParameter</methodname>
                                however the conversion is to an unsigned integer.
                                If your driver requires a
                                <option>-base</option> option, you should use
                                this method to retrieve that rather than
                                <methodname>getIntegerParameter</methodname>
                                to avoid overflow.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>bool</type> <methodname>getBoolParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the value of <parameter>name</parameter>
                                converted to a boolean.  Boolean parameters
                                should use <methodname>isBool</methodname>
                                as their constraint checkers.
                            </para>
                            <para>
                                In order to make boolean parameters more natural.
                                The following set of strings is acceepted as
                                <literal>true</literal>
                                <literal>{"true", "yes", "1", "on", "enabled"}</literal>
                                and <literal>false</literal> strings are in the
                                set:
                                <literal>{"false", "no", "0", "off", "disabled"}</literal>.
                            </para>
                            <para>
                                If the string value is not in one of those
                                two sets, a <type>std::string</type>
                                exception is thrown.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>double</type> <methodname>getFloatParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Returns the parameter <parameter>name</parameter>
                                converted to a floating point value.  <parameter>name</parameter>
                                should be associated with the
                                <methodname>isFloat</methodname> constraint checker.
                                If, however it is not, an <type>std::string</type>
                                exception is thrown if the value does not have
                                a floating point representation.
                            </para>
                         </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>std::vector&lt;int&gt;</type> <methodname>getIntegerList</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This member function parses the value of
                                parameter <parameter>name</parameter> as a Tcl
                                list of integers and returns those integers
                                as a <type>std::vector&lt;int&gt;</type>.
                                This is most often used when a configuration
                                parameter is used to represent per channel
                                values for a digitizer.
                            </para>
                            <para>
                                Normally you will use this to process values
                                of parameters that use the <methodname>isList</methodname>
                                constraint checker with <methodname>isInteger</methodname>
                                specifies as a per element constraint chedker.
                            </para>
                            <para>
                                As with all parameter value getting methods, if
                                the value does not parse correctly (is not a
                                Tcl list or a list element is not an integer),
                                a <type>std::string</type> exception is thrown.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>addParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>typeChecker</type> <parameter>checker</parameter>
                            </methodparam>
                            <methodparam>
                                <type>void*</type> <parameter>arg</parameter>
                            </methodparam>
                            <methodparam>
                                <type>std::string</type> <parameter>defaultValue</parameter>
                                <initializer>std::string(""))</initializer>
                            </methodparam>
                        </methodsynopsis>
                        <methodsynopsis>
                            <type>void</type> <methodname>clearConfiguration</methodname>
                            <void />
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Adds a new parameter to the configurable object.
                                This parameter will be reported in
                                <command>cget</command> subcommands and
                                can be modified in <command>config</command>
                                subcomands.
                            </para>
                            <para>
                                The <parameter>name</parameter> parameter is
                                the name fo the new parameter. By convention,
                                the first character of a configuration option
                                is a hyphen (<literal>-</literal>), although
                                the configurable object makes no such restriction.
                            </para>
                            <para>
                                <parameter>defaultValue</parameter> specifies
                                the initial value given to this variable.
                                Careful thought about initial/default values
                                allows users to minimize the number of
                                configuration options they actually need to set.
                            </para>
                            <para>
                                <parameter>checker</parameter> and
                                <parameter>arg</parameter> specify the constraint
                                checking that is performed on a parameter when
                                the configuration script attempts to modify it.
                                <parameter>checker</parameter> is a function that
                                is expected to check the proposed new value for
                                validity.  <parameter>arg</parameter> is a
                                parameter that is passed, without interpretation,
                                to the checker.  See TYPE CHECKERS below for
                                more information about constraint checking.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>configure</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>std::string</type> <parameter>value</parameter>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Provides a new proposed <parameter>value</parameter>
                                to the configuration parameter <parameter>name</parameter>.
                                This method does not bypass constraint checks.
                                If the constraint check on the parameter fails,
                                a <type>std::string</type> error message exception
                                is thrown.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>addIntegerParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>defaultVal</parameter>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                This is a convenience method that adds a new
                                parameter,
                                <parameter>name</parameter>,
                                to the configuration database.
                                The <methodname>isInteger</methodname>
                                constraint checker is associated with
                                the parameter, however no range limits are
                                specified.
                            </para>
                            <para>
                                The <parameter>defaultVal</parameter> is
                                used as the initial value of the parameter>
                            </para>
                        </listitem>    
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type>
                            <methodname>addIntegerParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>low</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int </type> <parameter>high</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type>    <parameter>defaultVal</parameter>
                                <initializer>0</initializer>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Same as the previous method, however
                                <parameter>low</parameter> and <parameter>high</parameter>
                                constrain the range of the integer value.
                                If you require an asymmetric range you have two choices.
                                Use <methodname>addParameter</methodname> and
                                fill in the parameter struct for <methodname>isInteger</methodname>
                                appropriately, or use one of
                                <literal>INT_MAX, INT_MIN, UINT_MAX</literal>
                                for the appropriate limit.  These values
                                are defined in <literal>&lt;limits.h&gt;</literal>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type><methodname> addBooleanParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>bool</type> <parameter>defaultVal</parameter>
                                <initializer>true</initializer>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Adds a parameter <parameter>name</parameter>
                                whose value checked via
                                <methodname>isBool</methodname> to ensure
                                it is always a boolean value.
                                <parameter>defaultVal</parameter> is the
                                initial value given to the parameter.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type><methodname> addEnumParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>const char**</type> <parameter>pValues</parameter>
                            </methodparam>
                            <methodparam>
                                <type>std::string</type> <parameter>defaultValue</parameter>
                                <initializer>std::string(""))</initializer>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Adds a parameter <parameter>name</parameter>
                                whose type checker ensures that valid values
                                are constrained to be in the list of
                                strings in <parameter>pValues</parameter>.
                                The initial value of the parameter is
                                <parameter>defautltValue</parameter>
                            </para>
                            <para>
                                <parameter>pValues</parameter> is a null
                                terminated array of pointers to the legal strings.
                                These can be declared as shown below:
                            </para>
                            <informalexample>
                                <programlisting>
static const char* validEnums[] = {
"one", "two", "three", NULL
};
                                </programlisting>
                            </informalexample>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>addBoolListParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>unsigned</type> <parameter>size</parameter>
                            </methodparam>
                            <methodparam>
                                <type>bool</type> <parameter>defaultVal</parameter>
                                <initializer>true</initializer>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Adds a parameter <parameter>name</parameter> to
                                the configuration whose legal values are
                                lists of boolean parameters.  The list
                                is a fixed <parameter>size</parameter>.
                                The <parameter>defaultVal</parameter>
                                is the value that each element of the list is
                                initialized to.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>addBoolListParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>unsigned</type> <parameter>minLength</parameter>
                            </methodparam>
                            <methodparam>
                                <type>unsigned</type> <parameter>maxLength</parameter>
                            </methodparam>
                            <methodparam>
                                <type>bool</type> <parameter>defaultVal</parameter>
                                <initializer>true</initializer>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>defaultSize</parameter>
                                <initializer>-1</initializer>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Same as the previous method, however
                                the length of the list can vary between a
                                minimum length (<parameter>minLength</parameter>)
                                and a maximum length (<parameter>maxLength</parameter>).
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>addIntListParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>unsigned</type> <parameter>size</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>defaultVal</parameter>
                                <initializer>0</initializer>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Adds a parameter <parameter>name</parameter>
                                that is checked to ensure it consists of a
                                list of integer values.  The size of the list
                                is fixed at <parameter>size</parameter>.
                                The initial value of all elements of the list
                                is set to <parameter>defaultValue</parameter>.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>addIntListParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>unsigned</type> <parameter>minlength</parameter>
                            </methodparam>
                            <methodparam>
                                <type>unsigned</type> <parameter>maxLength</parameter>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>defaultVal</parameter>
                                <initializer>0</initializer>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>defaultSize</parameter>
                                <initializer>-1</initializer>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Same as the previous function however
                                the length of the list can vary between
                                <parameter>minlength</parameter> and
                                <parameter>maxLength</parameter> and the
                                list has an initial value of <parameter>defaultSize</parameter>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                                <methodsynopsis>
                                    <modifier></modifier>
                                    <type>void</type>
                                    <methodname>addIntListParam</methodname>
                                    <methodparam><type>std::string</type> <parameter>name</parameter></methodparam>
                                    <methodparam><type>int</type> <parameter>minvalue</parameter></methodparam>
                                    <methodparam><type>int</type> <parameter>maxvalue</parameter></methodparam>
                                    <methodparam><type>unsigned</type> <parameter>minlength</parameter></methodparam>
                                    <methodparam><type>unsigned</type> <parameter>maxlength</parameter></methodparam>
                                     <methodparam>
                                        <type>int</type> <parameter>defaultVal</parameter>
                                    </methodparam>
                                    <methodparam>
                                        <type>int</type> <parameter>defaultSize</parameter>
                                    </methodparam>       
                                    
                                    <exceptionname></exceptionname>
                                    <modifier></modifier>
                                </methodsynopsis>  
                        </term>
                        <listitem>
                            <para>
                                Same as the other <methodname>addIntListParam</methodname>
                                methods however <parameter>minvalue</parameter>
                                and <parameter>maxvalue</parameter>
                                place constraints on the value that can be given to each
                                element of the list.
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>addStringListParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>unsigned</type> <parameter>size</parameter>
                            </methodparam>
                            <methodparam>
                                <type>std::string</type><parameter>defaultVal</parameter>
                                <initializer>""</initializer>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Adds a parameter <parameter>name</parameter> that
                                is a list of <parameter>size</parameter>   strings. Initially
                                each element of the list will have the value
                                <parameter>defautlVal</parameter>
                            </para>
                        </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
                        <methodsynopsis>
                            <type>void</type> <methodname>addStringListParameter</methodname>
                            <methodparam>
                                <type>std::string</type> <parameter>name</parameter>
                            </methodparam>
                            <methodparam>
                                <type>unsigned</type> <parameter>minLength</parameter>
                            </methodparam>
                            <methodparam>
                                <type>unsigned</type> <parameter>maxLength</parameter>
                            </methodparam>
                            <methodparam>
                                <type>std::string</type> <parameter>defaultVal</parameter>
                                <initializer>""</initializer>
                            </methodparam>
                            <methodparam>
                                <type>int</type> <parameter>defaultLength</parameter>
                                <initializer>-1</initializer>
                            </methodparam>
                        </methodsynopsis>
                        </term>
                        <listitem>
                            <para>
                                Same as the previous method however the
                                length of the list can provide to a
                                <command>config</command> subcommand can be
                                between <parameter>minLength</parameter>
                                and <parameter>maxLength</parameter>. The initial
                                length will be <parameter>defaultLength</parameter>  .
                            </para>
                        </listitem>
                    </varlistentry>
             </variablelist>
        </refsect1>
        <refsect1>
          <title>
              UTILITY METHODS
          </title>
          <para>
              This section provides some simple
              utility methods.
          </para>
          <variablelist>
              <varlistentry>
                  <term>
                  <methodsynopsis>
                      <modifier>static</modifier> <type>isEnumParameter</type>
                      <methodname>makeEnumSet</methodname>
                      <methodparam>
                          <modifier>const</modifier>
                          <type>char**</type>
                          <parameter>values</parameter>
                      </methodparam>
                  </methodsynopsis>
                  </term>
                  <listitem>
                      <para>
                          Produces a data structure used
                          by the enumerated parameter checker
                          <methodname>isEnum</methodname>
                          decribing the legal options.
                          <parameter>values</parameter>
                          is an array of pointers to
                          acceptable strings.  The last pointer
                          must be a NULL value.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term>
                      <methodsynopsis>
                          <modifier>static</modifier>
                          <type>bool</type>
                          <methodname>>strToBool</methodname>
                          <methodparam>
                              <type>std::string</type>
                              <parameter>value</parameter>
                          </methodparam>
                      </methodsynopsis>
                      </term>
                      <listitem>
                          <para>
                              Converts a string to its
                              boolean representation or
                              throws a <type>std::string</type>
                              exception if the string does
                              not map to a bool.
                          </para>
                      </listitem>
                  </varlistentry>
          </variablelist>
  
          </refsect1>
          <refsect1>
            <title>
                TYPE CHECKERS
            </title>
            <para>
                A type checker is a function that can be passed to
                <methodname>addParameter</methodname> to check constraints on
                the value of a parameter. See below in BUILT IN TYPE CHECKERS
                for information about the constraint checkers that are
                available for drop in use.
            </para>
            <para>
                A type checker <function>myTypeChecker</function>
                function has the following signature:
            </para>
            <informalexample>
                <programlisting>
bool myTypeChecker(std::string name, std::string value, void* arg)
                </programlisting>
            </informalexample>
            <para>
                <parameter>name</parameter> is the name of the configuration
                parameter that is being checked.
            </para>
            <para>
                <parameter>value</parameter> is the proposed new string value
                for the parameter.
            </para>
            <para>
                <parameter>arg</parameter> is the
                <parameter>arg</parameter> parameter in the
                <methodname>addParameter</methodname> method.  While not always
                the case, this parameter usually is a pointer to some struct
                or object that further refines the constraint checking required.
                For example, for the <methodname>isInteger</methodname> pre-packaged
                checker, this parameter is a pointer to a struct that defines
                whichi limits should be checked and what those limit values
                are, where appropriate.
            </para>
            <para>
                Type checkers are supposed to return <literal>true</literal>
                if the constraints they are checking match,
                <literal>false</literal> otherwise.
            </para>
        </refsect1>
          <refsect1>
            <title>
                BUILT IN TYPE CHECKERS.
            </title>
            <para>
                A built in set of type checkers allows you to define the vast
                majority of parameters without any need to write your own
                type checking function.
            </para>
            <para>
                In the descriptions below, <parameter>arg</parameter>
                always refers to the <parameter>arg</parameter> parameter
                of the <methodname>addParameter</methodname> method. It will
                be referred to as the <firstterm>additional data</firstterm>
                parameter and described in the documentation for each
                checker.
            </para>
            <para>
                Note that all type checkers descdibed allow you to pass a
                <literal>NULL</literal> for the <parameter>args</parameter>
                parameter which means that the value of the
                parameter does not undergo any of the processing that is
                implied by the data normally pointed to by <parameter>arg</parameter>.
            </para>
            <variablelist>
                <varlistentry>
                    <term>
                <methodsynopsis>
                    <modifier>static</modifier><type>bool</type> <methodname>isInteger</methodname>
                    <methodparam>
                        <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <type>std::string</type> <parameter>value</parameter>
                    </methodparam>
                    <methodparam>
                        <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Checks that the proposed new value is a valid integer.
                        Optionally, depending on the <parameter>arg</parameter>
                        struct this function can also ensure that the
                        converted integer value of the new value meets
                        range constraints.
                    </para>
                    <para>
                        <parameter>arg</parameter> actually points to a
                        <type>Limits</type> which provides optional flags
                        and values to determine if a lower and/or an upper limit
                        should be checked and the limit values as well.
                        <type>Limits</type> is described fully in TYPES
                        below.
                    </para>
                </listitem>
            </varlistentry>
                <varlistentry>
                    <term>
                <methodsynopsis>
                    <modifier>static</modifier> <type>bool</type><methodname> isBool</methodname>
                    <methodparam>
                        <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <type>std::string</type> <parameter>value</parameter>
                    </methodparam>
                    <methodparam>
                        <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Type checker that determines if the proposed new value
                        has a valid conversion to a  <type>boolean</type>.
                        The <parameter>args</parameter> parameter is not used by
                        this checker.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <methodsynopsis>
                    <modifier>static</modifier> <type>bool</type><methodname> isEnum</methodname>
                    <methodparam>
                        <type>std::string</type><parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <type>std::string</type><parameter>value</parameter>
                    </methodparam>
                    <methodparam>
                        <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Ensures that the proposed new <parameter>value</parameter>
                        is an element of a set of allowed strings.  <parameter>args</parameter>
                        is actually a pointer to a <type>std::set&lt;std::string&gt;</type>
                        where the elements of that set are the allowed values of the
                        parameter.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <methodsynopsis>
                    <modifier>static</modifier> <type>bool</type><methodname> isFloat</methodname>
                    <methodparam>
                        <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <type>std::string</type> <parameter>value</parameter>
                    </methodparam>
                    <methodparam>
                        <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Requires that the proposed new parameter
                        <parameter>value</parameter> is a valid floating point
                        and optionally that it satisfies lower and/or upper
                        limit constraints.  The <parameter>arg</parameter>
                        parameter actually points to a
                        <type>FloatingLimits</type> struct.
                        See TYPES below for a description of that struct.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <methodsynopsis>
                    <modifier>static</modifier><type>bool</type>
                    <methodname>isList</methodname>
                    <methodparam>
                        <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <type>std::string</type><parameter> value</parameter>
                    </methodparam>
                    <methodparam>
                        <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This type checker requires that the proposed new
                        <parameter>value</parameter> is a valid Tcl list.
                        The <parameter>arg</parameter> parameter points to a
                        <type>isListParameter</type>.  This is described in
                        TYPES below.  The struct allows you to constrain the list
                        size as well as to provide an additional type checker
                        that is applied to each element of the list.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <methodsynopsis>
                    <modifier>static</modifier> <type>bool</type> <methodname>isBoolList</methodname>
                    <methodparam>
                        <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <type>std::string</type> <parameter>value</parameter>
                    </methodparam>
                    <methodparam>
                        <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This is a simplified version of the previous function
                        that ensures that each element of the list
                        <parameter>value</parameter>is a
                        valid boolean.  The <parameter>arg</parameter>
                        parameter points to a <type>ListSizeConstraint</type>
                        which, as described in TYPES below, allows you to
                        place constraints on the length of the list.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <methodsynopsis>
                    <modifier>static</modifier> <type>bool</type> <methodname>isIntList</methodname>
                    <methodparam>
                        <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <type>std::string</type> <parameter>value</parameter>
                    </methodparam>
                    <methodparam>
                        <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        A specialized version of <methodname>isList</methodname>
                        that checks that all elements of a list parameter
                        are unbounded integers.  <parameter>arg</parameter>
                        is actually a pointer to a <type>ListSizeConstraint</type>
                        that allows you to place constraints of the size of the
                        list.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
                <methodsynopsis>
                    <modifier>static</modifier> <type>bool</type> <methodname>isStringList</methodname>
                    <methodparam>
                        <type>std::string</type> <parameter>name</parameter>
                    </methodparam>
                    <methodparam>
                        <type>std::string</type> <parameter>value</parameter>
                    </methodparam>
                    <methodparam>
                        <type>void*</type> <parameter>arg</parameter>
                    </methodparam>
                </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Checks only that a parameter is a valid Tcl List
                        constrained by the sizes specified by the
                        <type>ListSizeConstraint</type> pointed to by
                        <parameter>arg</parameter>
                    </para>
                </listitem>
            </varlistentry>
            </variablelist>
          </refsect1>
           <refsect1>
              <title>TYPES</title>
             <para>
                This section describes the data types that are exported
                 by the <classname>CConfigurableObject</classname>.
                 To a large extent, these are parameters to
                 constraint/type checkers described in the previous
                 secition.
             </para>
             <variablelist>
                <varlistentry>
                    <term>typedef <type>std::vector&lt;std::pair&lt;std::string, std::string&gt; &gt;
                          ConfigurationArray</type>;
                    </term>
                    <listitem>
                        <para>
                          This type is returned from <methodname>getConfiguration</methodname>
                          It consists of an <type>std::vector</type>.  Each element
                          of the vector is a <type>std::pair</type>.   The
                          first element of the pair is a configuration parameter
                          name.  The second element of that pair is the
                          parameter value.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term> struct<type>limit</type></term>
                    <listitem>
                        <para>
                            Provides a struct that describes a single optional
                            limit. <varname>s_checkMe</varname> is a boolean
                            which is <literal>true</literal> if the
                            limit should be checked and
                            <varname>s_value</varname> is the limit value.
                        </para>
                        <para>
                            The Constructor <methodname>limit</methodname>
                            comes in two flavors.  Without a parameter it
                            initializes the struct so that <varname>s_checkme</varname>
                            is false.  With an integer parameter it initializes
                            <varname>s_checkme</varname> to <literal>true</literal>
                            and sets the limit value to the parameter value.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>typedef <type>std::pair&lt;limit, limit&gt;   Limits</type></term>
                    <listitem>
                        <para>
                            Defines a set of integer limits.  The first item in
                            the pair is the lower limit, the second item,
                            the upper limit.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>typedef <type>std::set&lt;std::string&gt; isEnumParameter</type></term>
                    <listitem>
                        <para>
                            A set of strings that constrain the legal values
                            of an enumerated parameter.
                            The <methodname>makeEnumSet</methodname> is a
                            conveniencde method that builds one of these
                            from a null terminated array of const char*
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>struct ListSizeConstraint</term>
                    <listitem>
                        <para>
                            Defines a constraint on the size of a list
                            parameter.  <varname>s_atLeast</varname>
                            is the smallest length the list can have,
                            <varname>s_atMost</varname> the longest length.
                            These values are inclusive so if you specify
                            <varname>s_atLeast</varname> = <varname>s_atMost</varname>,
                            the list will have a fixed length.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>struct <type>isListParameter</type></term>
                    <listitem>
                        <para>
                            Defines a fully constrained list.  The list size
                            is constrained by the <varname>s_allowedSize</varname>
                            field which is a <type>ListSizeConstraint</type>.
                            The contents of the list are constrainded by the
                            <varname>s_checker</varname> field which is
                            a <type>TypeCheckinfo</type> data item.
                        </para>
                        <para>
                            The <varname>s_checker</varname> is an
                            <type>std::pair</type> whose first elemnent
                            is a pointer to a typeChecker function and
                            whose second element is the user parameter
                            that is normally passed in to allow the type checker
                            to further constrain values.
                        </para>
                        <para>
                            Several constructors are supplied to help build
                            this structure:
                            <informalexample>
                                <programlisting>
  <constructorsynopsis>
    <methodname>isListParameter</methodname>
    <methodparam>
        <type>limit</type> <parameter>atLeast</parameter>
    </methodparam>
    <methodparam>
        <type>limit</type> <parameter>atMost</parameter>
    </methodparam>
    <methodparam>
        <type>TypeCheckInfo</type> <parameter>checker</parameter>
    </methodparam>
  </constructorsynopsis>
                                </programlisting>
                            </informalexample>
                            Allows you to specify the size limits and
                            <type>TypeCheckInfo</type> pair used to
                            initialize all of the fields.
                        </para>
                        <para>
                            <informalexample>
                                <programlisting>
  <constructorsynopsis>
    <methodname>isListParameter</methodname>
    <methodparam>
        <type>ListSizeConstraint</type> <parameter>limits</parameter>
    </methodparam>
    <methodparam>
        <type>TypeCheckInfo</type> <parameter>checker</parameter>
    </methodparam>
  </constructorsynopsis>
                                </programlisting>
                            </informalexample>
                            Provides a constructor you an use if  you already
                            have built up a <type>ListSizeConstraint</type>
                            that descsribes the constraints on the list size.
                        </para>
                        <para>
                            A default constructor is also provided that doe
                            <emphasis>no</emphasis> initialization of the
                            struct.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>struct <type>flimit</type></term>
                    <listitem>
                        <para>
                            This is analagous to the
                            <type>limit</type> described above, however
                            the <varname>s_value</varname> field is
                            a <type>float</type> rather than an
                            <type>int</type>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>typedef <type>?std::pair&lt;flimit, flimit&gt;</type> <varname>FloatingLimits</varname>;
                    </term>
                    <listitem>
                        <para>
                            Defines a pair of floating point limits that constrain
                            the value of a float parameter.
                        </para>
                    </listitem>
                </varlistentry>
             </variablelist>

           </refsect1>
           
        </refentry>
      <refentry id='vmusb3_ccontrolhardware'>
         <refmeta>
	   <refentrytitle id='vmusb3_ccontrolhardware_title'>CControlHardware</refentrytitle>
	   <manvolnum>3vmusb</manvolnum>
	 </refmeta>
	 <refnamediv>
	   <refname>CControlHardware</refname>
	   <refpurpose>Base class for slow controls drivers</refpurpose>
	 </refnamediv>
	 <refsynopsisdiv>
	   <synopsis>
	     #include &lt;CControlHardware.h&gt;
	     class <ooclass><classname>CControlHardware</classname></ooclass> {
             protected:
                 CControlModule* m_pConfig;
             public:
	         <constructorsynopsis>
		   <methodname>CControlModule</methodname>
		   <methodparam>
		     <type>std::string</type><parameter>name</parameter>
		   </methodparam>
		 </constructorsynopsis>
		 <methodsynopsis>
		   <type>CControlModule*</type> <methodname>getConifguration</methodname>
		   <void />
		 </methodsynopsis>
		 <methodsynopsis>
		   <modifier>virtual</modifier>
		   <type>void</type> <methodname>onAttach</methodname>
		   <methodparam>
		     <type>CControlModule&amp;</type> <parameter>configuration</parameter>
		   </methodparam>
		   <modifier> = 0</modifier>
		 </methodsynopsis>
		 <methodsynopsis>
		   <modifier>virtual</modifier>
		   <type>void</type> <methodname>Initialize</methodname>
		   <methodparam>
		     <type>CVMUSB&amp;</type> <parameter>vme</parameter>
		   </methodparam>
		   <modifier> = 0</modifier>
		 </methodsynopsis>
		 <methodsynopsis>
		   <modifier>virtual</modifier>
		   <type>std::string</type><methodname>Update</methodname>
		   <methodparam>
		     <type>CVMUSB&amp;</type> <parameter>vme</parameter>
		   </methodparam>
		 </methodsynopsis>
		 <methodsynopsis>
		   <modifier>virtual</modifier>
		   <type>std::string</type> <methodname>Set</methodname>
		   <methodparam>
		     <type>CVMUSB&amp;</type><parameter> vme</parameter>
		   </methodparam>
		   <methodparam>
		     <type>std::string</type> <parameter>parameter</parameter>
		   </methodparam>
		   <methodparam>
		     <type>std::string</type><parameter> value</parameter>
		   </methodparam>
		   <modifier>= 0</modifier>
		 </methodsynopsis>
		 <methodsynopsis>
		   <modifier>virtual</modifier>
                   <type>std::string</type><methodname>Get</methodname>
		   <methodparam>
		     <type>CVMUSB&amp;</type><parameter> vme</parameter>
		   </methodparam>
		   <methodparam>
		     <type>std::string</type> <parameter>parameter</parameter>
		   </methodparam>
		   <modifier> = 0</modifier>
		 </methodsynopsis>
		 <methodsynopsis>
		   <modifier>virtual</modifier>
		   <type>void</type> <methodname> clone</methodname>
		   <methodparam>
		     <modifier>const</modifier>
		     <type> CControlHardware&amp;</type> <parameter> rhs</parameter>
		   </methodparam>
		   <modifier>= 0</modifier>
		 </methodsynopsis>
		 <methodsynopsis>
		   <modifier>virtual</modifier>
		   <type>void</type> <methodname> addMonitorList</methodname>
		   <methodparam>
		     <type>CVMUSBReadoutList&amp;</type> <parameter> vmeList</parameter>
		   </methodparam>
		 </methodsynopsis>
		 <methodsynopsis>
		   <modifier>virtual</modifier>
		   <type>void*</type> <methodname>processMonitorList</methodname>
		   <methodparam>
		     <type>void*</type><parameter> pData</parameter>
		   </methodparam>
		   <methodparam>
		     <type>size_t</type><parameter> remaining</parameter>
		   </methodparam>
		 </methodsynopsis>
		 <methodsynopsis>
		   <modifier> virtual</modifier>
		   <type>std::string</type>
		   <methodname>getMonitoredData</methodname>
		   <void />
		 </methodsynopsis>
		 
	     };
           </synopsis>
         </refsynopsisdiv>
	 <refsect1>
	   <title>DESCRIPTION</title> 
	   <para>
	     <classname>CControlHardware</classname> is an abstract base class for
	     slow control drivers.  To build a driver one must build a concrete
	     derived class, a <classname>CModuleCreator</classname> and register 
	     them with the <classname>CModuleFactory</classname> which associates
	     a module type string with a creator.
	   </para>
	   <para>
	     The base class and its <classname>CControLModule</classname> take care
	     of configuration management, command dispatching and parameter marshalling
	     for the methods of this class.  This framework therefore frees people
	     writing controls support software from most tasks not directly related to
	     controlling their devices.
	   </para>
	   <para>
	     The driver framework supports get and set operations and these transparently 
	     interrupt data taking if active.  Thus a series of sets or gets performed
	     while data taking is active can take a substantial time as each get or set
	     will pause data taking, flush in-flight buffers, perform the operatin and then
	     resume data taking.
	   </para>
	   <para>
	     In addition to get and set operations, the driver supports using a periodically
	     triggered list to monitor device state.  This monitoring does
	     <emphasis>not</emphasis> impact data taking other than the time required to
	     execute the list.   This mechanism is normally used to support the recognition
	     of exceptional states in the hardware (e.g. trips in detector bias supplies).
	   </para>
	   <para>
	     Implementation of the set/get interface is mandatory (those methods are pure
	     virtual)  Implementation of the monitor list operations is optional, as there
	     are do-nothing default behaviors defined in this base class.
	   </para>
	 </refsect1>
        <refsect1>
            <title>METHODS</title>
            <variablelist>
                <varlistentry>
                    <term>
                        <constructorsynopsis>
                          <methodname>CControlModule</methodname>
                          <methodparam>
                            <type>std::string</type><parameter>name</parameter>
                          </methodparam>
                        </constructorsynopsis>
                    </term>
                    <listitem>
                        <para>
                            The base class constructor makes a correspondence between
                            the name of the module and the actual device.  Therefore
                            when you construct an object you should invoke this
                            base class constructor passing <parameter>name</parameter>
                            the name passed into your own constructor>
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                          <type>CControlModule*</type> <methodname>getConifguration</methodname>
                          <void />
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            Obtains the configuration object from the module.
                            Your own methods can refer directly to the
                            <varname>m_pConfig</varname> member variable.
                            See MEMBER DATA below for more information.
                        </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
                        <methodsynopsis>
                          <modifier>virtual</modifier>
                          <type>void</type> <methodname>onAttach</methodname>
                          <methodparam>
                            <type>CControlModule&amp;</type> <parameter>configuration</parameter>
                          </methodparam>
                          <modifier> = 0</modifier>
                        </methodsynopsis>
                    </term>
                    <listitem>
                        <para>
                            This method must be implemented by concrete classes.
                            It is invoked as a new module instance is being
                            put together internally and hooked into the
                            slow controls server.  <parameter>configuration</parameter>
                            is the coniguration object.  Its address should be
                            stored in <varname>m_pConfig</varname> (see
                            MEMBER DATA) below.
                        </para>
                        <para>
                            This method should also be used to define any
                            configuration options you need.  Normally drivers will
                            define at least an option to allow the hardware to be
                            located.  For modules with base addressing this is
                            normally an option named <option>-base</option>
       H                 </para>
                    </listitem>
                </varlistentry>
		<varlistentry>
		  <term>
                        <methodsynopsis>
                          <modifier>virtual</modifier>
                          <type>void</type> <methodname>Initialize</methodname>
                          <methodparam>
                            <type>CVMUSB&amp;</type> <parameter>vme</parameter>
                          </methodparam>
                          <modifier> = 0</modifier>
                        </methodsynopsis>
		  </term>
		<listitem>
		  <para>
		    Optional method that can be implemented by concrete sub-classes.
		    The method is intended to do one-time initialization of the hardware
		    being controlled by this driver.  <parameter>vme</parameter>
		    is a reference to a VMUSB controller object.  This object can
		    perform VME operations on behalf of the method or execute
		    <classname>CVMUSBReadoutLists</classname> this method builds.
		  </para>
		  <para>
		    If this method is not implemented the base class method does nothing.
		  </para>
		</listitem>
	      </varlistentry>
	      <varlistentry>
		<term>
                        <methodsynopsis>
                          <modifier>virtual</modifier>
                          <type>std::string</type><methodname>Update</methodname>
                          <methodparam>
                            <type>CVMUSB&amp;</type> <parameter>vme</parameter>
                          </methodparam>
			  <modifier>= 0</modifier>
                        </methodsynopsis>
		</term>
		<listitem>
		  <para>
		    This method must be implemented by concrete sub-classes.
		    It is intended for use by drivers that work with devices that have 
		    write only state.  The method is called by clients that want to
		    push shadow data out to the write only state of the device.  Typically,
		    a device of this sort would have an initialization file that
		    describes the desired initial state of the device.  The <methodname>Update</methodname>
		    often is a means to push that state out to the device when the GUI starts and
		    reads in the same initializationfile.
		  </para>
		</listitem>
	      </varlistentry>
              <varlistentry>
                <term>
                        <methodsynopsis>
                          <modifier>virtual</modifier>
                          <type>std::string</type> <methodname>Set</methodname>
                          <methodparam>
                            <type>CVMUSB&amp;</type><parameter> vme</parameter>
                          </methodparam>
                          <methodparam>
                            <type>std::string</type> <parameter>parameter</parameter>
                          </methodparam>
                          <methodparam>
                            <type>std::string</type><parameter> value</parameter>
                          </methodparam>
                          <modifier>= 0</modifier>
                        </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method must be implemented by concrete sub-classes.
                        The framework will call this in response to a request
                        by a client to make a setting for this instance of the driver.
                        The <parameter>vme</parameter> object is a
                        <classname>CVMUSB</classname> object that can be used to
                        perform individual VME operations or execute immediate
                        <classname>CVMUSBReadoutList</classname> objects
                        created and filled by this method.
                    </para>
                    <para>
                        <parameter>parameter</parameter> is a string that specifies
                        the name of the parameter the client wants to set.
                        The parameter names that are supported by a driver are
                        up to the driver and hardware specific.  If the
                        client requests a parameter that is not supoprted an
                        error should be returned.
                    </para>
                    <para>
                        The <parameter>value</parameter> parameter is the
                        new value requested by the client.  If this value is
                        not legal for the parameter (e.g. a string that is not
                        an integer for an integer parameter), an error should
                        be returned.
                    </para>
                    <para>
                        The return value of this method is a
                        <classname>std::string</classname>.  On successful
                        completion this should be the value <literal>OK</literal>.
                        On failure, this should be a string that begins with
                        the word <literal>ERROR</literal> and, after some whitespace
                        provides a human readable message describing the error.
                    </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                        <methodsynopsis>
                          <modifier>virtual</modifier>
                          <type>std::string</type> <methodname>Get</methodname>		   
                          <methodparam>
                            <type>CVMUSB&amp;</type><parameter> vme</parameter>
                          </methodparam>
                          <methodparam>
                            <type>std::string</type> <parameter>parameter</parameter>
                          </methodparam>
                          <modifier> = 0</modifier>
                        </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method must be implemented by a concrete class.
                        It is invoked by the framework when a client requests the
                        value of a parameter from this instance of the driver.
                    </para>
                    <para>
                        <parameter>vme</parameter> is a <classname>CVMUSB</classname>
                        object that can be used to perform simple VME operations
                        or execute <classname>CVMUSBReadoutList</classname> objects
                        created by this method. 
                    </para>
                    <para>
                        <parameter>parameter</parameter> is the name of a parameter
                        supported by the driver.  The parameter names that are supported by a driver are
                        up to the driver and hardware specific.  If the
                        client requests a parameter that is not supoprted an
                        error should be returned.
                    </para>
                    <para>
                        The return value of this method is a
                        <classname>std::string</classname>.  On successful
                        completion this should be the value <literal>OK</literal>.
                        On failure, this should be a string that begins with
                        the word <literal>ERROR</literal> and, after some whitespace
                        provides a human readable message describing the error.
                    </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                          <methodsynopsis>
                            <modifier>virtual</modifier>
                            <type>void</type> <methodname> clone</methodname>
                            <methodparam>
                              <modifier>const</modifier>
                              <type> CControlHardware&amp;</type> <parameter> rhs</parameter>
                            </methodparam>
                            <modifier>= 0</modifier>
                          </methodsynopsis>
                </term>
                <listitem>
                  <para>
                      This must be implemented by concrete subclasses.  It is a
                      virtual copy constructor in the sense that the state of the
                      <parameter>rhs</parameter> object must be copied to the state
                      of <varname>this</varname>
                  </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                        <methodsynopsis>
                          <modifier>virtual</modifier>
                          <type>void</type> <methodname> addMonitorList</methodname>
                          <methodparam>
                            <type>CVMUSBReadoutList&amp;</type> <parameter> vmeList</parameter>
                          </methodparam>
                        </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        This method need only be implemented by drivers for
                        devies that require continuous monitoring.
                        <parameter>vmeList</parameter> is a reference for
                        a <classname>CVMUSBReadoutList</classname> to which this
                        call must add appropriate operations to obtain the
                        data fromt he device that needs to be monitored.
                        See also <methodname>processMonitorList</methodname> and
                        <methodname>getMonitoredData</methodname>
                    </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                        <methodsynopsis>
                          <modifier>virtual</modifier>
                          <type>void*</type> <methodname>processMonitorList</methodname>
                          <methodparam>
                            <type>void*</type><parameter> pData</parameter>
                          </methodparam>
                          <methodparam>
                            <type>size_t</type><parameter> remaining</parameter>
                          </methodparam>
                        </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called for each execution of the monitor list built up
                        via <methodname>addMonitorList</methodname>.
                        <parameter>pData</parameter> points to the data
                        for this device from that list and
                        <parameter>remaining</parameter> is the number of bytes
                        of data remaining in that buffer.
                    </para>
                    <para>
                        The method must return a pointer to the first byte in
                        the buffer pointed to by <parameter>pData</parameter>
                        beyond the data returned by this driver's monitor list.
                    </para>
                </listitem>
              </varlistentry>
              <varlistentry>
                <term>
                        <methodsynopsis>
                          <modifier> virtual</modifier>
                          <type>std::string</type>
                          <methodname>getMonitoredData</methodname>
                          <void />
                        </methodsynopsis>
                </term>
                <listitem>
                    <para>
                        Called to return the most recently received data from
                        the driver's monitor list.  The data are encoded
                        as a string that must begin with the word
                        <literal>OK</literal>.  normally the remainder of the
                        string is whitespace separated followed by a well formed
                        Tcl list containing the data from the monitor list.
                    </para>
                    <para>
                        If the device does not use monitor lists the return
                        value should be <literal>ERROR</literal>
                    </para>
                </listitem>
              </varlistentry>
            </variablelist>
        </refsect1>
	<refsect1>
            <title>MEMBER DATA</title>
            <para>
            </para>
        </refsect1>
       </refentry>

      <refentry id="vmusb3-cvmusb-swig">
        <refmeta>
           <refentrytitle>cvmusb</refentrytitle>
           <manvolnum>3tcl</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>cvmusb</refname>
           <refpurpose>SWIG Tcl wrapping of <classname>CVMUSB</classname></refpurpose>
        </refnamediv>
    
        <refsynopsisdiv>
            <cmdsynopsis>
                <command>
package require cvmusb
                </command>
            </cmdsynopsis>
            <formalpara>
                <title>Device enumeration and identification</title>
                <para></para>
            </formalpara>   
          <cmdsynopsis>
            <command>
::cvmusb::CVMUSB_enumerate
            </command>
          </cmdsynopsis>
          <cmdsynopsis>
            <command>
::cvmusb::usb_device_vector_get <replaceable>enumeration i</replaceable>
            </command>
          </cmdsynopsis>
        <cmdsynopsis>
        <command>
::cvmusb::usb_device_vector_size <replaceable>enumeration</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
        <command>
::cvmusb::CVMUSB_serialNo  <replaceable>usbdevice</replaceable>
            </command>
        </cmdsynopsis>
        
        <formalpara>
            <title>Construction</title>
            <para></para>
        </formalpara>
        <cmdsynopsis>
        <command>
::cvmusb::CVMUSBusb <replaceable>name usbdevice</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
        <command>
::cvmusb::CVMUSBusb <replaceable>name</replaceable> -this <replaceable>usb-object-ptr</replaceable>
            </command>
        </cmdsynopsis>
        <formalpara>
            <title>VM-USB register operations</title>
            <para></para>
        </formalpara>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readBulkXferSetup
            </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
<replaceable>object</replaceable> readDAQSettings
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readDGG_A
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readDGG_B
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readDGG_Extended
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readDeviceSource
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readFirmwareID
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readGlobalMode
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readIrqMask
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readLEDSource
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readScalerA
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readScalerB
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readVector
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeActionRegister <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeBulkXferSetup <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeDAQSettings <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeDGG_A <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeDGG_B <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeDGG_Extended <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeDeviceSource <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeGlobalMode <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeIrqMask <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeLEDSource <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeVector <replaceable>which value</replaceable>
            </command>
        </cmdsynopsis>
        <formalpara>
            <title>VME operations</title>
            <para></para>
        </formalpara>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeBlockRead <replaceable>base amod xfers</replaceable>
            </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
<replaceable>object</replaceable> vmeFifoRead <replaceable>base amod xfers</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeRead16 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeRead32 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeRead8 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeReadBlockCount16 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeReadBlockCount32 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeReadBlockCount8 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeVariableBlockRead  <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeVariableFifoRead  <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeWrite16 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeWrite32 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeWrite8 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
        <formalpara>
            <title>List operations</title><para></para>
        </formalpara>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> executeList <replaceable>list maxbytes</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> loadList    <replaceable>number list offset</replaceable>
            </command>
        </cmdsynopsis>
        <formalpara>
            <title>Miscellaneous operations.</title><para></para>
        </formalpara>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> setDefaultTimeout <replaceable>ms</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
::cvmusb::getuint16 <replaceable>uint16</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
::cvmusb::string_to_char <replaceable>std_string</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
::cvmusb::uint32_vector_get <replaceable>std_uint32_vector i</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
::cvmusb::uint32_vector_size <replaceable>std_uint32_vector</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
::cvmusb::uint8_vector_get <replaceable>std_uint8_vector i</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
::cvmusb::uint8_vector_size <replaceable>std_uint8_vector</replaceable>
            </command>
        </cmdsynopsis>
        
        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
                This package provides a tcl interface to the
                <classname>CVMUSB</classname> class described in
                <link linkend='vmusb3-CVMUSB' >CVMUSB(3)</link>.
                See COMMANDS below for more information.
           </para>
        </refsect1>
        <refsect1>
           <title>
              COMMANDS
           </title>
            <formalpara>
                <title>Device enumeration and identification</title>
                <para>
                    The commands in this section are used to determine the
                    set of VM-USB controllers attached to the host and
                    identify them by serial number.
                </para>
            </formalpara>

           <variablelist>
            <varlistentry>
                <term>
          <cmdsynopsis>
            <command>
::cvmusb::CVMUSB_enumerate
            </command>
          </cmdsynopsis>
          </term>
                <listitem>
                    <para>
                        Enumerates the set of VM-USB devices that are
                        attached to and powered up on the host.  The result
                        of this command is <type>usb_device_vector</type>.
                        You can think of this as a sort of an array with integer
                        indices whose elements represent a single VM-USB device.
                        See below for commands that can manipulate this vector.
                    </para>
                </listitem>
            </varlistentry>
            <varlistentry>
                <term>
          <cmdsynopsis>
            <command>
::cvmusb::usb_device_vector_get <replaceable>enumeration i</replaceable>
        </command>
          </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Given the result of the <command>::cvmusb::CVMUSB_enumerate</command>
                command <parameter>enumeration</parameter>   and an integer
                index <parameter>i</parameter>, returns a single element
                of the enumerated device set.  The return value is of type
                <type>usb_device</type> and can be passed to the constructor,
                to create a controller object that talks to this device or to
                <command>cvmusb::CVMUSB_serialNo</command> to get the device's
                serial number string.
                </para>
                </listitem>
                </varlistentry>
          <varlistentry>
            <term>
        <cmdsynopsis>
        <command>
::cvmusb::usb_device_vector_size <replaceable>enumeration</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Given a <parameter>enumeration</parameter> gotten from
                <command>::cvmusb::CVMUSB_enumerate</command>,
                returns the number of elements in that array.  The array is
                indexed from 0.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
        <command>
::cvmusb::CVMUSB_serialNo  <replaceable>usbdevice</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Given a <parameter>usbdevice</parameter> returned from
                <command>::cvmusb::usb_device_vector_get</command>
                Returns the serial number string.  Note that this is not
                immediately usable but must be converted to a Tcl string
                via a call to
                <command>::cvmusb::string_to_char</command>
                described below.
                </para>
                </listitem>
            </varlistentry>
           </variablelist>
        <formalpara>
            <title>Construction</title>
            <para>
                This set of commands is used to construct CVMUSB objects.
                The return value of these constructors is a command. The
                command can be either explicitly named by the
                <parameter>name</parameter> parameter in each of these
                constructors or you can use the name <literal>%AUTO</literal>
                to allow constructors to generate a unique object command
                name.
            </para>
        </formalpara>
        <variablelist>
        <varlistentry>
            <term>
        <cmdsynopsis>
        <command>
::cvmusb::CVMUSBusb <replaceable>name usbdevice</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Creates a new CVMUSBusb object given a <parameter>usbdevice</parameter>
                gotten from
                <command>::cvmusb::usb_device_vector_get</command>.
                This results in a new command <parameter>name</parameter> unless
                <parameter>name</parameter> is the special value
                <literal>%AUTO</literal>, in which case a unique name will be
                assigned the object. To construct a CVMUSB-type object to control
                a locally connected usb, this CVMUSBusb constructor must be used rather than 
                a CVMUSB because the C++ CVMUSB base class is abstract and cannot be instantiated.
                SWIG therefore does not produce a cvmusb::CVMUSB constructor. With that said, 
                the object produced by this command will inherit the functionality of the
                cvmusb::CVMUSB type.
                </para>
            <para>
                Naturally if you use <literal>%AUTO</literal> as the name
                 you must capture the actual name in a Tcl variable e.g.:
            </para>
            <informalexample>
                <programlisting>
set controller [::cvmusb::CVMUSBusb %AUTO $device]
$controller <replaceable>some method</replaceable>
                </programlisting>
            </informalexample>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
    <cmdsynopsis>
        <command>
::cvmusb::CVMUSB <replaceable>name</replaceable> -this <replaceable>usb-object-ptr</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Constructs a VMUSB object given a <replaceable>usb-object-ptr</replaceable>
                    object pointer.  This is normally used to wrap a pointer to a C++
                    underlying object passsed into a method from compiled code
                    (e.g in the Tcl driver <methodname>Initialize</methodname> method).
                    </para>
                    </listitem>
                    </varlistentry>
        </variablelist>
        <formalpara>
            <title>VM-USB register operations</title>
            <para>
                These methods all require a constructed VM-USB object
                <parameter>object</parameter> and write internal registers
                of the VM-USB.  It is beyond the scope of this document to fully
                describe these registers.  For each method, therefore, a high level
                description will be given along with the VM-USB reference manual
                section that does fully describe the register.
            </para>
        </formalpara>
        <variablelist>
        
        <varlistentry>
            <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readBulkXferSetup
            </command>
    </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Returns the current value of the USB Bulk transfer register.
                This register is described in section 3.4.10.  It can be used
                to tune performance of the USB interface by setting the number
                of buffers that can be streamed without a packet end signal.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
    <cmdsynopsis>
        <command>
<replaceable>object</replaceable> readDAQSettings
            </command>
        </cmdsynopsis>
    </term>
    <listitem>
        <para>
            Returns the current value of the Data acquisition settings register.
            This register is described in section 3.4.3 of the VM-USB manual.
            It contains bit fields that control the way in which the scaler stack
            is trigggered and the delay between a trigger and stack start.
            Note that within the VM-USB readout framework, this register is
            programmed by the framework at the start of each run.  You will
            only need to program this register if you are building pure Tcl
            applications with the VM-USB.
            </para>
            </listitem>
            </varlistentry>
            <varlistentry>
                <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readDGG_A
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Reads the contents of the VM-USB A gate and delay generator.
                The VM-USB has two internal Gate and delay generators named
                A and B.  Section 3.4.6 describes the registers that control
                these resources. The
                bit fields in this register control the gate width and delay of
                the A gate and delay generator.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readDGG_B
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as <command>readDGGG_A </command> but the register
                for the B gate and delay register is read.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readDGG_Extended
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Returns the value of the extended gate and delay generator
                register.  This supplies high order bits for the delay values
                for both the A and B DGG's.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readDeviceSource
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Reads the device source register.  This register, described in
                section 3.4.5 defines the sources for the the NIM outputs, the
                internal scalers and the starts for the gate generators.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readFirmwareID
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Returns the current firmware revision level of the controller.
                The bit fields of this register are defined in section 3.4.1 of
                the VM-USB manual.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readGlobalMode
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Reads the module's global mode register
                (see VM-USB manual secgtion 3.4.2).  This register sets the
                VME bus request level, as well as several data acquisition
                options.
                </para>
                    </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readIrqMask
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
 
                            This reads a shadow regiseter that remembers
                            the last value written to the VM-USB's
                            interrupt request mask register (see
                            section 3.5 of the VM-USB manual).  This is
                            a write only register.  Therefore, when you
                            create a <classname>CVMUSB</classname> object,
                            the value of the register is set to all ones which
                            disables all interrupts.  Remember to set interrupt
                            enable bits if you use interrupt triggered stacks.
                
                </para>
                </listitem>
                </varlistentry>
             <varlistentry>
                <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readLEDSource
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Reads the LED source selectors register.  This is described in
                section 3.4.4 of the VM-USB manual.  The registser allows you to
                determine the cirumstances which light each of the four LED's on
                the VM-USB front panel.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readScalerA
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                The VM-USB has a pair of 32 bit scalers, Scaler A and B.
                These are descsribed in section 3.4.7 of the VM-USB manual.
                This method returns the value of scaler A's counter.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readScalerB
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                The VM-USB has a pair of 32 bit scalers, Scaler A and B.
                These are descsribed in section 3.4.7 of the VM-USB manual.
                This method returns the value of scaler B's counter.
                   </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> readVector <replaceable>which</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Reads the value of the interrupt vector register designated
                by <parameter>which</parameter>
                The vector registers are described in section 3.4.8 of the VM-USB
                Manual.  The VM-USB supports triggering stacks as a result of
                an interrupt on the VME bus.  To do this, an interrupt service vector
                register must be programmed with the IPL, the vector and stack id.
                The interrupt sevice vectors are in pairs numbered <literal>1-4</literal>.
                This function returns one of those pairs.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeActionRegister <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Writes the <parameter>value</parameter> to the action register.
                This register is responsible for starting data acquisition
                mode and can be used to trigger lists.  It is a write only register
                that is described in section 3.1 of the VM-USB manual.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeBulkXferSetup <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Writes <parameter>value</parameter> to the bulk transfer setup
                register described in section 3.4.10 of the VM-USB manual.
                This register allows sophisiticated users to optimize the
                bandwidth of the USB during event data transfer.
                </para>
                </listitem>
                </varlistentry>
       
            <varlistentry>
                <term>
                <cmdsynopsis>
                   <command>
               <replaceable>object</replaceable> writeDAQSettings <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
 
            </term>
            <listitem>
                <para>
                    Writes <parameter>value</parameter> to the data
                    acquisition settings register described in sectino
                    3.4.3 of the VM-USB manual.  TYhat register allows
                    you to determine how the scaler stack is triggered as well
                    as the delay betrweena stack trigger and the start of
                    stack execution.
                    </para>
                    </listitem>
                    </varlistentry>
            <varlistentry>
                <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeDGG_A <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Writes <parameter>value</parameter> to the A delay and gate
                generator.  The gate and delay generator registers are
                described in section 3.4.6 of the VM-USB manual.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeDGG_B <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as above but writes to the B delay and gate generator
                register.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeDGG_Extended <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Writes the gate and delay extended delay register. This is
                provides the ability to run very long delays.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeDeviceSource <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Writes <parameter>value</parameter> to the users device
                sources selection register described in section 3.4.5 of the
                VM-USB manual.  This determines what is gated to the
                NIM 0/1 outputs, the Scaler inputs and the gate and delay
                generator inputs.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeGlobalMode <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Writes <parameter>value</parameter> to the global mode
                register described in section 3.4.2 of the VM-USB manual.  This
                sets a variety of data acquisition parameters as well as
                the VM-USB bus request level.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeIrqMask <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Writes the interrupt request mask register.  This register is
                desacribed in section 3.5 and describes the set of interrupt
                priority levels the VM-USB responds to.  See also
                <methodname>writeVector</methodname>.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeLEDSource <replaceable>value</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Writes
                <parameter>value</parameter>
                the LED source register described in section 3.4.4 of the
                VM-USB manual.  This register determines the conditions under
                which the four programmable LEDS on the front panel of the
                VM-USB light.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> writeVector <replaceable>which value</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Writes one of the four vector registers (numbered
                <literal>[1-4]</literal>) described in section 3.4.8.  These
                allow stacks to be triggered by specific VME interrupts.
                Note that at present there is no support to write the
                interrupt extension bits registers as virtually all VME
                interrupters use 8-bit vectors.
                </para>
                </listitem>
                </varlistentry>
        </variablelist>
        <formalpara>
            <title>VME operations</title>
            <para>
                This section describes the methods that perform VME
                actions.  Single shot read operations return the value
                read, howver block reads return an std::vector which
                requires further calls to obtain the actual number
                of items read and to fish out individual items.
            </para>
        </formalpara>
            <para>
                VME operations target an address within an address space.
                The address space is seleted by what in VME parlance is
                called an <firstterm>address modifier</firstterm>.
                A table of address modifiers is available on the Wikipedia
                article describing the VME bus:
                <ulink url='http://en.wikipedia.org/wiki/VMEbus'>
                    http://en.wikipedia.org/wiki/VMEbus</ulink>.
            </para>
            <para>
                The documentation that describes each module describes the
                set of address modifiers it supports.  Modules occupy an
                address space whose base is generally configured by switches,
                jumpers or rotary switches.  The module documentation will describe
                both the size and contents of its address space as well as
                how the base address is determined.
            </para>
        <variablelist>
        <varlistentry>
        <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeBlockRead <replaceable>base amod xfers</replaceable>
            </command>
    </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Performs a block read from the the VME bus. The source is
                determined by the <parameter>base</parameter> address and
                the address  modifier (<parameter>amod</parameter>).
                At most <parameter>xfers</parameter> transfers will be performed.
                The block transfer may terminate prematurely if a bus error
                occurs during the transfer.
                </para>
            <para>
                The result of the block read is returned as an item that is
                encapsulates a <type>std::vector&lt;uint32_t&gt;</type>.
                See <methodname>::cvmusb::CVMUSB_uint32_vector_size</methodname>
                which will return the actual number of transfers performed.
                <methodname>::cvmusb::CVMUSB_uint32_vector_get</methodname>
                allows you to extract individual values from the data
                returned.
            </para>
            <para>
                Suitable address modifiers force the VME bus to run in
                <firstterm>block transfer mode</firstterm>. In that mode,
                Addresses cycles are only performed infrequently with the
                source device keeping track of the offset from the last address
                cycle.  If the module providing the data supports block transfer
                address modifiers, substantial peformance gains can be had
                by using it.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
    <cmdsynopsis>
        <command>
<replaceable>object</replaceable> vmeFifoRead <replaceable>base amod xfers</replaceable>
            </command>
        </cmdsynopsis>
    </term>
    <listitem>
        <para>
            This method is the same as <methodname>vmeBlockRead</methodname>
            however all address cycles assert the <parameter>base</parameter>
            address. This makes the operation suitable for address blocks
            that actually implement FIFO memories.
        </para>
        <para>
            Consider, for example the
            data buffer address block of a large group of CAEN 32 bit
            digitizers run in multi-event mode read out via a chained block
            transfer.  If a block read is used to read this module, it is possible
            for the address to increment off the end of the window that is
            recognized as the data buffer.  Using a FIFO read ensures this
            cannot happen.
            </para>
            </listitem>
            </varlistentry>
            <varlistentry>
                <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeRead16 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Performs a single 16 bit transfer from <parameter>address</parameter>
                in the address space selected by <parameter>amod</parameter>
                The result of the command is word that was read.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeRead32 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as <methodname>vmeRead16</methodname> however a 32
                bit read is performed.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeRead8 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as <methodname>vmeRead16</methodname> however a 16 bit
                read is performed.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeReadBlockCount16 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                The VM-USB provides the ability to do a variable sized block read.
                When using this facility you first perform a VME read operation
                to obtain the number of transfers in the block read.
                You then perform the block read itself
                </para>
            <para>
                The block read count is a field in the data transferred from
                the VME <parameter>address</parameter>/<parameter>amod</parameter>
                specified by a <parameter>mask</parameter>.  This method performs
                an 16 bit read from the VME bus and uses the
                <parameter>mask</parameter> provided to determine which bits
                constitute the transfer size.  The resulting block transfer
                size is saved for the variable block transfer operation which
                should immediately follow.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeReadBlockCount32 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as <methodname>vmeReadBlockCount16</methodname> however
                the read is 32 bits wide.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeReadBlockCount8 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as <methodname>vmeReadBlockCount16</methodname> however
                the data transfer is 8 bits wide.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeVariableBlockRead  <replaceable>address mask maxcount</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Performs a variable block read whose transfer count was
                determined by one of the previous three methods.
                The transfer base address is specified by
                <parameter>address</parameter>/<parameter>amod</parameter>.
                <parameter>maxcount</parameter> is used to allocate aninternal
                buffer fro the transfer and can further limit the number of
                transfers.  The return value from this method is the same as
                a return value from <methodname>vmeBlockRead</methodname>
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeVariableFifoRead  <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as <methodname>vmeVariableBlockRead</methodname> however
                all address cycles provide <parameter>address</parameter> as
                the address making this suitable as a block read froma  FIFO.
                The return value is the same as from
                <methodname>vmeBlockRead</methodname>.
                </para>
                </listitem>
                </varlistentry>
             <varlistentry>
                <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeWrite16 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Performs a single shot 16 bit write of <parameter>data</parameter>
                to the VME target specified by
                <parameter>address</parameter>/<parameter>amod</parameter>.
                The least significant bits of <parameter>data</parameter>
                are written.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeWrite32 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as <parameter>vmeWrite16</parameter> however 32bits of
                <parameter>data</parameter> are written.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> vmeWrite8 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as vmeWrite16, however only the least significant 8 bits
                of <parameter>data</parameter> are written.
                </para>
                </listitem>
                </varlistentry>
        </variablelist>
        <formalpara>
            <title>List operations</title>
            <para>
                The VM-USB allows you to build and execute lists of VME
                operations.  These are built up using
                cvmusbreadoutlist.  Lists can also be downloaded for
                execution in data acquisition mode when triggered.
            </para>
        </formalpara>
        <variablelist>
        <varlistentry>
            <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> executeList <replaceable>list maxbytes</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Executes a list of instructions.  <parameter>list</parameter>
                is a <classname>cvmusbreadoutlist</classname> object or pointer.
                <parameter>mabytes</parameter> is the maximum number of
                bytes of data that miight be returned from this list as a result
                of the reado operations it contains.   This is used to size
                an internal buffer into which that data are accepted.
                </para>
            <para>
                The return value from this command is a
                <type>std::vector&lt;uint8_t&gt;</type>.
                See <methodname>cvmusb::CVMUSB_uint8_vector_size</methodname>
                and <methodname>cvmusb::CVMUSB_uint8_vector_get</methodname>
                for information about how to get data ouf of this object.
            </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> loadList    <replaceable>number list offset</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Loads a list into the VM-USB for execution in response to a trigger
                in data taking mode.
                <parameter>list</parameter> is a <classname>cvmusbreadoutlist</classname>
                object.  <parameter>number</parameter> is the stack number and
                must be in the range <literal>[0..7]</literal>.
                <parameter>offset</parameter> is the memory offset at which
                the list should be loaded.  See
                <classname>CVMUSB</classname>::<methodname>loadList</methodname>
                for information about how to compute this.
                </para>
                </listitem>
                </varlistentry>
        </variablelist>
        <formalpara>
            <title>Miscellaneous operations.</title>
            <para>
                This section describes methods that don't fit into a convenient
                category.  Many of these are static methods that provide
                impedance matching between the data types in use in the
                <classname>CVMUSB</classname> underlying class ansd Tcl data types.
            </para>
        </formalpara>
        <variablelist>
        <varlistentry>
            <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> setDefaultTimeout <replaceable>ms</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Sets the default timeout of VM-USB operations as
                <parameter>ms</parameter> milliseconds.  This timeout is
                used to define how long most of the methods in this
                section will wait for a response from the VM-USB before
                giving up. It is ONLY valid to call with a cvmusb::CVMUSBusb
                object.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
::cvmusb::getuint16 <replaceable>uint16</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Given a <type>uint16_t</type>
                Returns an integer that has the same value  This is needed
                because SWIG thinks that <type>uint16_t</type> is some
                fancy object type and will not allow it to be shimmered
                to an int.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
::cvmusb::string_to_char <replaceable>std_string</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Given an <type>std::string</type>, returns a string that
                Tcl can deal with.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
::cvmusb::uint32_vector_get <replaceable>std_uint32_vector i</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Given a <type>std::vector&lt;uint32_t&gt;</type>
                (<parameter>std_uint32_vector</parameter>) returns
                element <parameter>i</parameter>.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
::cvmusb::uint32_vector_size <replaceable>std_uint32_vector</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Given <parameter>std_uint32_vector</parameter> a
                <type>std::vector&lt;uint32_t&gt;</type> returns
                the number of elements it contains.  Elements
                are indexed from zero.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
::cvmusb::uint8_vector_get <replaceable>std_uint8_vector i</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as
                <methodname>::cvmusb::uint32_vector_get</methodname> but
                <parameter>std_uint8_vector</parameter> is a
                <type>std::vector&lt;uint8_t&gt;</type>.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
::cvmusb::uint8_vector_size <replaceable>std_uint8_vector</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Same as <methodname>::cvmusb::uint32_vector_size</methodname>
                but <parameter>std_uint8_vector</parameter>
                is a <type>std::vector&lt;uint8_t&gt;</type>
                </para>
                </listitem>
                </varlistentry>
        

           </variablelist>
        </refsect1>

      </refentry>
            <refentry id="vmusb3-cvmusbreadoutlist-swig">
              <refmeta>
                 <refentrytitle>cvmusbreadoutlist</refentrytitle>
                 <manvolnum>3tcl</manvolnum>
              </refmeta>
              <refnamediv>
                 <refname>cvmusbreadoutlist</refname>
                 <refpurpose>SWIG wrappers for <classname>CVMUSBReadoutList</classname>
                 </refpurpose>
              </refnamediv>
              
              <refsynopsisdiv>

                <formalpara>
                    <title>Construction</title>
                    <para></para>
                </formalpara>
                     <synopsis>
                <cmdsynopsis>
                    <command>
::cvmusbreadoutlist::CVMUSBReadoutList <replaceable>name</replaceable>
            </command>
            </cmdsynopsis>
                <cmdsynopsis>
                    <command>
::cvmusbreadoutlist::CVMUSBReadoutList <replaceable>name</replaceable> -this <replaceable>ptr</replaceable>
            </command>
            </cmdsynopsis>
                     </synopsis>
            <formalpara>
                <title>Simple VME/register operations</title>
                <para></para>
            </formalpara>
            <synopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRead16 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRead32 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRead8 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRegisterRead <replaceable>address</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRegisterWrite <replaceable>address data</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addWrite16 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addWrite32 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addWrite8 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
            </synopsis>
            <formalpara>
                <title>Block transfer operations</title>
                <para></para>
            </formalpara>
            <synopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addBlockRead32 <replaceable>base amod transfers</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addFifoRead16 <replaceable>address amod transfers</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addFifoRead32 <replaceable>address amod transfers</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addMaskedCountBlockRead32 <replaceable>base amod</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addMaskedCountFifoRead32 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addBlockCountRead16 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addBlockCountRead32 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addBlockCountRead8 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
            </synopsis>
        <formalpara>
            <title>Miscellaneous methods</title>
            <para></para>
        </formalpara>
        <synopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> addMarker <replaceable>value</replaceable>
            </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
<replaceable>object</replaceable> addDelay <replaceable>cycles</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> clear
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> get
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> size
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
::cvmusbreadoutlist::CVMUSBReadoutList_uint32_vector_get <replaceable>v i</replaceable>
            </command>
        </cmdsynopsis>
        <cmdsynopsis>
            <command>
::cvmusbreadoutlist::CVMUSBReadoutList_uint32_vector_size <replaceable>v</replaceable>
            </command>
        </cmdsynopsis>
        </synopsis>
        <formalpara>
            <title>Variables</title>
            <para></para>
            </formalpara>
    <synopsis>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a16Priv</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a16User</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24PrivBlock</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24PrivData</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24PrivProgram</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24UserBlock</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24UserData</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24UserProgram</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32PrivBlock</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32PrivData</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32PrivProgram</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32UserBlock</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32UserData</varname>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32UserProgram</varname>

     </synopsis>
              </refsynopsisdiv>
              <refsect1>
                 <title>DESCRIPTION</title>
                 <para>
                    This package encapsulates a <classname>CVMUSBReadoutList</classname>
                    class/object.  The class allows you to create instances
                    of VME operation lists.  Once created, you can add
                    operations to that list that can either be executed
                    immediately or stored fro execution in data taking mode
                    in response to an appropriate trigger.
                 </para>
                 <para>
                    For more information about this class and its methods,
                    see METHODS below.  The class also defines a set of
                    variables that contain the VME address modifier values.
                    See VARIABLES for information about those.
                 </para>
              </refsect1>
              <refsect1>
                 <title>
                    METHODS
                 </title>
                <formalpara>
                    <title>Construction</title>
                    <para>
                        Two construction mechanisms are provided.  The first
                        creates an empty list.  The second creates an object
                        that wraps itself around a pointer to an existing list.
                    </para>
                </formalpara>
                <para>
                    Constructed objects appear like a command ensemble who's
                    base command name is the <parameter>name</parameter> parameter
                    to the constructor command.  If the special name
                    <literal>%AUTO</literal> is specified, the constructor will
                    assign a unique name.  In all cases the base name of the
                    command ensemble (or object name) is returned by the constructor.
                </para>
                <variablelist>
                <varlistentry>
                    <term>
                <cmdsynopsis>
                    <command>
::cvmusbreadoutlist::CVMUSBReadoutList <replaceable>name</replaceable>
            </command>
            </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs an empty list object named <parameter>name</parameter>
                        (see the discussion above however).  The name of the object
                        is returned by this command.
                        </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
                <cmdsynopsis>
                    <command>
::cvmusbreadoutlist::CVMUSBReadoutList <replaceable>name</replaceable> -this <replaceable>ptr</replaceable>
            </command>
            </cmdsynopsis>
                </term>
                <listitem>
                    <para>
                        Constructs an object around an existing pointer to a
                        list object.  The name of the object is
                        <parameter>name</parameter> and <parameter>ptr</parameter>
                        is a SWIG type safe pointer.  Type-safe pointers are
                        just the address of a C++ object as a string that has
                        been decorated with information about the type of the
                        object.
                        </para>
                    <para>
                        A type-safe pointer to a readout list is passed to a Tcl
                        driver's <methodname>addReadoutList</methodname>
                        sub-command.
                    </para>
                        </listitem>
                        </varlistentry>
                </variablelist>
            <formalpara>
                <title>Simple VME/register operations</title>
                <para>
                    This group of methods add single shot VME operations
                    and register transfers to a list.  A VME operation is
                    specified by both an address and an address modifier.
                    The address modifier selects a specific address space.
                    See
                    <ulink url="http://en.wikipedia.org/wiki/VMEbus">
                        http://en.wikipedia.org/wiki/VMEbus</ulink>
                    for a table of address modifiers and their meaning.
                </para>
            </formalpara>
            <para>
                    <classname>cvmusbreadoutlist</classname> also defines
                    some variables that contain these address modifiers.
                    See VARIABLES below for a description of those
                    variables.
            </para>
            <variablelist>
            <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRead16 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a 16 bit read from the address and address modifier
                    specified by <parameter>address</parameter> and
                    <parameter>amod</parameter> respectively.  The data
                    are put in either the output buffer if the read is performed
                    by <methodname>cvmsub::executeList</methodname> or in the
                    event buffer if the list is triggered in data acquisition
                    mode.
                    </para>
                    </listitem>
                    </varlistentry>
            <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRead32 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addRead16</methodname> however the
                    data transfer width is 32 bits.  The list performs
                    the operation in little endian order.   That is the
                    low order part of the longword is placed in the
                    output/event buffer prior to the upper order bits.
                    </para>
                    </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRead8 <replaceable>address amod</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addRead16</methodname> however only
                    the data emitted consists of 8 bits of data in the low order
                    8 bits of a 16 bit word.
                    </para>
                    </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRegisterRead <replaceable>address</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a read of an internal register to the stack.
                    The <parameter>address</parameter> parameter specifies
                    which register to read.  This is a number that should be
                    taken from the table in section 3.4 of the VM-USB
                    manual.
                    </para>
                    </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addRegisterWrite <replaceable>address data</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a register write to the list.  <parameter>address</parameter>
                    specifies the register address (taken from the table in
                    section 3.4 of the VM-USB manual), <parameter>data</parameter>
                    is the value to write.
                    </para>
                    </listitem>
                    </varlistentry>
             <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addWrite16 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Writes the 16 bit <parameter>data</parameter> to the VME
                    location specified by <parameter>address</parameter>
                    and <parameter>amod</parameter>.  If there are bits set
                    above the least significant 16 bits of <parameter>data</parameter>,
                    they are ignored.
                    </para>
                    </listitem>
                    </varlistentry>
            <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addWrite32 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Same as for <methodname>addWrite16</methodname> however 32 bits of
                    <parameter>data</parameter> are written.
                    </para>
                    </listitem>
                    </varlistentry>
            <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addWrite8 <replaceable>address amod data</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addWrite16</methodname> however only the
                    least significant 8 bits are written.
                    </para>
                    </listitem>
                    </varlistentry>
            </variablelist>
            <formalpara>
                <title>Block transfer operations</title>
                <para>
                    The VM-USB is capable of several types of block transfer
                    operations.  If the address modifier is a block transfer
                    address modifier, the VM-USB will take advantage of that
                    mode of transfer.
                </para>
            </formalpara>
                <para>
                    VME block transfer operations allow a significant
                    improvment in performance by reducing the number of address
                    cycles asserted on the bus by the master.  Specifically,
                    in steady state operation, an address is only cycled on the
                    bus as the transfer address crosses a 256 byte address
                    boundary.  In between these boundaries, slave boards that
                    support block transfers are assumed to maintain counters
                    that keep track of the transfer offset within the 256 byte
                    page.
                </para>
                <para>
                    In addition to block transfer operations as described above,
                    the VM-USB also supports FIFO block transfers.   A FIFO
                    block transfer is just a block transfer that always asserts
                    the base address when an address cycle is required.
                </para>
                <para>
                    Finaly the VM-USB also supports block transfers whose
                    size depends on a bit field in a value read from the VME
                    bus.
                </para>
            <variablelist>
            <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addBlockRead32 <replaceable>base amod transfers</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a block read that is 32 bits wide tyo the stack.
                    The first transfer address is <parameter>base</parameter>,
                    transfers are all done with <parameter>amod</parameter> as
                    the address modifier.  <parameter>transfers</parameter>
                    operations are performed (transers*sizeof(uint32_t) bytes), unless
                    a transfer causes a bus error.
                    </para>
                <para>
                    If a transfer triggered a bus error, a <literal>0xffffffff</literal>
                    is placed in the output/event buffer and the transfer terminates.
                    Note that if the last transfer was a bus error and the data
                    in a successful transfer might have been a <literal>0xffffffff</literal>,
                    there is some ambiguity about how the transfer actually terminated.
                    If you expect that the tranfer might be terminated by a bus
                    error "normally", ber sure to specify a transfer count very
                    much in exceess of what you might reasonably expect to get.
                </para>
                    </listitem>
                    </varlistentry>
             <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addFifoRead16 <replaceable>base amod transfers</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a 16 bit FIFO read to the list.  All transfers are
                    performed from <parameter>base</parameter> with the
                    <parameter>amod</parameter> address modifier.
                    At most <parameter>transfers</parameter> transfers are performed.
                    In the even to of a bus error, a marker value;
                    <literal>0xffff</literal> will be inserted in the
                    read/event buffer, and the transfer will terminate.
                    </para>
                    </listitem>
                    </varlistentry>
            <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addFifoRead32 <replaceable>base amod transfers</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addFifoRead16</methodname> however
                    each read transfers 32 bits of data.
                    </para>
                    </listitem>
                    </varlistentry>
            <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addBlockCountRead16 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a 16 bit read that extracts the transfer count for the
                    next variable block read.   A 16 bit read is performed from
                    the location specified by <parameter>address</parameter> and
                    address modifier <parameter>amod</parameter>.  The
                    bits that are set in <parameter>mask</parameter> determine the final
                    actual value of the transfer count (bits set in
                    <parameter>mask</parameter> matter unset bits don't).
                    </para>
                    </listitem>
                    </varlistentry>
            <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addBlockCountRead32 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addBlockCount16</methodname> however
                    the tranfer is 32 bits wide.
                    </para>
                    </listitem>
                    </varlistentry>
        <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addBlockCountRead8 <replaceable>address mask amod</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addblockCountRead16</methodname> but the
                    transfer is 8 bits.
                    </para>
                    </listitem>
            </varlistentry>

             <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addMaskedCountBlockRead32 <replaceable>base amod</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Adds a variable block read operation to the VME operation
                    list.  The last block count read by one of the
                    <methodname>addBlockCountReadxxx</methodname> methods'
                    above is used as the transfer count.    The base address
                    of the transfer is <parameter>base</parameter>
                    and all transfers are done with the <parameter>amod</parameter>
                    address modifier.
                    </para>
                <para>
                    The normal rules for bus error termination of block transfers
                    apply.
                </para>
                    </listitem>
                    </varlistentry>
            <varlistentry>
                <term>
            <cmdsynopsis>
                <command>
<replaceable>object</replaceable> addMaskedCountFifoRead32 <replaceable>base amod</replaceable>
            </command>
        </cmdsynopsis>
            </term>
            <listitem>
                <para>
                    Same as <methodname>addMaskedCountBlockRead32</methodname>,
                    however any needed address cycles always place
                    <parameter>base</parameter> on the address bus.  This
                    makes this method usable to get data from a FIFO register.
                    </para>
                    </listitem>
                    </varlistentry>
        </variablelist>
        <formalpara>
            <title>Miscellaneous methods</title>
            <para>
                The methods in this section don't fit into any other category.
                Where the method is not a subcommand of a <parameter>object</parameter>
                it is a static method of the class.
            </para>
        </formalpara>
        <variablelist>
        <varlistentry>
            <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> addMarker <replaceable>value</replaceable>
            </command>
    </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Adds a command to put a literal marker for
                <parameter>value</parameter> in to the buffer/event.
                </para>
                </listitem>
                </varlistentry>
    <varlistentry>
        <term>
    <cmdsynopsis>
        <command>
<replaceable>object</replaceable> addDelay <replaceable>cycles</replaceable>
            </command>
        </cmdsynopsis>
    </term>
    <listitem>
        <para>
            Adds a delay to the list.  When this instruction is executed,
            stack execution stalls for <parameter>cycles</parameter> cycles where
            one cycle is 200ns.    The maximum wait time is 255 cycles, however
            you can insert more than one wait operation to get longer waits.
            </para>
            </listitem>
            </varlistentry>
        <varlistentry>
            <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> clear
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Clears the list
                </para>
                </listitem>
                </varlistentry>
         <varlistentry>
            <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> get
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Returns a vector to a uint32 where each vector element is one
                32 bit stack line.  See below for static methods to get
                information about/from this vector.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
<replaceable>object</replaceable> size
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Returns the number of 32 bit stack lines in the object.
                </para>
                </listitem>
                </varlistentry>
         <varlistentry>
            <term>
        <cmdsynopsis>
            <command>
::cvmusbreadoutlist::CVMUSBReadoutList_uint32_vector_get <replaceable>v i</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Given a vector <parameter>v</parameter> retrived from
                the <methodname>get</methodname> method tells you  how many
                elements it contains.
                </para>
                </listitem>
                </varlistentry>
                <varlistentry>
                    <term>
        <cmdsynopsis>
            <command>
::cvmusbreadoutlist::CVMUSBReadoutList_uint32_vector_size <replaceable>v</replaceable>
            </command>
        </cmdsynopsis>
        </term>
        <listitem>
            <para>
                Given a vector <parameter>v</parameter> gotten from
                <methodname>get</methodname> returns the nmber of 32 bit entities
                 in the vrctor.
                </para>
                </listitem>
                </varlistentry>
        </variablelist>
              </refsect1>
              <refsect1>
                <title>VARIABLES</title>
                <para>
                    The <classname>cvmusbreadoutlist</classname> class provides
                    several variables that define the various address modifiers
                    symbolcally:
                </para>
                <variablelist>
                    <varlistentry>
                        <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a16Priv</varname></term>
                        <listitem>
                            <para>
                                Defines the address modifier for 16 bit address
                                widths privilege access.  16 bit address space
                                is often refered to as shortio as  well.
                            </para>
                        </listitem>
                        </varlistentry>
                    <varlistentry>
                        <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a16User</varname></term>
                        <listitem>
                            <para>
                                Same as above, however accesses are in user
                                mode rather than privileged transfer mode.
                                </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24PrivBlock</varname></term>
                            <listitem>
                                <para>
                                    Defines the address modifier for A24
                                    privileged block transfers.  Block transfers
                                    are a mechanism the VME bus defines for
                                    reducing the number of address cycles required
                                    to transfer a contiguous block of data.
                                    </para>
                                <para>
                                    A24 bit addressing mode is also called
                                    standard addressing.
                                </para>
                            </listitem>
                            </varlistentry>
                            <varlistentry>
                                <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24PrivData</varname></term>
                                <listitem>
                                    <para>
                                        Defines the address modifier for 24
                                        bit wide addressing of privileged data.
                                        A24 address modes are also called
                                        standard addressing.
                                        </para>
                                </listitem>
                                </varlistentry>
                                <varlistentry>
                                    <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24PrivProgram</varname></term>
                                    <listitem>
                                        <para>
                                            Same as above, however the
                                            addressing is to privileged progfam space.
                                            </para>
                                    </listitem>
                                    </varlistentry>
                                    <varlistentry>
                                        <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24UserBlock</varname></term>
                                        <listitem>
                                            <para>
                                                Defines the address modifier for
                                                24 bit wide address block transfers.
                                                </para>
                                        </listitem>
                                        </varlistentry>
                    <varlistentry>
                        <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24UserData</varname></term>
                        <listitem>
                            <para>
                                Defines the address modifier for 24 bit wide
                                user data transfers.
                                </para>
                        </listitem>
                        </varlistentry>
                    <varlistentry>
                        <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a24UserProgram</varname></term>
                        <listitem>
                            <para>
                                Defines the address modifier for 24 bit wide
                                user program space.
                                </para>
                        </listitem>
                        </varlistentry>
                <varlistentry>
                    <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32PrivBlock</varname></term>
                    <listitem>
                        <para>
                            Defines the address modifier for 32 bit privileged
                            block transfers.
                            </para>
                    </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32PrivData</varname></term>
                        <listitem>
                            <para>
                                Defines the address modifier for 32 bit wide
                                privileged data transfers.  32 bit addressing is
                                sometimes called <firstterm>extended addressing</firstterm>.
                                </para>
                        </listitem>
                        </varlistentry>
                   <varlistentry>
                    <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32PrivProgram</varname></term>
                    <listitem>
                        <para>
                            Defines the address modifier for 32 bit privileged
                            program accesses.
                            </para>
                    </listitem>
                    </varlistentry>
                <varlistentry>
                    <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32UserBlock</varname></term>
                    <listitem>
                        <para>
                            Defines the address modifier for 32 bit user
                            block transfers.
                            </para>
                    </listitem>
                    </varlistentry>
                    <varlistentry>
                        <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32UserData</varname></term>
                        <listitem>
                            <para>
                                Defines the address modifier for 32 bit user
                                data transfers.
                                </para>
                        </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>
<varname>::cvmusbreadoutlist::CVMUSBReadoutList_a32UserProgram</varname></term>
                            <listitem>
                                <para>
                                    Defines the address modifier for 32 bit user
                                    program access.
                                    </para>
                            </listitem>
                            </varlistentry>
                </variablelist>
              </refsect1>               
      
            </refentry>
      <refentry id="vmusb3-Module">
        <refmeta>
           <refentrytitle>Module</refentrytitle>
           <manvolnum>3tcl</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>Module</refname>
           <refpurpose>control config command: create/configure modules.</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <synopsis>
          <cmdsynopsis>
          <command>
Module create <replaceable>type name</replaceable>
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
Module config <replaceable>name ?option value? ...</replaceable> 
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
Module cget <replaceable>name</replaceable>
                </command>
            </cmdsynopsis>
          </synopsis>
        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            This command is processed by the Tcl slow controls server when it
            processes the control configuration file.  It is used to create,
            configure and query the configuration of slow controls
            modules.
           </para>
           <para>
                The <command>create</command> subcommand creates a new module
                assigned the <parameter>name</parameter> by which it can be
                referred to by remote control panels, and the remainder of
                the cofiguration file.  The module will be of type
                <parameter>type</parameter>.  See MODULE TYPES below for
                information about the module types supported.
           </para>
           <para>
            The <command>config</command> subcommand configures the
            module <parameter>name</parameter>, setting the configuration
            options provided on the command line to the specified values.
            See MODULE TYPES below for information about the configuration
            options accepted by each module.
           </para>
           <para>
            The <command>cget</command> subcommand returns the configuration of
            the <parameter>name</parameter>ed module.  The configuration is
            returned as a list of pairs where each pair consists of the
            configuration parameter name and value.
           </para>  
        </refsect1>
        <refsect1>
           <title>
              MODULE TYPES
           </title>
            <para>
                This section describes the module types that are supported
                currently and the device specific configuration options and
                settable/readable parameters
                each supports.  Device support includes both the
                driver and a control panel for the device.
            </para>
            <refsect2>
                <title>jtecgdg</title>
                <para>
                    This module is actually a general purpose logic module.
                    The only support for it at this time is as a multi-channel
                    gate and delay generator.
                </para>
                <refsect3>
                    <title>Options</title>
                    <para>
                        The only option supported by the <literal>jtecgdg</literal>
                        is the <option>-base</option> option which sets the
                        VME base address for the module (must match the
                        rotary switch settings).
                    </para>
                </refsect3>
                <refsect3>
                    <title>Parameters</title>
                    <variablelist>
                        <varlistentry>
                            <term>delay<emphasis>n</emphasis></term>
                            <listitem>
                                <para>
                                    The delay register value for register n.
                                    There are 8 registers numbered
                                    <literal>[0..7]</literal>
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term>width<emphasis>n</emphasis></term>
                            <listitem>
                                <para>
                                    The width of channel <parameter>n</parameter>
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </refsect3>
            </refsect2>
            <refsect2>
                <title>caenv812/caen895</title>
                <para>
                    The CAEN V812 is a VME 16 channel constant fraction
                    disriminator while the V895 is a software compatible
                    leading edge discriminator.
                </para>
                <refsect3>
                    <title>Options</title>
                    <variablelist>
                        <varlistentry>
                            <term><option>-base</option></term>
                            <listitem>
                                <para>
                                    The value of this parameter is the base
                                    address of the module as set by the
                                    on-board rotary switches.
                                    </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><option>-file</option></term>
                            <listitem>
                                <para>
                                    The value of this parameter is the path to a
                                    configuration file whose contents are used to
                                    initialize the state of the device. Note
                                    that these modules are write-only so writing
                                    their initial state is the only way to put them
                                    into a known state.
                                </para>
                                <para>
                                    The contents of this file are described in
                                    <link linkend='manpage.caenv812config'>
                                        CAENV812Config(5)</link>
                                </para>
                            </listitem>
                        </varlistentry>
                    </variablelist>
                </refsect3>
                <refsect3>
                    <title>Parameters</title>
                    <variablelist>
                        <varlistentry>
                            <term><parameter>threshold</parameter>n</term>
                            <listitem>
                                <para>
                                    The threshold register value for
                                    channel <parameter>n</parameter>
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><parameter>width</parameter>i</term>
                            <listitem>
                                <para>
                                    The width register value for bank
                                    <parameter>i</parameter>.  The module
                                    is divided into two banks of 8 modules.
                                    the banks are numbered 0 and 1.
                                </para>
                            </listitem>
                        </varlistentry>
                        
                    </variablelist>
                </refsect3>
            </refsect2>
            <refsect2>
                <title>vmusb</title>
                <para>
                    This slow control module supports remote execution of
                    arbitrary VM-USB lists.  Full documentation of this facility
                    will be produced in a later version of this document.
                    The idea is, however that the module, which has no
                    configuration options, has exactly one parameter,
                    <literal>list</literal>
                </para>
                <para>
                    <literal>list</literal> is a set only parameter.  It's
                    value is a Tcl list.  The first element of thel ist specifies
                    the maximum input buffer size required by the list.
                    The second value of the list is a Tcl list containing
                    the VM-USB stack.  The Set operation executes the stack
                    and returns the text <literal>Ok - </literal> followed by a
                    Tcl list  whose elements are the bytes of data put in the
                    read buffer by the stack.
                </para>
            </refsect2>
            <refsect2>
              <title>mxdcrcbus</title>
              <para>
                This slow-controls module enables a Mesytec MxDC device to be used as a 
                proxy for the RC-bus protocol. The NIM busy output of the targeted 
                MxDC will be hijacked for this purpose. To use, clients of the slow-controls
                server can send Set and Get commands with appropriate
                arguments to the slow-controls server. The first argument should specify 
                the name of the mxdcrcbus slow-controls module to handle the request. 
                The second argument, i.e. the parameter name, will provide the device 
                number of the hardware on the rc-bus and address of the parameter 
                referred to in it. The device number, D, and parameter address, A, are to be encoded
                into a string of the form "dDaA". In other words, if an mxdcrcbus module
                was created with the name "mymod" and the user wanted to use it 
                to write the value 23 to a parameter 
                address 10 on the device whose number is 20, the client would write
                "Set mymod d20a10 23" to the slow-controls server. To read the value
                back, the client would write "Get mymod d20a10" to the slow-controls server.
              </para>
              <refsect3>
                <title>OPTIONS</title>
                <para>
                  The module supports only the <option>-base</option>
                  option which describes to the software the base address
                  of the Mesytec digitizer as encoded in the module's rotary
                  switches.
                </para>
              </refsect3>
            </refsect2>
            <refsect2>
              <title>mxdcreset</title>
              <para>
                This slow-controls module provides an on-demand soft reset. It also 
                clears the device's internal counters.
              </para>
              <refsect3>
                <title>OPTIONS</title>
                <para>
                  The module supports only the <option>-base</option>
                  option which describes to the software the base address
                  of the Mesytec digitizer as encoded in the module's rotary
                  switches.
                </para>
              </refsect3>
            </refsect2>

            <refsect2>
                <title>v6553</title>
                <para>
                    This is a CAEN bias supply controller.  It makes use of the
                    slow controls monitor facility to maintain an up-to-date
                    module state without interrupting data acquisition.
                </para>
                <refsect3>
                    <title>Options</title>
                    <para>
                        The module supports only the <option>-base</option>
                        option which describes to the software the base address
                        of the bias supply as encoded in the module rotary
                        switches.
                    </para>
                </refsect3>
                <refsect3>
                    <title>Parameters</title>
                    <para>
                        The following parameters can be Set:
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term><literal>>v</literal><emphasis>i</emphasis></term>
                            <listitem>
                                <para>
                                    Sets the requested voltage on channel
                                    <parameter>i</parameter> in floating point
                                    volts.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>i</literal><emphasis>i</emphasis></term>
                            <listitem>
                                <para>
                                    Sets the current limit on channel <parameter>i</parameter>
                                    in floating point micro-amps.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>on</literal><emphasis>i</emphasis></term>
                            <listitem>
                                <para>
                                    Turns channel on or off.  The value of this
                                    parameter is a legal boolean value.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>ttrip</literal><emphasis>i</emphasis></term>
                            <listitem>
                                <para>
                                    Sets the number of seconds (floating point)
                                    for which channel <parameter>i</parameter>
                                    is allowed to be out of specification before
                                    it trips  off.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>svmax</literal><emphasis>i</emphasis></term>
                            <listitem>
                                <para>
                                    Sets the maximum voltage allowed for
                                    channel <parameter>i</parameter> in floating
                                    point volts.  If a voltage setting is made
                                    that is larger than this, the actual requested
                                    voltage will be limited to this value.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>rdown</literal><emphasis>i</emphasis></term>
                            <listitem>
                                <para>
                                    Sets the ramp down rate of channel
                                    <parameter>i</parameter> in
                                    floating point volts per second.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>rup</literal><emphasis>i</emphasis></term>
                            <listitem>
                                <para>
                                    Sets the ramp up rate of channel
                                    <parameter>i</parameter> in floating point
                                    volts per second.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>pdownmode</literal><emphasis>i</emphasis></term>
                            <listitem>
                                <para>
                                    Sets the power down mode of channel
                                    <parameter>i</parameter>.  The value of this
                                    parameter can be either <literal>kill</literal>
                                    which abruptly drops the voltage to zero,
                                    or <literal>ramp</literal> which ramps the
                                    channels down at the ramp down rate.
                                </para>
                            </listitem>
                        </varlistentry>
                        
                    </variablelist>
                    <para>
                        Note that if you want to monitor key components
                        of this device periodically you should use the
                        <command>Mon</command> command as that will retrieve
                        data without temporarily halting data taking.
                    </para>
                    <para>
                        The following parameters can be retrieved via Get:
                    </para>
                    <variablelist>
                        <varlistentry>
                            <term><literal>globalmaxv</literal></term>
                            <listitem>
                                <para>
                                    Returns the global maximum voltage
                                    for the module.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>globalmaxI</literal></term>
                            <listitem>
                                <para>
                                    Returns the global maximum current for the
                                    module.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>v</literal></term>
                            <listitem>
                                <para>
                                    Returns a list of the requested voltages from all
                                    channels.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>i</literal></term>
                            <listitem>
                                <para>
                                    Returns  a list consisting of the requested
                                    maximum currents
                                    from all channels.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>on</literal></term>
                            <listitem>
                                <para>
                                    Returns a list that contains the requested
                                    channel states (on or off for each
                                    channel).
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>vact</literal></term>
                            <listitem>
                                <para>
                                    Returns a list contaning the actual voltage
                                    reading from each channel.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>iact</literal></term>
                            <listitem>
                                <para>
                                    Returns a list containing the actual
                                    current readings from each channel.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>status</literal></term>
                            <listitem>
                                <para>
                                    Returns a list of status values for each
                                    channel.  See sections 3.2.2.6 for a bit
                                    b bit description of the valuesthat
                                    can be set in each list element.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>ttrip</literal></term>
                            <listitem>
                                <para>
                                    Returns the trip times for each channel.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>svmax</literal></term>
                            <listitem>
                                <para>
                                    Returns the software maximum voltage for
                                    each channel.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>rdown</literal></term>
                            <listitem>
                                <para>
                                    Returns a list of ramp down rates for each
                                    channel.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>rup</literal></term>
                            <listitem>
                                <para>
                                    Returns a list of the ramp up rates for each
                                    channel.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>pdownmode</literal></term>
                            <listitem>
                                <para>
                                    Returns a list of the power down modes
                                    for each channel.
                                </para>
                            </listitem>
                        </varlistentry>
                        <varlistentry>
                            <term><literal>polarities</literal> </term>
                            <listitem>
                                <para>
                                    Returns a list of the channel polarity values.
                                    Each channel polarity is represented by a
                                    <literal>+</literal> or a
                                    <literal>-</literal>
                                </para>
                            </listitem>
                        </varlistentry>
                        
                        <varlistentry>
                            <term><literal>temp</literal></term>
                            <listitem>
                                <para>
                                    Returns a list of the temperaturs  for each
                                    channel.
                                </para>
                            </listitem>
                        </varlistentry>
                        
                    </variablelist>
                </refsect3>
                <refsect3>
                    <title>Monitored variables</title>
                    <para>
                        Bias supplies must normally be monitored periodically
                        so that operators can be informed of trip and alarm
                        conditions.  The VM-USB framework provides for each
                        slow control device to contribut to a list that is
                        triggered periodically via the action register.
                        This allows this monitoring to be done without
                        pausing data taking.
                    </para>
                    <para>
                        The V5633 driver uses this capability and the
                        <command>mon</command> command should be used to
                        retrieve the most recent values of the monitored
                        variables.
                    </para>
                    <para>
                        The <command>mon</command> protocol command
                        will return the the string
                        <literal>OK </literal> followed by a Tcl list of lists.
                        The first list will be the channel status values.
                        The second list will be the channel actual voltages.
                        The third list will be the actual channel currents.
                        The fourth and last list will be the channel temperatures.
                    </para>
                </refsect3>
            </refsect2>
            <refsect2>
                <title>mdgg16</title>
                <para>
                  This slow-controls module provides support for the Wiener 
                  MDGG-16 device as used as a fourfold 16-channel configurable
                  OR. It sets up the device to output NIM logic signals
                  according to four separately defined OR definitions.                 
                </para>
                <refsect3>
                  <title>Options</title>
                  <variablelist>
                    
                    <varlistentry>
                      <term><option>-base</option></term>
                      <listitem>
                        <para>
                          The value of the base address of the Wiener MDGG-16
                          must be provided via this option.  
                        </para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><option>-mode</option></term>
                      <listitem>
                        <para>
                          This is an enumerated option that only accepts two
                          parameter values: explicit, file. The "explicit" value
                          will use the values of the -or_a, -or_b, -or_c, and
                          -or_d parameters to set up the ORs. The "file" value
                          will read an input file defined by the -configfile
                          parameter to load the definitions. Default =
                          explicit.
                        </para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><option>-or_a</option></term>
                      <listitem>
                        <para>
                          This is a 16-bit integer that represents the 16-bit
                          mask identifying which input channels will
                          contribute to the NIM 0 output (OR A). A bit that is
                          set indicates that its corresponding channel will
                          contribute to the OR A output. Bit 0 corresponds to
                          the first input channel and bit 15 corresponds to the
                          last input channel.  Default value is 65535 (i.e. all
                          16 channels contribute to output).
                        </para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><option>-or_b</option></term>
                      <listitem>
                        <para>
                          This is the same as the -or_a parameter except that it
                          corresponds to the OR B definition controlling the NIM
                          1 output.
                        </para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><option>-or_c</option></term>
                      <listitem>
                        <para>
                          This is the same as the -or_a parameter except that it
                          corresponds to the OR C definition controlling the NIM
                          2 output.
                        </para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><option>-or_d</option></term>
                      <listitem>
                        <para>
                          This is the same as the -or_a parameter except that it
                          corresponds to the OR D definition controlling the NIM
                          3 output.
                        </para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><option>-configfile</option></term>
                      <listitem>
                        <para>
                          The value of this parameter should be a valid path to
                          a configuration file. The configuration file should be
                          in the same form as the one generated by the
                          MDGG16Control program. In general, it should have the
                          following form:
                        </para>

                        <programlisting>
                         or_a  value_a  
                         or_b  value_b  
                         or_c  value_c  
                         or_d  value_d  
                        </programlisting>

                        <para> 
                          where value_a, value_b, value_c, and value_d are the
                          16-bit integers defining the bit masks for OR A, OR B,
                          OR C, and OR D, respectively.
                        </para>
                      </listitem>
                    </varlistentry>
                  </variablelist>
                </refsect3>

                <refsect3>
                  <title>Parameters</title>

                  <para>
                    The following parameters can be Set:
                  </para>

                  <variablelist>
                    <varlistentry>
                      <term><literal>or_ab</literal></term>
                      <listitem>
                        <para>
                          Provides the bit masks for the OR A and the OR B 
                          definitions. See the description of the -or_a option 
                          for how each of these are defined individually. The
                          value to provide for this parameter should be a
                          combination of the two individual masks. It is a 32-bit
                          integer where the least significant 16-bits are the OR A
                          definition and the upper 16-bits are the OR B
                          definition.
                        </para>
                        <para>
                          The return value of this should be the response of the
                          device when successful. Any failure will result in a
                          return value beginning with "ERROR - " and is followed
                          by a description of the error.
                        </para>

                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><literal>or_cd</literal></term>
                      <listitem>
                        <para>
                          This is the same as the <parameter>or_ab</parameter> 
                          parameter except that it is formed by OR C and OR D bit
                          masks. The least significant 16-bits are the OR C
                          definition and the upper 16-bits are the OR D
                          definition.
                        </para>
                        <para>
                          The return value of this should be the response of the
                          device when successful. Any failure will result in a
                          return value beginning with "ERROR - " and is followed
                          by a description of the error.
                        </para>

                      </listitem>
                    </varlistentry>
                  </variablelist>

                  <para>
                    The following parameters can be retrieved via Get:
                  </para>

                  <variablelist>
                    <varlistentry>
                      <term><literal>or_ab</literal></term>
                      <listitem>
                        <para>
                          Reads the values of the OR A and OR B bit masks from the
                          device. The returned value will have both 16-bit masks
                          encoded into a 32-bit integer. The least significant
                          16 bits define the OR A mask and the upper 16 bits
                          define the OR B mask.
                        </para>

                        <para>
                          If an error occurs while communicating with the device,
                          the response will begin with "ERROR - " and will be
                          followed by a description of the error.
                        </para>
                      </listitem>
                    </varlistentry>

                    <varlistentry>
                      <term><literal>or_cd</literal></term>
                      <listitem>
                        <para>
                          Reads the values of the OR C and OR D bit masks from the
                          device. The returned value will have both 16-bit masks
                          encoded into a 32-bit integer. The least significant
                          16 bits define the OR C mask and the upper 16 bits
                          define the OR D mask.
                        </para>

                        <para>
                          If an error occurs while communicating with the device,
                          the response will begin with "ERROR - " and will be
                          followed by a description of the error.
                        </para>
                      </listitem>
                    </varlistentry>
                  </variablelist>
                </refsect3>
            </refsect2> 
            <refsect2>
                <title>marker</title>
                <para>
                    This module inserts a marker in the monitor list.  The main use
                    is to get data buffers periodically flushed for slow data
                    rate applications.
                </para>
                <para>
                    The module has no gettable or settable parameters.  It has a
                    single configuration option <option>-value</option> which
                    sets the of the marker word.  Normally  you don't need to
                    modify this as the marker word will never make it outside the
                    VMUSBReadout program.
                </para>
            </refsect2>
        </refsect1>

      </refentry>
      <refentry id="vmusb3-watch">
        <refmeta>
           <refentrytitle id='vmusb3-watch-title'>watch</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>watch</refname>
           <refpurpose>Watch variables (slow controls)</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
          <command>
watch <replaceable>name</replaceable>   
          </command>
          </cmdsynopsis>

        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            Informs the slow controls server that a variable or array
            named <parameter>name</parameter> should be monitored.  The
            watched variable are monitored for changes (which are initiated
            by clients performing <command>set</command> commands). Periodically
            the current values of changed variables are dumped to the event
            stream as string items of type <literal>MONITORED_VARIABLES</literal>.
           </para>
           <para>
            If <parameter>name</parameter> is an array, all elements
            of that array are monitored.
           </para>
        </refsect1>
      </refentry>

<refentry id="vmusb3-delay">
  <refmeta>
     <refentrytitle>delay</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>

  <refnamediv>
     <refname>delay</refname>
     <refpurpose>Insert a stack delay.</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
    	<command>
delay create <replaceable>name ?options...?</replaceable>
	    </command>
    </cmdsynopsis>
    
    <cmdsynopsis>
      <command>
delay config <replaceable>name option value ...</replaceable>
      </command>
    </cmdsynopsis>
  
    <cmdsynopsis>
        <command>
delay cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
 
  </refsynopsisdiv>

  <refsect1>
     <title>DESCRIPTION</title>
     <para>
      This command creates a wait point in a stack. 	
     </para>
  </refsect1>

  <refsect1>
     <title>OPTIONS</title>
  
     <variablelist>
	    <varlistentry>
	       <term><command>-value</command> <replaceable>value</replaceable></term>
	       <listitem>
		       <para>Defines the duration of delay in units of 200 ns.</para>
		       <para>Defaults to 0</para>
	       </listitem>
	     </varlistentry>
     </variablelist>
 
  </refsect1>

  <refsect1>
      <title>EXAMPLES</title>
      <example>
        <title>A simple delay example</title>
         <programlisting>
delay create delay0 -value 4 
         </programlisting>
      </example>
      <para>
        Defines an 800 ns delay.
      </para>
  </refsect1>

</refentry>

<refentry id="vmusb3-CBDCamacBranch">
  <refmeta>
     <refentrytitle>CBDCamacBranch</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>

  <refnamediv>
     <refname>CBDCamacBranch</refname>
     <refpurpose>run a CAMAC branch through a CES CBD8210 bridge</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
    	<command>
CBDCamacBranch create <replaceable>name base</replaceable>
	    </command>
    </cmdsynopsis>
    
    <cmdsynopsis>
      <command>
CBDCamacBranch config <replaceable>name option value ...</replaceable>
      </command>
    </cmdsynopsis>
  
    <cmdsynopsis>
      <command>
CBDCamacBranch cget <replaceable>name</replaceable>
      </command>
    </cmdsynopsis>
 
   </refsynopsisdiv>
  
  <refsect1>
    <title>DESCRIPTION</title>
    
    <para>
When the user intends to read out CAMAC devices through the VM-USB this driver can be used if the branch driver is a CES CBD8210. This class maintains a camac branch driver object that must encapsulate the necessary functionality for controlling the CAMAC devices on its branch. The camac branch driver essentially provides the means for translating standard bcnaf commands to VME commands that are executable by the VM-USB in a command stack. It must also properly implements the CCamacBranchDriver interface. 
    </para>
    
    <para>
A CAMAC branch is just a bunch of CAMAC crates strung together with a common branch number. For this reason, the CBDCamacBranch must be told which branch number it is operating on and also the camac crates that exist on the branch. Be sure that the camac crates registered to the branch are consistent with the driver being used by the CBDCamacBranch. In other words, modules prefixed by CBD, like CBDCamacCrates, must be registered to the CBDCamacBranch if the driver has been defined as a CES CBD8210.
    </para>
    
    <para>
    At initialization the following operations occur:
    <orderedlist>
      <listitem>
        <para> Setup the appropriate camac branch driver </para>
      </listitem>
      
      <listitem>
        <para> The branch driver will initiate the branch </para>
      </listitem>
     
      <listitem>
        <para> Call initialize for each crate registered to the branch </para>
      </listitem>
  
    </orderedlist>
    </para>

    <para>
    At the end of the run, the specific end of run operations are called for each crate registered to the branch.
    </para>

    <para>
    During execution of an event stack, the operations defined in each crate are executed in the order that the crate list was passed.
    </para>
  
  </refsect1>

  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	    <varlistentry>
	      <term><command>-branch</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
        Specifies the branch index. Default is 0.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-crates</command> <replaceable>list</replaceable></term>
	      <listitem>
		    <para>
        Specify a proper tcl list of crate modules to be operated on the branch.
	These crates must be compatible with the driver in use. Care should also
	be taken to ensure that the crate indices are all different.
	Default is an empty list. 
		    </para>
	       </listitem>
	    </varlistentry>
   </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
        <title>Sample setup of two camac crates on branch 0</title>
         <programlisting>
# define some camac crates
CBDCamacCrate create crate1 -crate 1
CBDCamacCrate create crate2 -crate 2

CBDCamacBranch create branch0 -branch 0
CBDCamacBranch config branch0 -crates [list crate1 crate2]
         </programlisting>
      </example>
      <para>
       Defines two camac crates compatible with the CBD8210 branch driver and adds those to the camac branch, whose branch index is 0.
      </para>
  </refsect1>
</refentry>

<refentry id="vmusb3-CBDCamacCrate">
  <refmeta>
     <refentrytitle>CBDCamacCrate</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>CBDCamacCrate</refname>
     <refpurpose>group CBD8210 compatible modules into a crate</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
CBDCamacCrate create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
CBDCamacCrate config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
CBDCamacCrate cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>

  <refsect1>
     <title>DESCRIPTION</title>
     <para>
The CBDCamacCrate command defines a container type driver that holds a registry
of modules. It is designed to work on a CAMAC branch rooted in a VME crate
by a CES CBD8210 device. If this is not the case, use of this driver will fail.
In addition, the modules that are registered to this crate must also be capable
of working with a CBD8210 device. This module cannot operate on its own and
must be registered to a valid CBDCamacBranch. 
  </para>

  <para>
At the start of every run, the initialization procedures will be called for all
of the registered modules in the order the modules were listed.
  </para>

  <para>
At the end of every run, the end of run procedures will be called for all of the
registered module in the order the modules were listed.
  </para>

  <para>
During stack execution initiated by an event trigger, the event-wise procedures
of each of the registered modules will be executed in the order that they were
listed.
  </para>

  </refsect1>

  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	    <varlistentry>
	      <term><command>-crate</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
        Specifies the crate index. Default is 0.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-modules</command> <replaceable>list</replaceable></term>
	      <listitem>
		    <para>
        Specify a proper tcl list of modules to be registered with this crate.
	These must all be compatible with the CBD8210 branch driver. The order
	in which modules are listed will be the order in which each module is
	serviced. A single module can be registered to multiple CBDCamacCrates.
	Default is an empty list. 
		    </para>
	       </listitem>
	    </varlistentry>
  </variablelist>

  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
        <title>Sample setup of a single LeCroy 2551</title>
         <programlisting>
CBDLeCroy2551 create sclr -slot 10

# Create a crate to stick it in
CBDCamacCrate create crate0 -crate 1
CBDCamacCrate config crate0 -modules [list sclr]

# Create a branch to register the crate in
CBDCamacBranch create branch0 -branch 0
CBDCamacBranch config branch0 -crates [list crate0]
         </programlisting>
      </example>
      <para>
       Defines a camac crate with a single LeCroy2551 to operate on with a CBD8210 branch driver. This crate is labeled with index 1 on the branch and the branch is labeled with index 0.
      </para>
  </refsect1>
</refentry>

<refentry id="vmusb3-CBDLeCroy4300B">
  <refmeta>
     <refentrytitle>CBDLeCroy4300B</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>CBDLeCroy4300B</refname>
     <refpurpose>control a LeCroy 4300B FERA on a CAMAC branch</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
CBDLeCroy4300B create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
CBDLeCroy4300B config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
CBDLeCroy4300B cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
  <para>
The CBDLeCroy4300B cannot be registered as a stack module by itself. Instead it
must be registered first to a CBDCamacCrate. That CBDCamacCrate must then be
registered to a CBDCamacBranch module. See the example below to understand how
this works. 
  </para>
  <para>
There are a number of options that are provided to ultimately control the
command register of the device. The command register is what establishes how
the FERA will read out its data. Two options must be specified to operate the
device, -pedestals and slot. If either of these are not specified,
the initialization of the module will fail. 
  </para>

  <para>
  During initialization the following operations occur:
    <orderedlist>
     <listitem> 
        <para> Clear the module </para>
     </listitem>
     <listitem>
      <para> Write all pedestals passed to the -pedestal option </para>
     </listitem>
     <listitem>
      <para>
	  Compute the command register from user define options and write it
	  to the module
      </para>
     </listitem>
  </orderedlist>
  </para>

  <para>
  At the end of the run, no actions are taken. 
  </para>

  <para>
  During stack execution initiated by an event trigger, this driver will operate
  based on the following logic:
  <programlisting>

  if "-camacclear" is true
      Clear the module

  </programlisting>
  
  </para>
  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	    <varlistentry>
	      <term><command>-slot</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
        Specifies the slot of the CAMAC crate the target module is occupying. DEFAULT is 1.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-pedestals</command> <replaceable>list</replaceable></term>
	      <listitem>
		    <para>
          A proper tcl list of 16 integer parameters defining the pedestals for
	  each of the 16 channels. The first element of the list will configure
	  the first channel of the FERA, the second element will configure the
	  second channel, and so on. REQUIRED (no legal default value).
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-vsn</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
The virtual station number to associate with the target device. This will be
included in the header if data compression is enabled.  Defaults to <literal>0</literal>
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-eclpedsub</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
        	Specify whether to use pedestal subtraction in ECL port readout (aka. EPS). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-eclcompression</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specify whether to enable a data compression cycle before ECL port readout (aka. ECE). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-eclenable</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
        	Specify whether to enable ECL port readout (aka. EEN). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-camacpedsub</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specify whether to use pedestal subtraction in CAMAC readout (aka. CPS). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-camaccompression</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specify whether to enable a data compression cycle before CAMAC readout (aka. CCE). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-camacseqrdo</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specify whether to configure the device for sequential readout in CAMAC (aka. CSR). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-camaclam</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specify whether the allow the device to emit a LAM when data is available to be read (aka. CLE). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-overflowsuppress</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specify whether to suppress output of overflows as well as zeros (aka. OAFS). Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
   </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
         <title>Sample setup of a few FERAs</title>
         <programlisting>
CBDLeCroy4300B create fera -slot 10 
CBDLeCroy4300B config fera -pedestals \
          [list 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1]
CBDLeCroy4300B config fera -eclenable on
CBDLeCroy4300B config fera -eclpedsub on
CBDLeCroy4300B config fera -eclcompression on
CBDLeCroy4300B config fera -camacclear off

# Create a crate to stick it in
CBDCamacCrate create crate0 -crate 1
CBDCamacCrate config crate0 -modules [list fera]

# Create a branch to register the crate in
CBDCamacBranch create branch0 -branch 0
CBDCamacBranch config branch0 -crates [list crate0]
         </programlisting>
      </example>
      <para>
        Sets up a LeCroy4300B module with all pedestals 1 to be read out by the ECL ports. The FERA resides in slot 10.
      </para>
  </refsect1>
</refentry>

<refentry id="vmusb3-CBDLeCroy4434">
  <refmeta>
     <refentrytitle>CBDLeCroy4434</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>CBDLeCroy4434</refname>
     <refpurpose>control a LeCroy 4434 Scaler on a CAMAC branch</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
CBDLeCroy4434 create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
CBDLeCroy4434 config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
CBDLeCroy4434 cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
    <para>
The CBDLeCroy4434 is intended to control a LeCroy 4434 scaler situated on a
camac branch rooted in a VME crate by a CES CBD8210 branch driver. If you
intend to utilize the driver in a camac crate controlled by a CCUSB, see the
LeCroy4434 command. It provides the exact same functionality but understands the
CCUSB to be its controller.
  </para>

  <para>
The CBDLeCroy4434 cannot be registered as a stack module by itself. Instead it
must be registered first to a CBDCamacCrate. That CBDCamacCrate must then be
registered to a CBDCamacBranch module. See the example below to understand how
this works.
  </para>

  <para>
  During initialization, all scalers are cleared and the auxiliary bus is disabled. 
  </para>

  <para>
  At the end of the run, no actions are taken. 
  </para>

  <para>
  During stack execution initiated by an event trigger, this driver will operate
  based on the following logic:
  <programlisting>

  Read all channels
  if "-incremental" is true
      Clear the module
  </programlisting>

  Just as a note, the latch and the clear are not atomic.
  </para>
  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	    <varlistentry>
	      <term><command>-slot</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
        Specifies the slot of the CAMAC crate the target module is occupying.
	Default is 1.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-incremental</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Specifies whether to clear the scalers on each event after latching
	  them. Default is false.
		    </para>
	       </listitem>
	    </varlistentry>
   </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
         <title>Sample setup of a single scaler</title>
         <programlisting>
CBDLeCroy4434 create sclr -slot 10

# Create a crate to stick it in
CBDCamacCrate create crate0 -crate 1
CBDCamacCrate config crate0 -modules [list sclr]

# Create a branch to register the crate in
CBDCamacBranch create branch0 -branch 0
CBDCamacBranch config branch0 -crates [list crate0]
         </programlisting>
      </example>
      <para>
        Sets up a LeCroy 4434 scaler module in slot 10.
      </para>
  </refsect1>
</refentry>
  
<refentry id="vmusb3-CBDLeCroy2551">
  <refmeta>
     <refentrytitle>CBDLeCroy2551</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>CBDLeCroy2551</refname>
     <refpurpose>control a LeCroy 2551 Scaler on a CAMAC branch</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
CBDLeCroy2551 create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
CBDLeCroy2551 config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
CBDLeCroy2551 cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
    <para>
The CBDLeCroy2551 is intended to control a LeCroy 2551 scaler situated on a
camac branch rooted in a VME crate by a CES CBD8210 branch driver.
If you intend to utilize the driver in a camac crate controlled by a CCUSB,
see the LeCroy2551 command. It provides the exact same functionality but
understands the CCUSB to be its controller.
  </para>

    <para>
The CBDLeCroy2551 cannot be registered as a stack module by itself. Instead it
must be registered first to a CBDCamacCrate. That CBDCamacCrate must then be
registered to a CBDCamacBranch module. See the example below to understand how
this works.
    </para>

  <para>
  During initialization, all scalers are cleared. 
  </para>

  <para>
  At the end of the run, no actions are taken. 
  </para>

  <para>
  During stack execution initiated by an event trigger, all 12 scaler channels
  are read individually. There is no clear at the end of an event.
  </para>

  <para>
  It is important for the user to understand that format of the data is
  outputted by the VMUSB when this scaler is used. Each channel readout consists
  of two separate 16-bit reads that accomplish the reading of the upper bits
  followed by the lower 16-bits of the actual scaler value. This is done
  because the CBD8210 is a D16 device rather than a D32 device. There is no
  getting around it. What this means is that the actual scaler values need to
  be filtered or processed before they look like meaningful numbers.
  </para>

  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	    <varlistentry>
	      <term><command>-slot</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
        Specifies the slot of the CAMAC crate the target module is occupying.
	Default is 1.
		    </para>
	       </listitem>
	    </varlistentry>
   </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
         <title>Simple setup of a single scaler</title>
         <programlisting>
CBDLeCroy2551 create sclr -slot 10

# Create a crate to stick it in
CBDCamacCrate create crate0 -crate 1
CBDCamacCrate config crate0 -modules [list sclr]

# Create a branch to register the crate in
CBDCamacBranch create branch0 -branch 0
CBDCamacBranch config branch0 -crates [list crate0]
         </programlisting>
      </example>
      <para>
        Sets up a LeCroy 2551 scaler module in slot 10.
      </para>
  </refsect1>
</refentry>

<refentry id="vmusb3-CBDULMTrigger">
  <refmeta>
     <refentrytitle>CBDULMTrigger</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>CBDULMTrigger</refname>
     <refpurpose>control a LeCroy 2637 ULM running trigger firmware on a CAMAC branch</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
CBDULMTrigger create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
CBDULMTrigger config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
CBDULMTrigger cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>
    <para>
The CBDULMTrigger is intended to control a LeCroy 2367 ULM situated on a camac
branch rooted in a VME crate by a CES CBD8210 branch driver. If you intend to
utilize the driver in a camac crate controlled by a CCUSB, see the ULMTrigger
command. It provides the exact same functionality but understands the CCUSB to
be its controller.
  </para>

    <para>
The CBDULMTrigger cannot be registered as a stack module by itself. Instead it
must be registered first to a CBDCamacCrate. That CBDCamacCrate must then be
registered to a CBDCamacBranch module.
    </para>

  <para>
Two options need to be specified to function properly. The first is firmware
which defines the location of the firmware file to load. The second is the slot
number in the camac crate it lives in.
  </para>


  <para>
  On initialization the module will always be cleared and the GO bit set to 1.
  </para>

  <para>
  At the end of the run, the GO bit is set to 0.
  </para>

  <para>
  During stack execution initiated by an event trigger, the following logic is
  carried out:

  <programlisting>
if "-registerRead" is true
    Read the register

if "-eventwiseClear" is true
    Clear the register
  </programlisting>
  
  By default, both -registerRead and -eventwiseClear are set to false.
  </para>

  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>
	    <varlistentry>
	      <term><command>-slot</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
        Specifies the slot of the CAMAC crate the target module is occupying.
	Default is 1.
		    </para>
	       </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-firmware</command> <replaceable>path</replaceable></term>
	      <listitem>
		    <para>
        The path to the firmware file usbtrig.bit. Default is "" making this a
	mandatory parameter.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-readRegister</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
        Specifies whether to add a hit register read into the event stack.
	Defaults to true.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-eventwiseClear</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
        Specifies whether to send a clear command via the CAMAC dataway at the
	end of the event. Defaults to true.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-forceFirmwareLoad</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
        By default, the ULM will only load the firmware if it fails to validate
	the configuration. This occurs always after a bad firmware load or after
	a crate has been power cycled. Firmware loads take a bit of time so it
	is worthwhile to skip reloading the firmware on every run. However,
	sometimes it may be considered useful. This option causes the firmware
	to be loaded at the start of EVERY run. Defaults to false.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-configuration</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
        Specifies the number that will be used to validate a successful firmware
	configuration. This number is compared to the value returned by the
	function A=15 F=0.  Default is <literal>0</literal>
		    </para>
	      </listitem>
	    </varlistentry>
     </variablelist>
     <para>
      The next set of parameters allow the user to intialize the trigger parameters.
      These are best understood by referencing a picture of the ULM trigger
      GUI.   See below:
     </para>
     <figure>
      <title>S800 Trigger GUI</title>
      <mediaobject>
	 <imageobject>
	    <imagedata fileref='s800trigger.jpg' format='JPEG' />
	 </imageobject>
      </mediaobject>
     </figure>
     <variablelist>
	    <varlistentry>
	      <term><command>-pcDelay</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
                        Primary S800 Gate and delay generator delay value
			in units of 25ns.  This is for the green box at the left
			of the top branch of the trigger logic.
			Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-pcWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
			Primary S800 Gate and delay generator width value in
			units of 25 ns. This is for the green box at the left of
			the top branch of the trigger logic.
			Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-scDelay</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
			Secondary gate and delay generator delay value
			in 25ns units.  This is for the green box to the
			left of the bottom branch of the trigger logic.
			Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-scWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
			Secondary gate and delay generator width
			in 25ns units.  This is for the green box to the
			left of the bottom branch of the trigger logic.
			Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
		<term><command>-psDelay</command></term>
		<listitem>
		    <para>
		     Delay length in units of 25ns for the delay generator
		     (pink box) in the primary trigger branch of the logic.
		     Default is 0.
		    </para>
		</listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-ccWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
		     Width of the coincidence gate (yellow box
		     after the AND in the middle of the trigger
		     logic) in 25ns units.  Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-ssDelay</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
			 Length of delay in 25ns units for the delay generator
			 in the secondary trigger.  This is the pink box
			 at the bottom of the trigger GUI.
			 Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-bypasses</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
			Bitmask of bypasses (check boxes on various elements
			of the trigger logic). 
			Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-pdFactor</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
			S800 downscale value (the blue box at the top
			middle of the trigger GUI). Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-sdFactor</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
                      Secondary trigger scaledown value (the blue box
		      at the bottom middle of the trigger GUI). Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-triggerBox</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
			Bit mask for the check boxes in the
			<literal>Trigger Box</literal>. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-inspect1</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
                        Selects the wire number routed to the inpect 1
			output. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-inspect2</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
			Selects the wire number routed to the
			inspect 2 output. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-inspect3</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
			Selects the wire number routed to the
			inspect 3 output. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-inspect4</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
			Selects the wire number routed to the
			inspect 4 output. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-adcWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
		     Selects the width of the output from the
		     ADC Gate generator (see the yellow boxes to the
		     right of the trigger GUI).
		     Units are 25ns. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-qdcWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
			Sets the width (in 25 ns units) of the
			gate generator for the QDC.  See the
			yellow boxes at the right of the trigger
			GUI. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-tdcWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
			Sets the width of the TDC gate generator in
			25ns units.  See the yellow boxes at the
			right of the trigger GUI. Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
	    <varlistentry>
	      <term><command>-coincWidth</command> <replaceable>num</replaceable></term>
	      <listitem>
		    <para>
			Sets the width of the coincidence gate generator
			in 25ns units.  Default is 0.
		    </para>
	      </listitem>
	    </varlistentry>
   </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
         <title>Setup of a single ULM trigger module</title>
         <programlisting>
# Define values for each parameter in TRIGGER array
CBDULMTrigger create sclr -slot 23
CBDULMTrigger config ulm firmware /user/s800/server/fpga/usbtrig.bit
CBDULMTrigger config ulm -pcDelay $TRIGGER(PCDelay) \
                  -pcWidth $TRIGGER(PCWidth) \
                  -scDelay $TRIGGER(SCDelay) \
                  -scWidth $TRIGGER(SCWidth) \
                  -psDelay $TRIGGER(PSDelay) \
                  -ccWidth $TRIGGER(CCWidth) \
                  -ssDelay $TRIGGER(SSDelay) \
                  -bypasses $TRIGGER(Bypasses) \
                  -pdFactor $TRIGGER(PDFactor) \
                  -sdFactor $TRIGGER(SDFactor) \
                  -triggerBox $TRIGGER(TriggerBox) \
                  -inspect1 $TRIGGER(Inspect1) \
                  -inspect2 $TRIGGER(Inspect2) \
                  -inspect3 $TRIGGER(Inspect3) \
                  -inspect4 $TRIGGER(Inspect4) \
                  -adcWidth $TRIGGER(ADCWidth) \
                  -qdcWidth $TRIGGER(QDCWidth) \
                  -tdcWidth $TRIGGER(TDCWidth) \
                  -coincWidth $TRIGGER(CoincidenceWidth) \
                  -configuration $TRIGGER(configuration) 
CBDULMTrigger config trig -forceFirmwareLoad off
CBDULMTrigger config trig -readRegister on
CBDULMTrigger config trig -eventwiseClear off


# Create a crate to stick it in
CBDCamacCrate create crate0 -crate 1
CBDCamacCrate config crate0 -modules [list trig]

# Create a branch to register the crate in
CBDCamacBranch create branch0 -branch 0
CBDCamacBranch config branch0 -crates [list crate0]
         </programlisting>
      </example>
      <para>
        Sets up a ULM module in slot 23 of crate 1 on branch 0.
      </para>
  </refsect1>
</refentry>

  
<refentry id="vmusb3-XLMTimestamp">
  <refmeta>
     <refentrytitle>XLMTimestamp</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>XLMTimestamp</refname>
     <refpurpose>control an XLM running 64-bit latching scaler firmware</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
XLMTimestamp create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
XLMTimestamp config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
XLMTimestamp cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>

     <para>
      The XLMTimestamp module is a driver to control an JTech XLM running a
      64-bit latching scaler firmware. It is intended to be used specifically
      with the stamp64.bit firmware written by Daniel Bazin at the NSCL.
    </para>

  <para>
  During initialization, the firmware is loaded and all scalers are cleared. 
  </para>

  <para>
  At the end of the run, no actions are taken. 
  </para>

  <para>
  During stack execution initiated by an event trigger, the 64-bits of scaler
  are read out in two 32-bit chunks. The lower 32-bits are read first and the
  upper 32-bits are read second. 
  </para>

  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>

	    <varlistentry>
	      <term><command>-base</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
          Specifies the base address of the module. See the manual on how to
	  address the XLM. When the module is using geographic addressing, the
	  slot number is shifted left by 27 bits (i.e. slot 10 produces a base
	  address of 0x50000000).
		    </para>
	       </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><command>-firmware</command> <replaceable>path</replaceable></term>
	      <listitem>
		    <para>
          The path to the stamp64.bit firmware file.
		    </para>
	       </listitem>
	    </varlistentry>

   </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
         <title>Simple setup of a single timestamp module</title>
         <programlisting>
          xlmtstamp create tstamp -base [expr 10 << 27]
          xlmtstamp config tstamp -firmware /user/s800/server/fpga/stamp64.bit
         </programlisting>
      </example>
      <para>
        Sets up an XLM in slot 10 to run the stamp64.bit firmware.
      </para>
  </refsect1>
</refentry>
      <refentry id="vmusb3-marker">
        <refentryinfo>
          <author>
                  <personname>
                          <firstname>Ron</firstname>
                          <surname>Fox</surname>
                  </personname>
          </author>
          <productname>NSCLDAQ</productname>
          <productnumber></productnumber>
        </refentryinfo>
        <refmeta>
           <refentrytitle id='vmusb3-marker-title'>marker</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
           <refmiscinfo class='empty'></refmiscinfo>
        </refmeta>
        <refnamediv>
           <refname>marker</refname>
           <refpurpose>Insert a constant into the VMUSB data stream</refpurpose>
        </refnamediv>
        
        <refsynopsisdiv>
          <cmdsynopsis>
              <command>
marker create <replaceable>name</replaceable>
          </command>
          </cmdsynopsis>
            <cmdsynopsis>
                <command>
marker config <replaceable>name -value uint16</replaceable>                    
                </command>
            </cmdsynopsis>
            <cmdsynopsis>
                <command>
marker cget <replaceable>name</replaceable>
                </command>
            </cmdsynopsis>
            
            
        </refsynopsisdiv>
        <refsect1>
           <title>DESCRIPTION</title>
           <para>
            When added to a stack, a marker inserts a constant 16 bit unsigned
            value in the outupt data produced by the VM-USB in response to that
            stack's trigger.
           </para>
        </refsect1>
        <refsect1>
           <title>
              OPTIONS
           </title>
           <variablelist>
            <varlistentry>
                <term><option>-value</option> <replaceable>uint16</replaceable></term>
                <listitem>
                    <para>
                        The <replaceable>uint16</replaceable> unsigned 16 bit
                        bit integer will be inserted into the output stream.
			Defaults to <literal>0</literal>
                    </para>
		    <para>
			 Note that if you want to place a 32 bit marker in the
			 buffer, you can do this with two markers.  Be sure to
			 place the least significant 16 bits in the buffer
			 first.
		    </para>
                </listitem>
            </varlistentry>
            
           </variablelist>
        </refsect1>

      </refentry>

<refentry id="vmusb3-XLMFERA">
  <refmeta>
     <refentrytitle>XLMFERA</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>XLMFERA</refname>
     <refpurpose>control an XLM72V running firmware to readout FERA via ECL ports</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
XLMFERA create <replaceable>name base</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
XLMFERA config <replaceable>name option value ...</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
XLMFERA cget <replaceable>name</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>
     <title>DESCRIPTION</title>

     <para>
      The XLMFERA module is a driver to control a JTech XLM72V running firmware
      to handle readout of FERA modules via ECL ports. The XLM actually
      interfaces with a LeCroy 4301 FERA driver to accomplish this.
      The firmware associated with this is the xferajan.bit firmware that was
      written primarily by an unknown author but was assisted by Jan Toke (JTech). 
    </para>

    <para>
     This is just a derived class of the CXLM base class. 
    </para>

  <para>
  During initialization, the firmware is loaded. The user must provide the path
  to the firmware file by means of the -firmware option. If no firmware file
  is specified or the path provided is invalid, an exception will be thrown.
  The firmware will always be validated on initialization by a validation test.
  This validation test reads the signature of the firmware from the device and
  compares it to the value passed by the -configuration option. If these numbers
  are not identical or the -forceFirmwareLoad flag is set to true, the firmware
  will be loaded. The user will be alerted to the success of the validation via
  messages printed to the console. Immediately following the firmware load, the
  validation test is repeated and the user will be alerted of the results. An
  exception will be thrown if the validation test fails at this point.
  </para>

  <para>
  At the end of the run, no actions are taken. 
  </para>

  <para>
  During stack execution, a block transfer is executed. First, the lowest
  16-bits of memory in the sramA is read via a 32-bit read. The value of these
  16-bits will be used to specify the number of 32-bit transfers to execute in
  a subsequent block transfer. The block transfer will begin at 5th byte of
  sramA (i.e. the second 32-bits, offset 4).
  </para>

  </refsect1>
  <refsect1>
     <title>
	OPTIONS
     </title>
     <variablelist>

	    <varlistentry>
	      <term><command>-base</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
          Specifies the base address of the module. See the manual on how to
	  address the XLM. When the module is using geographic addressing, the
	  slot number is shifted left by 27 bits (i.e. slot 10 produces a
	  base address of 0x50000000). 
		    </para>
	       </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><command>-firmware</command> <replaceable>path</replaceable></term>
	      <listitem>
		    <para>
          The path to the xferajan.bit firmware file.
		    </para>
	       </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><command>-configurationID</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
          The value to use in the validation test. Default is
	  <literal>0x54000041</literal>. 
		    </para>
	       </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><command>-forceFirmwareLoad</command> <replaceable>bool</replaceable></term>
	      <listitem>
		    <para>
          Force reload of the firmware every run regardless of whether the
	  XLM passes the validation test.  Defaults to <literal>false</literal>.
		    </para>
	       </listitem>
	    </varlistentry>

   </variablelist>
  </refsect1>
  <refsect1>
      <title>EXAMPLES</title>
      <example>
         <title>Simple setup of a single timestamp module</title>
         <programlisting>
          XLMFERA create myxlm -base [expr 10 << 27]
          XLMFERA config myxlm -firmware /user/s800/server/fpga/xferajan.bit
         </programlisting>
      </example>
      <para>
        Sets up an XLM in slot 10 to run the xferajan.bit firmware.
      </para>
  </refsect1>
</refentry>

<refentry id="vmusb3-AXLM72ScalerControl">
  <refmeta>
     <refentrytitle>AXLM72ScalerControl</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>AXLM72ScalerControl</refname>
     <refpurpose>slow-controls driver for controlling an XLM72 running 32-ch scaler firmware</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
    <cmdsynopsis>
	<command>
AXLM72ScalerControl <replaceable>name option value ...</replaceable>
	</command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
<replaceable>name</replaceable> Set <replaceable>usb parameter value</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
<replaceable>name</replaceable> Get <replaceable>usb parameter</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
<replaceable>name</replaceable> Update <replaceable>usb</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
<replaceable>name</replaceable> addMonitorList <replaceable>list</replaceable>
        </command>
    </cmdsynopsis>
    <cmdsynopsis>
        <command>
<replaceable>name</replaceable> processMonitorList <replaceable>data</replaceable>
        </command>
    </cmdsynopsis>
  </refsynopsisdiv>
  <refsect1>

  <title>DESCRIPTION</title>

     <para>
    The AXLM72ScalerControl driver is a pure-TCL driver that is used to
    communicate with the XLM72 when running the ech32x24.bit firmware. It
    implements the CControlHardware interface as is equivalent in TCL. When
    loaded into the slow-controls server, any remote process can send it
    commands that it will translate into actual communication with a specific
    XLM72 device. It communicates through the low-level driver for the
    ech32x24.bit firmware called AXLM72Scaler. The XLM72ScalerGUI requires that
    an instance of this class is registered as a TCL module (see Module command),
    in the slow-controls server.
    </para>

  </refsect1>
  
  <refsect1>
  <title>OPTIONS</title>
    <variablelist>

	    <varlistentry>
	      <term><command>-slot</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
          Specifies the slot in which the target XLM72 module resides.
		    </para>
	       </listitem>
	    </varlistentry>
    </variablelist>

  </refsect1>

  <refsect1>
  <title>METHODS</title>
  <variablelist>

    <varlistentry>
      <term><replaceable>name</replaceable> <command>Set</command> <replaceable>vmusb parameter value</replaceable></term>
      <listitem>
        <para>
          The Set command causes a write to the XLM72. There are 34 supported
	  parameters: enable, reset, trigger0, trigger1, trigger2, ..., and
	  trigger31. The number appended to the trigger parameter identifies
	  the channel number. The values provided for reset and the any trigger
	  must be either 0 or 1, and the value of the reset command is ignored.
	  The returned value is the status value of the return value for the
	  write operation (0 => success, otherwise => failure).
        </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><replaceable>name</replaceable> <command>Get</command> <replaceable>vmusb parameter</replaceable></term>
      <listitem>
        <para>
          The Get command causes a read from the XLM72. There are 5 parameters
	  that can be provided to this method: enable, alltriggers, firmware,
	  runstate, and allscalers. These all return the value read from the
	  device. The enable parameter returns a 0 or 1 indicating whether
	  the scalers are enabled. The alltriggers parameter returns a 32-bit
	  integer with the status of each channel's trigger status encoded in
	  its bits. Channel 0's status is encoded in bit 0 and channel 31's
	  status is encoded in bit 31, with all others likewise. The firmware
	  parameter returns the firmware signature. The runstate parameter
	  causes a return of the run state as one of the following strings:
	  idle, starting, stopping, active, paused. Finally the allscalers
	  parameters causes the scaler values to be latched and read out of
	  the device. These are returned as a list of 32 integers beginning
	  with channel 0.
        </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><replaceable>name</replaceable> <command>Update</command> <replaceable>vmusb</replaceable></term>
      <listitem>
        <para>
          The Update method is defined but does nothing.
        </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><replaceable>name</replaceable> <command>addMonitorList</command> <replaceable>list</replaceable></term>
      <listitem>
        <para>
          The addMonitorList method is defined but does nothing.
        </para>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term><replaceable>name</replaceable> <command>processMonitorList</command> <replaceable>data</replaceable></term>
      <listitem>
        <para>
          The processMonitorList method is defined but does nothing more than return 0.
        </para>
      </listitem>
    </varlistentry>
  </variablelist> 

  </refsect1>

  <refsect1>
      <title>EXAMPLES</title>
      <example>
         <title>Simple setup of the AXLM72ScalerControl</title>
         <programlisting>
          package require scalerxlm72

          # Instantiation an object
          AXLM72ScalerControl mysclr -slot 5 

          # create the module for the slow-controls configure it to call the methods of the mysclr object
          Module create tcl sclrmod
          Module config sclrmod -ensemble mysclr
         </programlisting>
      </example>
      <para>
        Sets up an instance of the AXLM72ScalerControl to run on the
	slow-controls server. If the XLM72ScalerGUI is to be run with this
	module, it would have to be given the name of the module as "sclrmod".
      </para>
  </refsect1>
</refentry>

<refentry id="vmusb3-XLM72ScalerGUI">
  <refmeta>
     <refentrytitle>XLM72ScalerGUI</refentrytitle>
     <manvolnum>3vmusb</manvolnum>
  </refmeta>
  <refnamediv>
     <refname>XLM72ScalerGUI</refname>
     <refpurpose>Diagnostics GUI for controlling an XLM72 running 32 ch scaler firmware</refpurpose>
  </refnamediv>
  
  <refsynopsisdiv>
  <cmdsynopsis>
    <command>
      XLM72ScalerGUI <replaceable>name option value ...</replaceable>
    </command>
  </cmdsynopsis>
  </refsynopsisdiv>

  <refsect1>

  <title>DESCRIPTION</title>
  <para>
The XLM72ScalerGUI is a graphical user interface (GUI) that provides interactive
control over an XLM72 running the ech32x24.bit firmware in a crate being readout
by VMUSBReadout program. This firmware was written and is supported by
Daniel Bazin and the software driver that supports the readout is provided by
NSCLDAQ as the AXLM72Scaler tcl driver. The XLM72ScalerGUI is a UI that displays
the scaler values of the XLM72 when not in DAQ mode and gives the user some
basic control over the XLM72 while the VMUSB is not in acquisition mode. It is
primarily a diagnostics tools that can be used to enable or disable the scaler
channels from counting, to clear the scaler counters, and also to repeatedly
update the values at a selectable frequency.
  </para>

  </refsect1>

  <refsect1>
    <title>PARAMETERS</title>

    <variablelist>

	    <varlistentry>
	      <term><command>--module</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
          The name of the module registered to the VMUSBReadout slow-controls
	  server that will handle the requests of the GUI.
		    </para>
	       </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><command>--host</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
          The host running the VMUSBReadout slow-controls server.
		    </para>
	       </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><command>--port</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
          The port on which the VMUSBReadout slow-controls server is listening
	  for connections.
		    </para>
	       </listitem>
	    </varlistentry>

	    <varlistentry>
	      <term><command>--ring</command> <replaceable>value</replaceable></term>
	      <listitem>
		    <para>
          The name of the ring being filled by the VMUSBReadout program
		    </para>
	       </listitem>
	    </varlistentry>
    </variablelist>

  </refsect1>


  <refsect1>
    <title>Configuration</title>

    <para>
      The XLM72ScalerGUI is designed employes a client-server architecture and thus
      using it requires setting up two different pieces: the client and the
      server. The setup of the server will be explained first. To avoid
      confusion, the server that will be communicated with is the
      VMUSBReadout slow-controls server and thus setting it up requires
      loading a driver with the needed functionality into it. The specific
      driver to be used is contained in the AXLM72ScalerControl class. It is
      just a standard slow-controls driver written purely in TCL that
      implements the Set, Get, and Update methods. Once an instance has been
      created of the AXLM72ScalerControl class, it needs to be registered as a T
      CL module using the ?Module? command. The name of the ensemble is just
      the name of the instance created. As with all slow-controls set up, this
      must be done in the ctlconfig.tcl file. The name of the AXLM72ScalerControl
      instance is not important so long as it does not conflict with any other
      tcl commands (e.g. setting the name to ?set? would lead to unexpected
      failures). Here is a sample of how to set it up in the ctlconfig.tcl file.
    </para>

    <example>
    <title>Example ctlconfig.tcl entry</title>
    <programlisting>
package require scalerxlm72			          ;# load the plugin

AXLM72ScalerControl XLM72SclrCtl -slot 5  ;# Create an instance of for an XLM72 in slot 5

Module create tcl xlm72sclrctl		        ;# Create a new pure tcl module named xlm72sclrctl
Module config xlm72sclrctl -ensemble XLM72SclrCtl ;# set the name of the ensemble to be the same as the name of the instance
    </programlisting>
    </example>

    <para>
The second portion of the XLM72ScalerGUI is the setup of the client. The client
is much simpler and amounts to running the XLM72ScalerGUI program with the
appropriate arguments. This program requires a few pieces of information to
successfully communicate with the server. Those are the name of the host
running the VMUSBReadout slow-controls server, the port on which that server
is listening for connections, the name of the ringbuffer being filled by the
VMUSBReadout program, and the name of the slow-controls module that is receiving
requests from the GUI. In the above example, the name of that module would be
"xlm72sclrctl".  
    </para>

    <para>
    That is it. If you want know why the ringbuffer name is needed read on
    about run state awareness.
    </para>

  </refsect1>

  <refsect1>
    <title>Run State Awareness</title>
    <para>
  The XLM72ScalerGUI is only allowed to query the XLM72 while a run is not in
  progress. When a run is in progress (i.e. the VM-USB is in data acquisition
  mode rather than interactive mode), all of the GUI components become disabled
  except for the Exit button. When a run ends, the GUI components become active
  again. The idea is that the XLM72ScalerGUI is really a diagnostics tool
  rather than a tool for data acquisition. In order to respond to run state
  transitions, the GUI needs to have some run state awareness. Two mechanisms
  provide this to form some redundancy. The primary means by which it obtains
  run state information is through a sclclient program attached to the
  ringbuffer filled by the VMUSBReadout program. This is why the user must
  provide the name of the ringbuffer, when starting up the GUI. The sclclient
  communicates with a TclServer embedded into the GUI and manages a variable
  called RunState. Unfortunately, this approach is leaves a small chance that
  the GUI sends a request after the run has started but before the sclclient
  has alerted the TclServer of the change. In this scenario, the second
  redundancy kicks in because the first thing that happens before a request
  is a request from the slow-controls server to return the run state. If the
  run state is not idle, then it is assumed that a run is in progress.
  Otherwise, the requests proceed as usual. 
    </para>

    <para>
      This may seem overkill but there is a good reason for doing it this way
      that is tied to how the slow-controls server handles requests while in
      acquisition mode. Should a request come in that mode, the VMUSB will exit
      acquisition mode, process the request, and then resume acquisition.
      Unfortunately, ending a run usually lasts about a second or two, which
      causes long wait times. To avoid repeated interruptions like this, the
      above scheme ensures that at most, one interruption can occur. Understand
      that no data is ever lost in these scenarios, the data stream is simply
      interrupted for a period of time. 
    </para>
  </refsect1>
  
</refentry>

      <refentry id="vmusb3-AXLM72">
        <refmeta>
           <refentrytitle>AXLM72</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>AXLM72</refname>
           <refpurpose>TCL base class for JTech XLM72 family of devices</refpurpose>
        </refnamediv>
    
        <refsynopsisdiv>
            <cmdsynopsis>
                <command>
package require xlm72
                </command>
            </cmdsynopsis>
          
        <cmdsynopsis>
            <command>
AXLM72 <replaceable>name slot</replaceable>
            </command>
        </cmdsynopsis>
        
        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> GetVariable <replaceable>v</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> Read <replaceable>ctlr dev address</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> Write <replaceable>ctlr dev address data</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> ReadSBLT <replaceable>ctlr dev address words</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> ReadNBLT <replaceable>ctlr ndev naddr mask dev addr</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> AccessBus <replaceable>ctlr code</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> ReleaseBus <replaceable>ctlr</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> BootFPGA <replaceable>ctlr</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> SetFPGABoot <replaceable>ctlr source</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> Configure <replaceable>ctlr filename</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> ExecuteLongStack <replaceable>ctlr stack</replaceable>
            </command>
        </cmdsynopsis>
      
        <formalpara> 
          <title>Stack Building Methods</title>
          <para></para>
        </formalpara> 
  
        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sRead <replaceable>stack dev addr</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sWrite <replaceable>stack dev addr data</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sReadSBLT <replaceable>stack dev addr words</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sReadNBLT <replaceable>stack ndev naddr mask dev addr</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sAccessBus <replaceable>stack code</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sReleaseBus <replaceable>stack code</replaceable>
            </command>
        </cmdsynopsis>

        </refsynopsisdiv>

        <refsect1>
           <title>DESCRIPTION</title>
           <para>
 This is the IncrTcl base class for the family of XLM72 devices. It provides
 a large number of convenience functions that derived classes can use
 in their drivers. The JTech XLM72 family of devices are general purpose
 logic modules that have no real function independent of the firmware
 loaded onto them. For this reason, derived classed typically handle
 how to interact with devices that are running a specific firmware.
           </para>
        </refsect1>
        <refsect1>
           <title>
              COMMANDS
           </title>

           <variablelist>

             <varlistentry>
               <term><cmdsynopsis><command>
AXLM72 <replaceable>name slot</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Constructs an AXLM72 object for a device seated in
                      slot <parameter>slot</parameter>
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> GetVariable <replaceable>v</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Returns the value of the variable named <parameter>v</parameter>
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> Read <replaceable>ctlr dev address</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Immediately performs an A32/D32 read from the
		      address $<parameter>dev</parameter>+$<parameter>address</parameter>.
		      The access is performed through the swig wrapped CVMUSB
		      class provided as <parameter>ctlr</parameter>. The method
		      returns the value of read from the device.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> Write <replaceable>ctlr dev address data</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Immediately performs an A32/D32 write of
		      <parameter>data</parameter> to the address
		      $<parameter>dev</parameter>+$<parameter>address</parameter>.
		      The access is performed through the swig wrapped CVMUSB
		      class provided as <parameter>ctlr</parameter>. Returns
		      the status of the write operation (success = 0, failure otherwise).
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> ReadSBLT <replaceable>ctlr dev address words</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Immediately performs a block transfer (A32/D32) of
		      <parameter>words</parameter> transfers beginning at
		      address $<parameter>dev</parameter>+$<parameter>address</parameter>.
		      The access is performed through the swig wrapped CVMUSB
		      class provided as <parameter>ctlr</parameter>. The method
		      returns a swig wrapped std::vector&lt;uint8_t&gt; so one
		      must use the cvmusb::uint8_vector_get and
		      cvmusb::uint8_vector_size procs to handle it.
		      The VMUSBDriverSupport::convertBytesListToTclList will
		      convert it to a tcl list of 32-bit integer values if that
		      is desired and sensible.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> ReadNBLT <replaceable>ctlr ndev naddr mask dev addr</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Immediately performs a block transfer (A32/D32) whose
		      transfer count is determined by read data from the
		      address $<parameter>ndev</parameter>+$<parameter>naddr</parameter>
		      and applying the mask <parameter>mask</parameter> to the
		      result. This read is an unprivileged A32/D32 read. A
		      subsequent block transfer then begins at
		      address $<parameter>dev</parameter>+$<parameter>address</parameter>.
		      The access is performed through the swig wrapped CVMUSB
		      class provided as <parameter>ctlr</parameter>. The method
		      returns a swig wrapped std::vector&lt;uint8_t&gt; so one
		      must use the cvmusb::uint8_vector_get and
		      cvmusb::uint8_vector_size procs to handle it.
		      The VMUSBDriverSupport::convertBytesListToTclList
		      will convert it to a tcl list of 32-bit integer values
		      if that is desired and sensible.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> AccessBus <replaceable>ctlr code</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Convenience function for gaining access of an internal bus. This is 
                      two single shot operations. The first requests the bus of interest
                      and the second inhibits the FPGA and DSP from gaining mastership.
                      The valid values for <parameter>code</parameter> are any
		      bitwise OR of bus A (0x1), bus B (0x2), 
                      bus X (0x1000), and bus D (0x2000).
		      The <parameter>ctlr</parameter> is a 
		     swig cvmusb::CVMUSB object.

                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> ReleaseBus <replaceable>ctlr</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
   Convenience function for releasing ownership of the internal busses. 
   This is similar to the AccessBus method but writes 0 to both the bus
   request and bus inhibit addresses. The <parameter>ctlr</parameter> is a 
   swig cvmusb::CVMUSB object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> BootFPGA <replaceable>ctlr</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
   Convenience function for booting the device. The operation only boots
   the FPGA. This is accomplished by first writing 1's to the reset bits 
   of the FPGA and DSP and then writing a 1 to the DSP and a 0 to the FPGA. 
   This causes the FPGA to boot and the DSP remains in reset mode (i.e. its 
   reset bit is still set). The <parameter>ctlr</parameter> is a 
   swig cvmusb::CVMUSB object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> SetFPGABoot <replaceable>ctlr source</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
   A convenience method for writing to the FPGA boot source register.
   Valid values for <parameter>source</parameter> are : 0x0, 0x1, 0x2, 0x3, and
   0x10000. The meanings
   are as follows: 
                  </para>
  <informaltable frame="all">
    <tgroup cols='2'>
    <tbody>
      <row>
        <entry>Boot Source Value</entry>
        <entry>Description</entry> 
      </row>
      <row>
        <entry>0x0</entry>
        <entry>Sector 0 flash</entry>
      </row>
      <row>
        <entry>0x1</entry>
        <entry>Sector 1 flash</entry>
      </row>
      <row>
        <entry>0x2</entry>
        <entry>Sector 2 flash</entry>
      </row>
      <row>
        <entry>0x3</entry>
        <entry>Sector 3 flash</entry>
      </row>
      <row>
        <entry>0x10000</entry>
        <entry>SRAM A</entry>
      </row>
    </tbody>
    </tgroup>
  </informaltable>
                    <para>
    The <parameter>ctlr</parameter> is a swig cvmusb::CVMUSB object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> Configure <replaceable>ctlr filename</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Loads firmware into SRAMA and then boots the device from SRAMA. The firmware is
    loaded from <parameter>filename</parameter>. The <parameter>ctlr</parameter>
    is a swig cvmusb::CVMUSB object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> ExecuteLongStack <replaceable>ctlr stack</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
   Converts the <parameter>stack</parameter> tcl list of raw stack commands into a 
   cvmusbreadoutlist::CVMUSBReadoutList object that gets 
   subsequently executed. Before returning the value data it is 
   parsed using the VMUSBDriverSupport::convertBytesListToTclList
   because the executeList command returns a vector of bytes.
   The <parameter>ctlr</parameter> is a swig cvmusb::CVMUSB object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sRead <replaceable>stack dev addr</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
   Adds an A32/D32 read from
   $<parameter>dev</parameter>+$<parameter>addr</parameter> to
   <parameter>stack</parameter>. <parameter>stack</parameter> is a swig
   cvmusbreadoutlist::CVMUSBReadoutList object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sWrite <replaceable>stack dev addr data</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
   Adds a A32/D32 write of <parameter>data</parameter> to
   $<parameter>dev</parameter>+$<parameter>addr</parameter> to
   <parameter>stack</parameter>. <parameter>stack</parameter> is a swig
   cvmusbreadoutlist::CVMUSBReadoutList object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sReadSBLT <replaceable>stack dev addr words</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Adds a standard block read of <parameter>words</parameter> transfers
    beginning at <parameter>dev</parameter>+<parameter>addr</parameter> to
    <parameter>stack</parameter>. <parameter>stack</parameter> is a swig
    cvmusbreadoutlist::CVMUSBReadoutList object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sReadNBLT <replaceable>stack ndev naddr mask dev addr words</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      This adds the same functionality of ReadNBLT to
		      <parameter>stack</parameter>. See documentation for
		      ReadNBLT for explanation of its functionality.
                    </para>
                </listitem>
            </varlistentry>
           
             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sAccessBus <replaceable>stack code</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Adds a bus access command to the <parameter>stack</parameter>
		      readoutlist. See documentation for AccessBus for the
		      allowed values.
                    </para>
                </listitem>
            </varlistentry>
           
             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sReleaseBus <replaceable>stack</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Adds a command to the <parameter>stack</parameter>
		      readoutlist to release acquisition of any previously
		      acquired busses.
                    </para>
                </listitem>
            </varlistentry>

          </variablelist>
        </refsect1>

    </refentry>

      <refentry id="vmusb3-AXLM72Scaler">
        <refmeta>
           <refentrytitle>AXLM72Scaler</refentrytitle>
           <manvolnum>3vmusb</manvolnum>
        </refmeta>
        <refnamediv>
           <refname>AXLM72Scaler</refname>
           <refpurpose>Driver for an XLM72 running 32-channel scaler firmware</refpurpose>
        </refnamediv>
    
        <refsynopsisdiv>
            <cmdsynopsis>
                <command>
package require scalerxlm72
                </command>
            </cmdsynopsis>
          
        <cmdsynopsis>
            <command>
AXLM72Scaler <replaceable>name slot</replaceable>
            </command>
        </cmdsynopsis>
        
        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> GetFirmware <replaceable>ctlr</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> Reset <replaceable>ctlr</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> Latch <replaceable>ctlr</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> SetTrigger <replaceable>ctlr bit</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> SetTriggetBit <replaceable>ctlr bit value</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> SetTriggerBits <replaceable>ctlr bitset</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> ReadTrigger <replaceable>ctlr</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> SetEnable <replaceable>ctlr onoff</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> ReadEnable <replaceable>ctlr</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> ReadAll <replaceable>ctlr</replaceable>
            </command>
        </cmdsynopsis>

        <formalpara> 
          <title>Stack Building Methods</title>
          <para></para>
        </formalpara> 

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sEnable <replaceable>stack</replaceable>
            </command>
        </cmdsynopsis>
  
        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sDisable <replaceable>stack</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sLatch <replaceable>stack</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sReadAll <replaceable>stack</replaceable>
            </command>
        </cmdsynopsis>

        <cmdsynopsis>
            <command>
<replaceable>name</replaceable> sReset <replaceable>stack</replaceable>
            </command>
        </cmdsynopsis>

        </refsynopsisdiv>

        <refsect1>
           <title>DESCRIPTION</title>
           <para>
 This device is mostly just a 32-bit latching scaler but has the feature
 that channel inputs can be redirected as a trigger output. The trigger 
 output is the result of OR'ing all of the input signals of channels
 whose trigger bits are set. 
          </para>

          <para>
 The scaler can be enabled/disabled and atomically cleared (aka reset).
           </para>
        </refsect1>
        <refsect1>
           <title>
              COMMANDS
           </title>

           <variablelist>

             <varlistentry>
               <term><cmdsynopsis><command>
AXLM72Scaler <replaceable>name slot</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Constructs an AXLM72Scaler object for a device seated in
                      slot <parameter>slot</parameter>
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> GetFirmware <replaceable>ctlr</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Reads and returns the firmware signature. The
		      <parameter>ctlr</parameter> is
                      a cvmusb::CVMUSB object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> Reset <replaceable>ctlr</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                    Atomically resets all scaler values by writing a 1 and then
		    a 0 to the lowest
                    address of the FPGA address space. Returns 0 on success or
		    a negative value for failure.
                    The <parameter>ctlr</parameter> is a cvmusb::CVMUSB object. 
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> Latch <replaceable>ctlr</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
                      Latch the current values of the scaler counters into
		      SRAMA for readout. 
                      The <parameter>ctlr</parameter> is a cvmusb::CVMUSB object.

                    </para>
                    <para>
                      The return value of this is either 0 for success or -1 for
		      failure.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> SetTrigger <replaceable>ctlr bit</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
   As a result of history, this relies on the state of the
   trigger array to determine what to write. This ultimately
   calls SetTriggerBits after properly setting the requested
   bit. The <parameter>ctlr</parameter> is a cvmusb::CVMUSB object.
                    </para>
                    <para>
    The return value of this is either 0 for success or -1 for failure.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> SetTriggerBits <replaceable>ctlr bitset</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
   As opposed to the previous two methods, this replaces the
   entire trigger register value rather than manipulating 
   specific bits. It is therefore a lower level method but
   it enables one to write all bits at once. The value of <parameter>bitset</parameter>
   is written to the entire register. The <parameter>ctlr</parameter> is a 
   cvmusb::CVMUSB object.
                    </para>
                    <para>
    The return value of this is either 0 for success or -1 for failure.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> ReadTrigger <replaceable>ctlr</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Read the trigger register.
    The <parameter>ctlr</parameter> parameter is a cvmusb::CVMUSB object.
                    </para>
                    <para>
    The return value of this the value of the trigger register. 
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> SetEnable <replaceable>ctlr onoff</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Write the value of <parameter>onoff</parameter> to the enable register. Valid
    values for <parameter>onoff</parameter> are 0 (i.e. enable on) and 1 (i.e. enable off).
    The <parameter>ctlr</parameter> parameter is a cvmusb::CVMUSB object.
                    </para>
                    <para>
    Returns either 0 for success or -1 for failure.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> ReadEnable <replaceable>ctlr</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Read and return the value of the enable register. 
    The <parameter>ctlr</parameter> parameter is a cvmusb::CVMUSB object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> ReadAll <replaceable>ctlr</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Read and return the value of all 32 scaler counters.
    The <parameter>ctlr</parameter> parameter is a cvmusb::CVMUSB object.
                    </para>
                    <para>
    The return value of this is a tcl list of all 32 channels of scaler values.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sEnable <replaceable>stack</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Appends a write of 1 to the enable register onto <parameter>stack</parameter>.
    The <parameter>stack</parameter> parameter is a cvmusbreadoutlist::CVMUSBReadoutList object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sDisable <replaceable>stack</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Appends a write of 0 to the enable register onto <parameter>stack</parameter>.
    The <parameter>stack</parameter> parameter is a cvmusbreadoutlist::CVMUSBReadoutList object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sLatch <replaceable>stack</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Adds a command to <parameter>stack</parameter> to latch the current value of the scaler
    counter into the SRAMA memory for later readout. The <parameter>stack</parameter> parameter is a cvmusbreadoutlist::CVMUSBReadoutList object.
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sReadAll <replaceable>stack</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Adds a readout cycle to <parameter>stack</parameter>. The values of the counters are
    latched and then are readout using a BLT. After the BLT, the SRAMA data is reset. This handles the acquisition of the appropriate busses. The <parameter>stack</parameter> parameter is a cvmusbreadoutlist::CVMUSBReadoutList object. 
                    </para>
                </listitem>
            </varlistentry>

             <varlistentry>
               <term><cmdsynopsis><command>
<replaceable>name</replaceable> sReset <replaceable>stack</replaceable>
              </command></cmdsynopsis></term>
                <listitem>
                    <para>
    Adds a write of 0 to SRAMA[0] to reset the data. The <parameter>stack</parameter> parameter is a cvmusbreadoutlist::CVMUSBReadoutList object.
                    </para>
                </listitem>
            </varlistentry>
          </variablelist>
        </refsect1>

    </refentry>

   <!-- caenchain command - aggregate 785's into CBLT chains -->

      <refentry id="vmusb3_v1495sc">
	<refentryinfo>
	  <author>
		  <personname>
			  <firstname>Ron</firstname>
			  <surname>Fox</surname>
		  </personname>
	  </author>
	  <productname>NSCLDAQ</productname>
	  <productnumber></productnumber>
	</refentryinfo>
	<refmeta>
	   <refentrytitle id='vmusb3_v1495sc_title'>v1495sc</refentrytitle>
	   <manvolnum>3vmusb</manvolnum>
	   <refmiscinfo class='empty'></refmiscinfo>
	</refmeta>
	<refnamediv>
	   <refname>v1495sc</refname>
	   <refpurpose>CAEN V1495 with Scaler firmware</refpurpose>
	</refnamediv>
	
	<refsynopsisdiv>
	  <cmdsynopsis>
	  <command>
v1495sc create <replaceable>name base-address</replaceable>
	   </command>
	  </cmdsynopsis>
	  <cmdsynopsis>
	       <command>
v1495sc create <replaceable>name ?options...?</replaceable>
	       </command>
	  </cmdsynopsis>
	  <cmdsynopsis>
	       <command>
v1495sc cget <replaceable>name</replaceable>
	       </command>
	  </cmdsynopsis>
	  

	</refsynopsisdiv>
	<refsect1>
	   <title>DESCRIPTION</title>
	   <para>
	       When equipped with the appropriate firmware a V1495 logic
	       module is a 128 channel scaler.  This module is then sold
	       under the name V1495sc.  This command supplies support for the
	       V1495sc module in the VMUSBReadout program.
	   </para>
	   <para>
	       As with all device support commands <command>v1495sc</command>
	       is a command ensemble with the three subcommands;
	       <command>create</command>, <command>config</command> and
	       <command>cget</command>.  The <command>create</command>
	       command is responsible for adding new scalers to the system
	       configuration and naming them.  The <command>config</command>
	       command is responsible for setting the detailed configuration
	       of the module.  The configuration is used to define how the
	       module is going to be programmed when the run starts.  The
	       <command>cget</command> command allows you to retrieve a module's
	       current configuration.  See <literal>OPTIONS</literal> below
	       for information about the options supported.
	   </para>
	</refsect1>
	<refsect1>
	   <title>
	      OPTIONS
	   </title>
	   <variablelist>
	       <varlistentry>
		   <term>
		    <option>-base</option>
		    <replaceable>base-addresss</replaceable>
		   </term>
		   <listitem>
		       <para>
			 Allows you to override the base address set at creation
			 time.  The base address must be the address of a
			 V1495sc module.  Defaults to <literal>0</literal>
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term>
		    <option>-exttrig </option> <literal>enabled | disabled</literal>
		   </term>
		   <listitem>
		       <para>
			 Enables the external trigger to latch scaler
			 values into the multi-event memory of the module.
			 The external trigger is the module's G0 input.
			 By default this is <literal>disabled</literal>.
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term>
		     <option>-inttrig</option>  <replaceable>enabled | disabled</replaceable>
		   </term>
		   <listitem>
		       <para>
			  Enables the internal trigger to latch values in to the
			  scaler's mult-event memory.  THe internal trigger
			  fires when the scaler dwell tiem has been reached.
			  See <option>-dwelltime</option> for more information
			  about this.  The default value is
			  <literal>disabled</literal>.
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term>
		     <option>-vmetrigger</option> <replaceable>enabled |disabled</replaceable>
		   </term>
		   <listitem>
		       <para>
			  Enables or disables the software trigger.  This is used
			  to programmatically latch scaler values as desired.
			  The default value of this option is  <literal>enabled</literal>
			  which is suitable for using this scaler as
			  a provider of scaler channels to the scaler display program.
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term>
		    <option>-inputlevel</option> <replaceable>nim | ttl</replaceable>
		   </term>
		   <listitem>
		       <para>
			 Sets the input signalling levels expected by the
			 G0, and G1 inputs.  The default value is <literal>nim</literal>
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term>
		    <option>-autoreset</option> <replaceable>on | off</replaceable>
		   </term>
		   <listitem>
		       <para>
			  If <literal>on</literal> (the default), the scalers are
			  atomically reset after a read.  This is suitable for use
			  in creating incremental scaler items.
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term>
		    <option>-g1_mode</option> <replaceable>inhibit | reset | test</replaceable>
		   </term>
		   <listitem>
		       <para>
			 Sets the use of the G1 input.  If <literal>inhibit</literal>
			 (the default), while G1 is logic true, the scalers are
			 inhibited from counting.  If <literal>reset</literal>,
			 scaler values will be cleared on the leading edge of a
			 false to true transition.  See the documentation for the
			 V1495sc module for information about the effect of using
			 <literal>test</literal> for this configuration value.
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term>
		    <option>-includetime</option> <replaceable>yes | no</replaceable>
		   </term>
		   <listitem>
		       <para>
			 If
			 <literal>yes</literal>, includes the trigger time since
			 the latest board reset
			 in the event data in the MEB.  This is <literal>no</literal>
			 by default
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term>
		    <option>-bank*enables</option> <replaceable>mask</replaceable>
		   </term>
		   <listitem>
		       <para>
			 Where <literal>*</literal> should be replaced by any of
			 <literal>1, 2, 3, 4</literal> (e.g. -bank1enables).
			 The value is a bitmask that determines which scaler
			 channels are enabled to count.  These options
			 all default to <literal>0xffffffff</literal> enabling
			 all 32 channels in an input bank.  Input banks represent
			 the scalers associated with one of the input connectors
			 on the module.
		       </para>
		   </listitem>
	       </varlistentry>
	       <varlistentry>
		   <term>
		    <option>-dwelltime</option> <replaceable>micro-seconds</replaceable>
		   </term>
		   <listitem>
		       <para>
			 When the internal trigger is enabled, this sets the
			 number of microseconds between internal triggers.
			 The default value is <literal>0x2000000</literal>, an
			 arbitrary value that works out to .131 seconds or so.
		       </para>
		   </listitem>
	       </varlistentry>
	   </variablelist>
	</refsect1>

      </refentry>
        


<!-- /manpage -->
<!-- manpage 5vmusb -->

    <refentry id="vmusb5-slowcontrols-protocol">
      <refentryinfo>
        <author>
            <personname>
                <firstname>Ron</firstname>
                <surname>Fox</surname>
            </personname>
        </author>
        <productname>NSCLDAQ</productname>
        <productnumber></productnumber>
      </refentryinfo>  
      <refmeta>
         <refentrytitle>VMUSB slow controls protocol</refentrytitle>
         <manvolnum>5vmusb</manvolnum>
          <refmiscinfo class='empty'></refmiscinfo>
      </refmeta>
      <refnamediv>
         <refname>VMUSB Slow controls protocol</refname>
         <refpurpose>VMUSB Slow controls protocol</refpurpose>
      </refnamediv>
      
      <refsynopsisdiv>
        <cmdsynopsis>
        <command>
Set <replaceable>module-name parameter-name value</replaceable>
        </command>
        </cmdsynopsis>
          <cmdsynopsis>
              <command>
Get <replaceable>module-name parameter-name</replaceable>
              </command>
          </cmdsynopsis>
          <cmdsynopsis>
              <command>
mon <replaceable>module-name</replaceable>
              </command>
          </cmdsynopsis>

      </refsynopsisdiv>
      <refsect1>
         <title>DESCRIPTION</title>
         <para>
          The slow controls protocol allows control panel software
          to be built that communicates with slow controls drivers
          in the VM-USB raadout framework.   This is intended to allow
          the contruction of control panels for devices that have slow
          controls drivers.  Note that the <classname>vmusb</classname>
          controller allows drivers to be written for devices
          that don't have slow controls drivers yet.
         </para>
         <para>
          The slow controls server listens for connections on the port
          specified by the Readout program's <option>--port</option>
          option or <literal>27000</literal> if that option is not
          specified.
         </para>
         <para>
          Connected clients send commands to the server as lines
          of text and get back singe line replies.  Replies are
          expected to begin with <literal>OK</literal> if the request
          was successful and <literal>ERROR</literal> otherwise.
          The text that follows the header text depends on the
          driver.
         </para>
      </refsect1>
      <refsect1>
          <title>
             COMMANDS
          </title>
          <variablelist>
              <varlistentry>
                  <term><command>Set <replaceable>module-name module-parameter value</replaceable></command></term>
                  <listitem>
                      <para>
                          Attempts to set a parameter
                          <parameter>module-parameter</parameter>
                          in a module <parameter>module-name</parameter>
                          to a new <parameter>value</parameter>.
                      </para>
                      <para>
                          <parameter>module-name</parameter> is the name
                          of a module that has been defined by the
                          control configuration file.
                          <parameter>module-parameter</parameter>
                          is a parameter that must be recognized by
                          the driver that manage that module.
                          <parameter>value</parameter> must be a valid
                          new value for that parameter.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><command>Get <replaceable>module-name module-parameter</replaceable></command></term>
                  <listitem>
                      <para>
                          Retrives a parameter (<parameter>module-parameter</parameter>)
                          from a module (<parameter>module-name</parameter>).   
                      </para>
                      <para>
                          <parameter>module-name</parameter> is the name
                          of a module that has been defined by the
                          control configuration file.
                          <parameter>module-parameter</parameter>
                          is a parameter that must be recognized by
                          the driver that manage that module.
                          It is entirely up to the module driver to
                          decide what is returned, however by
                          convention, as described above, the string
                          returned will begin either with
                          <literal>OK</literal> or
                          <literal>ERROR</literal>.
                      </para>
                  </listitem>
              </varlistentry>
              <varlistentry>
                  <term><command>mon <replaceable>module-name</replaceable></command></term>
                  <listitem>
                      <para>
                          Returns data that is monitored by the
                          device.  Again it is up to the driver
                          to decide exactly what should be returned.
                      </para>
                  </listitem>
              </varlistentry>
              
          </variablelist>
       </refsect1>

    </refentry>


        

<!-- /manpage -->